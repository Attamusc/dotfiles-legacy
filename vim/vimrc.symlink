" Enable Sytax highlighting for pretty colors
syntax enable

" Vundle setup for plugin management
set nocompatible
filetype off

set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

Bundle "gmarik/vundle"

" Utilities
Bundle "scrooloose/nerdcommenter"
Bundle "tpope/vim-unimpaired"
Bundle "tpope/vim-surround"
Bundle "tpope/vim-repeat"
Bundle "scrooloose/nerdtree"
Bundle "mattn/zencoding-vim"
Bundle "scrooloose/syntastic"
Bundle "kien/ctrlp.vim"
Bundle "airblade/vim-gitgutter"
Bundle "majutsushi/tagbar"
Bundle "Townk/vim-autoclose"
Bundle "Shougo/neocomplcache"
Bundle 'Shougo/neosnippet'
Bundle 'honza/vim-snippets'

" Langs
Bundle "tpope/vim-rails"
Bundle "cakebaker/scss-syntax.vim"
Bundle "pangloss/vim-javascript"
Bundle "wavded/vim-stylus"
Bundle "digitaltoad/vim-jade"
Bundle "kchmck/vim-coffee-script"
Bundle "othree/html5.vim"

" Colors
Bundle "zeis/vim-kolor"
Bundle "nanotech/jellybeans.vim"

filetype plugin indent on

" Various sets to make stuff better
set visualbell
set t_vb=
set hidden
set number
set showcmd
set autoindent
set smartindent
set cursorline
set splitright
set synmaxcol=400
set formatoptions=qrn1
set cmdheight=2
set laststatus=2
set scrolloff=5
set switchbuf=useopen
set backspace=indent,eol,start

" Use the same symbols as TextMate for tabstops and EOLs
set listchars=tab:▸\ ,eol:¬,trail:·
set ts=2 sts=2 sw=2 expandtab

set noswapfile
set nobackup
set undofile
set undodir=~/tmp/vim/undo
if !isdirectory(expand(&undodir))
    call mkdir(expand(&undodir), "p")
endif

set showmatch
set incsearch
set hlsearch
set foldlevelstart=0

" Better Completion
set omnifunc=syntaxcomplete#Complete
set complete=.,w,b,u,t
set completeopt+=longest,menuone,preview

hi Pmenu  guifg=#000000 guibg=#F8F8F8 ctermfg=black ctermbg=Lightgray
hi PmenuSbar  guifg=#8A95A7 guibg=#F8F8F8 gui=NONE ctermfg=darkcyan ctermbg=lightgray cterm=NONE
hi PmenuThumb  guifg=#F8F8F8 guibg=#8A95A7 gui=NONE ctermfg=lightgray ctermbg=darkcyan cterm=NONE

set wildmenu
set wildmode=list:longest

set wildignore+=.hg/,.git/,.svn/
set wildignore+=*.aux,*.out,*.toc
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest
set wildignore+=*.spl
set wildignore+=*.sw?
set wildignore+=*.DS_Store
set wildignore+=*.luac
set wildignore+=migrations
set wildignore+=*.pyc
set wildignore+=*.orig
set wildignore+=*/classes/*,*/tmp*,*/node_modules,*/vendor/*ruby

set statusline=%<%f\ (%{&ft})\ %-4(%m%)%=%-19(%3l,%02c%03V%)

let mapleader=","
let base16colorspace=256  " Access colors present in 256 colorspace

let g:jellybeans_overrides = {
\    'Todo': { 'guifg': 'f0f000',
\              'ctermfg': 'Yellow',
\              'attr': 'bold' },
\}

let g:ctrlp_dotfiles = 1
let g:ctrlp_match_window_bottom = 0

" Show hidden files in NerdTree
let NERDTreeShowHidden=1

" Syntastic configs
" Ignore HTML files since templating breaks it
let g:syntastic_mode_map = { 'mode': 'active',
	\ 'active_filetypes': [],
	\ 'passive_filetypes': ['html'] }
let g:syntastic_error_symbol = '✗'
let g:syntastic_warning_symbol = '✗'
let g:syntastic_enable_highlighting = 0

"{{{ neocomplcache
let g:neocomplcache_enable_at_startup = 1
let g:neocomplcache_disable_auto_complete = 1
let g:neocomplcache_enable_camel_case_completion = 1
let g:neocomplcache_enable_smart_case = 1
let g:neocomplcache_enable_underbar_completion = 1
let g:neocomplcache_enable_auto_delimiter = 1
let g:neocomplcache_max_list = 15
let g:neocomplcache_force_overwrite_completefunc = 1

" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = { 'default' : '' }

" Define keyword.
if !exists('g:neocomplcache_keyword_patterns')
    let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns._ = '\h\w*'

imap <C-k> <Plug>(neosnippet_expand_or_jump)
smap <C-k> <Plug>(neosnippet_expand_or_jump)

" Plugin key-mappings.
inoremap <expr><C-g> neocomplcache#undo_completion()
inoremap <expr><C-l> neocomplcache#complete_common_string()
inoremap <expr><CR> neocomplcache#complete_common_string()

" <CR>: close popup
" <s-CR>: close popup and save indent.
inoremap <expr><s-CR> pumvisible() ? neocomplcache#close_popup()"\<CR>" : "\<CR>"
inoremap <expr><CR> pumvisible() ? neocomplcache#close_popup() : "\<CR>"

" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y> neocomplcache#close_popup()

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete

" Enable heavy omni completion.
if !exists('g:neocomplcache_omni_patterns')
    let g:neocomplcache_omni_patterns = {}
endif
let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
let g:neocomplcache_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
let g:neocomplcache_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
let g:neocomplcache_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'

" Use honza's snippets.
let g:neosnippet#snippets_directory='~/.vim/bundle/vim-snippets/snippets'

" Enable neosnippet snipmate compatibility mode
let g:neosnippet#enable_snipmate_compatibility = 1

" For snippet_complete marker.
if has('conceal')
    set conceallevel=2 concealcursor=i
endif

" Disable the neosnippet preview candidate window
" When enabled, there can be too much visual noise
" especially when splits are used.
set completeopt-=preview
"}}}

if has('gui_running')
  set guifont=Source\ Code\ Pro\ For\ Powerline:h13
  set background=dark
  colorscheme jellybeans
  set go-=T
  set go-=l
  set go-=L
  set go-=r
  set go-=R
  " Remap CtrlP because muscle memory's a bitch
  let g:ctrlp_map = '<D-t>'
else
  set background=dark
  colorscheme base16-eighties
  let g:ctrlp_map = '<C-p>'
endif

highlight clear SignColumn

" Shortcut to rapidly toggle `set list`
nnoremap <leader>lt :set list!<CR>

" Only do this part when compiled with support for autocommands
if has("autocmd")
  augroup common
    au!

    " Jump to last cursor position unless it's invalid or in an event handler
    au BufWinEnter *
      \ if line("'\"") > 0 && line("'\"") <= line("$") |
      \   exe "normal g`\"" |
      \ endif

    " Cursor Highlight in Insert mode is annoying
    au WinLeave,InsertEnter * set nocursorline
    au WinEnter,InsertLeave * set cursorline

    " I like having the option of folding, but I don't like everything
    " folded when I open the file
    au BufWinEnter,BufRead * normal zR
  augroup END

  augroup git
    au!

    au BufNewFile,BufRead *gitconfig* setfiletype gitconfig

  augroup vimrcEx
    au!

    " Save the buffer when focus is lost
    au FocusLost * :wa

    " Auto-source the .vimrc file when it is saved
    au BufWritePost *vimrc* source $MYVIMRC

    " Syntax of these languages is fussy over tabs Vs spaces
    au FileType make setlocal ts=8 sts=8 sw=8 noexpandtab
    au FileType yaml setlocal ts=2 sts=2 sw=2 expandtab
    au FileType ruby setlocal ts=2 sts=2 sw=2 expandtab
    au FileType python setlocal ts=4 sts=4 sw=4 expandtab

    " Customisations based on personal preferences
    au FileType html setlocal ts=2 sts=2 sw=2 expandtab
    au FileType css setlocal ts=2 sts=2 sw=2 expandtab

    au BufNewFile,BufRead *.zsh* setfiletype zsh
  augroup END

  augroup html
    au!

    au BufNewFile,BufRead *.hbs setfiletype html
    au BufNewFile,BufRead *.handlebars setfiletype html
    au BufNewFile,BufRead *.ejs setfiletype html
  augroup END
  augroup java
      au!

      au FileType java setlocal foldmethod=marker
      au FileType java setlocal foldmarker={,}
  augroup END

  augroup javascript
      au!

      au BufNewFile,BufRead .jshintrc setfiletype javascript

      au FileType javascript setlocal foldmethod=marker
      au FileType javascript setlocal foldmarker={,}
      au FileType javascript setlocal ts=2 sts=2 sw=2 expandtab
  augroup END

  augroup css
    au!

    au BufNewFile,BufRead *.styl setfiletype stylus

    au Filetype css,sass,scss,less,stylus setlocal foldmethod=marker
    au Filetype css,sass,scss,less,stylus setlocal foldmarker={,}
    au Filetype css,sass,scss,less,stylus setlocal omnifunc=csscomplete#CompleteCSS
    au Filetype css,sass,scss,less,stylus setlocal iskeyword+=-
  augroup END

  augroup groovy
    au!

    au BufNewFile,BufRead *.gradle set ft=groovy
  augroup END

  augroup ruby
    au!

    au BufNewFile,BufRead Rakefile,Guardfile set ft=ruby
  augroup END
endif

" Super Awesome fold text taken from @sjl
function! MyFoldText() " {{{
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
    return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
endfunction " }}}
set foldtext=MyFoldText()

" Context sensitive tab completion taken from @garybernhardt's dotfiles
function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
    else
        return pumvisible() ? "\<c-p>" : "\<c-x>\<c-u>"
    endif
endfunction

inoremap <tab> <c-r>=InsertTabWrapper()<cr>
inoremap <s-tab> <c-n>

" For fast and east bundler installing
nnoremap <Leader>bi :BundleInstall<cr>

" Show TagBar
nnoremap <Leader>ts :TagbarToggle<CR>

" WTF vim?
map j gj
map k gk

" 'Bubble' the text up or down a line
" These bindings require @tpope's unimpaired plugin
nmap <C-Up> [e
nmap <C-Down> ]e

" Make changing tags in HTML super easy
nmap <leader>ct cst<

nnoremap <s-tab> <<
nnoremap <tab> >>
vnoremap <s-tab> <gv
vnoremap <tab> >gv

nnoremap <CR> :nohlsearch<CR>

nnoremap <space> za
vnoremap <space> za

" To enforce good habits...
map <Left> <Nop>
map <Right> <Nop>
map <Up> <Nop>
map <Down> <Nop>

" Quick access to vimrc for on-the-fly customizations
nmap <leader>ev :tabedit $MYVIMRC<CR>

nmap <leader>ss :%s/\s\+$//<CR><CR>``

map <leader>nf :NERDTreeFind<CR>
map <leader>n :NERDTreeToggle<CR>
map <leader>/ <plug>NERDCommenterToggle<CR>
imap <leader>/ <esc><plug>NERDCommenterToggle<CR>

nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

" uppercase/lowercase a word
nmap <leader>uc mQviwU`Q
nmap <leader>lc mQviwu`Q

" rspec mappings, taken from @thoughtbot's dotfiles
" assumes using zeus in ruby projects
"map <Leader>t :call RunCurrentSpecFile()<CR>
"map <Leader>s :call RunNearestSpec()<CR>
"map <Leader>l :call RunLastSpec()<CR>

function! RunCurrentSpecFile()
  if InSpecFile()
    let l:command = "s -f documentation " . @%
    call SetLastSpecCommand(l:command)
    call RunSpecs(l:command)
  endif
endfunction

function! RunNearestSpec()
  if InSpecFile()
    let l:command = "s -f documentation " . " -l " . line("."). " " . @%
    call SetLastSpecCommand(l:command)
    call RunSpecs(l:command)
  endif
endfunction

function! RunLastSpec()
  if exists("t:last_spec_command")
    call RunSpecs(t:last_spec_command)
  endif
endfunction

function! InSpecFile()
  return match(expand("%"), "_spec.rb$") != -1
endfunction

function! SetLastSpecCommand(command)
  let t:last_spec_command = a:command
endfunction

function! RunSpecs(command)
  execute ":w\|silent !echo 'clear && echo " . a:command . " && echo && " . a:command . "' > bipolar-pipe"
endfunction

" Dash searching integration
map <leader>d :call SearchDash()<CR>

function! SearchDash()
  let s:browser = "/usr/bin/open"
  let s:wordUnderCursor = expand("<cword>")

  " Get the filetype (everything after the first ., for special cases
  " such as index.html.haml or abc.css.scss.erb)
  let s:fileType = substitute(expand("%"),"^[^.]*\.","",1)

  " Match it and set the searchType
  if match(s:fileType, "js") != -1
    let s:searchType = "js:"
  elseif match(s:fileType, "css") != -1
    let s:searchType = "css:"
  elseif match(s:fileType, "html") != -1
    let s:searchType = "html:"
  elseif match(s:fileType, "rb") != -1
    let s:searchType = "rb:"
  elseif match(s:fileType, "php") != -1
    let s:searchType = "php:"
  elseif match(s:fileType, "py") != -1
    let s:searchType = "python:"
  else
    let s:searchType = ""
  endif

  " Run it
  let s:url = "dash://".s:searchType.s:wordUnderCursor
  let s:cmd ="silent ! " . s:browser . " " . s:url
  execute s:cmd
  redraw!
endfunction
