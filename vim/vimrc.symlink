" Enable Sytax highlighting for pretty colors
syntax enable

" Vundle setup for plugin management
set nocompatible
filetype off

set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

Bundle "gmarik/vundle"

" Utilities
Bundle "Attamusc/vim-mocha"
Bundle "bling/vim-airline"
Bundle "godlygeek/tabular"
Bundle "jgdavey/tslime.vim"
Bundle "mattn/emmet-vim"
Bundle "mhinz/vim-signify"
Bundle "Raimondi/delimitMate"
Bundle "scrooloose/nerdtree"
Bundle "scrooloose/nerdcommenter"
Bundle "scrooloose/syntastic"
Bundle "Shougo/unite.vim"
Bundle "Shougo/vimproc"
Bundle "tpope/vim-endwise"
Bundle "tpope/vim-fugitive"
Bundle "tpope/vim-repeat"
Bundle "tpope/vim-surround"
Bundle "tpope/vim-unimpaired"
Bundle "Valloric/MatchTagAlways"
Bundle "Valloric/YouCompleteMe"

" Langs
Bundle "cakebaker/scss-syntax.vim"
Bundle "elixir-lang/vim-elixir"
Bundle "jelera/vim-javascript-syntax"
Bundle "juvenn/mustache.vim"
Bundle "kchmck/vim-coffee-script"
Bundle "othree/html5.vim"
Bundle "tpope/vim-rails"
Bundle "wavded/vim-stylus"

" Colors
Bundle "baskerville/bubblegum"
Bundle "nanotech/jellybeans.vim"
Bundle "Pychimp/vim-luna"

filetype plugin indent on

" Various sets to make stuff better
set visualbell
set t_vb=
set hidden
set rnu
set showcmd
set autoindent
set smartindent
set cursorline
set splitright
set synmaxcol=400
set formatoptions=qrn1
set cmdheight=2
set laststatus=2
set scrolloff=5
set switchbuf=useopen
set backspace=indent,eol,start
set autoread
set t_Co=256

" Use the same symbols as TextMate for tabstops and EOLs
set listchars=tab:▸\ ,eol:¬,trail:·
set ts=2 sts=2 sw=2 expandtab

set noswapfile
set nobackup

set showmatch
set incsearch
set hlsearch
set foldlevelstart=0

" Better Completion
set omnifunc=syntaxcomplete#Complete
set complete=.,w,b,u,t
set completeopt+=longest,menuone,preview

hi Pmenu  guifg=#000000 guibg=#F8F8F8 ctermfg=black ctermbg=Lightgray
hi PmenuSbar  guifg=#8A95A7 guibg=#F8F8F8 gui=NONE ctermfg=darkcyan ctermbg=lightgray cterm=NONE
hi PmenuThumb  guifg=#F8F8F8 guibg=#8A95A7 gui=NONE ctermfg=lightgray ctermbg=darkcyan cterm=NONE

set wildmenu
set wildmode=list:longest

set wildignore+=.hg/,.git/,.svn/
set wildignore+=*.aux,*.out,*.toc
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest
set wildignore+=*.spl
set wildignore+=*.sw?
set wildignore+=*.DS_Store
set wildignore+=*.luac
set wildignore+=migrations
set wildignore+=*.pyc
set wildignore+=*.orig
set wildignore+=*/classes/*,*/tmp*,*/node_modules,*/vendor/*ruby

set statusline=%<%f\ (%{&ft})\ %-4(%m%)%=%-19(%3l,%02c%03V%)

let mapleader=","

" vim-airline config
let g:airline_powerline_fonts = 1

let g:jellybeans_overrides = {
\    'Todo': { 'guifg': 'f0f000',
\              'ctermfg': 'Yellow',
\              'attr': 'bold' },
\}

" ctrlp config
let g:ctrlp_dotfiles = 1
let g:ctrlp_match_window_bottom = 0

" Show hidden files in NerdTree
let NERDTreeShowHidden=1

" Syntastic configs
" Ignore HTML files since templating breaks it
let g:syntastic_mode_map = { 'mode': 'active',
	\ 'active_filetypes': [],
	\ 'passive_filetypes': ['html'] }
let g:syntastic_error_symbol = '✗'
let g:syntastic_warning_symbol = '✗'
let g:syntastic_enable_highlighting = 0

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete

if has('gui_running')
  set guifont=Source\ Code\ Pro\ For\ Powerline:h13
  set background=dark
  colorscheme jellybeans
  let g:airline_theme='jellybeans'
  set go-=T
  set go-=l
  set go-=L
  set go-=r
  set go-=R
  " Remap CtrlP because muscle memory's a bitch
  let g:ctrlp_map = '<D-t>'
else
  set background=dark
  colorscheme jellybeans
  let g:airline_theme='jellybeans'
  let g:ctrlp_map = '<C-p>'
endif

highlight clear SignColumn

" Only do this part when compiled with support for autocommands
if has("autocmd")
  augroup common
    au!

    " Jump to last cursor position unless it's invalid or in an event handler
    au BufWinEnter *
      \ if line("'\"") > 0 && line("'\"") <= line("$") |
      \   exe "normal g`\"" |
      \ endif

    " Cursor Highlight in Insert mode is annoying
    au WinLeave,InsertEnter * set nocursorline
    au WinEnter,InsertLeave * set cursorline

    " I like having the option of folding, but I don't like everything
    " folded when I open the file
    au BufWinEnter,BufRead * normal zR
  augroup END

  augroup git
    au!

    au BufNewFile,BufRead *gitconfig* setfiletype gitconfig

  augroup vimrcEx
    au!

    " Save the buffer when focus is lost
    au FocusLost * :wa

    " Auto-source the .vimrc file when it is saved
    au BufWritePost *vimrc* source $MYVIMRC

    " Syntax of these languages is fussy over tabs Vs spaces
    au FileType make setlocal ts=8 sts=8 sw=8 noexpandtab
    au FileType yaml setlocal ts=2 sts=2 sw=2 expandtab
    au FileType ruby setlocal ts=2 sts=2 sw=2 expandtab
    au FileType python setlocal ts=4 sts=4 sw=4 expandtab

    " Customisations based on personal preferences
    au FileType html setlocal ts=2 sts=2 sw=2 expandtab
    au FileType css setlocal ts=2 sts=2 sw=2 expandtab

    au BufNewFile,BufRead *.zsh* setfiletype zsh
  augroup END

  augroup html
    au!

    "au BufNewFile,BufRead *.hbs setfiletype html
    "au BufNewFile,BufRead *.handlebars setfiletype html
    "au BufNewFile,BufRead *.mustache setfiletype html
    au BufNewFile,BufRead *.ejs setfiletype html
  augroup END

  augroup java
      au!

      au FileType java setlocal foldmethod=marker
      au FileType java setlocal foldmarker={,}
  augroup END

  augroup javascript
      au!

      au BufNewFile,BufRead .jshintrc setfiletype javascript
      au BufNewFile,BufRead *.json setfiletype javascript
      au BufNewFile,BufRead *.njs setfiletype javascript

      au FileType javascript setlocal foldmethod=marker
      au FileType javascript setlocal foldmarker={,}
      au FileType javascript setlocal ts=2 sts=2 sw=2 expandtab
  augroup END

  augroup css
    au!

    au BufNewFile,BufRead *.styl setfiletype stylus
    au BufNewFile,BufRead *.roo setfiletype stylus

    au Filetype css,sass,scss,less,stylus setlocal foldmethod=marker
    au Filetype css,sass,scss,less,stylus setlocal foldmarker={,}
    au Filetype css,sass,scss,less,stylus setlocal omnifunc=csscomplete#CompleteCSS
    au Filetype css,sass,scss,less,stylus setlocal iskeyword+=-
  augroup END

  augroup groovy
    au!

    au BufNewFile,BufRead *.gradle set ft=groovy
  augroup END

  augroup ruby
    au!

    au BufNewFile,BufRead Rakefile,Guardfile set ft=ruby
  augroup END

  " strip trailing whitespace on buffer saves
  augroup whitespace
    autocmd BufWritePre *.rb,*.js call StripTrailing()
  augroup END
endif

" thanks to http://vimcasts.org/e/4
function! StripTrailing()
  let previous_search=@/
  let previous_cursor_line=line('.')
  let previous_cursor_column=col('.')
  %s/\s\+$//e
  let @/=previous_search
  call cursor(previous_cursor_line, previous_cursor_column)
endfunction

" Super Awesome fold text taken from @sjl
function! MyFoldText() " {{{
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
    return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
endfunction " }}}
set foldtext=MyFoldText()

" Context sensitive tab completion taken from @garybernhardt's dotfiles
function! InsertTabWrapper()
    let col = col('.') - 1
    if (!col || getline('.')[col - 1] !~ '\k') && !pumvisible()
        return "\<tab>"
    else
        return pumvisible() ? "\<c-n>" : "\<c-x>\<c-u>"
    endif
endfunction

"inoremap <tab> <c-r>=InsertTabWrapper()<cr>
"inoremap <s-tab> <c-p>

" Unite settings
call unite#set_profile('files', 'smartcase', 1)
call unite#custom#source('file,file/new,buffer,file_rec,file_rec/async',
	\ 'matchers', 'matcher_fuzzy')
call unite#custom#source('file_mru,file_rec,file_rec/async,grepocate',
        \ 'max_candidates', 30000)
call unite#custom#profile('files', 'filters', 'sorter_rank')

let g:unite_data_directory='~/.vim/.cache/unite'
let g:unite_enable_start_insert=1
let g:unite_source_history_yank_enable=1
let g:unite_source_file_rec_max_cache_files=30000
let g:unite_prompt='» '
let g:unite_source_grep_command='ag'
let g:unite_source_grep_default_opts='--nocolor --nogroup --column'
let g:unite_source_grep_recursive_opt=''

" Make Unite's window behave more like a preview window
function! s:unite_settings()
  nmap <buffer> Q <plug>(unite_exit)
  nmap <buffer> <esc> <plug>(unite_exit)
  imap <buffer> <esc> <plug>(unite_exit)
  imap <buffer> <C-j> <down>
  imap <buffer> <C-k> <up>
endfunction
autocmd FileType unite call s:unite_settings()

" Unite keybindings
nnoremap <D-t> :Unite -toggle -auto-resize -buffer-name=files file_rec/async:!<cr>
nnoremap <leader>aa :Unite -no-quit -buffer-name=search grep:.<cr>

nnoremap <space><space> :Unite -toggle -auto-resize -buffer-name=mixed file_rec/async buffer file_mru bookmark<cr>
nnoremap <space>r :Unite -toggle -auto-resize -buffer-name=files file_mru<cr>
nnoremap <space>y :Unite -buffer-name=yanks history/yank<cr>
nnoremap <space>l :Unite -auto-resize -buffer-name=line line<cr>
nnoremap <space>b :Unite -auto-resize -buffer-name=buffers buffer<cr>
nnoremap <space>m :Unite -auto-resize -buffer-name=mappings mapping<cr>
nnoremap <space>s :Unite -quick-match buffer<cr>

" Plugin key-mappings.
imap <C-k> <Plug>(neosnippet_expand_or_jump)
smap <C-k> <Plug>(neosnippet_expand_or_jump)
xmap <C-k> <Plug>(neosnippet_expand_target)

" For fast and east bundler installing
nnoremap <Leader>bi :BundleInstall<cr>

" Show TagBar
nnoremap <Leader>ts :TagbarToggle<CR>

" Shortcut to rapidly toggle `set list`
nnoremap <leader>lt :set list!<CR>

" WTF vim?
map j gj
map k gk

" 'Bubble' the text up or down a line
" These bindings require @tpope's unimpaired plugin
nmap <C-Up> [e
nmap <C-Down> ]e

" Make changing tags in HTML super easy
nmap <leader>ct cst<

nnoremap <s-tab> <<
nnoremap <tab> >>
vnoremap <s-tab> <gv
vnoremap <tab> >gv

nnoremap <CR> :nohlsearch<CR>

nnoremap <space> za
vnoremap <space> za

" To enforce good habits...
map <Left> <Nop>
map <Right> <Nop>
map <Up> <Nop>
map <Down> <Nop>

" Tabular
if exists(":Tabularize")
  nmap <Leader>a= :Tabularize /=<CR>
  vmap <Leader>a= :Tabularize /=<CR>
  nmap <Leader>a: :Tabularize /:<CR>
  vmap <Leader>a: :Tabularize /:<CR>
endif


" For rsyncing
nmap <leader>rn :silent !rsync -rltz --executability --filter=':- .gitignore' -e ssh . root@dev17.be.lan:/var/www/vhosts/network/sandbox/<CR>
nmap <leader>ra :silent !rsync -rltz --executability --filter=':- .gitignore' -e ssh . root@dev17.be.lan:/var/www/vhosts/network/sandbox/public/assets/<CR>
nmap <leader>rs :silent !rsync -rltz --executability --filter=':- .gitignore' -e ssh . root@dev17.be.lan:/var/www/vhosts/scheduler/sandbox/<CR>

nmap <leader>rc :silent !osascript -e 'tell application "Google Chrome Canary" to tell the active tab of its last window to reload'<CR>

" Quick access to vimrc for on-the-fly customizations
nmap <leader>ev :tabedit $MYVIMRC<CR>

nmap <leader>ss :%s/\s\+$//<CR><CR>``

"map <leader>nf :NERDTreeFind<CR>
map <leader>n :NERDTreeToggle<CR>
map <leader>/ <plug>NERDCommenterToggle<CR>
imap <leader>/ <esc><plug>NERDCommenterToggle<CR>

nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

" uppercase/lowercase a word
nmap <leader>uc mQviwU`Q
nmap <leader>lc mQviwu`Q

" rspec mappings, taken from @thoughtbot's dotfiles
" assumes using zeus in ruby projects
"map <Leader>t :call RunCurrentSpecFile()<CR>
"map <Leader>s :call RunNearestSpec()<CR>
"map <Leader>l :call RunLastSpec()<CR>

" Dash searching integration
map <leader>d :call SearchDash()<CR>

function! SearchDash()
  let s:browser = "/usr/bin/open"
  let s:wordUnderCursor = expand("<cword>")

  " Get the filetype (everything after the first ., for special cases
  " such as index.html.haml or abc.css.scss.erb)
  let s:fileType = substitute(expand("%"),"^[^.]*\.","",1)

  " Match it and set the searchType
  if match(s:fileType, "js") != -1
    let s:searchType = "js:"
  elseif match(s:fileType, "css") != -1
    let s:searchType = "css:"
  elseif match(s:fileType, "html") != -1
    let s:searchType = "html:"
  elseif match(s:fileType, "rb") != -1
    let s:searchType = "rb:"
  elseif match(s:fileType, "php") != -1
    let s:searchType = "php:"
  elseif match(s:fileType, "py") != -1
    let s:searchType = "python:"
  else
    let s:searchType = ""
  endif

  " Run it
  let s:url = "dash://".s:searchType.s:wordUnderCursor
  let s:cmd ="silent ! " . s:browser . " " . s:url
  execute s:cmd
  redraw!
endfunction
