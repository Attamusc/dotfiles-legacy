#!/usr/bin/env node
// generatedy by JSX compiler 0.9.86 (2014-04-18 14:04:03 +0900; c83e8c53332f8cd6df20119c5d1c50c01edbcd09)
var JSX = {};
(function (JSX) {
/**
 * extends the class
 */
function $__jsx_extend(derivations, base) {
	var ctor = function () {};
	ctor.prototype = base.prototype;
	var proto = new ctor();
	for (var i in derivations) {
		derivations[i].prototype = proto;
	}
}

/**
 * copies the implementations from source interface to target
 */
function $__jsx_merge_interface(target, source) {
	for (var k in source.prototype)
		if (source.prototype.hasOwnProperty(k))
			target.prototype[k] = source.prototype[k];
}

/**
 * defers the initialization of the property
 */
function $__jsx_lazy_init(obj, prop, func) {
	function reset(obj, prop, value) {
		delete obj[prop];
		obj[prop] = value;
		return value;
	}

	Object.defineProperty(obj, prop, {
		get: function () {
			return reset(obj, prop, func());
		},
		set: function (v) {
			reset(obj, prop, v);
		},
		enumerable: true,
		configurable: true
	});
}

var $__jsx_imul = Math.imul;
if (typeof $__jsx_imul === "undefined") {
	$__jsx_imul = function (a, b) {
		var ah  = (a >>> 16) & 0xffff;
		var al = a & 0xffff;
		var bh  = (b >>> 16) & 0xffff;
		var bl = b & 0xffff;
		return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0)|0);
	};
}

/**
 * fused int-ops with side-effects
 */
function $__jsx_ipadd(o, p, r) {
	return o[p] = (o[p] + r) | 0;
}
function $__jsx_ipsub(o, p, r) {
	return o[p] = (o[p] - r) | 0;
}
function $__jsx_ipmul(o, p, r) {
	return o[p] = $__jsx_imul(o[p], r);
}
function $__jsx_ipdiv(o, p, r) {
	return o[p] = (o[p] / r) | 0;
}
function $__jsx_ipmod(o, p, r) {
	return o[p] = (o[p] % r) | 0;
}
function $__jsx_ippostinc(o, p) {
	var v = o[p];
	o[p] = (v + 1) | 0;
	return v;
}
function $__jsx_ippostdec(o, p) {
	var v = o[p];
	o[p] = (v - 1) | 0;
	return v;
}

/**
 * non-inlined version of Array#each
 */
function $__jsx_forEach(o, f) {
	var l = o.length;
	for (var i = 0; i < l; ++i)
		f(o[i]);
}

/*
 * global functions, renamed to avoid conflict with local variable names
 */
var $__jsx_parseInt = parseInt;
var $__jsx_parseFloat = parseFloat;
function $__jsx_isNaN(n) { return n !== n; }
var $__jsx_isFinite = isFinite;

var $__jsx_encodeURIComponent = encodeURIComponent;
var $__jsx_decodeURIComponent = decodeURIComponent;
var $__jsx_encodeURI = encodeURI;
var $__jsx_decodeURI = decodeURI;

var $__jsx_ObjectToString = Object.prototype.toString;
var $__jsx_ObjectHasOwnProperty = Object.prototype.hasOwnProperty;

/*
 * profiler object, initialized afterwards
 */
function $__jsx_profiler() {
}

/*
 * public interface to JSX code
 */
JSX.require = function (path) {
	var m = $__jsx_classMap[path];
	return m !== undefined ? m : null;
};

JSX.profilerIsRunning = function () {
	return $__jsx_profiler.getResults != null;
};

JSX.getProfileResults = function () {
	return ($__jsx_profiler.getResults || function () { return {}; })();
};

JSX.postProfileResults = function (url, cb) {
	if ($__jsx_profiler.postResults == null)
		throw new Error("profiler has not been turned on");
	return $__jsx_profiler.postResults(url, cb);
};

JSX.resetProfileResults = function () {
	if ($__jsx_profiler.resetResults == null)
		throw new Error("profiler has not been turned on");
	return $__jsx_profiler.resetResults();
};
JSX.DEBUG = false;
var GeneratorFunction$0 = 
(function () {
  try {
    return Function('import {GeneratorFunction} from "std:iteration"; return GeneratorFunction')();
  } catch (e) {
    return function GeneratorFunction () {};
  }
})();
var __jsx_generator_object$0 = 
(function () {
  function __jsx_generator_object() {
  	this.__next = 0;
  	this.__loop = null;
	this.__seed = null;
  	this.__value = undefined;
  	this.__status = 0;	// SUSPENDED: 0, ACTIVE: 1, DEAD: 2
  }

  __jsx_generator_object.prototype.next = function (seed) {
  	switch (this.__status) {
  	case 0:
  		this.__status = 1;
  		this.__seed = seed;

  		// go next!
  		this.__loop(this.__next);

  		var done = false;
  		if (this.__next != -1) {
  			this.__status = 0;
  		} else {
  			this.__status = 2;
  			done = true;
  		}
  		return { value: this.__value, done: done };
  	case 1:
  		throw new Error("Generator is already running");
  	case 2:
  		throw new Error("Generator is already finished");
  	default:
  		throw new Error("Unexpected generator internal state");
  	}
  };

  return __jsx_generator_object;
}());
function _Main() {
};

$__jsx_extend([_Main], Object);
function _Main$main$AS(args) {
	var exitCode;
	var stdoutIsFlushed;
	var stderrIsFlushed;
	var exitIfFlushed;
	var opts$0;
	exitCode = JSXCommand$main$LPlatform$AS(new NodePlatform(), (opts$0 = process.env.JSX_OPTS, ! opts$0 ? [] : opts$0.split(/\s+/)).concat(args));
	if (JSX.profilerIsRunning()) {
		js$0.global.setTimeout((function () {
			JSX.postProfileResults("http://localhost:2012/post-profile", (function (err, result) {
			}));
		}), 0);
	}
	if (exitCode === 0) {
		return;
	}
	stdoutIsFlushed = process.stdout.write("");
	stderrIsFlushed = process.stderr.write("");
	exitIfFlushed = (function (data) {
		if (stdoutIsFlushed && stderrIsFlushed) {
			process.exit((exitCode | 0));
		}
	});
	if (! stdoutIsFlushed) {
		process.stdout.on('drain', exitIfFlushed);
	}
	if (! stderrIsFlushed) {
		process.stderr.on('drain', exitIfFlushed);
	}
	exitIfFlushed(null);
};

_Main.main = _Main$main$AS;
_Main.main$AS = _Main$main$AS;

var js$0 = (function () {
	var global = Function("return this")();
	return {
		global: global,
		eval: global.eval,
		invoke: function(invocant, methodName, args) {
			return invocant[methodName].apply(invocant, args);
		},
		newFunction: Function
	};
}());
function node() {}
$__jsx_extend([node], Object);
function node$require$S(source) {
	var src;
	src = 'require(' + JSON.stringify(source) + ')';
	return eval(src);
};

node.require$S = node$require$S;

function Timer() {
};

$__jsx_extend([Timer], Object);
function Timer$setTimeout$F$V$N(callback, intervalMS) {
	return js$0.global.setTimeout(callback, intervalMS);
};

Timer.setTimeout$F$V$N = Timer$setTimeout$F$V$N;

function Timer$clearTimeout$LTimerHandle$(timer) {
	js$0.global.clearTimeout(timer);
};

Timer.clearTimeout$LTimerHandle$ = Timer$clearTimeout$LTimerHandle$;

function Timer$setInterval$F$V$N(callback, intervalMS) {
	return js$0.global.setInterval(callback, intervalMS);
};

Timer.setInterval$F$V$N = Timer$setInterval$F$V$N;

function Timer$clearInterval$LTimerHandle$(timer) {
	js$0.global.clearInterval(timer);
};

Timer.clearInterval$LTimerHandle$ = Timer$clearInterval$LTimerHandle$;

function Timer$requestAnimationFrame$F$NV$(callback) {
	return Timer._requestAnimationFrame(callback);
};

Timer.requestAnimationFrame$F$NV$ = Timer$requestAnimationFrame$F$NV$;

function Timer$cancelAnimationFrame$LTimerHandle$(timer) {
	Timer._cancelAnimationFrame(timer);
};

Timer.cancelAnimationFrame$LTimerHandle$ = Timer$cancelAnimationFrame$LTimerHandle$;

function Timer$useNativeRAF$B(enable) {
	Timer._requestAnimationFrame = Timer$_getRequestAnimationFrameImpl$B(enable);
	Timer._cancelAnimationFrame = Timer$_getCancelAnimationFrameImpl$B(enable);
};

Timer.useNativeRAF$B = Timer$useNativeRAF$B;

function Timer$_getRequestAnimationFrameImpl$B(useNativeImpl) {
	var prefixes;
	var i;
	var name;
	var lastTime;
	var prefixes$len$0;
	if (useNativeImpl) {
		prefixes = [ "r", "webkitR", "mozR", "oR", "msR" ];
		for ((i = 0, prefixes$len$0 = prefixes.length); i < prefixes$len$0; ++i) {
			name = prefixes[i] + "equestAnimationFrame";
			if (js$0.global[name] instanceof Function) {
				return (function (callback) {
					return js$0.global[name](callback);
				});
			}
		}
	}
	lastTime = 0;
	return (function (callback) {
		var now;
		var timeToCall;
		var value2$0;
		now = Date.now();
		value2$0 = 16 - (now - lastTime);
		timeToCall = (0 >= value2$0 ? 0 : value2$0);
		lastTime = now + timeToCall;
		return js$0.global.setTimeout((function () {
			callback(now + timeToCall);
		}), timeToCall);
	});
};

Timer._getRequestAnimationFrameImpl$B = Timer$_getRequestAnimationFrameImpl$B;

function Timer$_getCancelAnimationFrameImpl$B(useNativeImpl) {
	var prefixes;
	var i;
	var name;
	var prefixes$len$0;
	if (useNativeImpl) {
		prefixes = [ "c", "webkitC", "mozC", "oC", "msC" ];
		for ((i = 0, prefixes$len$0 = prefixes.length); i < prefixes$len$0; ++i) {
			name = prefixes[i] + "ancelAnimationFrame";
			if (js$0.global[name] instanceof Function) {
				return (function (timer) {
					js$0.global[name](timer);
				});
			}
		}
	}
	return Timer$clearTimeout$LTimerHandle$;
};

Timer._getCancelAnimationFrameImpl$B = Timer$_getCancelAnimationFrameImpl$B;

function TimerHandle() {}
$__jsx_extend([TimerHandle], Object);
function Util() {
};

$__jsx_extend([Util], Object);
function Util$repeat$SN(c, n) {
	var s;
	var i;
	s = "";
	for (i = 0; i < n; ++i) {
		s += c;
	}
	return s;
};

Util.repeat$SN = Util$repeat$SN;

function Util$format$SAS(fmt, args) {
	return fmt.replace(/%(\d+|%)/g, (function (m) {
		var arg;
		if (m === "%%") {
			return "%";
		} else {
			arg = args[(m.substring(1) | 0) - 1];
			return (arg == null ? "null" : arg);
		}
	}));
};

Util.format$SAS = Util$format$SAS;

function Util$ld$SS(a, b) {
	var m;
	var i;
	var j;
	var diff;
	var x;
	m = [];
	for (i = 0; i <= a.length; ++i) {
		m[i] = [ i ];
	}
	for (j = 0; j <= b.length; ++j) {
		m[0][j] = j;
	}
	for (i = 1; i <= a.length; ++i) {
		for (j = 1; j <= b.length; ++j) {
			diff = (a.charCodeAt(i - 1) === b.charCodeAt(j - 1) ? 0 : 1);
			m[i][j] = Math.min(m[i - 1][j - 1] + diff, m[i - 1][j] + 1, m[i][j - 1] + 1);
		}
	}
	x = m[m.length - 1];
	return x[x.length - 1];
};

Util.ld$SS = Util$ld$SS;

function Util$isBuiltInClass$S(name) {
	return $__jsx_ObjectHasOwnProperty.call(Util._builtInClass, name);
};

Util.isBuiltInClass$S = Util$isBuiltInClass$S;

function Util$isBuiltInClass$LType$(type) {
	return Util$_isBuiltInObjectType$LType$HB(type, Util._builtInClass);
};

Util.isBuiltInClass$LType$ = Util$isBuiltInClass$LType$;

function Util$isBuiltInContainer$LType$(type) {
	return Util$_isBuiltInObjectType$LType$HB(type, Util._builtInContainer);
};

Util.isBuiltInContainer$LType$ = Util$isBuiltInContainer$LType$;

function Util$_isBuiltInObjectType$LType$HB(type, classeSet) {
	var classDef;
	var className;
	var this$0;
	var this$0$0;
	if (type instanceof ObjectType) {
		classDef = type.getClassDef$();
		className = (classDef instanceof InstantiatedClassDefinition ? (this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) : classDef.className$());
		return $__jsx_ObjectHasOwnProperty.call(classeSet, className);
	}
	return false;
};

Util._isBuiltInObjectType$LType$HB = Util$_isBuiltInObjectType$LType$HB;

function Util$rootIsNativeClass$LType$(type) {
	var classDef;
	if (type instanceof ObjectType) {
		classDef = type.getClassDef$();
		return ! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(classDef, (function (classDef) {
			return (classDef.className$() === "Object" || (classDef.flags$() & 16) === 0 ? true : false);
		}));
	}
	return false;
};

Util.rootIsNativeClass$LType$ = Util$rootIsNativeClass$LType$;

function Util$instantiateTemplate$LAnalysisContext$LToken$SALType$(context, token, className, typeArguments) {
	return Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: token, _className: className, _typeArgs: typeArguments}), context.postInstantiationCallback);
};

Util.instantiateTemplate$LAnalysisContext$LToken$SALType$ = Util$instantiateTemplate$LAnalysisContext$LToken$SALType$;

function Util$analyzeArgs$LAnalysisContext$ALExpression$LExpression$ALUtil$x2EArgumentTypeRequest$(context, args, parentExpr, expectedTypes) {
	var argTypes;
	var i;
	var funcDef;
	var expectedCallbackType;
	var j;
	var callbackType;
	var typeNotContainsParameter;
	var k;
	var argType;
	var arrayExpr;
	var expectedArrayType;
	var mapExpr;
	var expectedMapType;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$0$0;
	var this$4;
	var this$0$1;
	var this$5;
	argTypes = [  ];
	for (i = 0; i < args.length; ++i) {
		if (args[i] instanceof FunctionExpression && ! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(args[i])) {
			this$0 = args[i];
			funcDef = this$0._funcDef;
			expectedCallbackType = null;
			for (j = 0; j < expectedTypes.length; ++j) {
				if (Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)) != null && Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)) instanceof StaticFunctionType && (this$5 = Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)), this$5._argTypes).length === funcDef._args.length) {
					callbackType = (this$1 = Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)), new StaticFunctionType(this$1._token, this$1._returnType, this$1._argTypes.concat([  ]), this$1._isAssignable));
					function typeNotContainsParameter(type) {
						var k;
						var this$0;
						var this$1;
						var this$2;
						var this$3;
						var this$4;
						var this$0$0;
						var this$5;
						var this$6;
						for (k = 0; k < expectedTypes[j].typeArgs.length; ++k) {
							if (type instanceof ParsedObjectType && (this$1 = (this$0 = type, this$0._qualifiedName), this$1._import) == null && (this$3 = (this$2 = type, this$2._qualifiedName), this$3._enclosingType) == null && (this$5 = (this$4 = type, this$0$0 = this$4._qualifiedName, this$0$0._token), this$5._value) === (this$6 = expectedTypes[j].typeArgs[k], this$6._value)) {
								return false;
							}
						}
						return type.forEachType$F$LType$B$(typeNotContainsParameter);
					}
					for (k = 0; k < callbackType._argTypes.length; ++k) {
						argType = callbackType._argTypes[k];
						if (! typeNotContainsParameter(argType)) {
							callbackType._argTypes[k] = null;
						}
					}
					if (callbackType._returnType != null && ! typeNotContainsParameter(callbackType._returnType)) {
						callbackType._returnType = null;
					}
					if (expectedCallbackType == null) {
						expectedCallbackType = callbackType;
					} else if (Util$typesAreEqual$ALType$ALType$(expectedCallbackType._argTypes, callbackType._argTypes) && (expectedCallbackType._returnType == null && callbackType._returnType == null || expectedCallbackType._returnType.equals$LType$(callbackType._returnType))) {
					} else {
						break;
					}
				}
			}
			if (j !== expectedTypes.length) {
			} else if (expectedCallbackType != null) {
				if (! (this$2 = args[i], ! MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$(this$2._funcDef, context, expectedCallbackType) ? false : true)) {
					return null;
				}
			}
		} else if (args[i] instanceof ArrayLiteralExpression) {
			arrayExpr = args[i];
			expectedArrayType = null;
			for (j = 0; j < expectedTypes.length; ++j) {
				if (Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)) != null && Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)) instanceof ObjectType && Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)).getClassDef$() instanceof InstantiatedClassDefinition && (this$3 = Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)).getClassDef$(), this$0$0 = this$3._templateClassDef, this$0$0._className) === 'Array') {
					if (expectedArrayType == null) {
						expectedArrayType = Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0));
					} else if (expectedArrayType.equals$LType$(Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)))) {
					} else {
						break;
					}
				}
			}
			if (j !== expectedTypes.length) {
			} else if (expectedArrayType != null) {
				arrayExpr._type = expectedArrayType;
			}
		} else if (args[i] instanceof MapLiteralExpression) {
			mapExpr = args[i];
			expectedMapType = null;
			for (j = 0; j < expectedTypes.length; ++j) {
				if (Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)) != null && Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)) instanceof ObjectType && Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)).getClassDef$() instanceof InstantiatedClassDefinition && (this$4 = Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)).getClassDef$(), this$0$1 = this$4._templateClassDef, this$0$1._className) === 'Map') {
					if (expectedMapType == null) {
						expectedMapType = Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0));
					} else if (expectedMapType.equals$LType$(Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I(expectedTypes[j], (i | 0)))) {
					} else {
						break;
					}
				}
			}
			if (j !== expectedTypes.length) {
			} else if (expectedMapType != null) {
				mapExpr._type = expectedMapType;
			}
		}
		if (! args[i].analyze$LAnalysisContext$LExpression$(context, parentExpr)) {
			return null;
		}
		argTypes[i] = args[i].getType$();
	}
	return argTypes;
};

Util.analyzeArgs$LAnalysisContext$ALExpression$LExpression$ALUtil$x2EArgumentTypeRequest$ = Util$analyzeArgs$LAnalysisContext$ALExpression$LExpression$ALUtil$x2EArgumentTypeRequest$;

function Util$typesAreEqual$ALType$ALType$(x, y) {
	var i;
	var x$len$0;
	if (x.length !== y.length) {
		return false;
	}
	for ((i = 0, x$len$0 = x.length); i < x$len$0; ++i) {
		if (x[i] == null || y[i] == null) {
			continue;
		}
		if (! x[i].equals$LType$(y[i])) {
			return false;
		}
	}
	return true;
};

Util.typesAreEqual$ALType$ALType$ = Util$typesAreEqual$ALType$ALType$;

function Util$forEachStatement$F$LStatement$B$ALStatement$(cb, statements) {
	return Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$((function (stmt, _) {
		return cb(stmt);
	}), statements);
};

Util.forEachStatement$F$LStatement$B$ALStatement$ = Util$forEachStatement$F$LStatement$B$ALStatement$;

function Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$(cb, statements) {
	var i;
	var statements$len$0;
	if (statements != null) {
		for ((i = 0, statements$len$0 = statements.length); i < statements$len$0; ++i) {
			if (! cb(statements[i], (function (statements, index) {
				return (function (stmt) {
					statements[index] = stmt;
				});
			})(statements, i))) {
				return false;
			}
		}
	}
	return true;
};

Util.forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$ = Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$;

function Util$forEachExpression$F$LExpression$B$ALExpression$(cb, exprs) {
	return Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$((function (expr, _) {
		return cb(expr);
	}), exprs);
};

Util.forEachExpression$F$LExpression$B$ALExpression$ = Util$forEachExpression$F$LExpression$B$ALExpression$;

function Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, exprs) {
	var i;
	var exprs$len$0;
	if (exprs != null) {
		for ((i = 0, exprs$len$0 = exprs.length); i < exprs$len$0; ++i) {
			if (! cb(exprs[i], (function (exprs, index) {
				return (function (expr) {
					exprs[index] = expr;
				});
			})(exprs, i))) {
				return false;
			}
		}
	}
	return true;
};

Util.forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$ = Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$;

function Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, funcName, argTypes, isStatic) {
	var found;
	found = null;
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
		var this$0$0;
		if (isStatic === ((funcDef._flags & 8) !== 0) && (this$0$0 = funcDef._nameToken, this$0$0._value) === funcName && Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), argTypes)) {
			found = funcDef;
			return false;
		}
		return true;
	}));
	return found;
};

Util.findFunctionInClass$LClassDefinition$SALType$B = Util$findFunctionInClass$LClassDefinition$SALType$B;

function Util$findVariableInClass$LClassDefinition$SB(classDef, name, isStatic) {
	var found;
	found = null;
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (def) {
		var this$0$0;
		if (isStatic === ((def._flags & 8) !== 0) && (this$0$0 = def._nameToken, this$0$0._value) === name) {
			found = def;
			return false;
		}
		return true;
	}));
	return found;
};

Util.findVariableInClass$LClassDefinition$SB = Util$findVariableInClass$LClassDefinition$SB;

function Util$findMemberInClass$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic) {
	return (argTypes != null ? Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic) : Util$findVariableInClass$LClassDefinition$SB(classDef, name, isStatic));
};

Util.findMemberInClass$LClassDefinition$SALType$B = Util$findMemberInClass$LClassDefinition$SALType$B;

function Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic) {
	var rootIsNativeNonStatic;
	if (isStatic) {
		return (classDef.flags$() & 272) !== 0;
	}
	function rootIsNativeNonStatic(classDef, name, argTypes) {
		var found;
		var this$0;
		found = (argTypes != null ? Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, false) : Util$findVariableInClass$LClassDefinition$SB(classDef, name, false));
		return (found != null && (found._flags & 32) === 0 ? (classDef.flags$() & 272) !== 0 : classDef._extendType == null ? false : rootIsNativeNonStatic((this$0 = classDef._extendType, this$0._classDef), name, argTypes));
	}
	return rootIsNativeNonStatic(classDef, name, argTypes);
};

Util.memberRootIsNative$LClassDefinition$SALType$B = Util$memberRootIsNative$LClassDefinition$SALType$B;

function Util$propertyRootIsNative$LPropertyExpression$(expr) {
	var baseExpr;
	var this$0;
	var exprType$0;
	var this$1;
	baseExpr = expr._expr;
	return Util$memberRootIsNative$LClassDefinition$SALType$B(baseExpr.getType$().getClassDef$(), (this$0 = expr._identifierToken, this$0._value), (exprType$0 = expr._type, ! (exprType$0 instanceof FunctionType) ? false : exprType$0.isAssignable$() ? false : true) ? (this$1 = expr._type, this$1._argTypes) : null, baseExpr.isClassSpecifier$());
};

Util.propertyRootIsNative$LPropertyExpression$ = Util$propertyRootIsNative$LPropertyExpression$;

function Util$memberIsExported$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic) {
	var found;
	var check;
	if (isStatic) {
		found = (argTypes != null ? Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, true) : Util$findVariableInClass$LClassDefinition$SB(classDef, name, true));
		return (found._flags & 16384) !== 0;
	}
	function check(classDef) {
		var found;
		var isExportedInImpl;
		var this$0;
		if ((classDef.flags$() & 16) !== 0) {
			return false;
		}
		found = (argTypes != null ? Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, false) : Util$findVariableInClass$LClassDefinition$SB(classDef, name, false));
		if (found != null && (found._flags & 16384) !== 0) {
			return true;
		}
		if (classDef._extendType != null) {
			if (check((this$0 = classDef._extendType, this$0._classDef))) {
				return true;
			}
		}
		isExportedInImpl = false;
		classDef._implementTypes.forEach((function (implType) {
			if (check(implType.getClassDef$())) {
				isExportedInImpl = true;
			}
		}));
		return isExportedInImpl;
	}
	return check(classDef);
};

Util.memberIsExported$LClassDefinition$SALType$B = Util$memberIsExported$LClassDefinition$SALType$B;

function Util$isReferringToFunctionDefinition$LPropertyExpression$(expr) {
	var exprType;
	exprType = expr._type;
	return (! (exprType instanceof FunctionType) ? false : exprType.isAssignable$() ? false : true);
};

Util.isReferringToFunctionDefinition$LPropertyExpression$ = Util$isReferringToFunctionDefinition$LPropertyExpression$;

function Util$encodeStringLiteral$S(str) {
	var escaped;
	escaped = str.replace(/[\0-\x19\\'"\u007f-\uffff]/g, (function (ch) {
		var t;
		if (ch in Util._stringLiteralEncodingMap) {
			return Util._stringLiteralEncodingMap[ch];
		} else {
			t = "000" + ch.charCodeAt(0).toString(16);
			t = t.substring(t.length - 4);
			return "\\u" + t;
		}
	}));
	return "\"" + escaped + "\"";
};

Util.encodeStringLiteral$S = Util$encodeStringLiteral$S;

function Util$decodeStringLiteral$S(literal) {
	var matched;
	var src;
	var decoded;
	var pos;
	var backslashAt;
	var escapeChar;
	literal = Util$_normalizeHeredoc$S(literal);
	matched = literal.match(/^([\'\"]).*([\'\"])$/);
	if (matched == null || matched[1] !== matched[2]) {
		throw new Error("input string is not quoted properly: " + literal);
	}
	src = literal.substring(1, literal.length - 1);
	decoded = "";
	pos = 0;
	while ((backslashAt = src.indexOf("\\", pos)) !== -1) {
		decoded += src.substring(pos, backslashAt);
		pos = backslashAt + 1;
		if (pos === src.length) {
			throw new Error("last character within a string literal cannot be a backslash: " + literal);
		}
		escapeChar = src.charAt(pos++);
		switch (escapeChar) {
		case "'":
		case "\"":
		case "\\":
			decoded += escapeChar;
			break;
		case "b":
			decoded += "\b";
			break;
		case "f":
			decoded += "\f";
			break;
		case "n":
			decoded += "\n";
			break;
		case "r":
			decoded += "\r";
			break;
		case "t":
			decoded += "\t";
			break;
		case "v":
			decoded += "\v";
			break;
		case "u":
			matched = src.substring(pos).match(/^([0-9A-Fa-f]{4})/);
			if (matched == null) {
				throw new Error("expected four hexdigits after \\u: " + literal);
			}
			decoded += String.fromCharCode($__jsx_parseInt(matched[1], 16));
			pos += 4;
			break;
		case "x":
			matched = src.substring(pos).match(/^([0-9A-Fa-f]{2})/);
			if (matched == null) {
				throw new Error("expected two hexdigits after \\x: " + literal);
			}
			decoded += String.fromCharCode($__jsx_parseInt(matched[1], 16));
			pos += 2;
			break;
		case "0":
			if (pos === src.length || src.charAt(pos).match(/[0-9]/) == null) {
				decoded += "\0";
			} else {
				throw new Error("found a digit after '\\0': " + literal);
			}
			break;
		}
	}
	decoded += src.substring(pos);
	return decoded;
};

Util.decodeStringLiteral$S = Util$decodeStringLiteral$S;

function Util$_normalizeHeredoc$S(literal) {
	var body;
	if (! literal.match(/^(?:"""|''')/)) {
		return literal;
	}
	body = literal.substring(3, literal.length - 3);
	body = body.replace(/\\*['"]/g, (function (matched) {
		return (matched.length % 2 === 0 ? matched : matched.replace(/(.)$/, "\\$1"));
	}));
	body = body.replace(/\n/g, "\\n");
	return '"' + body + '"';
};

Util._normalizeHeredoc$S = Util$_normalizeHeredoc$S;

function Util$_resolvedPathParts$S(path) {
	var tokens;
	var i;
	tokens = path.split(/[\\\/]+/);
	if (tokens.length === 1) {
		return tokens;
	}
	for (i = 0; i < tokens.length; ) {
		if (tokens[i] === ".") {
			tokens.splice(i, 1);
		} else if (tokens[i] === ".." && i !== 0 && tokens[i - 1] !== "..") {
			tokens.splice(i - 1, 2);
			i -= 1;
		} else {
			i++;
		}
	}
	return tokens;
};

Util._resolvedPathParts$S = Util$_resolvedPathParts$S;

function Util$resolvePath$S(path) {
	return Util$_resolvedPathParts$S(path).join("/");
};

Util.resolvePath$S = Util$resolvePath$S;

function Util$relativePath$SSB(fromPath, toPath, isFile) {
	var f;
	var t;
	var minLen;
	var samePartsIndex;
	var i;
	var pathParts;
	var value1$0;
	var value2$0;
	f = Util$_resolvedPathParts$S(fromPath);
	t = Util$_resolvedPathParts$S(toPath);
	if (isFile) {
		f.pop();
	}
	if (f[0] === "") {
		f.shift();
	}
	if (t[0] === "") {
		t.shift();
	}
	value1$0 = f.length;
	value2$0 = t.length;
	minLen = (value1$0 <= value2$0 ? value1$0 : value2$0);
	samePartsIndex = minLen;
	for (i = 0; i < minLen; ++i) {
		if (f[i] !== t[i]) {
			samePartsIndex = i;
			break;
		}
	}
	pathParts = [];
	for (i = samePartsIndex; i < f.length; ++i) {
		pathParts.push("..");
	}
	return pathParts.concat(t.slice(samePartsIndex)).join("/");
};

Util.relativePath$SSB = Util$relativePath$SSB;

function Util$basename$S(path) {
	var parts;
	parts = Util$_resolvedPathParts$S(path);
	return parts.pop();
};

Util.basename$S = Util$basename$S;

function Util$dirname$S(path) {
	var parts;
	parts = Util$_resolvedPathParts$S(path);
	parts.pop();
	return (parts.length !== 0 ? parts.join("/") : ".");
};

Util.dirname$S = Util$dirname$S;

function Util$toOrdinal$N(n) {
	if (10 < n && n < 14) {
		return (n + "") + 'th';
	}
	switch (n % 10) {
	case 1:
		return (n + "") + 'st';
	case 2:
		return (n + "") + 'nd';
	case 3:
		return (n + "") + 'rd';
	default:
		return (n + "") + 'th';
	}
};

Util.toOrdinal$N = Util$toOrdinal$N;

function Util$makeErrorMessage$LPlatform$SUSNNN(platform, message, filename, lineNumber, columnNumber, size) {
	var content;
	var sourceLine;
	var TAB_WIDTH;
	var tabs;
	if (filename == null) {
		return message + "\n";
	}
	content = platform.load$S(filename);
	sourceLine = content.split(/\n/)[lineNumber - 1] + "\n";
	TAB_WIDTH = 4;
	tabs = sourceLine.slice(0, columnNumber).match(/\t/g);
	if (tabs != null) {
		columnNumber += (TAB_WIDTH - 1) * tabs.length;
	}
	sourceLine = sourceLine.replace(/\t/g, Util$repeat$SN(" ", TAB_WIDTH));
	sourceLine += Util$repeat$SN(" ", columnNumber);
	sourceLine += Util$repeat$SN("^", size);
	return Util$format$SAS("[%1:%2:%3] %4\n%5\n", [ filename, lineNumber + "", columnNumber + "", message, sourceLine ]);
};

Util.makeErrorMessage$LPlatform$SUSNNN = Util$makeErrorMessage$LPlatform$SUSNNN;

function Util$isArrayOf$LClassDefinition$LType$(classDef, expectedElementType) {
	var instantiatedClassDef;
	var this$0$0;
	if (! (classDef instanceof InstantiatedClassDefinition)) {
		return false;
	}
	instantiatedClassDef = classDef;
	return ((this$0$0 = instantiatedClassDef._templateClassDef, this$0$0._className) !== "Array" ? false : ! instantiatedClassDef._typeArguments[0].equals$LType$(expectedElementType) ? false : true);
};

Util.isArrayOf$LClassDefinition$LType$ = Util$isArrayOf$LClassDefinition$LType$;

function Util$asSet$AS(array) {
	var set;
	var i;
	set = {};
	for (i = 0; i < array.length; ++i) {
		set[array[i]] = true;
	}
	return set;
};

Util.asSet$AS = Util$asSet$AS;

function Util$rebaseClosures$LMemberFunctionDefinition$LMemberFunctionDefinition$(srcParent, dstParent) {
	var closures;
	var i;
	var funcDef$0;
	var j$0;
	var funcDef$1;
	var classDef$0$0;
	closures = [];
	Util$forEachStatement$F$LStatement$B$ALStatement$((function (statement) {
		var this$0;
		if (statement instanceof FunctionStatement) {
			closures.push((this$0 = statement, this$0._funcDef));
		}
		return Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			if (expr instanceof FunctionExpression) {
				closures.push(FunctionExpression$getFuncDef$LFunctionExpression$(expr));
				return true;
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}));
	}), dstParent._statements);
	for (i = 0; i < closures.length; ++i) {
		funcDef$0 = closures[i];
		if ((j$0 = srcParent._closures.indexOf(funcDef$0)) !== -1) {
			srcParent._closures.splice(j$0, 1);
		}
		MemberFunctionDefinition$setParent$LMemberFunctionDefinition$LMemberFunctionDefinition$(funcDef$0, null);
		funcDef$1 = closures[i];
		dstParent._closures.push(funcDef$1);
		funcDef$1._parent = dstParent;
		classDef$0$0 = dstParent._classDef;
		funcDef$1._classDef = classDef$0$0;
	}
};

Util.rebaseClosures$LMemberFunctionDefinition$LMemberFunctionDefinition$ = Util$rebaseClosures$LMemberFunctionDefinition$LMemberFunctionDefinition$;

function Util$unlinkFunction$LMemberFunctionDefinition$LMemberFunctionDefinition$(funcDef, oldParent) {
	var j;
	if ((j = oldParent._closures.indexOf(funcDef)) !== -1) {
		oldParent._closures.splice(j, 1);
	}
	MemberFunctionDefinition$setParent$LMemberFunctionDefinition$LMemberFunctionDefinition$(funcDef, null);
};

Util.unlinkFunction$LMemberFunctionDefinition$LMemberFunctionDefinition$ = Util$unlinkFunction$LMemberFunctionDefinition$LMemberFunctionDefinition$;

function Util$linkFunction$LMemberFunctionDefinition$LMemberFunctionDefinition$(funcDef, newParent) {
	var classDef$0;
	newParent._closures.push(funcDef);
	funcDef._parent = newParent;
	classDef$0 = newParent._classDef;
	funcDef._classDef = classDef$0;
};

Util.linkFunction$LMemberFunctionDefinition$LMemberFunctionDefinition$ = Util$linkFunction$LMemberFunctionDefinition$LMemberFunctionDefinition$;

function Util$cloneArray$ALExpression$(a) {
	var r;
	var i;
	r = [  ];
	for (i = 0; i < a.length; ++i) {
		r[i] = a[i].clone$();
	}
	return r;
};

Util.cloneArray$ALExpression$ = Util$cloneArray$ALExpression$;

function Util$serializeArray$ALExpression$(a) {
	var ret;
	var i;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++i) {
		ret[i] = a[i].serialize$();
	}
	return ret;
};

Util.serializeArray$ALExpression$ = Util$serializeArray$ALExpression$;

function Util$serializeNullable$LType$(v) {
	return (v == null ? null : v.toString());
};

Util.serializeNullable$LType$ = Util$serializeNullable$LType$;

function Util$serializeArray$ALMapLiteralElement$(a) {
	var ret;
	var i;
	var this$0;
	var this$0$0;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++i) {
		this$0 = a[i];
		ret[i] = [ (this$0$0 = this$0._key, [ this$0$0._value, this$0$0._isIdentifier, this$0$0._filename, this$0$0._lineNumber, this$0$0._columnNumber ]), this$0._expr.serialize$() ];
	}
	return ret;
};

Util.serializeArray$ALMapLiteralElement$ = Util$serializeArray$ALMapLiteralElement$;

function Util$serializeNullable$LExpression$(v) {
	return (v == null ? null : v.serialize$());
};

Util.serializeNullable$LExpression$ = Util$serializeNullable$LExpression$;

function Util$cloneNullable$LExpression$(o) {
	return (o == null ? null : o.clone$());
};

Util.cloneNullable$LExpression$ = Util$cloneNullable$LExpression$;

function Util$serializeNullable$LToken$(v) {
	return (v == null ? null : [ v._value, v._isIdentifier, v._filename, v._lineNumber, v._columnNumber ]);
};

Util.serializeNullable$LToken$ = Util$serializeNullable$LToken$;

function Util$cloneArray$ALStatement$(a) {
	var r;
	var i;
	r = [  ];
	for (i = 0; i < a.length; ++i) {
		r[i] = a[i].clone$();
	}
	return r;
};

Util.cloneArray$ALStatement$ = Util$cloneArray$ALStatement$;

function Util$serializeArray$ALStatement$(a) {
	var ret;
	var i;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++i) {
		ret[i] = a[i].serialize$();
	}
	return ret;
};

Util.serializeArray$ALStatement$ = Util$serializeArray$ALStatement$;

function Util$cloneArray$ALCatchStatement$(a) {
	var r;
	var i;
	var this$0;
	r = [  ];
	for (i = 0; i < a.length; ++i) {
		r[i] = (this$0 = a[i], new CatchStatement(this$0._token, this$0._local, Util$cloneArray$ALStatement$(this$0._statements)));
	}
	return r;
};

Util.cloneArray$ALCatchStatement$ = Util$cloneArray$ALCatchStatement$;

function Util$serializeArray$ALCatchStatement$(a) {
	var ret;
	var i;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++i) {
		ret[i] = a[i].serialize$();
	}
	return ret;
};

Util.serializeArray$ALCatchStatement$ = Util$serializeArray$ALCatchStatement$;

function Util$serializeNullable$LParsedObjectType$(v) {
	return (v == null ? null : v.toString());
};

Util.serializeNullable$LParsedObjectType$ = Util$serializeNullable$LParsedObjectType$;

function Util$serializeArray$ALParsedObjectType$(a) {
	var ret;
	var i;
	var this$0;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++i) {
		this$0 = a[i];
		ret[i] = this$0.toString();
	}
	return ret;
};

Util.serializeArray$ALParsedObjectType$ = Util$serializeArray$ALParsedObjectType$;

function Util$serializeArray$ALMemberDefinition$(a) {
	var ret;
	var i;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++i) {
		ret[i] = a[i].serialize$();
	}
	return ret;
};

Util.serializeArray$ALMemberDefinition$ = Util$serializeArray$ALMemberDefinition$;

function Util$serializeArray$ALClassDefinition$(a) {
	var ret;
	var i;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++i) {
		ret[i] = ClassDefinition$serialize$LClassDefinition$(a[i]);
	}
	return ret;
};

Util.serializeArray$ALClassDefinition$ = Util$serializeArray$ALClassDefinition$;

function Util$serializeArray$ALTemplateClassDefinition$(a) {
	var ret;
	var i;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++i) {
		ret[i] = ClassDefinition$serialize$LClassDefinition$(a[i]);
	}
	return ret;
};

Util.serializeArray$ALTemplateClassDefinition$ = Util$serializeArray$ALTemplateClassDefinition$;

function Util$serializeArray$ALArgumentDeclaration$(a) {
	var ret;
	var i;
	var this$0;
	var v$0$0;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++i) {
		this$0 = a[i];
		ret[i] = [ this$0._name, (v$0$0 = this$0._type, v$0$0 == null ? null : v$0$0.toString()) ];
	}
	return ret;
};

Util.serializeArray$ALArgumentDeclaration$ = Util$serializeArray$ALArgumentDeclaration$;

function Util$serializeArray$ALLocalVariable$(a) {
	var ret;
	var i;
	var this$0;
	var v$0$0;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++i) {
		this$0 = a[i];
		ret[i] = [ this$0._name, (v$0$0 = this$0._type, v$0$0 == null ? null : v$0$0.toString()) ];
	}
	return ret;
};

Util.serializeArray$ALLocalVariable$ = Util$serializeArray$ALLocalVariable$;

function Util$serializeArray$ALToken$(a) {
	var ret;
	var i;
	var this$0;
	if (a == null) {
		return null;
	}
	ret = [  ];
	for (i = 0; i < a.length; ++i) {
		this$0 = a[i];
		ret[i] = [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ];
	}
	return ret;
};

Util.serializeArray$ALToken$ = Util$serializeArray$ALToken$;

function Util$serializeNullable$LImport$(v) {
	return (v == null ? null : Import$serialize$LImport$(v));
};

Util.serializeNullable$LImport$ = Util$serializeNullable$LImport$;

function Util$makePair$LAssignmentExpression$F$LExpression$V$(first, second) {
	return ({first: first, second: second});
};

Util.makePair$LAssignmentExpression$F$LExpression$V$ = Util$makePair$LAssignmentExpression$F$LExpression$V$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E() {
	var $this = this;
	this._list = [];
	this._equalsCallback = (function (x, y) {
		return x == y;
	});
};

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$0(equalsCallback) {
	this._list = [];
	this._equalsCallback = equalsCallback;
};

$__jsx_extend([TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E, TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$0], Object);
function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$clone$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$($this) {
	var x;
	x = ({_list: [], _equalsCallback: $this._equalsCallback});
	x._list = $this._list.concat([  ]);
	return x;
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.clone$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$clone$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$has$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$($this, key) {
	return ! TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$forEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$($this, (function (entryKey, entryValue) {
		return ! $this._equalsCallback(key, entryKey);
	}));
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.has$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$has$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$set$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$LMemberFunctionDefinition$($this, key, val) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list[i].second = val;
			return;
		}
	}
	$this._list.push(({first: key, second: val}));
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.set$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$LMemberFunctionDefinition$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$set$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$LMemberFunctionDefinition$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$get$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			return $this._list[i].second;
		}
	}
	return null;
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.get$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$get$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$delete$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list.splice(i, 1);
			return;
		}
	}
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.delete$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$delete$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$clear$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$($this) {
	var _list$0;
	(_list$0 = $this._list).splice(0, _list$0.length);
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.clear$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$clear$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$forEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$($this, cb) {
	var i;
	var e;
	for (i = 0; i < $this._list.length; ++i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.forEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$forEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$;

function TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$reversedForEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$($this, cb) {
	var i;
	var e;
	for (i = $this._list.length - 1; i >= 0; --i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E.reversedForEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$ = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$reversedForEach$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$F$ALType$LMemberFunctionDefinition$B$;

function Pair$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E(first, second) {
	this.first = first;
	this.second = second;
};

$__jsx_extend([Pair$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E], Object);
function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E() {
	var $this = this;
	this._list = [];
	this._equalsCallback = (function (x, y) {
		return x == y;
	});
};

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$0(equalsCallback) {
	this._list = [];
	this._equalsCallback = equalsCallback;
};

$__jsx_extend([TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E, TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$0], Object);
function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$clone$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$($this) {
	var x;
	x = ({_list: [], _equalsCallback: $this._equalsCallback});
	x._list = $this._list.concat([  ]);
	return x;
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.clone$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$clone$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$($this, key) {
	return ! TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$($this, (function (entryKey, entryValue) {
		return ! $this._equalsCallback(key, entryKey);
	}));
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.has$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B($this, key, val) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list[i].second = val;
			return;
		}
	}
	$this._list.push(({first: key, second: val}));
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			return $this._list[i].second;
		}
	}
	return null;
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list.splice(i, 1);
			return;
		}
	}
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.delete$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$($this) {
	var _list$0;
	(_list$0 = $this._list).splice(0, _list$0.length);
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.clear$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$($this, cb) {
	var i;
	var e;
	for (i = 0; i < $this._list.length; ++i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.forEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$;

function TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$($this, cb) {
	var i;
	var e;
	for (i = $this._list.length - 1; i >= 0; --i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E.reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$ = TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$F$LLocalVariable$BB$;

function Pair$x2E$x3CLocalVariable$x2Cboolean$x3E(first, second) {
	this.first = first;
	this.second = second;
};

$__jsx_extend([Pair$x2E$x3CLocalVariable$x2Cboolean$x3E], Object);
function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E() {
	var $this = this;
	this._list = [];
	this._equalsCallback = (function (x, y) {
		return x == y;
	});
};

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$0(equalsCallback) {
	this._list = [];
	this._equalsCallback = equalsCallback;
};

$__jsx_extend([TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E, TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$0], Object);
function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$clone$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$($this) {
	var x;
	x = ({_list: [], _equalsCallback: $this._equalsCallback});
	x._list = $this._list.concat([  ]);
	return x;
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.clone$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$clone$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$($this, key) {
	return ! TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$($this, (function (entryKey, entryValue) {
		return ! $this._equalsCallback(key, entryKey);
	}));
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.has$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$($this, key, val) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list[i].second = val;
			return;
		}
	}
	$this._list.push(({first: key, second: val}));
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			return $this._list[i].second;
		}
	}
	return null;
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.get$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list.splice(i, 1);
			return;
		}
	}
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$($this) {
	var _list$0;
	(_list$0 = $this._list).splice(0, _list$0.length);
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.clear$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$($this, cb) {
	var i;
	var e;
	for (i = 0; i < $this._list.length; ++i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.forEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$;

function TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$($this, cb) {
	var i;
	var e;
	for (i = $this._list.length - 1; i >= 0; --i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E.reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$ = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$;

function Pair$x2E$x3CLocalVariable$x2CExpression$x3E(first, second) {
	this.first = first;
	this.second = second;
};

$__jsx_extend([Pair$x2E$x3CLocalVariable$x2CExpression$x3E], Object);
function Pair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E(first, second) {
	this.first = first;
	this.second = second;
};

$__jsx_extend([Pair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E], Object);
function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E() {
	var $this = this;
	this._list = [];
	this._equalsCallback = (function (x, y) {
		return x == y;
	});
};

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$0(equalsCallback) {
	this._list = [];
	this._equalsCallback = equalsCallback;
};

$__jsx_extend([TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E, TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$0], Object);
function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$clone$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$($this) {
	var x;
	x = ({_list: [], _equalsCallback: $this._equalsCallback});
	x._list = $this._list.concat([  ]);
	return x;
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.clone$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$clone$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$($this, key) {
	return ! TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$($this, (function (entryKey, entryValue) {
		return ! $this._equalsCallback(key, entryKey);
	}));
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.has$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$($this, key, val) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list[i].second = val;
			return;
		}
	}
	$this._list.push(({first: key, second: val}));
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.set$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			return $this._list[i].second;
		}
	}
	return null;
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.get$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list.splice(i, 1);
			return;
		}
	}
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.delete$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$($this) {
	var _list$0;
	(_list$0 = $this._list).splice(0, _list$0.length);
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.clear$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$($this, cb) {
	var i;
	var e;
	for (i = 0; i < $this._list.length; ++i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.forEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$forEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$;

function TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$($this, cb) {
	var i;
	var e;
	for (i = $this._list.length - 1; i >= 0; --i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E.reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$ = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$F$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$B$;

function Pair$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E(first, second) {
	this.first = first;
	this.second = second;
};

$__jsx_extend([Pair$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E], Object);
function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E() {
	var $this = this;
	this._list = [];
	this._equalsCallback = (function (x, y) {
		return x == y;
	});
};

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$0(equalsCallback) {
	this._list = [];
	this._equalsCallback = equalsCallback;
};

$__jsx_extend([TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E, TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$0], Object);
function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$clone$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$($this) {
	var x;
	x = ({_list: [], _equalsCallback: $this._equalsCallback});
	x._list = $this._list.concat([  ]);
	return x;
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.clone$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$clone$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$has$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$($this, key) {
	return ! TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$forEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$($this, (function (entryKey, entryValue) {
		return ! $this._equalsCallback(key, entryKey);
	}));
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.has$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$has$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$set$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$S($this, key, val) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list[i].second = val;
			return;
		}
	}
	$this._list.push(({first: key, second: val}));
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.set$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$S = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$set$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$S;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$get$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			return $this._list[i].second;
		}
	}
	return null;
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.get$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$get$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$delete$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$($this, key) {
	var i;
	for (i = 0; i < $this._list.length; ++i) {
		if ($this._equalsCallback($this._list[i].first, key)) {
			$this._list.splice(i, 1);
			return;
		}
	}
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.delete$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$delete$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$clear$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$($this) {
	var _list$0;
	(_list$0 = $this._list).splice(0, _list$0.length);
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.clear$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$clear$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$forEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$($this, cb) {
	var i;
	var e;
	for (i = 0; i < $this._list.length; ++i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.forEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$forEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$;

function TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$reversedForEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$($this, cb) {
	var i;
	var e;
	for (i = $this._list.length - 1; i >= 0; --i) {
		e = $this._list[i];
		if (! cb(e.first, e.second)) {
			return false;
		}
	}
	return true;
};

TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E.reversedForEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$ = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$reversedForEach$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$F$LClassDefinition$SB$;

function Pair$x2E$x3CClassDefinition$x2Cstring$x3E(first, second) {
	this.first = first;
	this.second = second;
};

$__jsx_extend([Pair$x2E$x3CClassDefinition$x2Cstring$x3E], Object);
function _Util() {
};

$__jsx_extend([_Util], Object);
function _Util$getOutputClassName$LClassDefinition$(classDef) {
	var stash;
	stash = classDef.getStash$S("emitter.outputname");
	return stash.outputName;
};

_Util.getOutputClassName$LClassDefinition$ = _Util$getOutputClassName$LClassDefinition$;

function _Util$getOutputConstructorName$LClassDefinition$ALType$(classDef, argTypes) {
	var ctor;
	var stash;
	if ((classDef.flags$() & 16) !== 0) {
		return _Util$getNameOfNativeConstructor$LClassDefinition$(classDef);
	}
	ctor = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, "constructor", argTypes, false);
	stash = ctor.getStash$S("emitter.outputname");
	return stash.outputName;
};

_Util.getOutputConstructorName$LClassDefinition$ALType$ = _Util$getOutputConstructorName$LClassDefinition$ALType$;

function _Util$getNameOfNativeConstructor$LClassDefinition$(classDef) {
	var stash$0;
	var this$0;
	var this$1;
	var this$2;
	var classDef$0;
	var stash$1;
	var this$3;
	var this$0$0;
	var this$4;
	var this$0$1;
	return (classDef._nativeSource != null || classDef._outerClassDef != null ? (stash$0 = classDef.getStash$S("emitter.outputname"), stash$0.outputName) : classDef instanceof InstantiatedClassDefinition ? (this$1 = (this$0 = classDef, this$0._templateClassDef), this$1._nativeSource) != null ? (classDef$0 = (this$2 = classDef, this$2._templateClassDef), stash$1 = classDef$0.getStash$S("emitter.outputname"), stash$1.outputName) : (this$3 = classDef, this$0$0 = this$3._templateClassDef, this$0$0._className) === "Map" ? "Object" : (this$4 = classDef, this$0$1 = this$4._templateClassDef, this$0$1._className) : classDef.className$());
};

_Util.getNameOfNativeConstructor$LClassDefinition$ = _Util$getNameOfNativeConstructor$LClassDefinition$;

function _Util$setOutputClassNames$ALClassDefinition$(classDefs) {
	var setOutputName;
	var escapeClassName;
	var countByName;
	var newUniqueName;
	var i;
	var classDef;
	var className;
	var ctors;
	var j;
	var exportedCtor;
	var n;
	var instantiated;
	var this$0;
	var classDef$0;
	var stash$0;
	var this$0$0;
	function setOutputName(stashable, name) {
		stashable.setStash$SLStash$("emitter.outputname", new _Util$x2EOutputNameStash(name));
	}
	function escapeClassName(name) {
		return name.replace(/[^A-Za-z0-9_\$]/g, (function (matched) {
			return "$x" + matched.charCodeAt(0).toString(16).toUpperCase();
		}));
	}
	countByName = {};
	function newUniqueName(className) {
		var name;
		if (countByName[className]) {
			name = className + "$" + (countByName[className] - 1 + "");
			++countByName[className];
		} else {
			name = className;
			countByName[className] = 1;
		}
		return escapeClassName(name);
	}
	for (i = 0; i < classDefs.length; ++i) {
		classDef = classDefs[i];
		if ((classDef.flags$() & 16) !== 0) {
			className = classDef.className$();
			if (! $__jsx_ObjectHasOwnProperty.call(countByName, className)) {
				setOutputName(classDef, escapeClassName(className));
				countByName[className] = 1;
			}
		}
	}
	for (i = 0; i < classDefs.length; ++i) {
		classDef = classDefs[i];
		if ((classDef.flags$() & 16) === 0) {
			className = ClassDefinition$classFullName$LClassDefinition$(classDef);
			ctors = _Util$findFunctions$LClassDefinition$SB(classDef, "constructor", false);
			if (ctors.length !== 0) {
				for (j = 0; j < ctors.length; ++j) {
					if (((this$0 = ctors[j], this$0._flags) & 16384) !== 0) {
						exportedCtor = ctors[j];
						ctors.splice(j, 1);
						ctors.unshift(exportedCtor);
						break;
					}
				}
				n = newUniqueName(className);
				setOutputName(classDef, n);
				setOutputName(ctors[0], n);
				for (j = 1; j < ctors.length; ++j) {
					setOutputName(ctors[j], newUniqueName(className));
				}
			} else {
				setOutputName(classDef, newUniqueName(className));
			}
		} else if (classDef._outerClassDef != null) {
			className = (classDef$0 = classDef._outerClassDef, stash$0 = classDef$0.getStash$S("emitter.outputname"), stash$0.outputName) + "." + classDef.className$();
			setOutputName(classDef, className);
		} else if (classDef._nativeSource != null) {
			setOutputName(classDef, newUniqueName(ClassDefinition$classFullName$LClassDefinition$(classDef)));
		} else if (classDef instanceof InstantiatedClassDefinition) {
			instantiated = classDef;
			className = (this$0$0 = instantiated._templateClassDef, this$0$0._className) + newUniqueName(".<" + instantiated._typeArguments.map((function (type) {
				return type.toString();
			})).join(",") + ">");
			setOutputName(classDef, escapeClassName(className));
		} else {
			setOutputName(classDef, escapeClassName(ClassDefinition$classFullName$LClassDefinition$(classDef)));
		}
	}
};

_Util.setOutputClassNames$ALClassDefinition$ = _Util$setOutputClassNames$ALClassDefinition$;

function _Util$encodeObjectLiteralKey$S(s) {
	return (s.length === 0 || s.match(/^[A-Za-z_$][A-Za-z0-9_$]*$/) ? s : Util$encodeStringLiteral$S(s));
};

_Util.encodeObjectLiteralKey$S = _Util$encodeObjectLiteralKey$S;

function _Util$findFunctions$LClassDefinition$SB(classDef, name, isStatic) {
	var functions;
	var members;
	var i;
	var member;
	var this$0$0;
	functions = [];
	members = classDef._members;
	for (i = 0; i < members.length; ++i) {
		member = members[i];
		if (member instanceof MemberFunctionDefinition && (this$0$0 = member._nameToken, this$0$0._value) === name && (member._flags & 8) === (isStatic ? 8 : 0)) {
			functions.push(member);
		}
	}
	return functions;
};

_Util.findFunctions$LClassDefinition$SB = _Util$findFunctions$LClassDefinition$SB;

function _Util$nameIsValidAsProperty$S(name) {
	return /^[\$_A-Za-z][\$_0-9A-Za-z]*$/.test(name) && ! $__jsx_ObjectHasOwnProperty.call(_Util._ecma262reserved, name);
};

_Util.nameIsValidAsProperty$S = _Util$nameIsValidAsProperty$S;

function _Util$isECMA262Reserved$S(word) {
	return $__jsx_ObjectHasOwnProperty.call(_Util._ecma262reserved, word);
};

_Util.isECMA262Reserved$S = _Util$isECMA262Reserved$S;

function _Util$getECMA262ReservedWords$() {
	return Object.keys(_Util._ecma262reserved);
};

_Util.getECMA262ReservedWords$ = _Util$getECMA262ReservedWords$;

function _Util$getECMA262NumberLiteral$LNumberLiteralExpression$(expr) {
	var this$0;
	return (expr.tokenIsECMA262Conformant$() ? (this$0 = expr._token, this$0._value) : expr.getDecoded$() + "");
};

_Util.getECMA262NumberLiteral$LNumberLiteralExpression$ = _Util$getECMA262NumberLiteral$LNumberLiteralExpression$;

function _Util$getECMA262StringLiteral$LStringLiteralExpression$(expr) {
	var this$0;
	return (expr.tokenIsECMA262Conformant$() ? (this$0 = expr._token, this$0._value) : Util$encodeStringLiteral$S(expr.getDecoded$()));
};

_Util.getECMA262StringLiteral$LStringLiteralExpression$ = _Util$getECMA262StringLiteral$LStringLiteralExpression$;

function _Util$isArrayType$LType$(type) {
	var this$0;
	var this$0$0;
	return type.getClassDef$() instanceof InstantiatedClassDefinition && (this$0 = type.getClassDef$(), this$0$0 = this$0._templateClassDef, this$0$0._className) === "Array";
};

_Util.isArrayType$LType$ = _Util$isArrayType$LType$;

function _Util$emitWithPrecedence$LJavaScriptEmitter$NNF$V$(emitter, outerOpPrecedence, precedence, callback) {
	if (precedence > outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter, "(", null);
		callback();
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter, ")", null);
	} else {
		callback();
	}
};

_Util.emitWithPrecedence$LJavaScriptEmitter$NNF$V$ = _Util$emitWithPrecedence$LJavaScriptEmitter$NNF$V$;

function _Util$emitFusedIntOpWithSideEffects$LJavaScriptEmitter$SLExpression$F$NV$N(emitter, helperFunc, expr, otherExprEmitter, outerOpPrecedence) {
	var propertyExpr;
	var name;
	var classDef;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter, helperFunc + "(", expr._token);
	if (expr instanceof PropertyExpression) {
		propertyExpr = expr;
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(emitter, propertyExpr._expr).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter, ", ", expr._token);
		if (propertyExpr._expr.isClassSpecifier$()) {
			classDef = propertyExpr.getHolderType$().getClassDef$();
			name = emitter._namer.getNameOfStaticVariable$LClassDefinition$S(classDef, (this$0 = propertyExpr._identifierToken, this$0._value));
		} else {
			name = emitter._namer.getNameOfProperty$LClassDefinition$S(propertyExpr.getHolderType$().getClassDef$(), (this$1 = propertyExpr._identifierToken, this$1._value));
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter, Util$encodeStringLiteral$S(name), propertyExpr._identifierToken);
	} else {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(emitter, (this$2 = expr, this$2._expr1)).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter, ", ", expr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(emitter, (this$3 = expr, this$3._expr2)).emit$N(0);
	}
	if (otherExprEmitter != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter, ", ", expr._token);
		otherExprEmitter(0);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter, ")", expr._token);
};

_Util.emitFusedIntOpWithSideEffects$LJavaScriptEmitter$SLExpression$F$NV$N = _Util$emitFusedIntOpWithSideEffects$LJavaScriptEmitter$SLExpression$F$NV$N;

function _Util$getNewExpressionInliner$LNewExpression$(expr) {
	var classDef;
	var ctor;
	var argTypes;
	var callingFuncDef;
	var stash;
	classDef = expr._type.getClassDef$();
	ctor = expr._constructor;
	argTypes = ctor._argTypes;
	callingFuncDef = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, "constructor", argTypes, false);
	stash = callingFuncDef.getStash$S("unclassify");
	return (stash ? stash.inliner : null);
};

_Util.getNewExpressionInliner$LNewExpression$ = _Util$getNewExpressionInliner$LNewExpression$;

function _Util$getElementTypeOfCompoundType$LType$(type) {
	var classDef;
	var this$0;
	if (type.equals$LType$(Type.variantType)) {
		return Type.variantType;
	}
	classDef = type.getClassDef$();
	return (this$0 = classDef, this$0._typeArguments)[0];
};

_Util.getElementTypeOfCompoundType$LType$ = _Util$getElementTypeOfCompoundType$LType$;

function _TempVarLister() {
	this._varNameMap = {};
};

$__jsx_extend([_TempVarLister], Object);
function _TempVarLister$finalize$L_TempVarLister$($this) {
	var varNames;
	var k;
	varNames = [];
	for (k in $this._varNameMap) {
		varNames.push(k);
	}
	return varNames;
};

_TempVarLister.finalize$L_TempVarLister$ = _TempVarLister$finalize$L_TempVarLister$;

function _TempVarLister$update$L_TempVarLister$LMemberFunctionDefinition$($this, funcDef) {
	var onStmt;
	function onStmt(stmt) {
		Statement$forEachExpression$LStatement$F$LExpression$B$(stmt, (function (expr) {
			_TempVarLister$update$L_TempVarLister$LExpression$($this, expr);
			return true;
		}));
		Statement$forEachStatement$LStatement$F$LStatement$B$(stmt, onStmt);
		return true;
	}
	Util$forEachStatement$F$LStatement$B$ALStatement$(onStmt, funcDef._statements);
	return $this;
};

_TempVarLister.update$L_TempVarLister$LMemberFunctionDefinition$ = _TempVarLister$update$L_TempVarLister$LMemberFunctionDefinition$;

function _TempVarLister$update$L_TempVarLister$LExpression$($this, expr) {
	var onExpr;
	function onExpr(expr) {
		Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		if (expr instanceof PostIncrementExpression) {
			if ($this._varNameMap.$__jsx_postinc_t == null && _PostIncrementExpressionEmitter$needsTempVarFor$LPostIncrementExpression$(expr)) {
				$this._varNameMap.$__jsx_postinc_t = true;
			}
		}
		return true;
	}
	onExpr(expr);
	return $this;
};

_TempVarLister.update$L_TempVarLister$LExpression$ = _TempVarLister$update$L_TempVarLister$LExpression$;

function _Mangler() {
};

$__jsx_extend([_Mangler], Object);
function _Mangler$mangleFunctionName$L_Mangler$SALType$($this, name, argTypes) {
	return name + _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this, argTypes);
};

_Mangler.mangleFunctionName$L_Mangler$SALType$ = _Mangler$mangleFunctionName$L_Mangler$SALType$;

function _Mangler$mangleTypeName$L_Mangler$LType$($this, type) {
	var classDef;
	var typeArgs;
	var this$0;
	var this$1;
	var this$0$0;
	var classDef$0;
	var stash$0;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	if (type.equals$LType$(Type.voidType)) {
		return "V";
	} else if (type.equals$LType$(Type.booleanType)) {
		return "B";
	} else if (type.equals$LType$(Type.integerType)) {
		return "I";
	} else if (type.equals$LType$(Type.numberType)) {
		return "N";
	} else if (type.equals$LType$(Type.stringType)) {
		return "S";
	} else if (type instanceof ObjectType) {
		classDef = type.getClassDef$();
		if (classDef instanceof InstantiatedClassDefinition) {
			this$0 = classDef;
			typeArgs = this$0._typeArguments;
			switch ((this$1 = classDef, this$0$0 = this$1._templateClassDef, this$0$0._className)) {
			case "Array":
				return "A" + _Mangler$mangleTypeName$L_Mangler$LType$($this, typeArgs[0]);
			case "Map":
				return "H" + _Mangler$mangleTypeName$L_Mangler$LType$($this, typeArgs[0]);
			default:
			}
		}
		return "L" + (classDef$0 = type.getClassDef$(), stash$0 = classDef$0.getStash$S("emitter.outputname"), stash$0.outputName).replace(/\./g, (function (c) {
			return "$x" + c.charCodeAt(0).toString(16).toUpperCase();
		})) + "$";
	} else if (type instanceof StaticFunctionType) {
		return "F" + _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this, (this$2 = type, this$2._argTypes)) + _Mangler$mangleTypeName$L_Mangler$LType$($this, (this$3 = type, this$3._returnType)) + "$";
	} else if (type instanceof MemberFunctionType) {
		return "M" + _Mangler$mangleTypeName$L_Mangler$LType$($this, (this$4 = type, this$4._objectType)) + _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this, (this$5 = type, this$5._argTypes)) + _Mangler$mangleTypeName$L_Mangler$LType$($this, (this$6 = type, this$6._returnType)) + "$";
	} else if (type instanceof NullableType) {
		return "U" + _Mangler$mangleTypeName$L_Mangler$LType$($this, (this$7 = type, this$7._baseType));
	} else if (type.equals$LType$(Type.variantType)) {
		return "X";
	} else {
		throw new Error("FIXME " + type.toString());
	}
};

_Mangler.mangleTypeName$L_Mangler$LType$ = _Mangler$mangleTypeName$L_Mangler$LType$;

function _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this, argTypes) {
	var s;
	var i;
	var argTypes$len$0;
	s = "$";
	for ((i = 0, argTypes$len$0 = argTypes.length); i < argTypes$len$0; ++i) {
		s += _Mangler$mangleTypeName$L_Mangler$LType$($this, argTypes[i]);
	}
	return s;
};

_Mangler.mangleFunctionArguments$L_Mangler$ALType$ = _Mangler$mangleFunctionArguments$L_Mangler$ALType$;

function _Mangler$requiresMangling$L_Mangler$LClassDefinition$SALType$B($this, classDef, name, argTypes, isStatic) {
	return ! Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic);
};

_Mangler.requiresMangling$L_Mangler$LClassDefinition$SALType$B = _Mangler$requiresMangling$L_Mangler$LClassDefinition$SALType$B;

function _Mangler$requiresMangling$L_Mangler$LPropertyExpression$($this, expr) {
	var exprType$0;
	return (! (exprType$0 = expr._type, ! (exprType$0 instanceof FunctionType) ? false : exprType$0.isAssignable$() ? false : true) ? false : ! Util$propertyRootIsNative$LPropertyExpression$(expr));
};

_Mangler.requiresMangling$L_Mangler$LPropertyExpression$ = _Mangler$requiresMangling$L_Mangler$LPropertyExpression$;

function _Mangler$requiresMangling$L_Mangler$LMemberFunctionDefinition$($this, member) {
	var classDef$0;
	var name$0;
	var isStatic$0;
	var this$0$0;
	var argTypes$1;
	var i$0;
	var this$0$1;
	classDef$0 = member._classDef;
	this$0$0 = member._nameToken;
	name$0 = this$0$0._value;
	argTypes$1 = [];
	for (i$0 = 0; i$0 < member._args.length; ++i$0) {
		this$0$1 = member._args[i$0];
		argTypes$1[i$0] = this$0$1._type;
	}
	isStatic$0 = (member._flags & 8) !== 0;
	return ! Util$memberRootIsNative$LClassDefinition$SALType$B(classDef$0, name$0, argTypes$1, isStatic$0);
};

_Mangler.requiresMangling$L_Mangler$LMemberFunctionDefinition$ = _Mangler$requiresMangling$L_Mangler$LMemberFunctionDefinition$;

function _Namer() {
	this._emitter = null;
	this._catchLevel = -1;
};

$__jsx_extend([_Namer], Object);
_Namer.prototype.setup$LJavaScriptEmitter$ = function (emitter) {
	this._emitter = emitter;
	return this;
};


function _Namer$setup$L_Namer$LJavaScriptEmitter$($this, emitter) {
	$this._emitter = emitter;
	return $this;
};

_Namer.setup$L_Namer$LJavaScriptEmitter$ = _Namer$setup$L_Namer$LJavaScriptEmitter$;

_Namer.prototype.getNameOfProperty$LClassDefinition$S = function (classDef, name) {
	return name;
};


_Namer.prototype.getNameOfMethod$LClassDefinition$SALType$ = function (classDef, name, argTypes) {
	var this$0;
	var this$1;
	return (Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, argTypes, false) ? name : (this$1 = (this$0 = this._emitter, this$0._mangler), name + _Mangler$mangleFunctionArguments$L_Mangler$ALType$(this$1, argTypes)));
};


_Namer.prototype.getNameOfStaticVariable$LClassDefinition$S = function (classDef, name) {
	return name;
};


_Namer.prototype.getNameOfStaticFunction$LClassDefinition$SALType$ = function (classDef, name, argTypes) {
	var className;
	var stash$0;
	var this$0;
	var this$1;
	stash$0 = classDef.getStash$S("emitter.outputname");
	className = stash$0.outputName;
	return (Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, argTypes, true) ? className + "." + name : className + "$" + (this$1 = (this$0 = this._emitter, this$0._mangler), name + _Mangler$mangleFunctionArguments$L_Mangler$ALType$(this$1, argTypes)));
};


_Namer.prototype.getNameOfConstructor$LClassDefinition$ALType$ = function (classDef, argTypes) {
	return _Util$getOutputConstructorName$LClassDefinition$ALType$(classDef, argTypes);
};


_Namer.prototype.getNameOfClass$LClassDefinition$ = function (classDef) {
	var stash$0;
	stash$0 = classDef.getStash$S("emitter.outputname");
	return stash$0.outputName;
};


_Namer.prototype.enterScope$LLocalVariable$F$V$ = function (local, cb) {
	cb();
};


_Namer.prototype.enterFunction$LMemberFunctionDefinition$F$V$ = function (funcDef, cb) {
	cb();
};


_Namer.prototype.enterCatch$LTryStatement$F$F$S$V$ = function (tryStmt, cb) {
	++this._catchLevel;
	_Namer$_enterCatch$L_Namer$LTryStatement$F$F$S$V$S(this, tryStmt, cb, "$__jsx_catch_" + (this._catchLevel + ""));
	--this._catchLevel;
};


function _Namer$enterCatch$L_Namer$LTryStatement$F$F$S$V$($this, tryStmt, cb) {
	++$this._catchLevel;
	_Namer$_enterCatch$L_Namer$LTryStatement$F$F$S$V$S($this, tryStmt, cb, "$__jsx_catch_" + ($this._catchLevel + ""));
	--$this._catchLevel;
};

_Namer.enterCatch$L_Namer$LTryStatement$F$F$S$V$ = _Namer$enterCatch$L_Namer$LTryStatement$F$F$S$V$;

_Namer.prototype._enterCatch$LTryStatement$F$F$S$V$S = function (tryStmt, cb, catchName) {
	var $this = this;
	var catchStmts;
	var i;
	var this$0;
	tryStmt.setStash$SLStash$("namer", new _Namer$x2E_TryStash(catchName));
	catchStmts = tryStmt._catchStatements;
	for (i in catchStmts) { i |= 0;
		(this$0 = catchStmts[i], this$0._local).setStash$SLStash$("namer", new _Namer$x2E_CatchTargetStash(tryStmt));
	}
	cb((function () {
		return tryStmt.getStash$S("namer").catchName;
	}));
};


function _Namer$_enterCatch$L_Namer$LTryStatement$F$F$S$V$S($this, tryStmt, cb, catchName) {
	var catchStmts;
	var i;
	var this$0;
	tryStmt.setStash$SLStash$("namer", new _Namer$x2E_TryStash(catchName));
	catchStmts = tryStmt._catchStatements;
	for (i in catchStmts) { i |= 0;
		(this$0 = catchStmts[i], this$0._local).setStash$SLStash$("namer", new _Namer$x2E_CatchTargetStash(tryStmt));
	}
	cb((function () {
		return tryStmt.getStash$S("namer").catchName;
	}));
};

_Namer._enterCatch$L_Namer$LTryStatement$F$F$S$V$S = _Namer$_enterCatch$L_Namer$LTryStatement$F$F$S$V$S;

_Namer.prototype.getNameOfLocalVariable$LLocalVariable$ = function (local) {
	var caught$0;
	var tryStmt$0$0;
	var this$0;
	return (local instanceof CaughtVariable ? (caught$0 = local, tryStmt$0$0 = caught$0.getStash$S("namer").tryStmt, tryStmt$0$0.getStash$S("namer").catchName) : (this$0 = local._name, this$0._value));
};


_Namer.prototype._getCatchName$LCaughtVariable$ = function (caught) {
	var tryStmt$0;
	tryStmt$0 = caught.getStash$S("namer").tryStmt;
	return tryStmt$0.getStash$S("namer").catchName;
};


function _Namer$_getCatchName$L_Namer$LCaughtVariable$($this, caught) {
	var tryStmt$0;
	tryStmt$0 = caught.getStash$S("namer").tryStmt;
	return tryStmt$0.getStash$S("namer").catchName;
};

_Namer._getCatchName$L_Namer$LCaughtVariable$ = _Namer$_getCatchName$L_Namer$LCaughtVariable$;

_Namer.prototype._getCatchName$LTryStatement$ = function (tryStmt) {
	return tryStmt.getStash$S("namer").catchName;
};


function _Namer$_getCatchName$L_Namer$LTryStatement$($this, tryStmt) {
	return tryStmt.getStash$S("namer").catchName;
};

_Namer._getCatchName$L_Namer$LTryStatement$ = _Namer$_getCatchName$L_Namer$LTryStatement$;

function _MinifiedNameGenerator(skipWords) {
	var i;
	this._skipWords = {};
	this._memo = [];
	this._counter = 0;
	for (i in skipWords) { i |= 0;
		this._skipWords[skipWords[i]] = true;
	}
};

$__jsx_extend([_MinifiedNameGenerator], Object);
_MinifiedNameGenerator.prototype.get$N = function (n) {
	var candidate;
	var n$0;
	var name$0;
	var colIndex$0;
	while (this._memo.length <= n) {
		do {
			n$0 = this._counter++;
			name$0 = "";
			do {
				colIndex$0 = n$0 % 64;
				name$0 += "$_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".charAt(colIndex$0);
				n$0 = (n$0 - colIndex$0) / 64;
			} while (n$0 !== 0);
			candidate = name$0;
		} while ($__jsx_ObjectHasOwnProperty.call(this._skipWords, candidate) || candidate.match(/^[0-9$]/));
		this._memo.push(candidate);
	}
	return this._memo[n];
};


function _MinifiedNameGenerator$get$L_MinifiedNameGenerator$N($this, n) {
	var candidate;
	var n$0;
	var name$0;
	var colIndex$0;
	while ($this._memo.length <= n) {
		do {
			n$0 = $this._counter++;
			name$0 = "";
			do {
				colIndex$0 = n$0 % 64;
				name$0 += "$_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".charAt(colIndex$0);
				n$0 = (n$0 - colIndex$0) / 64;
			} while (n$0 !== 0);
			candidate = name$0;
		} while ($__jsx_ObjectHasOwnProperty.call($this._skipWords, candidate) || candidate.match(/^[0-9$]/));
		$this._memo.push(candidate);
	}
	return $this._memo[n];
};

_MinifiedNameGenerator.get$L_MinifiedNameGenerator$N = _MinifiedNameGenerator$get$L_MinifiedNameGenerator$N;

function _MinifiedNameGenerator$_stringify$N(n) {
	var name;
	var colIndex;
	name = "";
	do {
		colIndex = n % 64;
		name += "$_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".charAt(colIndex);
		n = (n - colIndex) / 64;
	} while (n !== 0);
	return name;
};

_MinifiedNameGenerator._stringify$N = _MinifiedNameGenerator$_stringify$N;

function _Minifier(emitter, classDefs) {
	this._propertyUseCount = {};
	this._propertyConversionTable = null;
	this._globalUseCount = {};
	this._globalConversionTable = null;
	this._outerLocals = [];
	this._emitter = emitter;
	this._classDefs = classDefs;
};

$__jsx_extend([_Minifier], Object);
function _Minifier$getCountingNamer$L_Minifier$($this) {
	return new _Minifier$x2E_MinifyingNamer().setup$L_Minifier$($this);
};

_Minifier.getCountingNamer$L_Minifier$ = _Minifier$getCountingNamer$L_Minifier$;

function _Minifier$getMinifyingNamer$L_Minifier$($this) {
	_Minifier$_minifyProperties$L_Minifier$($this);
	_Minifier$_minifyStaticVariables$L_Minifier$($this);
	_Minifier$_minifyGlobals$L_Minifier$($this);
	return new _Minifier$x2E_MinifyingNamer().setup$L_Minifier$($this);
};

_Minifier.getMinifyingNamer$L_Minifier$ = _Minifier$getMinifyingNamer$L_Minifier$;

function _Minifier$_isCounting$L_Minifier$($this) {
	return $this._propertyConversionTable == null;
};

_Minifier._isCounting$L_Minifier$ = _Minifier$_isCounting$L_Minifier$;

function _Minifier$_recordUsedIdentifiers$L_Minifier$LStashable$F$V$($this, stashable, cb) {
	var globalUseCountBackup;
	var k;
	var outerLocalUseCount;
	var i;
	var scopeStash;
	var stash$0;
	globalUseCountBackup = {};
	for (k in $this._globalUseCount) {
		globalUseCountBackup[k] = $this._globalUseCount[k];
	}
	outerLocalUseCount = [];
	for (i in $this._outerLocals) { i |= 0;
		outerLocalUseCount[i] = _Minifier$_getLocalStash$LLocalVariable$($this._outerLocals[i]).useCount;
	}
	cb();
	stash$0 = stashable.getStash$S("minifier.scope");
	if (stash$0 == null) {
		stash$0 = stashable.setStash$SLStash$("minifier.scope", new _Minifier$x2E_ScopeStash());
	}
	scopeStash = stash$0;
	for (k in $this._globalUseCount) {
		if ($this._globalUseCount[k] !== globalUseCountBackup[k]) {
			scopeStash.usedGlobals[k] = true;
		}
	}
	for (i in $this._outerLocals) { i |= 0;
		if (outerLocalUseCount[i] !== _Minifier$_getLocalStash$LLocalVariable$($this._outerLocals[i]).useCount) {
			scopeStash.usedOuterLocals.push($this._outerLocals[i]);
		}
	}
};

_Minifier._recordUsedIdentifiers$L_Minifier$LStashable$F$V$ = _Minifier$_recordUsedIdentifiers$L_Minifier$LStashable$F$V$;

function _Minifier$_minifyProperties$L_Minifier$($this) {
	var exportedPropertyNames;
	var k;
	exportedPropertyNames = [];
	$this._classDefs.forEach((function (classDef) {
		ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
			if ((MemberDefinition$flags$LMemberDefinition$(member) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_EXPORT)) === ClassDefinition.IS_EXPORT && ! (member instanceof MemberFunctionDefinition && MemberDefinition$name$LMemberDefinition$(member) === "constructor")) {
				exportedPropertyNames.push(MemberDefinition$name$LMemberDefinition$(member));
			}
			return true;
		}));
	}));
	$this._propertyConversionTable = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$($this._propertyUseCount, new _MinifiedNameGenerator(Object.keys(_Util._ecma262reserved).concat((function () {
		var nativePropertyNames;
		nativePropertyNames = {};
		$this._classDefs.forEach((function (classDef) {
			ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
				if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_STATIC) === 0 && ((MemberDefinition$flags$LMemberDefinition$(member) | classDef.flags$()) & ClassDefinition.IS_NATIVE) !== 0) {
					nativePropertyNames[MemberDefinition$name$LMemberDefinition$(member)] = true;
				}
				return true;
			}));
		}));
		return Object.keys(nativePropertyNames);
	})()).concat(exportedPropertyNames)));
	for (k in $this._propertyConversionTable) {
	}
};

_Minifier._minifyProperties$L_Minifier$ = _Minifier$_minifyProperties$L_Minifier$;

function _Minifier$_minifyStaticVariables$L_Minifier$($this) {
	$this._classDefs.forEach((function (classDef) {
		var exportedStaticVarNames;
		var stash;
		var stash$0;
		if ((classDef.flags$() & 272) === 0) {
			exportedStaticVarNames = [];
			ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (member) {
				if ((MemberDefinition$flags$LMemberDefinition$(member) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_EXPORT)) === (ClassDefinition.IS_STATIC | ClassDefinition.IS_EXPORT)) {
					exportedStaticVarNames.push(MemberDefinition$name$LMemberDefinition$(member));
				}
				return true;
			}));
			stash$0 = classDef.getStash$S("minifier.class");
			if (stash$0 == null) {
				stash$0 = classDef.setStash$SLStash$("minifier.class", new _Minifier$x2E_ClassStash());
			}
			stash = stash$0;
			stash.staticVariableConversionTable = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$(stash.staticVariableUseCount, new _MinifiedNameGenerator(Object.keys(_Util._ecma262reserved).concat(exportedStaticVarNames)));
		}
	}));
};

_Minifier._minifyStaticVariables$L_Minifier$ = _Minifier$_minifyStaticVariables$L_Minifier$;

function _Minifier$_minifyGlobals$L_Minifier$($this) {
	var useCount;
	var k;
	useCount = {};
	for (k in $this._globalUseCount) {
		useCount[k] = $this._globalUseCount[k];
	}
	$this._classDefs.forEach((function (classDef) {
		if ((classDef.flags$() & 272) !== 0) {
			delete useCount[classDef.className$()];
		}
	}));
	$this._globalConversionTable = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$(useCount, new _MinifiedNameGenerator(Object.keys(_Util._ecma262reserved).concat(_MinifiedNameGenerator.GLOBALS, (function () {
		var nativeClassNames;
		nativeClassNames = [];
		$this._classDefs.forEach((function (classDef) {
			if ((classDef.flags$() & ClassDefinition.IS_NATIVE) !== 0) {
				nativeClassNames.push(classDef.className$());
			}
		}));
		return nativeClassNames;
	})())));
	for (k in $this._globalConversionTable) {
	}
};

_Minifier._minifyGlobals$L_Minifier$ = _Minifier$_minifyGlobals$L_Minifier$;

function _Minifier$_log$L_Minifier$S($this, message) {
};

_Minifier._log$L_Minifier$S = _Minifier$_log$L_Minifier$S;

function _Minifier$_buildConversionTable$L_Minifier$ALLocalVariable$L_Minifier$x2E_ScopeStash$($this, locals, scopeStash) {
	var useCount;
	var reserved;
	var k;
	var i;
	var conversionTable;
	useCount = {};
	locals.forEach((function (local) {
		var this$0;
		useCount[(this$0 = local._name, this$0._value)] = _Minifier$_getLocalStash$LLocalVariable$(local).useCount;
	}));
	reserved = [  ];
	for (k in scopeStash.usedGlobals) {
		reserved.push($__jsx_ObjectHasOwnProperty.call($this._globalConversionTable, k) ? $this._globalConversionTable[k] : k);
	}
	for (i in scopeStash.usedOuterLocals) { i |= 0;
		reserved.push(_Minifier$_getLocalStash$LLocalVariable$(scopeStash.usedOuterLocals[i]).minifiedName);
	}
	"local minification, preserving: " + reserved.join(",");
	reserved = reserved.concat(Object.keys(_Util._ecma262reserved));
	conversionTable = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$(useCount, new _MinifiedNameGenerator(reserved));
	locals.forEach((function (local) {
		var this$0;
		_Minifier$_getLocalStash$LLocalVariable$(local).minifiedName = conversionTable[(this$0 = local._name, this$0._value)];
	}));
};

_Minifier._buildConversionTable$L_Minifier$ALLocalVariable$L_Minifier$x2E_ScopeStash$ = _Minifier$_buildConversionTable$L_Minifier$ALLocalVariable$L_Minifier$x2E_ScopeStash$;

function _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$(useCount, nameGenerator) {
	var propertyNames;
	var conversionTable;
	var i;
	propertyNames = Object.keys(useCount).sort((function (x, y) {
		var delta;
		delta = useCount[y] - useCount[x];
		return (delta !== 0 ? delta : x < y ? -1 : 1);
	}));
	conversionTable = {};
	for (i = 0; i < propertyNames.length; ++i) {
		conversionTable[propertyNames[i]] = _MinifiedNameGenerator$get$L_MinifiedNameGenerator$N(nameGenerator, i);
	}
	return conversionTable;
};

_Minifier._buildConversionTable$HNL_MinifiedNameGenerator$ = _Minifier$_buildConversionTable$HNL_MinifiedNameGenerator$;

function _Minifier$_getClassStash$LClassDefinition$(classDef) {
	var stash;
	stash = classDef.getStash$S("minifier.class");
	if (stash == null) {
		stash = classDef.setStash$SLStash$("minifier.class", new _Minifier$x2E_ClassStash());
	}
	return stash;
};

_Minifier._getClassStash$LClassDefinition$ = _Minifier$_getClassStash$LClassDefinition$;

function _Minifier$_getScopeStash$LStashable$(stashable) {
	var stash;
	stash = stashable.getStash$S("minifier.scope");
	if (stash == null) {
		stash = stashable.setStash$SLStash$("minifier.scope", new _Minifier$x2E_ScopeStash());
	}
	return stash;
};

_Minifier._getScopeStash$LStashable$ = _Minifier$_getScopeStash$LStashable$;

function _Minifier$_getLocalStash$LLocalVariable$(local) {
	var stash;
	stash = local.getStash$S("minifier.local");
	if (stash == null) {
		stash = local.setStash$SLStash$("minifier.local", new _Minifier$x2E_LocalStash());
	}
	return stash;
};

_Minifier._getLocalStash$LLocalVariable$ = _Minifier$_getLocalStash$LLocalVariable$;

function _Minifier$_incr$HNS(useCount, name) {
	if ($__jsx_ObjectHasOwnProperty.call(useCount, name)) {
		++useCount[name];
	} else {
		useCount[name] = 1;
	}
};

_Minifier._incr$HNS = _Minifier$_incr$HNS;

function _Minifier$_getArgsAndLocals$LMemberFunctionDefinition$(funcDef) {
	var list;
	list = [];
	funcDef._args.forEach((function (a) {
		list.push(a);
	}));
	return list.concat(funcDef._locals);
};

_Minifier._getArgsAndLocals$LMemberFunctionDefinition$ = _Minifier$_getArgsAndLocals$LMemberFunctionDefinition$;

function _Minifier$minifyJavaScript$S(src) {
	var ast;
	ast = esprima$0.parse(src);
	ast = esmangle$0.mangle(ast, ({ destructive: true }));
	return escodegen$0.generate(ast, ({ format: ({ renumber: true, hexadecimal: true, escapeless: true, compact: true, semicolons: false, parentheses: false }), directive: true }));
};

_Minifier.minifyJavaScript$S = _Minifier$minifyJavaScript$S;

var esprima$0 = require('esprima');
var esmangle$0 = require('esmangle');
var escodegen$0 = require('escodegen');
function _StatementEmitter(emitter) {
	this._emitter = emitter;
};

$__jsx_extend([_StatementEmitter], Object);
_StatementEmitter.prototype.emitLabelOfStatement$LLabellableStatement$ = function (statement) {
	var label;
	var this$0;
	var this$1;
	label = statement._label;
	if (label != null) {
		this$0 = this._emitter;
		if (--this$0._indent < 0) {
			throw new Error("indent mistach");
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, label._value + ":\n", label);
		this$1 = this._emitter;
		++this$1._indent;
	}
};


function _StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$($this, statement) {
	var label;
	var this$0;
	var this$1;
	label = statement._label;
	if (label != null) {
		this$0 = $this._emitter;
		if (--this$0._indent < 0) {
			throw new Error("indent mistach");
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, label._value + ":\n", label);
		this$1 = $this._emitter;
		++this$1._indent;
	}
};

_StatementEmitter.emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$ = _StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$;

function _ConstructorInvocationStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ConstructorInvocationStatementEmitter], _StatementEmitter);
_ConstructorInvocationStatementEmitter.prototype.emit$ = function () {
	var ctorType;
	var argTypes;
	var ctorName;
	var token;
	var thisVar;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$9;
	var this$10;
	var _emitter$0;
	var _emitter$1;
	ctorType = (this$0 = this._statement, this$0._ctorFunctionType);
	argTypes = (ctorType != null ? ctorType._argTypes : []);
	ctorName = (this$1 = this._emitter, this$1._namer).getNameOfConstructor$LClassDefinition$ALType$((this$2 = this._statement, this$2._ctorClassType.getClassDef$()), argTypes);
	this$3 = this._statement;
	token = this$3._token;
	thisVar = ((this$4 = this._emitter._emittingFunction, this$4._parent) != null ? "$this" : "this");
	JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(this._emitter, token, ctorName + ".call(" + thisVar, (this$5 = this._statement, this$5._args), argTypes);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ";\n", token);
	if (ctorName === "Error") {
		if ((this$10 = this._statement, this$10._args).length === 1) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "this.message = ", token);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$6 = this._statement, this$6._args)[0]).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ";\n", token);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = this._emitter, "this.name = \"" + ClassDefinition$classFullName$LClassDefinition$((this$7 = _emitter$0._emittingFunction, this$7._classDef)) + "\";\n", token);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "if (Error.captureStackTrace) Error.captureStackTrace(this, ", null);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$1 = this._emitter, (_emitter$1, _emitter$1._namer).getNameOfClass$LClassDefinition$((this$9 = _emitter$1._emittingFunction, this$9._classDef)), null);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ");\n", null);
	}
};


function _ExpressionStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ExpressionStatementEmitter], _StatementEmitter);
_ExpressionStatementEmitter.prototype.emit$ = function () {
	var this$0;
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$0 = this._statement, this$0._expr)).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ";\n", null);
};


function _FunctionStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_FunctionStatementEmitter], _StatementEmitter);
_FunctionStatementEmitter.prototype.emit$ = function () {
	var $this = this;
	var funcDef;
	var this$0;
	var this$1;
	var this$2;
	this$0 = this._statement;
	funcDef = this$0._funcDef;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "function " + ((funcDef._flags & 8192) !== 0 ? "* " : "") + (this$1 = this._emitter, this$1._namer).getNameOfLocalVariable$LLocalVariable$(funcDef._funcLocal) + "(", funcDef._token);
	(this$2 = this._emitter, this$2._namer).enterFunction$LMemberFunctionDefinition$F$V$(funcDef, (function () {
		var args;
		var i;
		var this$1;
		var this$2;
		var _emitter$0;
		args = funcDef._args;
		for (i = 0; i < args.length; ++i) {
			if (i !== 0) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", funcDef._token);
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = $this._emitter, (_emitter$0, _emitter$0._namer).getNameOfLocalVariable$LLocalVariable$(args[i]), funcDef._token);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ") {\n", funcDef._token);
		this$1 = $this._emitter;
		++this$1._indent;
		JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this._emitter, funcDef);
		this$2 = $this._emitter;
		if (--this$2._indent < 0) {
			throw new Error("indent mistach");
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "}\n", funcDef._token);
	}));
};


function _ReturnStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ReturnStatementEmitter], _StatementEmitter);
_ReturnStatementEmitter.prototype.emit$ = function () {
	var expr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var _emitter$0;
	this$0 = this._statement;
	expr = this$0._expr;
	if (expr != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "return ", null);
		if (this._emitter._enableProfiler) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "$__jsx_profiler.exit(", null);
		}
		JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$(_emitter$0 = this._emitter, (this$1 = this._statement, this$1._expr), (this$2 = _emitter$0._emittingFunction, this$2._returnType));
		if (this._emitter._enableProfiler) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", null);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ";\n", null);
	} else if (this._emitter._enableProfiler) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "return $__jsx_profiler.exit();\n", (this$3 = this._statement, this$3._token));
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "return;\n", (this$4 = this._statement, this$4._token));
	}
};


function _DeleteStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_DeleteStatementEmitter], _StatementEmitter);
_DeleteStatementEmitter.prototype.emit$ = function () {
	var this$0;
	var this$1;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "delete ", (this$0 = this._statement, this$0._token));
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$1 = this._statement, this$1._expr)).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ";\n", null);
};


function _BreakStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_BreakStatementEmitter], _StatementEmitter);
_BreakStatementEmitter.prototype.emit$ = function () {
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var _statement$0;
	if ((this$4 = this._statement, this$4._label) != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "break " + (this$1 = (this$0 = _statement$0 = this._statement, this$0._label), this$1._value) + ";\n", (this$2 = _statement$0, this$2._token));
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "break;\n", (this$3 = this._statement, this$3._token));
	}
};


function _ContinueStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ContinueStatementEmitter], _StatementEmitter);
_ContinueStatementEmitter.prototype.emit$ = function () {
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var _statement$0;
	if ((this$4 = this._statement, this$4._label) != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "continue " + (this$1 = (this$0 = _statement$0 = this._statement, this$0._label), this$1._value) + ";\n", (this$2 = _statement$0, this$2._token));
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "continue;\n", (this$3 = this._statement, this$3._token));
	}
};


function _DoWhileStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_DoWhileStatementEmitter], _StatementEmitter);
_DoWhileStatementEmitter.prototype.emit$ = function () {
	var this$0;
	_StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$(this, this._statement);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "do {\n", null);
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, this._statement.getStatements$());
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "} while (", null);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$0 = this._statement, this$0._expr)).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ");\n", null);
};


function _ForInStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ForInStatementEmitter], _StatementEmitter);
_ForInStatementEmitter.prototype.emit$ = function () {
	var this$0;
	var this$1;
	var type$0;
	var this$0$0;
	var this$0$0$0;
	var this$2;
	var this$3;
	var this$4;
	_StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$(this, this._statement);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "for (", null);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$0 = this._statement, this$0._lhsExpr)).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " in ", null);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$1 = this._statement, this$1._listExpr)).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ") {", null);
	type$0 = (this$4 = this._statement, this$4._listExpr).getType$();
	if (type$0.getClassDef$() instanceof InstantiatedClassDefinition && (this$0$0 = type$0.getClassDef$(), this$0$0$0 = this$0$0._templateClassDef, this$0$0$0._className) === "Array") {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " ", null);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$2 = this._statement, this$2._lhsExpr)).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " |= 0;", null);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "\n", null);
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, (this$3 = this._statement, this$3._statements));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}\n", null);
};


function _ForStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ForStatementEmitter], _StatementEmitter);
_ForStatementEmitter.prototype.emit$ = function () {
	var initExpr;
	var condExpr;
	var postExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	_StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$(this, this._statement);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "for (", (this$0 = this._statement, this$0._token));
	this$1 = this._statement;
	initExpr = this$1._initExpr;
	if (initExpr != null) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, initExpr).emit$N(0);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "; ", null);
	this$2 = this._statement;
	condExpr = this$2._condExpr;
	if (condExpr != null) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, condExpr).emit$N(0);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "; ", null);
	this$3 = this._statement;
	postExpr = this$3._postExpr;
	if (postExpr != null) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, postExpr).emit$N(0);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ") {\n", null);
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, (this$4 = this._statement, this$4._statements));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}\n", null);
};


function _IfStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_IfStatementEmitter], _StatementEmitter);
_IfStatementEmitter.prototype.emit$ = function () {
	var ifFalseStatements;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var statement$0;
	var emitter$0;
	var this$5;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "if (", (this$0 = this._statement, this$0._token));
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$1 = this._statement, this$1._expr)).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ") {\n", null);
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, (this$2 = this._statement, this$2._onTrueStatements));
	this$3 = this._statement;
	ifFalseStatements = this$3._onFalseStatements;
	if (ifFalseStatements.length === 1 && ifFalseStatements[0] instanceof IfStatement) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "} else ", null);
		this$4 = this._emitter;
		statement$0 = ifFalseStatements[0];
		emitter$0 = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$(this$4, statement$0);
		emitter$0.emit$();
		this$5 = ifFalseStatements[0];
		ifFalseStatements = this$5._onTrueStatements;
	} else {
		if (ifFalseStatements.length !== 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "} else {\n", null);
			JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, ifFalseStatements);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}\n", null);
	}
};


function _SwitchStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_SwitchStatementEmitter], _StatementEmitter);
_SwitchStatementEmitter.prototype.emit$ = function () {
	var this$0;
	var this$1;
	var this$2;
	_StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$(this, this._statement);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "switch (", (this$0 = this._statement, this$0._token));
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, (this$1 = this._statement, this$1._expr), 0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ") {\n", null);
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, (this$2 = this._statement, this$2._statements));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}\n", null);
};


function _CaseStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_CaseStatementEmitter], _StatementEmitter);
_CaseStatementEmitter.prototype.emit$ = function () {
	var this$0;
	var this$1;
	var this$2;
	this$0 = this._emitter;
	if (--this$0._indent < 0) {
		throw new Error("indent mistach");
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "case ", null);
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, (this$1 = this._statement, this$1._expr), 0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ":\n", null);
	this$2 = this._emitter;
	++this$2._indent;
};


function _DefaultStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_DefaultStatementEmitter], _StatementEmitter);
_DefaultStatementEmitter.prototype.emit$ = function () {
	var this$0;
	var this$1;
	this$0 = this._emitter;
	if (--this$0._indent < 0) {
		throw new Error("indent mistach");
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "default:\n", null);
	this$1 = this._emitter;
	++this$1._indent;
};


function _WhileStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_WhileStatementEmitter], _StatementEmitter);
_WhileStatementEmitter.prototype.emit$ = function () {
	var this$0;
	var this$1;
	var this$2;
	_StatementEmitter$emitLabelOfStatement$L_StatementEmitter$LLabellableStatement$(this, this._statement);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "while (", (this$0 = this._statement, this$0._token));
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$1 = this._statement, this$1._expr)).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ") {\n", null);
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, (this$2 = this._statement, this$2._statements));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}\n", null);
};


function _TryStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_TryStatementEmitter], _StatementEmitter);
_TryStatementEmitter.prototype.emit$ = function () {
	var $this = this;
	var catchStatements;
	var finallyStatements;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var tryStmt$0;
	var this$4;
	var this$5;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "try {\n", (this$0 = this._statement, this$0._token));
	JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, (this$1 = this._statement, this$1._tryStatements));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}", null);
	this$2 = this._statement;
	catchStatements = this$2._catchStatements;
	if (catchStatements.length !== 0) {
		this$5 = this._emitter;
		this$3 = this$5._namer;
		tryStmt$0 = this._statement;
		++this$3._catchLevel;
		_Namer$_enterCatch$L_Namer$LTryStatement$F$F$S$V$S(this$3, tryStmt$0, (function (getCatchName) {
			var this$0;
			var this$1;
			var this$2;
			var this$3;
			var this$4;
			var this$5;
			var this$6;
			var this$7;
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " catch (" + getCatchName() + ") {\n", null);
			if ($this._emitter._enableProfiler) {
				this$0 = $this._emitter;
				++this$0._indent;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$__jsx_profiler.resume($__jsx_profiler_ctx);\n", null);
				this$1 = $this._emitter;
				if (--this$1._indent < 0) {
					throw new Error("indent mistach");
				}
			}
			JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$($this._emitter, catchStatements.map((function (s) {
				return s;
			})));
			if (! (this$7 = (this$6 = catchStatements[catchStatements.length - 1], this$6._local), this$7._type).equals$LType$(Type.variantType)) {
				this$2 = $this._emitter;
				++this$2._indent;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "{\n", null);
				this$3 = $this._emitter;
				++this$3._indent;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "throw " + getCatchName() + ";\n", null);
				this$4 = $this._emitter;
				if (--this$4._indent < 0) {
					throw new Error("indent mistach");
				}
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "}\n", null);
				this$5 = $this._emitter;
				if (--this$5._indent < 0) {
					throw new Error("indent mistach");
				}
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "}", null);
		}), "$__jsx_catch_" + (this$3._catchLevel + ""));
		--this$3._catchLevel;
	}
	this$4 = this._statement;
	finallyStatements = this$4._finallyStatements;
	if (finallyStatements.length !== 0 || catchStatements.length === 0) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " finally {\n", null);
		JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, finallyStatements);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}", null);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "\n", null);
};


function _CatchStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_CatchStatementEmitter], _StatementEmitter);
_CatchStatementEmitter.prototype.emit$ = function () {
	var localType;
	var this$0;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var _emitter$0;
	this$7 = this._statement;
	this$0 = this$7._local;
	localType = this$0._type;
	if (localType instanceof ObjectType) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = this._emitter, "if (" + (_emitter$0, _emitter$0._namer).getNameOfLocalVariable$LLocalVariable$((this$2 = this._statement, this$2._local)) + " instanceof " + (this$3 = this._emitter, this$3._namer).getNameOfClass$LClassDefinition$(localType.getClassDef$()) + ") {\n", (this$4 = this._statement, this$4._token));
		JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, (this$5 = this._statement, this$5._statements));
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "} else ", null);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "{\n", null);
		JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$(this._emitter, (this$6 = this._statement, this$6._statements));
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "}\n", null);
	}
};


function _ThrowStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_ThrowStatementEmitter], _StatementEmitter);
_ThrowStatementEmitter.prototype.emit$ = function () {
	var this$0;
	var this$1;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "throw ", (this$0 = this._statement, this$0._token));
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$1 = this._statement, this$1._expr)).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ";\n", null);
};


function _AssertStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_AssertStatementEmitter], _StatementEmitter);
_AssertStatementEmitter.prototype.emit$ = function () {
	var $this = this;
	var condExpr;
	var _statement$0;
	condExpr = (_statement$0 = this._statement)._expr;
	if (_statement$0._msgExpr != null) {
		JavaScriptEmitter$_emitAssertionWithMsg$LJavaScriptEmitter$F$V$LToken$SLExpression$(this._emitter, (function () {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, condExpr).emit$N(0);
		}), condExpr._token, "assertion failure", this._statement._msgExpr);
	} else {
		JavaScriptEmitter$_emitAssertion$LJavaScriptEmitter$F$V$LToken$S(this._emitter, (function () {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, condExpr).emit$N(0);
		}), condExpr._token, "assertion failure");
	}
};


function _LogStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_LogStatementEmitter], _StatementEmitter);
_LogStatementEmitter.prototype.emit$ = function () {
	var exprs;
	var i;
	var this$0;
	var this$1;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "console.log(", (this$0 = this._statement, this$0._token));
	this$1 = this._statement;
	exprs = this$1._exprs;
	for (i = 0; i < exprs.length; ++i) {
		if (i !== 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", null);
		}
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, exprs[i]).emit$N(0);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ");\n", null);
};


function _DebuggerStatementEmitter(emitter, statement) {
	this._emitter = emitter;
	this._statement = statement;
};

$__jsx_extend([_DebuggerStatementEmitter], _StatementEmitter);
_DebuggerStatementEmitter.prototype.emit$ = function () {
	var this$0;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "debugger;\n", (this$0 = this._statement, this$0._token));
};


function _ExpressionEmitter(emitter) {
	this._emitter = emitter;
};

$__jsx_extend([_ExpressionEmitter], Object);
_ExpressionEmitter.prototype.emitWithPrecedence$NNF$V$ = function (outerOpPrecedence, precedence, callback) {
	var emitter$0;
	emitter$0 = this._emitter;
	if (precedence > outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0, "(", null);
		callback();
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0, ")", null);
	} else {
		callback();
	}
};


function _ExpressionEmitter$emitWithPrecedence$L_ExpressionEmitter$NNF$V$($this, outerOpPrecedence, precedence, callback) {
	var emitter$0;
	emitter$0 = $this._emitter;
	if (precedence > outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0, "(", null);
		callback();
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0, ")", null);
	} else {
		callback();
	}
};

_ExpressionEmitter.emitWithPrecedence$L_ExpressionEmitter$NNF$V$ = _ExpressionEmitter$emitWithPrecedence$L_ExpressionEmitter$NNF$V$;

function _LocalExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_LocalExpressionEmitter], _ExpressionEmitter);
_LocalExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var local;
	var this$0;
	var this$2;
	var _emitter$0;
	this$0 = this._expr;
	local = this$0._local;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = this._emitter, (_emitter$0, _emitter$0._namer).getNameOfLocalVariable$LLocalVariable$(local), (this$2 = this._expr, this$2._token));
};


function _ClassExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_ClassExpressionEmitter], _ExpressionEmitter);
_ClassExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var type;
	var this$0;
	var _emitter$0;
	this$0 = this._expr;
	type = this$0._parsedType;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = this._emitter, (_emitter$0, _emitter$0._namer).getNameOfClass$LClassDefinition$(type.getClassDef$()), null);
};


function _NullExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_NullExpressionEmitter], _ExpressionEmitter);
_NullExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var token;
	var this$0;
	this$0 = this._expr;
	token = this$0._token;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "null", token);
};


function _BooleanLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_BooleanLiteralExpressionEmitter], _ExpressionEmitter);
_BooleanLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var token;
	var this$0;
	this$0 = this._expr;
	token = this$0._token;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, token._value, token);
};


function _IntegerLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_IntegerLiteralExpressionEmitter], _ExpressionEmitter);
_IntegerLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var token;
	var this$0;
	this$0 = this._expr;
	token = this$0._token;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "" + token._value, token);
};


function _NumberLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_NumberLiteralExpressionEmitter], _ExpressionEmitter);
_NumberLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var str;
	var expr$0;
	var this$0$0;
	var this$0;
	var this$1;
	expr$0 = this._expr;
	str = (expr$0.tokenIsECMA262Conformant$() ? (this$0$0 = expr$0._token, this$0$0._value) : expr$0.getDecoded$() + "");
	if (outerOpPrecedence === _PropertyExpressionEmitter._operatorPrecedence && str.indexOf(".") === -1) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "(" + str + ")", (this$0 = this._expr, this$0._token));
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "" + str, (this$1 = this._expr, this$1._token));
	}
};


function _StringLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_StringLiteralExpressionEmitter], _ExpressionEmitter);
_StringLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var token;
	var this$0;
	var this$0$0;
	var _expr$0;
	this$0 = _expr$0 = this._expr;
	token = this$0._token;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, (_expr$0, _expr$0.tokenIsECMA262Conformant$() ? (this$0$0 = _expr$0._token, this$0$0._value) : Util$encodeStringLiteral$S(_expr$0.getDecoded$())), token);
};


function _RegExpLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_RegExpLiteralExpressionEmitter], _ExpressionEmitter);
_RegExpLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var token;
	var this$0;
	this$0 = this._expr;
	token = this$0._token;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, token._value, token);
};


function _ArrayLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_ArrayLiteralExpressionEmitter], _ExpressionEmitter);
_ArrayLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var exprs;
	var exprType;
	var i;
	var this$0;
	var _expr$0;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "[ ", null);
	this$0 = _expr$0 = this._expr;
	exprs = this$0._exprs;
	exprType = _Util$getElementTypeOfCompoundType$LType$((_expr$0, _expr$0._type));
	for (i = 0; i < exprs.length; ++i) {
		if (i !== 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", null);
		}
		JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$(this._emitter, exprs[i], exprType);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " ]", null);
};


function _MapLiteralExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_MapLiteralExpressionEmitter], _ExpressionEmitter);
_MapLiteralExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var elements;
	var elementType;
	var i;
	var element;
	var this$0;
	var this$2;
	var _key$0;
	var _expr$0;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "({ ", null);
	this$0 = _expr$0 = this._expr;
	elements = this$0._elements;
	elementType = _Util$getElementTypeOfCompoundType$LType$((_expr$0, _expr$0._type));
	for (i = 0; i < elements.length; ++i) {
		element = elements[i];
		if (i !== 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", null);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, (this$2 = _key$0 = element._key, this$2._value), _key$0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ": ", null);
		JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$(this._emitter, element._expr, elementType);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " })", null);
};


function _ThisExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_ThisExpressionEmitter], _ExpressionEmitter);
_ThisExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var emittingFunction;
	var this$0;
	var this$1;
	emittingFunction = this._emitter._emittingFunction;
	if (emittingFunction._parent != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "$this", (this$0 = this._expr, this$0._token));
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "this", (this$1 = this._expr, this$1._token));
	}
};


function _AsExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_AsExpressionEmitter], _ExpressionEmitter);
_AsExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var srcType;
	var destType;
	var prec;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$0$0;
	var this$6;
	var this$0$1;
	var this$0$2;
	var this$7;
	var this$8;
	var this$0$3;
	var _expr$0;
	srcType = (this$0 = this._expr, this$0._expr).getType$();
	this$1 = this._expr;
	destType = this$1._type;
	if (srcType instanceof ObjectType || srcType.equals$LType$(Type.variantType)) {
		if (srcType.isConvertibleTo$LType$(destType)) {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$2 = this._expr, this$2._expr)).emit$N(outerOpPrecedence);
			return;
		}
		if (destType instanceof ObjectType || destType instanceof FunctionType) {
			new _AsNoConvertExpressionEmitter(this._emitter, new AsNoConvertExpression((this$3 = _expr$0 = this._expr, this$3._token), (this$4 = _expr$0, this$4._expr), (_expr$0, _expr$0._type))).emit$N(outerOpPrecedence);
			return;
		}
	}
	if ((srcType instanceof NullableType ? (this$0$0 = srcType, this$0$0._baseType) : srcType).equals$LType$(Type.booleanType)) {
		if (destType.equals$LType$(Type.integerType) || destType.equals$LType$(Type.numberType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["+"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "+", null);
			return;
		}
		if (destType.equals$LType$(Type.stringType)) {
			prec = _AdditiveExpressionEmitter._operatorPrecedence;
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " + \"\"");
			return;
		}
	}
	if ((srcType instanceof NullableType ? (this$0$3 = srcType, this$0$3._baseType) : srcType).equals$LType$(Type.integerType)) {
		if (destType.equals$LType$(Type.booleanType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["!"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "!! ", null);
			return;
		}
		if (destType.equals$LType$(Type.numberType)) {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$6 = this._expr, this$6._expr)).emit$N(outerOpPrecedence);
			return;
		}
		if (destType.equals$LType$(Type.stringType)) {
			prec = _AdditiveExpressionEmitter._operatorPrecedence;
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " + \"\"");
			return;
		}
	}
	if ((srcType instanceof NullableType ? (this$0$1 = srcType, this$0$1._baseType) : srcType).equals$LType$(Type.numberType)) {
		if (destType.equals$LType$(Type.booleanType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["!"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "!! ", null);
			return;
		}
		if (destType.equals$LType$(Type.integerType)) {
			prec = _BinaryNumberExpressionEmitter._operatorPrecedence["|"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " | 0");
			return;
		}
		if (destType.equals$LType$(Type.stringType)) {
			prec = _AdditiveExpressionEmitter._operatorPrecedence;
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " + \"\"");
			return;
		}
	}
	if ((srcType instanceof NullableType ? (this$0$2 = srcType, this$0$2._baseType) : srcType).equals$LType$(Type.stringType)) {
		if (destType.equals$LType$(Type.booleanType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["!"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "!! ", null);
			return;
		}
		if (destType.equals$LType$(Type.integerType)) {
			prec = _BinaryNumberExpressionEmitter._operatorPrecedence["|"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " | 0");
			return;
		}
		if (destType.equals$LType$(Type.numberType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["+"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "+", null);
			return;
		}
	}
	if (srcType.equals$LType$(Type.variantType)) {
		if (destType.equals$LType$(Type.booleanType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["!"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "!! ", null);
			return;
		}
		if (destType.equals$LType$(Type.integerType)) {
			prec = _BinaryNumberExpressionEmitter._operatorPrecedence["|"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " | 0");
			return;
		}
		if (destType.equals$LType$(Type.numberType)) {
			prec = _UnaryExpressionEmitter._operatorPrecedence["+"];
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, "+", null);
			return;
		}
		if (destType.equals$LType$(Type.stringType)) {
			prec = _AdditiveExpressionEmitter._operatorPrecedence;
			_AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS(this, outerOpPrecedence, prec, prec, null, " + \"\"");
			return;
		}
	}
	if (srcType.isConvertibleTo$LType$(destType)) {
		if (srcType instanceof NullableType) {
			JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, (this$7 = this._expr, this$7._expr), outerOpPrecedence);
		} else {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$8 = this._expr, this$8._expr)).emit$N(outerOpPrecedence);
		}
		return;
	}
	throw new Error("explicit conversion logic unknown from " + srcType.toString() + " to " + destType.toString());
};


_AsExpressionEmitter.prototype._emitWithParens$NNNUSUS = function (outerOpPrecedence, opPrecedence, innerOpPrecedence, prefix, postfix) {
	var this$0;
	var this$1;
	var this$2;
	if (opPrecedence >= outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "(", null);
	}
	if (prefix != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, prefix, (this$0 = this._expr, this$0._token));
	}
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, (this$1 = this._expr, this$1._expr), innerOpPrecedence);
	if (postfix != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, postfix, (this$2 = this._expr, this$2._token));
	}
	if (opPrecedence >= outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", null);
	}
};


function _AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS($this, outerOpPrecedence, opPrecedence, innerOpPrecedence, prefix, postfix) {
	var this$0;
	var this$1;
	var this$2;
	if (opPrecedence >= outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "(", null);
	}
	if (prefix != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, prefix, (this$0 = $this._expr, this$0._token));
	}
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this._emitter, (this$1 = $this._expr, this$1._expr), innerOpPrecedence);
	if (postfix != null) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, postfix, (this$2 = $this._expr, this$2._token));
	}
	if (opPrecedence >= outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ")", null);
	}
};

_AsExpressionEmitter._emitWithParens$L_AsExpressionEmitter$NNNUSUS = _AsExpressionEmitter$_emitWithParens$L_AsExpressionEmitter$NNNUSUS;

function _AsNoConvertExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_AsNoConvertExpressionEmitter], _ExpressionEmitter);
_AsNoConvertExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var $this = this;
	var emitWithAssertion;
	var srcType;
	var destType;
	var destClassDef;
	var this$0;
	var this$1;
	var this$0$0;
	var this$0$0$0;
	var this$2;
	var this$0$1;
	var this$3;
	var this$0$2;
	var this$0$3;
	var this$0$4;
	var this$0$5;
	var this$0$6;
	if (this._emitter._enableRunTimeTypeCheck) {
		emitWithAssertion = (function (emitCheckExpr, message) {
			var token;
			var this$0;
			var this$1;
			var this$2;
			var this$3;
			this$0 = $this._expr;
			token = this$0._token;
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "(function ($v) {\n", token);
			this$1 = $this._emitter;
			++this$1._indent;
			JavaScriptEmitter$_emitAssertion$LJavaScriptEmitter$F$V$LToken$S($this._emitter, emitCheckExpr, token, message);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "return $v;\n", token);
			this$2 = $this._emitter;
			if (--this$2._indent < 0) {
				throw new Error("indent mistach");
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "}(", token);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, (this$3 = $this._expr, this$3._expr)).emit$N(0);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "))", token);
		});
		srcType = (this$0 = this._expr, this$0._expr).getType$();
		this$1 = this._expr;
		destType = this$1._type;
		if (srcType.equals$LType$(destType) || srcType.equals$LType$(destType instanceof NullableType ? (this$0$6 = destType, this$0$6._baseType) : destType)) {
		} else if (destType instanceof VariantType) {
		} else if (srcType instanceof ObjectType && srcType.isConvertibleTo$LType$(destType)) {
		} else if (destType.equals$LType$(Type.booleanType)) {
			emitWithAssertion((function () {
				var this$0;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "typeof $v === \"boolean\"", (this$0 = $this._expr, this$0._token));
			}), "detected invalid cast, value is not a boolean");
			return;
		} else if ((destType instanceof NullableType ? (this$0$5 = destType, this$0$5._baseType) : destType).equals$LType$(Type.booleanType)) {
			emitWithAssertion((function () {
				var this$0;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"boolean\"", (this$0 = $this._expr, this$0._token));
			}), "detected invalid cast, value is not a boolean nor null");
			return;
		} else if (destType.equals$LType$(Type.numberType)) {
			emitWithAssertion((function () {
				var this$0;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "typeof $v === \"number\"", (this$0 = $this._expr, this$0._token));
			}), "detected invalid cast, value is not a number");
			return;
		} else if ((destType instanceof NullableType ? (this$0$4 = destType, this$0$4._baseType) : destType).equals$LType$(Type.numberType)) {
			emitWithAssertion((function () {
				var this$0;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"number\"", (this$0 = $this._expr, this$0._token));
			}), "detected invalid cast, value is not a number nor nullable");
			return;
		} else if (destType.equals$LType$(Type.integerType)) {
			emitWithAssertion((function () {
				var this$0;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "typeof $v === \"number\" && (! $__jsx_isFinite($v) || $v % 1 === 0)", (this$0 = $this._expr, this$0._token));
			}), "detected invalid cast, value is not an int");
			return;
		} else if ((destType instanceof NullableType ? (this$0$3 = destType, this$0$3._baseType) : destType).equals$LType$(Type.integerType)) {
			emitWithAssertion((function () {
				var this$0;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"number\" && (! $__jsx_isFinite($v) || $v % 1 === 0)", (this$0 = $this._expr, this$0._token));
			}), "detected invalid cast, value is not an int nor null");
			return;
		} else if (destType.equals$LType$(Type.stringType)) {
			emitWithAssertion((function () {
				var this$0;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "typeof $v === \"string\"", (this$0 = $this._expr, this$0._token));
			}), "detected invalid cast, value is not a string");
			return;
		} else if ((destType instanceof NullableType ? (this$0$2 = destType, this$0$2._baseType) : destType).equals$LType$(Type.stringType)) {
			emitWithAssertion((function () {
				var this$0;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"string\"", (this$0 = $this._expr, this$0._token));
			}), "detected invalid cast, value is not a string nor null");
			return;
		} else if (destType instanceof FunctionType) {
			emitWithAssertion((function () {
				var this$0;
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"function\"", (this$0 = $this._expr, this$0._token));
			}), "detected invalid cast, value is not a function or null");
			return;
		} else if (destType instanceof ObjectType) {
			destClassDef = destType.getClassDef$();
			if ((destClassDef.flags$() & 256) !== 0) {
			} else if (destType.getClassDef$() instanceof InstantiatedClassDefinition && (this$0$0 = destType.getClassDef$(), this$0$0$0 = this$0$0._templateClassDef, this$0$0$0._className) === "Array") {
				emitWithAssertion((function () {
					var this$0;
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || $v instanceof Array", (this$0 = $this._expr, this$0._token));
				}), "detected invalid cast, value is not an Array or null");
				return;
			} else if (destClassDef instanceof InstantiatedClassDefinition && (this$2 = destClassDef, this$0$1 = this$2._templateClassDef, this$0$1._className) === "Map") {
				if (srcType.equals$LType$(Type.variantType)) {
					emitWithAssertion((function () {
						var this$0;
						JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"object\" || typeof $v === \"function\"", (this$0 = $this._expr, this$0._token));
					}), "detected invalid cast, value is not a Map or null");
				} else {
					emitWithAssertion((function () {
						var this$0;
						JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "$v == null || typeof $v === \"object\"", (this$0 = $this._expr, this$0._token));
					}), "detected invalid cast, value is not a Map or null");
				}
				return;
			} else if ((destClassDef.flags$() & 192) === 0) {
				emitWithAssertion((function () {
					var this$1;
					var _emitter$0;
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = $this._emitter, "$v == null || $v instanceof " + (_emitter$0, _emitter$0._namer).getNameOfClass$LClassDefinition$(destClassDef), (this$1 = $this._expr, this$1._token));
				}), "detected invalid cast, value is not an instance of the designated type or null");
				return;
			} else {
				emitWithAssertion((function () {
					var this$1;
					var _emitter$0;
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = $this._emitter, "$v == null || $v.$__jsx_implements_" + (_emitter$0, _emitter$0._namer).getNameOfClass$LClassDefinition$(destClassDef), (this$1 = $this._expr, this$1._token));
				}), "detected invalid cast, value is not an instance of the designated type or null");
				return;
			}
		} else {
			throw new Error("Hmm");
		}
	}
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$3 = this._expr, this$3._expr)).emit$N(outerOpPrecedence);
	return;
};


function _OperatorExpressionEmitter(emitter) {
	this._emitter = emitter;
};

$__jsx_extend([_OperatorExpressionEmitter], _ExpressionEmitter);
_OperatorExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var $this = this;
	var precedence$0;
	var callback$0;
	var emitter$0$0;
	precedence$0 = this._getPrecedence$();
	callback$0 = (function () {
		$this._emit$();
	});
	emitter$0$0 = this._emitter;
	if (precedence$0 > outerOpPrecedence) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$0, "(", null);
		callback$0();
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$0, ")", null);
	} else {
		callback$0();
	}
};


_OperatorExpressionEmitter.prototype._emit$ = function () {
};


function _UnaryExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_UnaryExpressionEmitter], _OperatorExpressionEmitter);
_UnaryExpressionEmitter.prototype._emit$ = function () {
	var opToken;
	var this$0;
	var this$1;
	this$0 = this._expr;
	opToken = this$0._token;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, opToken._value + " ", opToken);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$1 = this._expr, this$1._expr)).emit$N(this._getPrecedence$());
};


_UnaryExpressionEmitter.prototype._getPrecedence$ = function () {
	var this$0;
	var this$1;
	return _UnaryExpressionEmitter._operatorPrecedence[(this$1 = (this$0 = this._expr, this$0._token), this$1._value)];
};


function _UnaryExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_UnaryExpressionEmitter._operatorPrecedence[op] = precedence;
};

_UnaryExpressionEmitter._setOperatorPrecedence$SN = _UnaryExpressionEmitter$_setOperatorPrecedence$SN;

function _PreIncrementExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_PreIncrementExpressionEmitter], _UnaryExpressionEmitter);
_PreIncrementExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var $this = this;
	var opToken;
	var this$0;
	var this$1;
	var precedence$0;
	var callback$0;
	var emitter$0$0;
	var precedence$1;
	var callback$1;
	var emitter$0$1;
	var this$2;
	var this$0$0;
	var this$1$0;
	var this$3;
	var this$0$1;
	var _expr$0;
	this$0 = _expr$0 = this._expr;
	opToken = this$0._token;
	if ((this$3 = _expr$0.getType$(), this$3 instanceof NullableType ? (this$0$1 = this$3, this$0$1._baseType) : this$3).equals$LType$(Type.integerType)) {
		if (Expression$hasSideEffects$LExpression$((this$2 = this._expr, this$2._expr))) {
			_Util$emitFusedIntOpWithSideEffects$LJavaScriptEmitter$SLExpression$F$NV$N(this._emitter, (opToken._value === "++" ? "$__jsx_ipadd" : "$__jsx_ipsub"), (this$1 = this._expr, this$1._expr), (function (outerPred) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "1", opToken);
			}), 0);
		} else {
			precedence$0 = _AssignmentExpressionEmitter._operatorPrecedence["="];
			callback$0 = (function () {
				var this$0;
				var this$1;
				var this$2;
				var this$3;
				JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, (this$0 = $this._expr, this$0._expr)).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " = (", (this$1 = $this._expr, this$1._token));
				JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, (this$2 = $this._expr, this$2._expr)).emit$N(_AdditiveExpressionEmitter._operatorPrecedence);
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " " + opToken._value.charAt(0) + " 1) | 0", (this$3 = $this._expr, this$3._token));
			});
			emitter$0$0 = this._emitter;
			if (precedence$0 > outerOpPrecedence) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$0, "(", null);
				callback$0();
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$0, ")", null);
			} else {
				callback$0();
			}
		}
	} else {
		precedence$1 = _PreIncrementExpressionEmitter._operatorPrecedence[(this$1$0 = (this$0$0 = this._expr, this$0$0._token), this$1$0._value)];
		callback$1 = (function () {
			var this$0;
			var this$0$0;
			var this$1$0;
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, opToken._value, opToken);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, (this$0 = $this._expr, this$0._expr)).emit$N(_PreIncrementExpressionEmitter._operatorPrecedence[(this$1$0 = (this$0$0 = $this._expr, this$0$0._token), this$1$0._value)]);
		});
		emitter$0$1 = this._emitter;
		if (precedence$1 > outerOpPrecedence) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$1, "(", null);
			callback$1();
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$1, ")", null);
		} else {
			callback$1();
		}
	}
};


_PreIncrementExpressionEmitter.prototype._getPrecedence$ = function () {
	var this$0;
	var this$1;
	return _PreIncrementExpressionEmitter._operatorPrecedence[(this$1 = (this$0 = this._expr, this$0._token), this$1._value)];
};


function _PreIncrementExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_PreIncrementExpressionEmitter._operatorPrecedence[op] = precedence;
};

_PreIncrementExpressionEmitter._setOperatorPrecedence$SN = _PreIncrementExpressionEmitter$_setOperatorPrecedence$SN;

function _PostIncrementExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_PostIncrementExpressionEmitter], _UnaryExpressionEmitter);
_PostIncrementExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var $this = this;
	var opToken;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var precedence$0;
	var callback$0;
	var emitter$0$0;
	var this$7;
	var this$0$0;
	var this$1$0;
	var this$8;
	var this$0$1;
	var _expr$0;
	this$0 = _expr$0 = this._expr;
	opToken = this$0._token;
	if ((this$8 = _expr$0.getType$(), this$8 instanceof NullableType ? (this$0$1 = this$8, this$0$1._baseType) : this$8).equals$LType$(Type.integerType)) {
		if (Expression$hasSideEffects$LExpression$((this$7 = this._expr, this$7._expr))) {
			_Util$emitFusedIntOpWithSideEffects$LJavaScriptEmitter$SLExpression$F$NV$N(this._emitter, (opToken._value === "++" ? "$__jsx_ippostinc" : "$__jsx_ippostdec"), (this$1 = this._expr, this$1._expr), (function (outerPred) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "1", opToken);
			}), 0);
		} else {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "($__jsx_postinc_t = ", (this$2 = this._expr, this$2._token));
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$3 = this._expr, this$3._expr)).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", (this$4 = this._expr, this$4._token));
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$5 = this._expr, this$5._expr)).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " = ($__jsx_postinc_t " + opToken._value.charAt(0) + " 1) | 0, " + "$__jsx_postinc_t" + ")", (this$6 = this._expr, this$6._token));
		}
	} else {
		precedence$0 = _PostIncrementExpressionEmitter._operatorPrecedence[(this$1$0 = (this$0$0 = this._expr, this$0$0._token), this$1$0._value)];
		callback$0 = (function () {
			var this$0;
			var this$0$0;
			var this$1$0;
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, (this$0 = $this._expr, this$0._expr)).emit$N(_PostIncrementExpressionEmitter._operatorPrecedence[(this$1$0 = (this$0$0 = $this._expr, this$0$0._token), this$1$0._value)]);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, opToken._value, opToken);
		});
		emitter$0$0 = this._emitter;
		if (precedence$0 > outerOpPrecedence) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$0, "(", null);
			callback$0();
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$0, ")", null);
		} else {
			callback$0();
		}
	}
};


_PostIncrementExpressionEmitter.prototype._getPrecedence$ = function () {
	var this$0;
	var this$1;
	return _PostIncrementExpressionEmitter._operatorPrecedence[(this$1 = (this$0 = this._expr, this$0._token), this$1._value)];
};


function _PostIncrementExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_PostIncrementExpressionEmitter._operatorPrecedence[op] = precedence;
};

_PostIncrementExpressionEmitter._setOperatorPrecedence$SN = _PostIncrementExpressionEmitter$_setOperatorPrecedence$SN;

function _PostIncrementExpressionEmitter$needsTempVarFor$LPostIncrementExpression$(expr) {
	var this$0$0;
	var this$0$0$0;
	var this$0;
	var this$0$1;
	return (this$0 = (this$0$0 = expr._expr.getType$(), this$0$0 instanceof NullableType ? (this$0$0$0 = this$0$0, this$0$0$0._baseType) : this$0$0), this$0 instanceof NullableType ? (this$0$1 = this$0, this$0$1._baseType) : this$0).equals$LType$(Type.integerType) && ! Expression$hasSideEffects$LExpression$(expr._expr);
};

_PostIncrementExpressionEmitter.needsTempVarFor$LPostIncrementExpression$ = _PostIncrementExpressionEmitter$needsTempVarFor$LPostIncrementExpression$;

function _InstanceofExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_InstanceofExpressionEmitter], _ExpressionEmitter);
_InstanceofExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var $this = this;
	var expectedType;
	var this$0;
	var this$0$0;
	var this$0$0$0;
	var precedence$0;
	var callback$0;
	var emitter$0$0;
	var precedence$1;
	var callback$1;
	var emitter$0$1;
	var precedence$2;
	var callback$2;
	var emitter$0$2;
	var precedence$3;
	var callback$3;
	var emitter$0$3;
	var this$1;
	var this$0$1;
	this$0 = this._expr;
	expectedType = this$0._expectedType;
	if (expectedType.getClassDef$() instanceof InstantiatedClassDefinition && (this$0$0 = expectedType.getClassDef$(), this$0$0$0 = this$0$0._templateClassDef, this$0$0$0._className) === "Array") {
		precedence$0 = _InstanceofExpressionEmitter._operatorPrecedence;
		callback$0 = (function () {
			var this$0;
			var this$1;
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, (this$0 = $this._expr, this$0._expr)).emit$N(_InstanceofExpressionEmitter._operatorPrecedence);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " instanceof Array", (this$1 = $this._expr, this$1._token));
		});
		emitter$0$0 = this._emitter;
		if (precedence$0 > outerOpPrecedence) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$0, "(", null);
			callback$0();
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$0, ")", null);
		} else {
			callback$0();
		}
	} else if (expectedType.getClassDef$() instanceof InstantiatedClassDefinition && (this$1 = expectedType.getClassDef$(), this$0$1 = this$1._templateClassDef, this$0$1._className) === "Map") {
		precedence$1 = _InstanceofExpressionEmitter._operatorPrecedence;
		callback$1 = (function () {
			var this$0;
			var this$1;
			var this$2;
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "(typeof(", (this$0 = $this._expr, this$0._token));
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, (this$1 = $this._expr, this$1._expr)).emit$N(_InstanceofExpressionEmitter._operatorPrecedence);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ") === \"object\")", (this$2 = $this._expr, this$2._token));
		});
		emitter$0$1 = this._emitter;
		if (precedence$1 > outerOpPrecedence) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$1, "(", null);
			callback$1();
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$1, ")", null);
		} else {
			callback$1();
		}
	} else if ((expectedType.getClassDef$().flags$() & 192) === 0) {
		precedence$2 = _InstanceofExpressionEmitter._operatorPrecedence;
		callback$2 = (function () {
			var this$0;
			var this$1;
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, (this$0 = $this._expr, this$0._expr)).emit$N(_InstanceofExpressionEmitter._operatorPrecedence);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " instanceof " + _InstanceofExpressionEmitter$getInstanceofNameFromClassDef$L_InstanceofExpressionEmitter$LClassDefinition$($this, expectedType.getClassDef$()), (this$1 = $this._expr, this$1._token));
		});
		emitter$0$2 = this._emitter;
		if (precedence$2 > outerOpPrecedence) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$2, "(", null);
			callback$2();
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$2, ")", null);
		} else {
			callback$2();
		}
	} else {
		precedence$3 = _CallExpressionEmitter._operatorPrecedence;
		callback$3 = (function () {
			var this$1;
			var this$2;
			var this$3;
			var _emitter$0;
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = $this._emitter, "(function (o) { return !! (o && o.$__jsx_implements_" + (_emitter$0, _emitter$0._namer).getNameOfClass$LClassDefinition$(expectedType.getClassDef$()) + "); })(", (this$1 = $this._expr, this$1._token));
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, (this$2 = $this._expr, this$2._expr)).emit$N(0);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ")", (this$3 = $this._expr, this$3._token));
		});
		emitter$0$3 = this._emitter;
		if (precedence$3 > outerOpPrecedence) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$3, "(", null);
			callback$3();
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0$3, ")", null);
		} else {
			callback$3();
		}
	}
};


_InstanceofExpressionEmitter.prototype.getInstanceofNameFromClassDef$LClassDefinition$ = function (classDef) {
	var name;
	var this$0;
	var this$0$0;
	var this$1;
	if (classDef instanceof InstantiatedClassDefinition) {
		this$0 = classDef;
		this$0$0 = this$0._templateClassDef;
		name = this$0$0._className;
		if (name === "Map") {
			name = "Object";
		}
	} else {
		name = (this$1 = this._emitter, this$1._namer).getNameOfClass$LClassDefinition$(classDef);
	}
	return name;
};


function _InstanceofExpressionEmitter$getInstanceofNameFromClassDef$L_InstanceofExpressionEmitter$LClassDefinition$($this, classDef) {
	var name;
	var this$0;
	var this$0$0;
	var this$1;
	if (classDef instanceof InstantiatedClassDefinition) {
		this$0 = classDef;
		this$0$0 = this$0._templateClassDef;
		name = this$0$0._className;
		if (name === "Map") {
			name = "Object";
		}
	} else {
		name = (this$1 = $this._emitter, this$1._namer).getNameOfClass$LClassDefinition$(classDef);
	}
	return name;
};

_InstanceofExpressionEmitter.getInstanceofNameFromClassDef$L_InstanceofExpressionEmitter$LClassDefinition$ = _InstanceofExpressionEmitter$getInstanceofNameFromClassDef$L_InstanceofExpressionEmitter$LClassDefinition$;

function _InstanceofExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_InstanceofExpressionEmitter._operatorPrecedence = precedence;
};

_InstanceofExpressionEmitter._setOperatorPrecedence$SN = _InstanceofExpressionEmitter$_setOperatorPrecedence$SN;

function _PropertyExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_PropertyExpressionEmitter], _UnaryExpressionEmitter);
_PropertyExpressionEmitter.prototype._emit$ = function () {
	var expr;
	var exprType;
	var identifierToken;
	var classDef;
	var name;
	var exprType$0;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var exprType$1;
	var this$4;
	var this$5;
	var this$6;
	expr = this._expr;
	exprType = expr._type;
	identifierToken = expr._identifierToken;
	if (expr._expr.isClassSpecifier$() && expr._expr.getType$().getClassDef$() == (Type.numberType, NumberType._classDef)) {
		switch (identifierToken._value) {
		case "parseInt":
		case "parseFloat":
		case "isNaN":
		case "isFinite":
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, '$__jsx_' + identifierToken._value, identifierToken);
			return;
		}
	} else if (expr._expr.isClassSpecifier$() && expr._expr.getType$().getClassDef$() == (Type.stringType, StringType._classDef)) {
		switch (identifierToken._value) {
		case "encodeURIComponent":
		case "decodeURIComponent":
		case "encodeURI":
		case "decodeURI":
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, '$__jsx_' + identifierToken._value, identifierToken);
			return;
		}
	}
	classDef = expr.getHolderType$().getClassDef$();
	if (expr._expr.isClassSpecifier$()) {
		name = identifierToken._value;
		exprType$0 = expr._type;
		if (! (exprType$0 instanceof FunctionType) ? false : exprType$0.isAssignable$() ? false : true) {
			name = (this$0 = this._emitter, this$0._namer).getNameOfStaticFunction$LClassDefinition$SALType$(classDef, name, (this$1 = exprType, this$1._argTypes));
		} else {
			name = (this$2 = this._emitter, this$2._namer).getNameOfClass$LClassDefinition$(classDef) + "." + (this$3 = this._emitter, this$3._namer).getNameOfStaticVariable$LClassDefinition$S(classDef, name);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, name, identifierToken);
	} else {
		name = identifierToken._value;
		exprType$1 = expr._type;
		if (! (exprType$1 instanceof FunctionType) ? false : exprType$1.isAssignable$() ? false : true) {
			name = (this$4 = this._emitter, this$4._namer).getNameOfMethod$LClassDefinition$SALType$(classDef, name, (this$5 = exprType, this$5._argTypes));
		} else {
			name = (this$6 = this._emitter, this$6._namer).getNameOfProperty$LClassDefinition$S(classDef, name);
		}
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, expr._expr).emit$N(_PropertyExpressionEmitter._operatorPrecedence);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "." + name, identifierToken);
	}
};


_PropertyExpressionEmitter.prototype._getPrecedence$ = function () {
	return _PropertyExpressionEmitter._operatorPrecedence;
};


function _PropertyExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_PropertyExpressionEmitter._operatorPrecedence = precedence;
};

_PropertyExpressionEmitter._setOperatorPrecedence$SN = _PropertyExpressionEmitter$_setOperatorPrecedence$SN;

function _FunctionExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_FunctionExpressionEmitter], _OperatorExpressionEmitter);
_FunctionExpressionEmitter.prototype._emit$ = function () {
	var $this = this;
	var funcDef;
	var funcLocal;
	var this$0;
	var this$1;
	this$0 = this._expr;
	funcDef = this$0._funcDef;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "(", funcDef._token);
	funcLocal = funcDef._funcLocal;
	(this$1 = this._emitter, this$1._namer).enterScope$LLocalVariable$F$V$(funcLocal, (function () {
		var this$0;
		var this$1;
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "function " + ((funcDef._flags & 8192) !== 0 ? "* " : "") + (funcLocal != null ? (this$0 = $this._emitter, this$0._namer).getNameOfLocalVariable$LLocalVariable$(funcLocal) : "") + "(", funcDef._token);
		(this$1 = $this._emitter, this$1._namer).enterFunction$LMemberFunctionDefinition$F$V$(funcDef, (function () {
			var args;
			var i;
			args = MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef);
			for (i = 0; i < args.length; ++i) {
				if (i !== 0) {
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", MemberDefinition$getToken$LMemberDefinition$(funcDef));
				}
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, JavaScriptEmitter$getNamer$LJavaScriptEmitter$($this._emitter).getNameOfLocalVariable$LLocalVariable$(args[i]), MemberDefinition$getToken$LMemberDefinition$(funcDef));
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ") {\n", MemberDefinition$getToken$LMemberDefinition$(funcDef));
			JavaScriptEmitter$_advanceIndent$LJavaScriptEmitter$($this._emitter);
			JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this._emitter, funcDef);
			JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this._emitter);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "}", MemberDefinition$getToken$LMemberDefinition$(funcDef));
		}));
	}));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", funcDef._token);
};


_FunctionExpressionEmitter.prototype._getPrecedence$ = function () {
	return _FunctionExpressionEmitter._operatorPrecedence;
};


function _FunctionExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_FunctionExpressionEmitter._operatorPrecedence = precedence;
};

_FunctionExpressionEmitter._setOperatorPrecedence$SN = _FunctionExpressionEmitter$_setOperatorPrecedence$SN;

function _AdditiveExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_AdditiveExpressionEmitter], _OperatorExpressionEmitter);
_AdditiveExpressionEmitter.prototype._emit$ = function () {
	var isInt;
	var this$0;
	var this$1;
	var this$0$0;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	isInt = (this$1 = (this$0 = this._expr, this$0._type), this$1 instanceof NullableType ? (this$0$0 = this$1, this$0$0._baseType) : this$1).equals$LType$(Type.integerType);
	if (isInt) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "((", (this$2 = this._expr, this$2._token));
	}
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, (this$3 = this._expr, this$3._expr1), _AdditiveExpressionEmitter._operatorPrecedence);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " + ", (this$4 = this._expr, this$4._token));
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, (this$5 = this._expr, this$5._expr2), _AdditiveExpressionEmitter._operatorPrecedence - 1);
	if (isInt) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ") | 0)", (this$6 = this._expr, this$6._token));
	}
};


_AdditiveExpressionEmitter.prototype._getPrecedence$ = function () {
	return _AdditiveExpressionEmitter._operatorPrecedence;
};


function _AdditiveExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_AdditiveExpressionEmitter._operatorPrecedence = precedence;
};

_AdditiveExpressionEmitter._setOperatorPrecedence$SN = _AdditiveExpressionEmitter$_setOperatorPrecedence$SN;

function _AssignmentExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_AssignmentExpressionEmitter], _OperatorExpressionEmitter);
_AssignmentExpressionEmitter.prototype._emit$ = function () {
	var op;
	var this$0;
	var this$1;
	var this$0$0;
	var this$1$0;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var _expr$0;
	var _expr$1;
	this$5 = _expr$0 = this._expr;
	this$0 = this$5._token;
	op = this$0._value;
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$1 = _expr$0, this$1._expr1)).emit$N(_AssignmentExpressionEmitter._operatorPrecedence[(this$1$0 = (this$0$0 = this._expr, this$0$0._token), this$1$0._value)]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " " + op + " ", (this$2 = this._expr, this$2._token));
	JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$(this._emitter, (this$3 = _expr$1 = this._expr, this$3._expr2), (this$4 = _expr$1, this$4._expr1).getType$());
};


_AssignmentExpressionEmitter.prototype._getPrecedence$ = function () {
	var this$0;
	var this$1;
	return _AssignmentExpressionEmitter._operatorPrecedence[(this$1 = (this$0 = this._expr, this$0._token), this$1._value)];
};


function _AssignmentExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_AssignmentExpressionEmitter._operatorPrecedence[op] = precedence;
};

_AssignmentExpressionEmitter._setOperatorPrecedence$SN = _AssignmentExpressionEmitter$_setOperatorPrecedence$SN;

function _FusedAssignmentExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_FusedAssignmentExpressionEmitter], _OperatorExpressionEmitter);
_FusedAssignmentExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var $this = this;
	var coreOp;
	var this$0;
	var this$1;
	var this$2;
	var emitter$0;
	var precedence$0;
	var callback$0;
	var this$3;
	var this$4;
	var this$5;
	var this$0$0;
	coreOp = (this$1 = (this$0 = this._expr, this$0._token), this$1._value).charAt(0);
	if (_FusedAssignmentExpressionEmitter._fusedIntHelpers[coreOp] != null && (this$5 = (this$4 = this._expr, this$4._expr1).getType$(), this$5 instanceof NullableType ? (this$0$0 = this$5, this$0$0._baseType) : this$5).equals$LType$(Type.integerType)) {
		if (Expression$hasSideEffects$LExpression$((this$3 = this._expr, this$3._expr1))) {
			_Util$emitFusedIntOpWithSideEffects$LJavaScriptEmitter$SLExpression$F$NV$N(this._emitter, _FusedAssignmentExpressionEmitter._fusedIntHelpers[coreOp], (this$2 = this._expr, this$2._expr1), (function (outerPred) {
				var this$0;
				JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this._emitter, (this$0 = $this._expr, this$0._expr2), outerPred);
			}), outerOpPrecedence);
		} else {
			emitter$0 = this._emitter;
			precedence$0 = _AssignmentExpressionEmitter._operatorPrecedence["="];
			callback$0 = (function () {
				var coreOpPrecedence;
				var this$0;
				var this$1;
				var this$2;
				var this$3;
				var this$4;
				var this$5;
				var this$6;
				var this$7;
				var this$8;
				var this$9;
				var this$10;
				JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, (this$0 = $this._expr, this$0._expr1)).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
				if (coreOp === "*") {
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " = $__jsx_imul(", (this$1 = $this._expr, this$1._token));
					JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this._emitter, (this$2 = $this._expr, this$2._expr1), 0);
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", (this$3 = $this._expr, this$3._token));
					JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this._emitter, (this$4 = $this._expr, this$4._expr2), 0);
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ")", (this$5 = $this._expr, this$5._token));
				} else {
					coreOpPrecedence = (coreOp === "+" ? _AdditiveExpressionEmitter._operatorPrecedence : _BinaryNumberExpressionEmitter._operatorPrecedence[coreOp]);
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " = (", (this$6 = $this._expr, this$6._token));
					JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this._emitter, (this$7 = $this._expr, this$7._expr1), coreOpPrecedence);
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, " " + coreOp + " ", (this$8 = $this._expr, this$8._token));
					JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this._emitter, (this$9 = $this._expr, this$9._expr2), coreOpPrecedence - 1);
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ") | 0", (this$10 = $this._expr, this$10._token));
				}
			});
			if (precedence$0 > outerOpPrecedence) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0, "(", null);
				callback$0();
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(emitter$0, ")", null);
			} else {
				callback$0();
			}
		}
		return;
	}
	_OperatorExpressionEmitter.prototype.emit$N.call(this, outerOpPrecedence);
};


_FusedAssignmentExpressionEmitter.prototype._emit$ = function () {
	var op;
	var this$0;
	var this$1;
	var this$0$0;
	var this$1$0;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var _expr$0;
	var _expr$1;
	this$5 = _expr$0 = this._expr;
	this$0 = this$5._token;
	op = this$0._value;
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$1 = _expr$0, this$1._expr1)).emit$N(_FusedAssignmentExpressionEmitter._operatorPrecedence[(this$1$0 = (this$0$0 = this._expr, this$0$0._token), this$1$0._value)]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " " + op + " ", (this$2 = this._expr, this$2._token));
	JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$(this._emitter, (this$3 = _expr$1 = this._expr, this$3._expr2), (this$4 = _expr$1, this$4._expr1).getType$());
};


_FusedAssignmentExpressionEmitter.prototype._getPrecedence$ = function () {
	var this$0;
	var this$1;
	return _FusedAssignmentExpressionEmitter._operatorPrecedence[(this$1 = (this$0 = this._expr, this$0._token), this$1._value)];
};


function _FusedAssignmentExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_FusedAssignmentExpressionEmitter._operatorPrecedence[op] = precedence;
};

_FusedAssignmentExpressionEmitter._setOperatorPrecedence$SN = _FusedAssignmentExpressionEmitter$_setOperatorPrecedence$SN;

function _EqualityExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_EqualityExpressionEmitter], _OperatorExpressionEmitter);
_EqualityExpressionEmitter.prototype._emit$ = function () {
	var op;
	var emitOp;
	var lhs;
	var rhs;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$0$0;
	var this$4;
	var this$0$1;
	var this$5;
	var this$0$2;
	var this$6;
	var this$7;
	var _expr$0;
	this$7 = _expr$0 = this._expr;
	this$0 = this$7._token;
	op = this$0._value;
	emitOp = op;
	this$1 = _expr$0;
	lhs = this$1._expr1;
	this$2 = _expr$0;
	rhs = this$2._expr2;
	if (lhs.getType$() instanceof PrimitiveType && rhs.getType$() instanceof PrimitiveType) {
		emitOp += "=";
	} else if ((this$3 = lhs.getType$(), this$3 instanceof NullableType ? (this$0$0 = this$3, this$0$0._baseType) : this$3) instanceof PrimitiveType && (this$4 = lhs.getType$(), this$4 instanceof NullableType ? (this$0$1 = this$4, this$0$1._baseType) : this$4).equals$LType$((this$5 = rhs.getType$(), this$5 instanceof NullableType ? (this$0$2 = this$5, this$0$2._baseType) : this$5))) {
		emitOp += "=";
	}
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, lhs).emit$N(_EqualityExpressionEmitter._operatorPrecedence[op] - 1);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " " + emitOp + " ", (this$6 = this._expr, this$6._token));
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, rhs).emit$N(_EqualityExpressionEmitter._operatorPrecedence[op] - 1);
};


_EqualityExpressionEmitter.prototype._getPrecedence$ = function () {
	var this$0;
	var this$1;
	return _EqualityExpressionEmitter._operatorPrecedence[(this$1 = (this$0 = this._expr, this$0._token), this$1._value)];
};


function _EqualityExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_EqualityExpressionEmitter._operatorPrecedence[op] = precedence;
};

_EqualityExpressionEmitter._setOperatorPrecedence$SN = _EqualityExpressionEmitter$_setOperatorPrecedence$SN;

function _InExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_InExpressionEmitter], _OperatorExpressionEmitter);
_InExpressionEmitter.prototype._emit$ = function () {
	var this$0;
	var this$1;
	var this$2;
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, (this$0 = this._expr, this$0._expr1), _InExpressionEmitter._operatorPrecedence);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " in ", (this$1 = this._expr, this$1._token));
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$2 = this._expr, this$2._expr2)).emit$N(_InExpressionEmitter._operatorPrecedence);
};


_InExpressionEmitter.prototype._getPrecedence$ = function () {
	return _InExpressionEmitter._operatorPrecedence;
};


function _InExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_InExpressionEmitter._operatorPrecedence = precedence;
};

_InExpressionEmitter._setOperatorPrecedence$SN = _InExpressionEmitter$_setOperatorPrecedence$SN;

function _LogicalExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_LogicalExpressionEmitter], _OperatorExpressionEmitter);
_LogicalExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var this$0;
	var logicalExpr$0;
	var this$1;
	var this$2;
	this$0 = this._emitter;
	logicalExpr$0 = this._expr;
	if (JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$(this$0, logicalExpr$0).shouldBooleanize) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "!! (", (this$1 = this._expr, this$1._token));
		_OperatorExpressionEmitter.prototype.emit$N.call(this, 0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", (this$2 = this._expr, this$2._token));
		return;
	}
	_OperatorExpressionEmitter.prototype.emit$N.call(this, outerOpPrecedence);
};


_LogicalExpressionEmitter.prototype._emit$ = function () {
	var op;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var _expr$0;
	this$4 = _expr$0 = this._expr;
	this$0 = this$4._token;
	op = this$0._value;
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$1 = _expr$0, this$1._expr1)).emit$N(_LogicalExpressionEmitter._operatorPrecedence[op]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " " + op + " ", (this$2 = this._expr, this$2._token));
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$3 = this._expr, this$3._expr2)).emit$N(_LogicalExpressionEmitter._operatorPrecedence[op] - 1);
};


_LogicalExpressionEmitter.prototype._getPrecedence$ = function () {
	var this$0;
	var this$1;
	return _LogicalExpressionEmitter._operatorPrecedence[(this$1 = (this$0 = this._expr, this$0._token), this$1._value)];
};


function _LogicalExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_LogicalExpressionEmitter._operatorPrecedence[op] = precedence;
};

_LogicalExpressionEmitter._setOperatorPrecedence$SN = _LogicalExpressionEmitter$_setOperatorPrecedence$SN;

function _ShiftExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_ShiftExpressionEmitter], _OperatorExpressionEmitter);
_ShiftExpressionEmitter.prototype._emit$ = function () {
	var op;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var _expr$0;
	this$4 = _expr$0 = this._expr;
	this$0 = this$4._token;
	op = this$0._value;
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, (this$1 = _expr$0, this$1._expr1), _ShiftExpressionEmitter._operatorPrecedence[op]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " " + op + " ", (this$2 = this._expr, this$2._token));
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, (this$3 = this._expr, this$3._expr2), _ShiftExpressionEmitter._operatorPrecedence[op] - 1);
};


_ShiftExpressionEmitter.prototype._getPrecedence$ = function () {
	var this$0;
	var this$1;
	return _ShiftExpressionEmitter._operatorPrecedence[(this$1 = (this$0 = this._expr, this$0._token), this$1._value)];
};


function _ShiftExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_ShiftExpressionEmitter._operatorPrecedence[op] = precedence;
};

_ShiftExpressionEmitter._setOperatorPrecedence$SN = _ShiftExpressionEmitter$_setOperatorPrecedence$SN;

function _BinaryNumberExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_BinaryNumberExpressionEmitter], _OperatorExpressionEmitter);
_BinaryNumberExpressionEmitter.prototype._emit$ = function () {
	var op;
	var isInt;
	var needsBitOr;
	var this$0;
	var this$1;
	var this$0$0;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	var this$9;
	var this$10;
	var this$11;
	var this$12;
	var _expr$0;
	this$12 = _expr$0 = this._expr;
	this$0 = this$12._token;
	op = this$0._value;
	isInt = (this$1 = _expr$0.getType$(), this$1 instanceof NullableType ? (this$0$0 = this$1, this$0$0._baseType) : this$1).equals$LType$(Type.integerType);
	if (isInt && op === "*") {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "$__jsx_imul(", (this$2 = this._expr, this$2._token));
		JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, (this$3 = this._expr, this$3._expr1), 0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", (this$4 = this._expr, this$4._token));
		JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, (this$5 = this._expr, this$5._expr2), 0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", (this$6 = this._expr, this$6._token));
		return;
	}
	needsBitOr = isInt && ! _BinaryNumberExpressionEmitter._OPS_RETURNING_INT[op];
	if (needsBitOr) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "((", (this$7 = this._expr, this$7._token));
	}
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, (this$8 = this._expr, this$8._expr1), _BinaryNumberExpressionEmitter._operatorPrecedence[op]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " " + op + " ", (this$9 = this._expr, this$9._token));
	JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this._emitter, (this$10 = this._expr, this$10._expr2), _BinaryNumberExpressionEmitter._operatorPrecedence[op] - 1);
	if (needsBitOr) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ") | 0)", (this$11 = this._expr, this$11._token));
	}
};


_BinaryNumberExpressionEmitter.prototype._emitIfEitherIs$NF$LExpression$LExpression$LExpression$$ = function (outerOpPrecedence, cb) {
	var outcomeExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	if ((outcomeExpr = cb((this$0 = this._expr, this$0._expr1), (this$1 = this._expr, this$1._expr2))) != null || (outcomeExpr = cb((this$2 = this._expr, this$2._expr2), (this$3 = this._expr, this$3._expr1))) != null) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, outcomeExpr).emit$N(outerOpPrecedence);
		return true;
	} else {
		return false;
	}
};


function _BinaryNumberExpressionEmitter$_emitIfEitherIs$L_BinaryNumberExpressionEmitter$NF$LExpression$LExpression$LExpression$$($this, outerOpPrecedence, cb) {
	var outcomeExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	if ((outcomeExpr = cb((this$0 = $this._expr, this$0._expr1), (this$1 = $this._expr, this$1._expr2))) != null || (outcomeExpr = cb((this$2 = $this._expr, this$2._expr2), (this$3 = $this._expr, this$3._expr1))) != null) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, outcomeExpr).emit$N(outerOpPrecedence);
		return true;
	} else {
		return false;
	}
};

_BinaryNumberExpressionEmitter._emitIfEitherIs$L_BinaryNumberExpressionEmitter$NF$LExpression$LExpression$LExpression$$ = _BinaryNumberExpressionEmitter$_emitIfEitherIs$L_BinaryNumberExpressionEmitter$NF$LExpression$LExpression$LExpression$$;

_BinaryNumberExpressionEmitter.prototype._getPrecedence$ = function () {
	var this$0;
	var this$1;
	return _BinaryNumberExpressionEmitter._operatorPrecedence[(this$1 = (this$0 = this._expr, this$0._token), this$1._value)];
};


function _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_BinaryNumberExpressionEmitter._operatorPrecedence[op] = precedence;
};

_BinaryNumberExpressionEmitter._setOperatorPrecedence$SN = _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN;

function _ArrayExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_ArrayExpressionEmitter], _OperatorExpressionEmitter);
_ArrayExpressionEmitter.prototype._emit$ = function () {
	var secondExpr;
	var emitted;
	var propertyName;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$0 = this._expr, this$0._expr1)).emit$N(_ArrayExpressionEmitter._operatorPrecedence);
	this$1 = this._expr;
	secondExpr = this$1._expr2;
	emitted = false;
	if (secondExpr instanceof StringLiteralExpression) {
		propertyName = secondExpr.getDecoded$();
		if (/^[\$_A-Za-z][\$_0-9A-Za-z]*$/.test(propertyName) && ! $__jsx_ObjectHasOwnProperty.call(_Util._ecma262reserved, propertyName)) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ".", (this$2 = this._expr, this$2._token));
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, propertyName, secondExpr._token);
			emitted = true;
		}
	}
	if (! emitted) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "[", (this$3 = this._expr, this$3._token));
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, secondExpr).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "]", null);
	}
};


_ArrayExpressionEmitter.prototype._getPrecedence$ = function () {
	return _ArrayExpressionEmitter._operatorPrecedence;
};


function _ArrayExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_ArrayExpressionEmitter._operatorPrecedence = precedence;
};

_ArrayExpressionEmitter._setOperatorPrecedence$SN = _ArrayExpressionEmitter$_setOperatorPrecedence$SN;

function _ConditionalExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_ConditionalExpressionEmitter], _OperatorExpressionEmitter);
_ConditionalExpressionEmitter.prototype._emit$ = function () {
	var precedence;
	var ifTrueExpr;
	var this$0$0;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	precedence = ((this$0$0 = this._expr, this$0$0._ifTrueExpr) != null ? _ConditionalExpressionEmitter._operatorPrecedence : _LogicalExpressionEmitter._operatorPrecedence["||"]);
	this$0 = this._expr;
	ifTrueExpr = this$0._ifTrueExpr;
	if (ifTrueExpr != null) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$1 = this._expr, this$1._condExpr)).emit$N(precedence - 1);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " ? ", null);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, ifTrueExpr).emit$N(precedence);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " : ", null);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$2 = this._expr, this$2._ifFalseExpr)).emit$N(precedence);
	} else {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$3 = this._expr, this$3._condExpr)).emit$N(precedence - 1);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, " || ", null);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$4 = this._expr, this$4._ifFalseExpr)).emit$N(precedence - 1);
	}
};


_ConditionalExpressionEmitter.prototype._getPrecedence$ = function () {
	var this$0;
	return ((this$0 = this._expr, this$0._ifTrueExpr) != null ? _ConditionalExpressionEmitter._operatorPrecedence : _LogicalExpressionEmitter._operatorPrecedence["||"]);
};


function _ConditionalExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_ConditionalExpressionEmitter._operatorPrecedence = precedence;
};

_ConditionalExpressionEmitter._setOperatorPrecedence$SN = _ConditionalExpressionEmitter$_setOperatorPrecedence$SN;

function _CallExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_CallExpressionEmitter], _OperatorExpressionEmitter);
_CallExpressionEmitter.prototype._emit$ = function () {
	var calleeExpr;
	var this$0;
	var this$1;
	var this$4;
	var this$0$0;
	var this$5;
	var _expr$0;
	if (_CallExpressionEmitter$_emitSpecial$L_CallExpressionEmitter$(this)) {
		return;
	}
	this$0 = this._expr;
	calleeExpr = this$0._expr;
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, calleeExpr).emit$N(_CallExpressionEmitter._operatorPrecedence);
	JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(this._emitter, (this$1 = _expr$0 = this._expr, this$1._token), "(", (_expr$0, _expr$0._args), (this$5 = (this$4 = (_expr$0, _expr$0._expr).getType$(), this$4 instanceof NullableType ? (this$0$0 = this$4, this$0$0._baseType) : this$4), this$5._argTypes));
};


_CallExpressionEmitter.prototype._getPrecedence$ = function () {
	return _CallExpressionEmitter._operatorPrecedence;
};


function _CallExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_CallExpressionEmitter._operatorPrecedence = precedence;
};

_CallExpressionEmitter._setOperatorPrecedence$SN = _CallExpressionEmitter$_setOperatorPrecedence$SN;

_CallExpressionEmitter.prototype._emitSpecial$ = function () {
	var calleeExpr;
	var this$0;
	this$0 = this._expr;
	calleeExpr = this$0._expr;
	return (! (calleeExpr instanceof PropertyExpression) ? false : _CallExpressionEmitter$_emitIfJsInvoke$L_CallExpressionEmitter$LPropertyExpression$(this, calleeExpr) ? true : _CallExpressionEmitter$_emitIfJsEval$L_CallExpressionEmitter$LPropertyExpression$(this, calleeExpr) ? true : _CallExpressionEmitter$_emitCallsToMap$L_CallExpressionEmitter$LPropertyExpression$(this, calleeExpr) ? true : _CallExpressionEmitter$_emitCallsToArray$L_CallExpressionEmitter$LPropertyExpression$(this, calleeExpr) ? true : false);
};


function _CallExpressionEmitter$_emitSpecial$L_CallExpressionEmitter$($this) {
	var calleeExpr;
	var this$0;
	this$0 = $this._expr;
	calleeExpr = this$0._expr;
	return (! (calleeExpr instanceof PropertyExpression) ? false : _CallExpressionEmitter$_emitIfJsInvoke$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) ? true : _CallExpressionEmitter$_emitIfJsEval$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) ? true : _CallExpressionEmitter$_emitCallsToMap$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) ? true : _CallExpressionEmitter$_emitCallsToArray$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) ? true : false);
};

_CallExpressionEmitter._emitSpecial$L_CallExpressionEmitter$ = _CallExpressionEmitter$_emitSpecial$L_CallExpressionEmitter$;

_CallExpressionEmitter.prototype._emitIfJsEval$LPropertyExpression$ = function (calleeExpr) {
	var classDef;
	var args;
	var this$0;
	var this$1;
	if (! (calleeExpr._type instanceof StaticFunctionType)) {
		return false;
	}
	if ((this$0 = calleeExpr._identifierToken, this$0._value) !== "eval") {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$(this._emitter, classDef)) {
		return false;
	}
	this$1 = this._expr;
	args = this$1._args;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "eval(", calleeExpr._token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, args[0]).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", calleeExpr._token);
	return true;
};


function _CallExpressionEmitter$_emitIfJsEval$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) {
	var classDef;
	var args;
	var this$0;
	var this$1;
	if (! (calleeExpr._type instanceof StaticFunctionType)) {
		return false;
	}
	if ((this$0 = calleeExpr._identifierToken, this$0._value) !== "eval") {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$($this._emitter, classDef)) {
		return false;
	}
	this$1 = $this._expr;
	args = this$1._args;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "eval(", calleeExpr._token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, args[0]).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ")", calleeExpr._token);
	return true;
};

_CallExpressionEmitter._emitIfJsEval$L_CallExpressionEmitter$LPropertyExpression$ = _CallExpressionEmitter$_emitIfJsEval$L_CallExpressionEmitter$LPropertyExpression$;

_CallExpressionEmitter.prototype._emitIfJsInvoke$LPropertyExpression$ = function (calleeExpr) {
	var classDef;
	var args;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var name$0;
	if (! (calleeExpr._type instanceof StaticFunctionType)) {
		return false;
	}
	if ((this$0 = calleeExpr._identifierToken, this$0._value) !== "invoke") {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$(this._emitter, classDef)) {
		return false;
	}
	this$1 = this._expr;
	args = this$1._args;
	if (args[2] instanceof ArrayLiteralExpression) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, args[0]).emit$N(_PropertyExpressionEmitter._operatorPrecedence);
		if (args[1] instanceof StringLiteralExpression && (name$0 = args[1].getDecoded$(), /^[\$_A-Za-z][\$_0-9A-Za-z]*$/.test(name$0) && ! $__jsx_ObjectHasOwnProperty.call(_Util._ecma262reserved, name$0))) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ".", calleeExpr._token);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, args[1].getDecoded$(), (this$2 = args[1], this$2._token));
		} else {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "[", calleeExpr._token);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, args[1]).emit$N(0);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "]", calleeExpr._token);
		}
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(this._emitter, (this$3 = this._expr, this$3._token), "(", (this$4 = args[2], this$4._exprs), null);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "(function (o, p, a) { return o[p].apply(o, a); }(", calleeExpr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, args[0]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", (this$5 = this._expr, this$5._token));
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, args[1]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", (this$6 = this._expr, this$6._token));
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, args[2]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "))", (this$7 = this._expr, this$7._token));
	}
	return true;
};


function _CallExpressionEmitter$_emitIfJsInvoke$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) {
	var classDef;
	var args;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var name$0;
	if (! (calleeExpr._type instanceof StaticFunctionType)) {
		return false;
	}
	if ((this$0 = calleeExpr._identifierToken, this$0._value) !== "invoke") {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$($this._emitter, classDef)) {
		return false;
	}
	this$1 = $this._expr;
	args = this$1._args;
	if (args[2] instanceof ArrayLiteralExpression) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, args[0]).emit$N(_PropertyExpressionEmitter._operatorPrecedence);
		if (args[1] instanceof StringLiteralExpression && (name$0 = args[1].getDecoded$(), /^[\$_A-Za-z][\$_0-9A-Za-z]*$/.test(name$0) && ! $__jsx_ObjectHasOwnProperty.call(_Util._ecma262reserved, name$0))) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ".", calleeExpr._token);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, args[1].getDecoded$(), (this$2 = args[1], this$2._token));
		} else {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "[", calleeExpr._token);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, args[1]).emit$N(0);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "]", calleeExpr._token);
		}
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$($this._emitter, (this$3 = $this._expr, this$3._token), "(", (this$4 = args[2], this$4._exprs), null);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "(function (o, p, a) { return o[p].apply(o, a); }(", calleeExpr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, args[0]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", (this$5 = $this._expr, this$5._token));
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, args[1]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", (this$6 = $this._expr, this$6._token));
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, args[2]).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "))", (this$7 = $this._expr, this$7._token));
	}
	return true;
};

_CallExpressionEmitter._emitIfJsInvoke$L_CallExpressionEmitter$LPropertyExpression$ = _CallExpressionEmitter$_emitIfJsInvoke$L_CallExpressionEmitter$LPropertyExpression$;

_CallExpressionEmitter.prototype._emitCallsToMap$LPropertyExpression$ = function (calleeExpr) {
	var classDef;
	var this$0;
	var this$0$0;
	var this$1;
	var this$2;
	if (calleeExpr._type instanceof StaticFunctionType) {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! (classDef instanceof InstantiatedClassDefinition)) {
		return false;
	}
	if ((this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) !== "Map") {
		return false;
	}
	switch ((this$2 = calleeExpr._identifierToken, this$2._value)) {
	case "toString":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(this._emitter, calleeExpr._token, "$__jsx_ObjectToString.call(", [ calleeExpr._expr ], [ new ObjectType(classDef) ]);
		return true;
	case "hasOwnProperty":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(this._emitter, calleeExpr._token, "$__jsx_ObjectHasOwnProperty.call(", [ calleeExpr._expr, (this$1 = this._expr, this$1._args)[0] ], [ new ObjectType(classDef), Type.stringType ]);
		return true;
	case "keys":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(this._emitter, calleeExpr._token, "Object.keys(", [ calleeExpr._expr ], [ new ObjectType(classDef) ]);
		return true;
	default:
		return false;
	}
};


function _CallExpressionEmitter$_emitCallsToMap$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) {
	var classDef;
	var this$0;
	var this$0$0;
	var this$1;
	var this$2;
	if (calleeExpr._type instanceof StaticFunctionType) {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! (classDef instanceof InstantiatedClassDefinition)) {
		return false;
	}
	if ((this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) !== "Map") {
		return false;
	}
	switch ((this$2 = calleeExpr._identifierToken, this$2._value)) {
	case "toString":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$($this._emitter, calleeExpr._token, "$__jsx_ObjectToString.call(", [ calleeExpr._expr ], [ new ObjectType(classDef) ]);
		return true;
	case "hasOwnProperty":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$($this._emitter, calleeExpr._token, "$__jsx_ObjectHasOwnProperty.call(", [ calleeExpr._expr, (this$1 = $this._expr, this$1._args)[0] ], [ new ObjectType(classDef), Type.stringType ]);
		return true;
	case "keys":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$($this._emitter, calleeExpr._token, "Object.keys(", [ calleeExpr._expr ], [ new ObjectType(classDef) ]);
		return true;
	default:
		return false;
	}
};

_CallExpressionEmitter._emitCallsToMap$L_CallExpressionEmitter$LPropertyExpression$ = _CallExpressionEmitter$_emitCallsToMap$L_CallExpressionEmitter$LPropertyExpression$;

_CallExpressionEmitter.prototype._emitCallsToArray$LPropertyExpression$ = function (calleeExpr) {
	var classDef;
	var this$0;
	var this$0$0;
	var this$1;
	var this$2;
	if (calleeExpr._type instanceof StaticFunctionType) {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! (classDef instanceof InstantiatedClassDefinition)) {
		return false;
	}
	if ((this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) !== "Array") {
		return false;
	}
	switch ((this$2 = calleeExpr._identifierToken, this$2._value)) {
	case "_forEach":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(this._emitter, calleeExpr._token, "$__jsx_forEach(", [ calleeExpr._expr, (this$1 = this._expr, this$1._args)[0] ], null);
		return true;
	default:
		return false;
	}
};


function _CallExpressionEmitter$_emitCallsToArray$L_CallExpressionEmitter$LPropertyExpression$($this, calleeExpr) {
	var classDef;
	var this$0;
	var this$0$0;
	var this$1;
	var this$2;
	if (calleeExpr._type instanceof StaticFunctionType) {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! (classDef instanceof InstantiatedClassDefinition)) {
		return false;
	}
	if ((this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) !== "Array") {
		return false;
	}
	switch ((this$2 = calleeExpr._identifierToken, this$2._value)) {
	case "_forEach":
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$($this._emitter, calleeExpr._token, "$__jsx_forEach(", [ calleeExpr._expr, (this$1 = $this._expr, this$1._args)[0] ], null);
		return true;
	default:
		return false;
	}
};

_CallExpressionEmitter._emitCallsToArray$L_CallExpressionEmitter$LPropertyExpression$ = _CallExpressionEmitter$_emitCallsToArray$L_CallExpressionEmitter$LPropertyExpression$;

function _SuperExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_SuperExpressionEmitter], _OperatorExpressionEmitter);
_SuperExpressionEmitter.prototype._emit$ = function () {
	var funcType;
	var classDef;
	var methodName;
	var argTypes;
	var mangledFuncName;
	var thisVar;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$6;
	var this$7;
	var _emitter$0;
	this$0 = this._expr;
	funcType = this$0._funcType;
	classDef = funcType._objectType.getClassDef$();
	this$7 = this._expr;
	this$1 = this$7._name;
	methodName = this$1._value;
	argTypes = funcType._argTypes;
	mangledFuncName = (this$2 = this._emitter, this$2._namer).getNameOfMethod$LClassDefinition$SALType$(classDef, methodName, argTypes);
	thisVar = ((this$3 = this._emitter._emittingFunction, this$3._parent) != null ? "$this" : "this");
	JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(_emitter$0 = this._emitter, (this$4 = this._expr, this$4._token), (_emitter$0, _emitter$0._namer).getNameOfClass$LClassDefinition$(classDef) + ".prototype." + mangledFuncName + ".call(" + thisVar, (this$6 = this._expr, this$6._args), argTypes);
};


_SuperExpressionEmitter.prototype._getPrecedence$ = function () {
	return _CallExpressionEmitter._operatorPrecedence;
};


function _SuperExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_SuperExpressionEmitter._operatorPrecedence = precedence;
};

_SuperExpressionEmitter._setOperatorPrecedence$SN = _SuperExpressionEmitter$_setOperatorPrecedence$SN;

function _NewExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_NewExpressionEmitter], _OperatorExpressionEmitter);
_NewExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var inliner;
	var classDef;
	var argTypes;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$6;
	var this$7;
	var this$8;
	var this$0$0;
	var this$9;
	var type$0;
	var this$0$1;
	var this$0$0$0;
	var this$10;
	var _expr$0;
	var _emitter$0;
	inliner = _Util$getNewExpressionInliner$LNewExpression$(this._expr);
	classDef = (this$0 = this._expr, this$0._type).getClassDef$();
	if (inliner) {
		_NewExpressionEmitter$_emitAsObjectLiteral$L_NewExpressionEmitter$LClassDefinition$ALExpression$(this, classDef, inliner(this._expr));
	} else if ((type$0 = (this$9 = this._expr, this$9._type), type$0.getClassDef$() instanceof InstantiatedClassDefinition && (this$0$1 = type$0.getClassDef$(), this$0$0$0 = this$0$1._templateClassDef, this$0$0$0._className) === "Array") && (this$10 = this._expr, this$10._args).length === 0) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "[]", (this$1 = this._expr, this$1._token));
	} else if (classDef instanceof InstantiatedClassDefinition && (this$8 = classDef, this$0$0 = this$8._templateClassDef, this$0$0._className) === "Map") {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "{}", (this$2 = this._expr, this$2._token));
	} else {
		this$7 = _expr$0 = this._expr;
		this$3 = this$7._constructor;
		argTypes = this$3._argTypes;
		JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$(_emitter$0 = this._emitter, (this$4 = _expr$0, this$4._token), "new " + (_emitter$0, _emitter$0._namer).getNameOfConstructor$LClassDefinition$ALType$(classDef, argTypes) + "(", (this$6 = this._expr, this$6._args), argTypes);
	}
};


_NewExpressionEmitter.prototype._emitAsObjectLiteral$LClassDefinition$ALExpression$ = function (classDef, propertyExprs) {
	var $this = this;
	var propertyIndex;
	var this$0;
	var this$1;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "({", (this$0 = this._expr, this$0._token));
	propertyIndex = 0;
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (member) {
		var this$0;
		var this$0$0;
		var this$2;
		var _emitter$0;
		if ((member._flags & 8) === 0) {
			if (propertyIndex !== 0) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", (this$0 = $this._expr, this$0._token));
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = $this._emitter, (_emitter$0, _emitter$0._namer).getNameOfProperty$LClassDefinition$S(classDef, (this$0$0 = member._nameToken, this$0$0._value)) + ": ", (this$2 = $this._expr, this$2._token));
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, propertyExprs[propertyIndex++]).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
		}
		return true;
	}));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "})", (this$1 = this._expr, this$1._token));
};


function _NewExpressionEmitter$_emitAsObjectLiteral$L_NewExpressionEmitter$LClassDefinition$ALExpression$($this, classDef, propertyExprs) {
	var propertyIndex;
	var this$0;
	var this$1;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "({", (this$0 = $this._expr, this$0._token));
	propertyIndex = 0;
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (member) {
		var this$0;
		var this$0$0;
		var this$2;
		var _emitter$0;
		if ((member._flags & 8) === 0) {
			if (propertyIndex !== 0) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, ", ", (this$0 = $this._expr, this$0._token));
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(_emitter$0 = $this._emitter, (_emitter$0, _emitter$0._namer).getNameOfProperty$LClassDefinition$S(classDef, (this$0$0 = member._nameToken, this$0$0._value)) + ": ", (this$2 = $this._expr, this$2._token));
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this._emitter, propertyExprs[propertyIndex++]).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
		}
		return true;
	}));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this._emitter, "})", (this$1 = $this._expr, this$1._token));
};

_NewExpressionEmitter._emitAsObjectLiteral$L_NewExpressionEmitter$LClassDefinition$ALExpression$ = _NewExpressionEmitter$_emitAsObjectLiteral$L_NewExpressionEmitter$LClassDefinition$ALExpression$;

_NewExpressionEmitter.prototype._getPrecedence$ = function () {
	return _NewExpressionEmitter._operatorPrecedence;
};


function _NewExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_NewExpressionEmitter._operatorPrecedence = precedence;
};

_NewExpressionEmitter._setOperatorPrecedence$SN = _NewExpressionEmitter$_setOperatorPrecedence$SN;

function _CommaExpressionEmitter(emitter, expr) {
	this._emitter = emitter;
	this._expr = expr;
};

$__jsx_extend([_CommaExpressionEmitter], _ExpressionEmitter);
_CommaExpressionEmitter.prototype.emit$N = function (outerOpPrecedence) {
	var useBrackets;
	var this$0;
	var this$1;
	useBrackets = outerOpPrecedence !== _CommaExpressionEmitter._operatorPrecedence;
	if (useBrackets) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, "(", null);
	}
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$0 = this._expr, this$0._expr1)).emit$N(_CommaExpressionEmitter._operatorPrecedence);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ", ", null);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this._emitter, (this$1 = this._expr, this$1._expr2)).emit$N(_CommaExpressionEmitter._operatorPrecedence);
	if (useBrackets) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this._emitter, ")", null);
	}
};


function _CommaExpressionEmitter$_setOperatorPrecedence$SN(op, precedence) {
	_CommaExpressionEmitter._operatorPrecedence = precedence;
};

_CommaExpressionEmitter._setOperatorPrecedence$SN = _CommaExpressionEmitter$_setOperatorPrecedence$SN;

function _BootstrapBuilder() {
	this._emitter = null;
	this._entrySourceFile = "";
	this._executableFor = "";
};

$__jsx_extend([_BootstrapBuilder], Object);
_BootstrapBuilder.prototype.init$LJavaScriptEmitter$SS = function (emitter, entrySourceFile, executableFor) {
	this._emitter = emitter;
	this._entrySourceFile = entrySourceFile;
	this._executableFor = executableFor;
};


function _BootstrapBuilder$init$L_BootstrapBuilder$LJavaScriptEmitter$SS($this, emitter, entrySourceFile, executableFor) {
	$this._emitter = emitter;
	$this._entrySourceFile = entrySourceFile;
	$this._executableFor = executableFor;
};

_BootstrapBuilder.init$L_BootstrapBuilder$LJavaScriptEmitter$SS = _BootstrapBuilder$init$L_BootstrapBuilder$LJavaScriptEmitter$SS;

_BootstrapBuilder.prototype.addBootstrap$S = function (code) {
	var args;
	var callEntryPoint;
	var wrapper$0;
	var _platform$0;
	var _platform$1;
	code += (_platform$0 = this._emitter._platform).load$S(_platform$0.getRoot$() + "/lib/js/rt/launcher.js");
	switch (this._executableFor) {
	case "node":
		args = "process.argv.slice(2)";
		break;
	case "commonjs":
		args = "require('system').args.slice(1)";
		break;
	default:
		args = "[]";
		break;
	}
	callEntryPoint = Util$format$SAS("JSX.%1(%2, %3);", [ this._getLauncher$(), JSON.stringify(Platform$encodeFilename$LPlatform$S(this._emitter._platform, this._entrySourceFile)), args ]);
	if (this._executableFor === "web") {
		wrapper$0 = (_platform$1 = this._emitter._platform).load$S(_platform$1.getRoot$() + "/lib/js/rt/web-launcher.js");
		callEntryPoint = wrapper$0.replace(/\/\/--CODE--\/\//, callEntryPoint);
	}
	return code + callEntryPoint + "\n";
};


function _BootstrapBuilder$addBootstrap$L_BootstrapBuilder$S($this, code) {
	var args;
	var callEntryPoint;
	var wrapper$0;
	var _platform$0;
	var _platform$1;
	code += (_platform$0 = $this._emitter._platform).load$S(_platform$0.getRoot$() + "/lib/js/rt/launcher.js");
	switch ($this._executableFor) {
	case "node":
		args = "process.argv.slice(2)";
		break;
	case "commonjs":
		args = "require('system').args.slice(1)";
		break;
	default:
		args = "[]";
		break;
	}
	callEntryPoint = Util$format$SAS("JSX.%1(%2, %3);", [ $this._getLauncher$(), JSON.stringify(Platform$encodeFilename$LPlatform$S($this._emitter._platform, $this._entrySourceFile)), args ]);
	if ($this._executableFor === "web") {
		wrapper$0 = (_platform$1 = $this._emitter._platform).load$S(_platform$1.getRoot$() + "/lib/js/rt/web-launcher.js");
		callEntryPoint = wrapper$0.replace(/\/\/--CODE--\/\//, callEntryPoint);
	}
	return code + callEntryPoint + "\n";
};

_BootstrapBuilder.addBootstrap$L_BootstrapBuilder$S = _BootstrapBuilder$addBootstrap$L_BootstrapBuilder$S;

_BootstrapBuilder.prototype._wrapOnLoad$S = function (code) {
	var wrapper;
	var _platform$0;
	wrapper = (_platform$0 = this._emitter._platform).load$S(_platform$0.getRoot$() + "/lib/js/rt/web-launcher.js");
	return wrapper.replace(/\/\/--CODE--\/\//, code);
};


function _BootstrapBuilder$_wrapOnLoad$L_BootstrapBuilder$S($this, code) {
	var wrapper;
	var _platform$0;
	wrapper = (_platform$0 = $this._emitter._platform).load$S(_platform$0.getRoot$() + "/lib/js/rt/web-launcher.js");
	return wrapper.replace(/\/\/--CODE--\/\//, code);
};

_BootstrapBuilder._wrapOnLoad$L_BootstrapBuilder$S = _BootstrapBuilder$_wrapOnLoad$L_BootstrapBuilder$S;

function _ExecutableBootstrapBuilder() {
	this._emitter = null;
	this._entrySourceFile = "";
	this._executableFor = "";
};

$__jsx_extend([_ExecutableBootstrapBuilder], _BootstrapBuilder);
_ExecutableBootstrapBuilder.prototype._getLauncher$ = function () {
	return "runMain";
};


function _TestBootstrapBuilder() {
	this._emitter = null;
	this._entrySourceFile = "";
	this._executableFor = "";
};

$__jsx_extend([_TestBootstrapBuilder], _BootstrapBuilder);
_TestBootstrapBuilder.prototype._getLauncher$ = function () {
	return "runTests";
};


function Platform() {
	this.fileContent = {};
};

$__jsx_extend([Platform], Object);
Platform.prototype.setFileContent$SS = function (name, content) {
	this.fileContent[name] = content;
};


function Platform$setFileContent$LPlatform$SS($this, name, content) {
	$this.fileContent[name] = content;
};

Platform.setFileContent$LPlatform$SS = Platform$setFileContent$LPlatform$SS;

Platform.prototype.log$S = function (s) {
	console.log(s);
};


function Platform$log$LPlatform$S($this, s) {
	console.log(s);
};

Platform.log$LPlatform$S = Platform$log$LPlatform$S;

Platform.prototype.warn$S = function (s) {
	console.warn(s);
};


Platform.prototype.error$S = function (s) {
	console.error(s);
};


Platform.prototype.encodeFilename$S = function (filename) {
	var rootDir;
	rootDir = this.getRoot$() + "/";
	if (filename.indexOf(rootDir) === 0) {
		filename = "system:" + filename.substring(rootDir.length);
	}
	return filename;
};


function Platform$encodeFilename$LPlatform$S($this, filename) {
	var rootDir;
	rootDir = $this.getRoot$() + "/";
	if (filename.indexOf(rootDir) === 0) {
		filename = "system:" + filename.substring(rootDir.length);
	}
	return filename;
};

Platform.encodeFilename$LPlatform$S = Platform$encodeFilename$LPlatform$S;

function NodePlatform() {
	var root$0;
	var path$0$0;
	root$0 = node.path.dirname(node.__dirname);
	this.fileContent = {};
	path$0$0 = process.cwd();
	this._cwd = Util$_resolvedPathParts$S(path$0$0).join("/");
	this._root = Util$_resolvedPathParts$S(root$0).join("/");
};

function NodePlatform$0(root) {
	var path$0;
	this.fileContent = {};
	path$0 = process.cwd();
	this._cwd = Util$_resolvedPathParts$S(path$0).join("/");
	this._root = Util$_resolvedPathParts$S(root).join("/");
};

$__jsx_extend([NodePlatform, NodePlatform$0], Platform);
NodePlatform.prototype.getRoot$ = function () {
	return this._root;
};


NodePlatform.prototype._absPath$S = function (path) {
	return (path.charAt(0) === "/" || path.match(/^[a-zA-Z]:[\/\\]/) ? path : this._cwd + "/" + path);
};


function NodePlatform$_absPath$LNodePlatform$S($this, path) {
	return (path.charAt(0) === "/" || path.match(/^[a-zA-Z]:[\/\\]/) ? path : $this._cwd + "/" + path);
};

NodePlatform._absPath$LNodePlatform$S = NodePlatform$_absPath$LNodePlatform$S;

NodePlatform.prototype.fileExists$S = function (name) {
	name = Util$_resolvedPathParts$S(name).join("/");
	return ($__jsx_ObjectHasOwnProperty.call(this.fileContent, name) ? true : node.fs.existsSync((name.charAt(0) === "/" || name.match(/^[a-zA-Z]:[\/\\]/) ? name : this._cwd + "/" + name)));
};


NodePlatform.prototype.getFilesInDirectory$S = function (path) {
	return node.fs.readdirSync((path.charAt(0) === "/" || path.match(/^[a-zA-Z]:[\/\\]/) ? path : this._cwd + "/" + path));
};


NodePlatform.prototype.load$S = function (name) {
	var fd;
	var content;
	var BUFFER_SIZE;
	var buffer;
	var n;
	name = Util$_resolvedPathParts$S(name).join("/");
	if ($__jsx_ObjectHasOwnProperty.call(this.fileContent, name)) {
		return this.fileContent[name];
	} else if (name === "-") {
		fd = process.stdin.fd;
		content = "";
		BUFFER_SIZE = 4096;
		buffer = new Buffer(4096);
		while ((n = node.fs.readSync((fd | 0), buffer, 0, (BUFFER_SIZE | 0))) > 0) {
			content += buffer.slice(0, n).toString();
		}
		return content;
	} else {
		content = node.fs.readFileSync((name.charAt(0) === "/" || name.match(/^[a-zA-Z]:[\/\\]/) ? name : this._cwd + "/" + name), "utf-8");
		this.fileContent[name] = content;
		return content;
	}
};


NodePlatform.prototype.save$USS = function (outputFile, content) {
	var parts$0;
	if (outputFile == null) {
		process.stdout.write(content);
	} else {
		outputFile = (outputFile.charAt(0) === "/" || outputFile.match(/^[a-zA-Z]:[\/\\]/) ? outputFile : this._cwd + "/" + outputFile);
		this.mkpath$S((parts$0 = Util$_resolvedPathParts$S(outputFile), parts$0.pop(), parts$0.length !== 0 ? parts$0.join("/") : "."));
		node.fs.writeFileSync(outputFile, content);
	}
};


NodePlatform.prototype.setWorkingDir$S = function (dir) {
	this._cwd = (dir.charAt(0) === "/" || dir.match(/^[a-zA-Z]:[\/\\]/) ? dir : this._cwd + "/" + dir);
};


NodePlatform.prototype.mkpath$S = function (path) {
	var dirOfPath;
	var parts$0;
	path = (path.charAt(0) === "/" || path.match(/^[a-zA-Z]:[\/\\]/) ? path : this._cwd + "/" + path);
	if (! node.fs.existsSync(path)) {
		parts$0 = Util$_resolvedPathParts$S(path);
		parts$0.pop();
		dirOfPath = (parts$0.length !== 0 ? parts$0.join("/") : ".");
		if (dirOfPath !== path) {
			this.mkpath$S(dirOfPath);
		}
		node.fs.mkdirSync(path);
	}
};


NodePlatform.prototype.makeFileExecutable$SS = function (file, runEnv) {
	var filePath;
	var contents;
	if (runEnv === "node") {
		filePath = (file.charAt(0) === "/" || file.match(/^[a-zA-Z]:[\/\\]/) ? file : this._cwd + "/" + file);
		contents = node.fs.readFileSync(filePath, "utf-8");
		contents = "#!/usr/bin/env node\n" + contents;
		node.fs.writeFileSync(filePath, contents);
		node.fs.chmodSync((file.charAt(0) === "/" || file.match(/^[a-zA-Z]:[\/\\]/) ? file : this._cwd + "/" + file), "0755");
	}
};


NodePlatform.prototype.execute$USSAS = function (scriptFile, jsSource, args) {
	var $this = this;
	var jsFile;
	var argv;
	var child;
	var path$0;
	var src$0;
	path$0 = Util$format$SAS(".jsx.%1.%2.%3.js", [ node.path.basename(scriptFile || "-"), process.pid.toString(), Date.now().toString(16) ]);
	jsFile = (path$0.charAt(0) === "/" || path$0.match(/^[a-zA-Z]:[\/\\]/) ? path$0 : this._cwd + "/" + path$0);
	node.fs.writeFileSync(jsFile, jsSource);
	process.on("exit", (function (stream) {
		node.fs.unlinkSync(jsFile);
	}));
	if (process.env.JSX_RUNJS) {
		argv = process.env.JSX_RUNJS.split(/\s+/).concat([ jsFile ]).concat(args);
		child = node.child_process.spawn(argv.shift(), argv);
		child.stdin.end();
		child.stdout.on("data", (function (data) {
			process.stdout.write(data + "");
		}));
		child.stderr.on("data", (function (data) {
			process.stderr.write(data + "");
		}));
	} else {
		process.argv = [ process.argv[0], jsFile ].concat(args);
		src$0 = 'require(' + JSON.stringify(jsFile) + ')';
		eval(src$0);
	}
};


function NodePlatform$getEnvOpts$() {
	var opts;
	opts = process.env.JSX_OPTS;
	return (! opts ? [] : opts.split(/\s+/));
};

NodePlatform.getEnvOpts$ = NodePlatform$getEnvOpts$;

NodePlatform.prototype.colorize$NS = function (colorId, message) {
	return (NodePlatform._isColorSupported ? "\x1b[" + (colorId + "") + "m" + message + "\x1b[0m" : message);
};


function NodePlatform$colorize$LNodePlatform$NS($this, colorId, message) {
	return (NodePlatform._isColorSupported ? "\x1b[" + (colorId + "") + "m" + message + "\x1b[0m" : message);
};

NodePlatform.colorize$LNodePlatform$NS = NodePlatform$colorize$LNodePlatform$NS;

NodePlatform.prototype.error$S = function (message) {
	console.error(NodePlatform._isColorSupported ? "[31m" + message + "\x1b[0m" : message);
};


NodePlatform.prototype.warn$S = function (message) {
	console.warn(NodePlatform._isColorSupported ? "[33m" + message + "\x1b[0m" : message);
};


function JSXCommand() {
};

$__jsx_extend([JSXCommand], Object);
function JSXCommand$help$() {
	return "JSX compiler version 0.9.89\n\nUsage: jsx [options] source-file\n\nOptions:\n  --add-search-path path     adds a path to library search paths\n  --executable RUNENV        adds launcher to call _Main.main(:string[]):void\n                             supported RUNENV is node, commonjs and web.\n  --run                      runs _Main.main(:string[]):void after compiling\n  --test                     runs _Test#test*():void after compiling\n  --define name=var          defines compile-time constant as a property of JSX.ENV\n  --output file              output file (default:stdout)\n  --input-filename file      specifies the root path for searching imports (used when the source-file is \"-\" (stdin))\n  --mode (compile|parse|doc) specifies compilation mode (default:compile)\n  --target (javascript|c++)  specifies target language (default:javascript)\n  --release                  disables run-time type checking and enables optimizations (" + [ "lto", "no-assert", "no-log", "no-debug", "fold-const", "tail-rec", "return-if", "inline", "dce", "unbox", "fold-const", "lcse", "dce", "fold-const", "array-length", "unclassify", "staticize" ].join(",") + ")\n" + "  --profile                  enables the profiler (experimental)\n" + "  --optimize cmd1,cmd2,...   enables optimization commands\n" + "  --warn type1,type2,...     enables warnings (all, unused, experimental, deprecated, none)\n" + "  --disable-type-check       disables run-time type checking\n" + "  --minify                   compresses the target JavaScript code\n" + "  --enable-source-map        enables source map debugging info\n" + "  --complete line:column     shows code completion at line:column\n" + "  --version                  displays the version and compiler identifier and exits\n" + "  --version-number           displays the version as number and exits\n" + "  --help                     displays this help and exits\n" + "\n" + "Env:\n" + "  JSX_OPTS   options of jsx(1)\n" + "  JSX_RUNJS  JavaScript engine used by --run and --test\n" + "";
};

JSXCommand.help$ = JSXCommand$help$;

function JSXCommand$main$LPlatform$AS(platform, args) {
	var argIndex;
	var getopt;
	var getoptarg;
	var compiler;
	var tasks;
	var optimizer;
	var completionRequest;
	var emitter;
	var outputFile;
	var inputFilename;
	var executable;
	var setBootstrapMode;
	var runImmediately;
	var optimizeCommands;
	var transformCommands;
	var opt;
	var optarg;
	var a;
	var switchOpt;
	var mode;
	var sourceFile;
	var err;
	var result;
	var output;
	var map;
	var filename;
	var a$0;
	var s$0;
	var s$1;
	var content$0;
	var this$0;
	var this$1;
	argIndex = 0;
	getopt = (function () {
		var arg;
		if (args.length <= argIndex) {
			return null;
		}
		arg = args[argIndex++];
		if (arg === "--") {
			return null;
		}
		if (arg.match(/^-/)) {
			return arg;
		} else {
			--argIndex;
			return null;
		}
	});
	getoptarg = (function () {
		if (args.length <= argIndex) {
			platform.error$S("option " + args[argIndex - 1] + " requires a value");
			return null;
		}
		return args[argIndex++];
	});
	compiler = new Compiler(platform);
	tasks = [];
	optimizer = null;
	completionRequest = null;
	emitter = null;
	outputFile = null;
	inputFilename = null;
	executable = null;
	setBootstrapMode = (function (sourceFile) {
	});
	runImmediately = false;
	optimizeCommands = [];
	transformCommands = [];
	while ((opt = getopt()) != null) {
	NEXTOPT:
		switch (opt) {
		case "--add-search-path":
			if ((optarg = getoptarg()) == null) {
				return 1;
			}
			compiler._searchPaths.unshift(optarg);
			break;
		case "--output":
			if ((outputFile = getoptarg()) == null) {
				return 1;
			}
			break;
		case "--input-filename":
			if ((inputFilename = getoptarg()) == null) {
				return 1;
			}
			break;
		case "--working-dir":
			if ((optarg = getoptarg()) == null) {
				return 1;
			}
			platform.setWorkingDir$S(optarg);
			break;
		case "--mode":
			if ((optarg = getoptarg()) == null) {
				return 1;
			}
			switch (optarg) {
			case "compile":
				compiler._mode = 0;
				break;
			case "parse":
				compiler._mode = 1;
				break;
			case "doc":
				compiler._mode = 3;
				break;
			default:
				platform.error$S("unknown mode: " + optarg);
				return 1;
			}
			break;
		case "--complete":
			if ((optarg = getoptarg()) == null) {
				return 1;
			}
			a$0 = optarg.split(/:/);
			completionRequest = ({_lineNumber: +a$0[0], _columnOffest: +a$0[1] - 1, _candidates: []});
			compiler._mode = 2;
			break;
		case "--define":
			if ((optarg = getoptarg()) == null) {
				return 1;
			}
			a = optarg.split(/=/, 2);
			if (a.length !== 2) {
				platform.error$S("invalid environment variable (not defined as name=var): " + optarg);
				return 1;
			}
			compiler._userEnvironment[a[0]] = a[1];
			break;
		case "--target":
			if ((optarg = getoptarg()) == null) {
				return 1;
			}
			switch (optarg) {
			case "javascript":
				emitter = new JavaScriptEmitter(platform);
				break;
			case "c++":
				throw new Error("FIXME");
			default:
				platform.error$S("unknown target: " + optarg);
				return 1;
			}
			break;
		case "--release":
			tasks.push((function () {
				emitter.setEnableRunTimeTypeCheck$B(false);
				optimizer._enableRunTimeTypeCheck = false;
			}));
			optimizeCommands = [ "lto", "no-assert", "no-log", "no-debug", "fold-const", "tail-rec", "return-if", "inline", "dce", "unbox", "fold-const", "lcse", "dce", "fold-const", "array-length", "unclassify", "staticize" ];
			break;
		case "--optimize":
			if ((optarg = getoptarg()) == null) {
				return 1;
			}
			optarg.split(",").forEach((function (command) {
				if (command === "release") {
					optimizeCommands = [ "lto", "no-assert", "no-log", "no-debug", "fold-const", "tail-rec", "return-if", "inline", "dce", "unbox", "fold-const", "lcse", "dce", "fold-const", "array-length", "unclassify", "staticize" ];
				} else if (command.charAt(0) === "-") {
					command = command.slice(1);
					optimizeCommands = optimizeCommands.filter((function (item) {
						return command !== item;
					}));
				} else {
					optimizeCommands.push(command);
				}
			}));
			break;
		case "--transform":
			if ((optarg = getoptarg()) == null) {
				return 1;
			}
			optarg.split(",").forEach((function (command) {
				transformCommands.push(command);
			}));
			break;
		case "--disable-optimize":
			if ((optarg = getoptarg()) == null) {
				return 1;
			}
			optimizeCommands = optimizeCommands.filter((function (item) {
				return optarg.split(",").indexOf(item) === -1;
			}));
			break;
		case "--warn":
			if ((optarg = getoptarg()) == null) {
				return 1;
			}
			optarg.split(",").forEach((function (type) {
				switch (type) {
				case "none":
					compiler._warningFilters.unshift((function (warning) {
						return false;
					}));
					break;
				case "all":
					compiler._warningFilters.unshift((function (warning) {
						return true;
					}));
					break;
				case "unused":
					compiler._warningFilters.unshift((function (warning) {
						if (warning instanceof UnusedWarning) {
							return true;
						}
						return null;
					}));
					break;
				case "deprecated":
					compiler._warningFilters.unshift((function (warning) {
						if (warning instanceof DeprecatedWarning) {
							return true;
						}
						return null;
					}));
					break;
				case "experimental":
					compiler._warningFilters.unshift((function (warning) {
						if (warning instanceof ExperimentalWarning) {
							return true;
						}
						return null;
					}));
					break;
				default:
					platform.error$S("unknown warning type: " + type);
				}
			}));
			break;
		case "--warn-error":
			compiler._warningAsError = true;
			break;
		case "--executable":
			if ((optarg = getoptarg()) == null) {
				return 1;
			}
			switch (optarg) {
			case "web":
				break;
			case "commonjs":
				break;
			case "node":
				break;
			default:
				platform.error$S("unknown executable type (node|web)");
				return 1;
			}
			setBootstrapMode = (function (sourceFile) {
				JavaScriptEmitter$setBootstrapMode$LJavaScriptEmitter$NSS(emitter, 1, sourceFile, executable);
			});
			executable = optarg;
			break;
		case "--run":
			setBootstrapMode = (function (sourceFile) {
				JavaScriptEmitter$setBootstrapMode$LJavaScriptEmitter$NSS(emitter, 1, sourceFile, executable);
			});
			executable = executable || "node";
			runImmediately = true;
			break;
		case "--test":
			setBootstrapMode = (function (sourceFile) {
				JavaScriptEmitter$setBootstrapMode$LJavaScriptEmitter$NSS(emitter, 2, sourceFile, executable);
			});
			executable = executable || "node";
			runImmediately = true;
			break;
		case "--profile":
			tasks.push((function () {
				emitter.setEnableProfiler$B(true);
			}));
			break;
		case "--minify":
			tasks.push((function () {
				emitter.setEnableMinifier$B(true);
				if (optimizeCommands.length !== 0 && optimizeCommands[0] !== "strip") {
					optimizeCommands.unshift("strip");
				}
				if (optimizeCommands[optimizeCommands.length - 1] !== "strip") {
					optimizeCommands.push("strip");
				}
			}));
			break;
		case "--version":
			s$0 = Meta.IDENTIFIER;
			console.log(s$0);
			return 0;
		case "--version-number":
			console.log("0.009089");
			return 0;
		case "--help":
			s$1 = JSXCommand$help$();
			console.log(s$1);
			return 0;
		default:
			switchOpt = opt.match(new RegExp("^--(enable|disable)-(.*)$"));
			if (switchOpt != null) {
				mode = switchOpt[1] === "enable";
				switch (switchOpt[2]) {
				case "type-check":
					tasks.push((function (mode) {
						return (function () {
							emitter.setEnableRunTimeTypeCheck$B(mode);
							Optimizer$setEnableRunTimeTypeCheck$LOptimizer$B(optimizer, mode);
						});
					})(mode));
					break NEXTOPT;
				case "source-map":
					tasks.push((function (mode) {
						return (function () {
							emitter.setEnableSourceMap$B(mode);
						});
					})(mode));
					break NEXTOPT;
				case "generator-emulation":
					if (mode) {
						transformCommands.push("generator");
					} else {
						transformCommands = transformCommands.filter((function (cmd) {
							return cmd !== "generator";
						}));
					}
					break NEXTOPT;
				case "cps-transform":
					if (mode) {
						transformCommands.push("cps");
					} else {
						transformCommands = transformCommands.filter((function (cmd) {
							return cmd !== "cps";
						}));
					}
					break NEXTOPT;
				default:
					break;
				}
			}
			platform.error$S("unknown option: " + opt);
			return 1;
		}
	}
	if (argIndex === args.length) {
		platform.error$S("no files");
		return 1;
	}
	sourceFile = args[argIndex++];
	if (inputFilename != null) {
		content$0 = platform.load$S(sourceFile);
		platform.fileContent[inputFilename] = content$0;
		sourceFile = inputFilename;
	}
	Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$(compiler, null, sourceFile, completionRequest);
	switch (compiler._mode) {
	case 1:
		if (Compiler$compile$LCompiler$(compiler)) {
			platform.save$USS(outputFile, JSON.stringify(Compiler$getAST$LCompiler$(compiler)));
			return 0;
		} else {
			return 1;
		}
	}
	if (emitter == null) {
		emitter = new JavaScriptEmitter(platform);
	}
	emitter.setRunEnv$S((executable != null ? executable : ""));
	emitter.setOutputFile$US(outputFile);
	setBootstrapMode(sourceFile);
	compiler._emitter = emitter;
	switch (compiler._mode) {
	case 3:
		if (outputFile == null) {
			platform.error$S("--output is mandatory for --mode doc");
			return 1;
		}
		if (Compiler$compile$LCompiler$(compiler)) {
			DocumentGenerator$buildDoc$LDocumentGenerator$((this$1 = (this$0 = new DocumentGenerator(compiler, platform.getRoot$() + "/etc/doc-template", outputFile), this$0._resourceFiles = [ "style.css" ], this$0), this$1._pathFilter = (function (sourcePath) {
				return (sourcePath.indexOf("system:") === 0 ? false : sourcePath.charAt(0) === "/" ? false : sourcePath.indexOf("../") === 0 ? false : sourcePath.indexOf("/../") !== -1 ? false : true);
			}), this$1));
			return 0;
		} else {
			return 1;
		}
	}
	optimizer = ({_compiler: null, _commands: [], _log: "", _dumpLogs: false, _enableRunTimeTypeCheck: true});
	tasks.forEach((function (proc) {
		proc();
	}));
	if (emitter.getEnableMinifier$() && emitter.getEnableSourceMap$()) {
		platform.error$S("--minify and --source-map cannot be specified at the same time");
		return 1;
	}
	err = Compiler$setTransformCommands$LCompiler$AS(compiler, transformCommands);
	if (err != null) {
		platform.error$S(err);
		return 1;
	}
	err = Optimizer$setup$LOptimizer$AS(optimizer, optimizeCommands);
	if (err != null) {
		platform.error$S(err);
		return 1;
	}
	compiler._optimizer = optimizer;
	result = Compiler$compile$LCompiler$(compiler);
	if (completionRequest != null) {
		platform.save$USS(null, JSON.stringify(CompletionRequest$getCandidates$LCompletionRequest$(completionRequest)));
		return 0;
	}
	if (! result) {
		return 65;
	}
	output = emitter.getOutput$();
	if (emitter instanceof JavaScriptEmitter) {
		if (! runImmediately || outputFile != null) {
			platform.save$USS(outputFile, output);
			if (outputFile != null) {
				map = emitter.getSourceMappingFiles$();
				for (filename in map) {
					platform.save$USS(filename, map[filename]);
				}
				if (executable != null) {
					platform.makeFileExecutable$SS(outputFile, executable);
				}
			}
		} else {
			platform.execute$USSAS(sourceFile, output, args.slice(argIndex));
		}
	} else {
		throw new Error("FIXME: C++ emitter");
	}
	return 0;
};

JSXCommand.main$LPlatform$AS = JSXCommand$main$LPlatform$AS;

function Meta() {
};

$__jsx_extend([Meta], Object);
function MapLiteralElement(key, expr) {
	this._key = key;
	this._expr = expr;
};

$__jsx_extend([MapLiteralElement], Object);
function MapLiteralElement$getKey$LMapLiteralElement$($this) {
	return $this._key;
};

MapLiteralElement.getKey$LMapLiteralElement$ = MapLiteralElement$getKey$LMapLiteralElement$;

function MapLiteralElement$getExpr$LMapLiteralElement$($this) {
	return $this._expr;
};

MapLiteralElement.getExpr$LMapLiteralElement$ = MapLiteralElement$getExpr$LMapLiteralElement$;

function MapLiteralElement$setExpr$LMapLiteralElement$LExpression$($this, expr) {
	$this._expr = expr;
};

MapLiteralElement.setExpr$LMapLiteralElement$LExpression$ = MapLiteralElement$setExpr$LMapLiteralElement$LExpression$;

function MapLiteralElement$serialize$LMapLiteralElement$($this) {
	var this$0;
	return [ (this$0 = $this._key, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), $this._expr.serialize$() ];
};

MapLiteralElement.serialize$LMapLiteralElement$ = MapLiteralElement$serialize$LMapLiteralElement$;

function InstantiationContext(errors, typemap) {
	this.errors = errors;
	this.typemap = typemap;
	this.objectTypesUsed = [];
};

$__jsx_extend([InstantiationContext], Object);
function InstantiationContext$clone$LInstantiationContext$($this) {
	return ({errors: $this.errors, typemap: $this.typemap, objectTypesUsed: []});
};

InstantiationContext.clone$LInstantiationContext$ = InstantiationContext$clone$LInstantiationContext$;

function TemplateInstantiationRequest(token, className, typeArgs) {
	this._token = token;
	this._className = className;
	this._typeArgs = typeArgs;
};

$__jsx_extend([TemplateInstantiationRequest], Object);
function TemplateInstantiationRequest$getToken$LTemplateInstantiationRequest$($this) {
	return $this._token;
};

TemplateInstantiationRequest.getToken$LTemplateInstantiationRequest$ = TemplateInstantiationRequest$getToken$LTemplateInstantiationRequest$;

function TemplateInstantiationRequest$getClassName$LTemplateInstantiationRequest$($this) {
	return $this._className;
};

TemplateInstantiationRequest.getClassName$LTemplateInstantiationRequest$ = TemplateInstantiationRequest$getClassName$LTemplateInstantiationRequest$;

function TemplateInstantiationRequest$getTypeArguments$LTemplateInstantiationRequest$($this) {
	return $this._typeArgs;
};

TemplateInstantiationRequest.getTypeArguments$LTemplateInstantiationRequest$ = TemplateInstantiationRequest$getTypeArguments$LTemplateInstantiationRequest$;

function Block() {
};

$__jsx_extend([Block], Object);
Block.prototype.$__jsx_implements_Block = true;

function BlockContext(localVariableStatuses, block) {
	this.localVariableStatuses = localVariableStatuses;
	this.block = block;
};

$__jsx_extend([BlockContext], Object);
function AnalysisContext(errors, parser, postInstantiationCallback) {
	this.errors = errors;
	this.parser = parser;
	this.postInstantiationCallback = postInstantiationCallback;
	this.funcDef = null;
	this.blockStack = null;
	this.statement = null;
};

$__jsx_extend([AnalysisContext], Object);
function AnalysisContext$clone$LAnalysisContext$($this) {
	var this$0;
	var funcDef$0;
	this$0 = ({errors: $this.errors, parser: $this.parser, postInstantiationCallback: $this.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
	funcDef$0 = $this.funcDef;
	this$0.funcDef = funcDef$0;
	return this$0;
};

AnalysisContext.clone$LAnalysisContext$ = AnalysisContext$clone$LAnalysisContext$;

function AnalysisContext$setFuncDef$LAnalysisContext$LMemberFunctionDefinition$($this, funcDef) {
	$this.funcDef = funcDef;
	return $this;
};

AnalysisContext.setFuncDef$LAnalysisContext$LMemberFunctionDefinition$ = AnalysisContext$setFuncDef$LAnalysisContext$LMemberFunctionDefinition$;

function AnalysisContext$setBlockStack$LAnalysisContext$ALBlockContext$($this, stack) {
	$this.blockStack = stack;
	return $this;
};

AnalysisContext.setBlockStack$LAnalysisContext$ALBlockContext$ = AnalysisContext$setBlockStack$LAnalysisContext$ALBlockContext$;

function AnalysisContext$getTopBlock$LAnalysisContext$($this) {
	var blockStack$0;
	return (blockStack$0 = $this.blockStack)[blockStack$0.length - 1];
};

AnalysisContext.getTopBlock$LAnalysisContext$ = AnalysisContext$getTopBlock$LAnalysisContext$;

function Stash() {
};

$__jsx_extend([Stash], Object);
function _JSEmitterStash() {
	this.shouldBooleanize = false;
	this.returnsBoolean = false;
};

$__jsx_extend([_JSEmitterStash], Stash);
_JSEmitterStash.prototype.clone$ = function () {
	throw new Error("logic flaw");
};


function Stashable() {
	this._stash = {};
};

$__jsx_extend([Stashable], Object);
Stashable.prototype.$__jsx_implements_Stashable = true;

Stashable.prototype.setStash$SLStash$ = function (id, stash) {
	return this._stash[id] = stash;
};


Stashable.prototype.getStash$S = function (id) {
	return this._stash[id];
};


function Statement() {
	this._stash = {};
};

$__jsx_extend([Statement], Object);
$__jsx_merge_interface(Statement, Stashable);

Statement.prototype.analyze$LAnalysisContext$ = function (context) {
	var token;
	var srcPos;
	if (! (this instanceof CaseStatement || this instanceof DefaultStatement)) {
		if (! Statement$assertIsReachable$LAnalysisContext$LToken$(context, this.getToken$())) {
			return false;
		}
	}
	try {
		return this.doAnalyze$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			token = this.getToken$();
			srcPos = (token != null ? Util$format$SAS(" at file %1, line %2, near %3", [ token._filename, token._lineNumber + "", token._value ]) : "");
			$__jsx_catch_0.message = Util$format$SAS("fatal error while compiling statement%1\n%2", [ srcPos, $__jsx_catch_0.message ]);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
};


function Statement$analyze$LStatement$LAnalysisContext$($this, context) {
	var token;
	var srcPos;
	if (! ($this instanceof CaseStatement || $this instanceof DefaultStatement)) {
		if (! Statement$assertIsReachable$LAnalysisContext$LToken$(context, $this.getToken$())) {
			return false;
		}
	}
	try {
		return $this.doAnalyze$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			token = $this.getToken$();
			srcPos = (token != null ? Util$format$SAS(" at file %1, line %2, near %3", [ token._filename, token._lineNumber + "", token._value ]) : "");
			$__jsx_catch_0.message = Util$format$SAS("fatal error while compiling statement%1\n%2", [ srcPos, $__jsx_catch_0.message ]);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
};

Statement.analyze$LStatement$LAnalysisContext$ = Statement$analyze$LStatement$LAnalysisContext$;

Statement.prototype.forEachStatement$F$LStatement$B$ = function (cb) {
	var $this = this;
	return this.forEachStatement$F$LStatement$F$LStatement$V$B$((function (stmt, _) {
		return cb(stmt);
	}));
};


function Statement$forEachStatement$LStatement$F$LStatement$B$($this, cb) {
	return $this.forEachStatement$F$LStatement$F$LStatement$V$B$((function (stmt, _) {
		return cb(stmt);
	}));
};

Statement.forEachStatement$LStatement$F$LStatement$B$ = Statement$forEachStatement$LStatement$F$LStatement$B$;

Statement.prototype.forEachStatement$F$LStatement$F$LStatement$V$B$ = function (cb) {
	return true;
};


Statement.prototype.handleStatements$F$ALStatement$B$ = function (cb) {
	return true;
};


Statement.prototype.forEachExpression$F$LExpression$B$ = function (cb) {
	var $this = this;
	return this.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, _) {
		return cb(expr);
	}));
};


function Statement$forEachExpression$LStatement$F$LExpression$B$($this, cb) {
	return $this.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, _) {
		return cb(expr);
	}));
};

Statement.forEachExpression$LStatement$F$LExpression$B$ = Statement$forEachExpression$LStatement$F$LExpression$B$;

Statement.prototype._analyzeExpr$LAnalysisContext$LExpression$ = function (context, expr) {
	var result;
	if (context.statement != null) {
		throw new Error("logic flaw");
	}
	context.statement = this;
	result = false;
	try {
		result = expr.analyze$LAnalysisContext$LExpression$(context, null);
	} finally {
		context.statement = null;
	}
	return result;
};


function Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$($this, context, expr) {
	var result;
	if (context.statement != null) {
		throw new Error("logic flaw");
	}
	context.statement = $this;
	result = false;
	try {
		result = expr.analyze$LAnalysisContext$LExpression$(context, null);
	} finally {
		context.statement = null;
	}
	return result;
};

Statement._analyzeExpr$LStatement$LAnalysisContext$LExpression$ = Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$;

function Statement$assertIsReachable$LAnalysisContext$LToken$(context, token) {
	var this$0;
	var blockStack$0;
	if (! (this$0 = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses, this$0._isReachable)) {
		context.errors.push(new CompileWarning(token, "the code is unreachable"));
	}
	return true;
};

Statement.assertIsReachable$LAnalysisContext$LToken$ = Statement$assertIsReachable$LAnalysisContext$LToken$;

function LabelStatement(name) {
	this._stash = {};
	this._name = name;
	this._id = -1;
};

$__jsx_extend([LabelStatement], Statement);
LabelStatement.prototype.getName$ = function () {
	return this._name;
};


function LabelStatement$getName$LLabelStatement$($this) {
	return $this._name;
};

LabelStatement.getName$LLabelStatement$ = LabelStatement$getName$LLabelStatement$;

LabelStatement.prototype.getID$ = function () {
	return this._id;
};


function LabelStatement$getID$LLabelStatement$($this) {
	return $this._id;
};

LabelStatement.getID$LLabelStatement$ = LabelStatement$getID$LLabelStatement$;

LabelStatement.prototype.setID$I = function (id) {
	this._id = id;
};


function LabelStatement$setID$LLabelStatement$I($this, id) {
	$this._id = id;
};

LabelStatement.setID$LLabelStatement$I = LabelStatement$setID$LLabelStatement$I;

LabelStatement.prototype.getToken$ = function () {
	return null;
};


LabelStatement.prototype.clone$ = function () {
	return new LabelStatement(this._name);
};


LabelStatement.prototype.serialize$ = function () {
	return null;
};


LabelStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	return true;
};


LabelStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function GotoStatement(label) {
	this._stash = {};
	this._label = label;
	this._id = -1;
};

$__jsx_extend([GotoStatement], Statement);
GotoStatement.prototype.getLabel$ = function () {
	return this._label;
};


function GotoStatement$getLabel$LGotoStatement$($this) {
	return $this._label;
};

GotoStatement.getLabel$LGotoStatement$ = GotoStatement$getLabel$LGotoStatement$;

GotoStatement.prototype.setLabel$S = function (label) {
	this._label = label;
};


function GotoStatement$setLabel$LGotoStatement$S($this, label) {
	$this._label = label;
};

GotoStatement.setLabel$LGotoStatement$S = GotoStatement$setLabel$LGotoStatement$S;

GotoStatement.prototype.getID$ = function () {
	return this._id;
};


function GotoStatement$getID$LGotoStatement$($this) {
	return $this._id;
};

GotoStatement.getID$LGotoStatement$ = GotoStatement$getID$LGotoStatement$;

GotoStatement.prototype.setID$I = function (id) {
	this._id = id;
};


function GotoStatement$setID$LGotoStatement$I($this, id) {
	$this._id = id;
};

GotoStatement.setID$LGotoStatement$I = GotoStatement$setID$LGotoStatement$I;

GotoStatement.prototype.getToken$ = function () {
	return null;
};


GotoStatement.prototype.clone$ = function () {
	return new GotoStatement(this._label);
};


GotoStatement.prototype.serialize$ = function () {
	return null;
};


GotoStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	return true;
};


GotoStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function InformationStatement(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([InformationStatement], Statement);
InformationStatement.prototype.getToken$ = function () {
	return this._token;
};


function DebuggerStatement(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([DebuggerStatement], InformationStatement);
DebuggerStatement.prototype.clone$ = function () {
	return new DebuggerStatement(this._token);
};


DebuggerStatement.prototype.serialize$ = function () {
	var this$0;
	return [ "DebuggerStatement", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]) ];
};


DebuggerStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	return true;
};


DebuggerStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function LogStatement(token, exprs) {
	this._stash = {};
	this._token = token;
	this._exprs = exprs;
};

$__jsx_extend([LogStatement], InformationStatement);
LogStatement.prototype.clone$ = function () {
	return new LogStatement(this._token, Util$cloneArray$ALExpression$(this._exprs));
};


LogStatement.prototype.getExprs$ = function () {
	return this._exprs;
};


function LogStatement$getExprs$LLogStatement$($this) {
	return $this._exprs;
};

LogStatement.getExprs$LLogStatement$ = LogStatement$getExprs$LLogStatement$;

LogStatement.prototype.serialize$ = function () {
	var this$0;
	return [ "LogStatement", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), Util$serializeArray$ALExpression$(this._exprs) ];
};


LogStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var i;
	var exprType;
	for (i = 0; i < this._exprs.length; ++i) {
		if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._exprs[i])) {
			return true;
		}
		exprType = this._exprs[i].getType$();
		if (exprType == null) {
			return true;
		}
		if (exprType.equals$LType$(Type.voidType)) {
			context.errors.push(new CompileError(this._token, "cannot log a void expression"));
			break;
		}
	}
	return true;
};


LogStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, this._exprs);
};


function AssertStatement(token, expr, msgExpr) {
	this._stash = {};
	this._token = token;
	this._expr = expr;
	this._msgExpr = msgExpr;
};

$__jsx_extend([AssertStatement], InformationStatement);
AssertStatement.prototype.clone$ = function () {
	var o$0;
	return new AssertStatement(this._token, this._expr.clone$(), (o$0 = this._msgExpr, o$0 == null ? null : o$0.clone$()));
};


AssertStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function AssertStatement$getExpr$LAssertStatement$($this) {
	return $this._expr;
};

AssertStatement.getExpr$LAssertStatement$ = AssertStatement$getExpr$LAssertStatement$;

AssertStatement.prototype.getMessageExpr$ = function () {
	return this._msgExpr;
};


function AssertStatement$getMessageExpr$LAssertStatement$($this) {
	return $this._msgExpr;
};

AssertStatement.getMessageExpr$LAssertStatement$ = AssertStatement$getMessageExpr$LAssertStatement$;

AssertStatement.prototype.serialize$ = function () {
	var this$0;
	var v$0;
	var v$1;
	return [ "AssertStatement", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), (v$0 = this._expr, v$0 == null ? null : v$0.serialize$()), (v$1 = this._msgExpr, v$1 == null ? null : v$1.serialize$()) ];
};


AssertStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var exprType;
	var msgExprType;
	var this$0;
	var this$1;
	if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		return true;
	}
	exprType = this._expr.getType$();
	if (exprType.equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError((this$0 = this._expr, this$0._token), "argument of the assert statement cannot be void"));
	}
	if (this._msgExpr != null) {
		if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._msgExpr)) {
			return true;
		}
		msgExprType = this._msgExpr.getType$();
		if (! msgExprType.equals$LType$(Type.stringType)) {
			context.errors.push(new CompileError((this$1 = this._msgExpr, this$1._token), "message expression of the assert statement must be of string type"));
		}
	}
	return true;
};


AssertStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : this._msgExpr != null && ! cb(this._msgExpr, (function (expr) {
		$this._msgExpr = expr;
	})) ? false : true);
};


function ThrowStatement(token, expr) {
	this._stash = {};
	this._token = token;
	this._expr = expr;
};

$__jsx_extend([ThrowStatement], Statement);
ThrowStatement.prototype.clone$ = function () {
	return new ThrowStatement(this._token, this._expr.clone$());
};


ThrowStatement.prototype.getToken$ = function () {
	return this._token;
};


ThrowStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function ThrowStatement$getExpr$LThrowStatement$($this) {
	return $this._expr;
};

ThrowStatement.getExpr$LThrowStatement$ = ThrowStatement$getExpr$LThrowStatement$;

ThrowStatement.prototype.serialize$ = function () {
	var this$0;
	return [ "ThrowStatement", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), this._expr.serialize$() ];
};


ThrowStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var errorClassDef;
	var this$0;
	var blockStack$0;
	if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		return true;
	}
	errorClassDef = Parser$lookup$LParser$ALCompileError$LToken$S(context.parser, context.errors, this._token, "Error");
	if (errorClassDef == null) {
		throw new Error("could not find definition for Error");
	}
	if (this._expr.getType$().equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(this._token, "cannot throw 'void'"));
		return true;
	}
	this$0 = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
	this$0._isReachable = false;
	return true;
};


ThrowStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function CatchStatement(token, local, statements) {
	this._stash = {};
	this._token = token;
	this._local = local;
	this._statements = statements;
};

$__jsx_extend([CatchStatement], Statement);
$__jsx_merge_interface(CatchStatement, Block);

CatchStatement.prototype.clone$ = function () {
	return new CatchStatement(this._token, this._local, Util$cloneArray$ALStatement$(this._statements));
};


CatchStatement.prototype.getToken$ = function () {
	return this._token;
};


CatchStatement.prototype.getLocal$ = function () {
	return this._local;
};


function CatchStatement$getLocal$LCatchStatement$($this) {
	return $this._local;
};

CatchStatement.getLocal$LCatchStatement$ = CatchStatement$getLocal$LCatchStatement$;

CatchStatement.prototype.setLocal$LCaughtVariable$ = function (local) {
	this._local = local;
};


function CatchStatement$setLocal$LCatchStatement$LCaughtVariable$($this, local) {
	$this._local = local;
};

CatchStatement.setLocal$LCatchStatement$LCaughtVariable$ = CatchStatement$setLocal$LCatchStatement$LCaughtVariable$;

CatchStatement.prototype.getStatements$ = function () {
	return this._statements;
};


function CatchStatement$getStatements$LCatchStatement$($this) {
	return $this._statements;
};

CatchStatement.getStatements$LCatchStatement$ = CatchStatement$getStatements$LCatchStatement$;

CatchStatement.prototype.serialize$ = function () {
	var this$0;
	var this$1;
	var v$0$0;
	return [ "CatchStatement", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), (this$1 = this._local, [ this$1._name, (v$0$0 = this$1._type, v$0$0 == null ? null : v$0$0.toString()) ]), Util$serializeArray$ALStatement$(this._statements) ];
};


CatchStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var catchType;
	var i;
	var this$0;
	this$0 = this._local;
	catchType = this$0._type;
	if (! (catchType instanceof ObjectType || catchType.equals$LType$(Type.variantType))) {
		context.errors.push(new CompileError(this._token, "only objects or a variant may be caught"));
	}
	for (i = 0; i < this._statements.length; ++i) {
		if (! Statement$analyze$LStatement$LAnalysisContext$(this._statements[i], context)) {
			return false;
		}
	}
	return true;
};


CatchStatement.prototype.forEachStatement$F$LStatement$F$LStatement$V$B$ = function (cb) {
	return Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$(cb, this._statements);
};


CatchStatement.prototype.handleStatements$F$ALStatement$B$ = function (cb) {
	return cb(this._statements);
};


CatchStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function TryStatement(token, tryStatements, catchStatements, finallyStatements) {
	this._stash = {};
	this._token = token;
	this._tryStatements = tryStatements;
	this._catchStatements = catchStatements;
	this._finallyStatements = finallyStatements;
};

$__jsx_extend([TryStatement], Statement);
$__jsx_merge_interface(TryStatement, Block);

TryStatement.prototype.clone$ = function () {
	return new TryStatement(this._token, Util$cloneArray$ALStatement$(this._tryStatements), Util$cloneArray$ALCatchStatement$(this._catchStatements), Util$cloneArray$ALStatement$(this._finallyStatements));
};


TryStatement.prototype.getToken$ = function () {
	return this._token;
};


TryStatement.prototype.getTryStatements$ = function () {
	return this._tryStatements;
};


function TryStatement$getTryStatements$LTryStatement$($this) {
	return $this._tryStatements;
};

TryStatement.getTryStatements$LTryStatement$ = TryStatement$getTryStatements$LTryStatement$;

TryStatement.prototype.getCatchStatements$ = function () {
	return this._catchStatements;
};


function TryStatement$getCatchStatements$LTryStatement$($this) {
	return $this._catchStatements;
};

TryStatement.getCatchStatements$LTryStatement$ = TryStatement$getCatchStatements$LTryStatement$;

TryStatement.prototype.getFinallyStatements$ = function () {
	return this._finallyStatements;
};


function TryStatement$getFinallyStatements$LTryStatement$($this) {
	return $this._finallyStatements;
};

TryStatement.getFinallyStatements$LTryStatement$ = TryStatement$getFinallyStatements$LTryStatement$;

TryStatement.prototype.serialize$ = function () {
	return [ "TryStatement", Util$serializeArray$ALStatement$(this._tryStatements), Util$serializeArray$ALCatchStatement$(this._catchStatements), Util$serializeArray$ALStatement$(this._finallyStatements) ];
};


TryStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var lvStatusesAfterTryCatch;
	var i;
	var lvStatusesAfterCatch;
	var curCatchType;
	var j;
	var precCatchType;
	var lvStatusesAfterFinally;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var blockStack$0;
	var blockStack$1;
	var blockStack$2;
	var blockStack$3;
	var blockStack$4;
	var blockStack$5;
	var blockStack$6;
	(blockStack$1 = context.blockStack).push(({localVariableStatuses: (this$0 = blockStack$1[blockStack$1.length - 1].localVariableStatuses, new LocalVariableStatuses$0(this$0)), block: this}));
	lvStatusesAfterTryCatch = null;
	try {
		for (i = 0; i < this._tryStatements.length; ++i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._tryStatements[i], context)) {
				return false;
			}
		}
		lvStatusesAfterTryCatch = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
	} finally {
		context.blockStack.pop();
	}
	for (i = 0; i < this._catchStatements.length; ++i) {
		(blockStack$3 = context.blockStack).push(({localVariableStatuses: (this$1 = blockStack$3[blockStack$3.length - 1].localVariableStatuses, new LocalVariableStatuses$0(this$1)), block: this._catchStatements[i]}));
		lvStatusesAfterCatch = null;
		try {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._catchStatements[i], context)) {
				return false;
			}
			lvStatusesAfterCatch = (blockStack$2 = context.blockStack)[blockStack$2.length - 1].localVariableStatuses;
		} finally {
			context.blockStack.pop();
		}
		lvStatusesAfterTryCatch = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(lvStatusesAfterTryCatch, lvStatusesAfterCatch);
		this$4 = this._catchStatements[i];
		this$2 = this$4._local;
		curCatchType = this$2._type;
		for (j = 0; j < i; ++j) {
			this$5 = this._catchStatements[j];
			this$3 = this$5._local;
			precCatchType = this$3._type;
			if (curCatchType.isConvertibleTo$LType$(precCatchType)) {
				context.errors.push(new CompileError(this._catchStatements[i]._token, "code is unreachable, a broader catch statement for type '" + precCatchType.toString() + "' already exists"));
				return false;
			}
		}
	}
	(blockStack$5 = context.blockStack).push(({localVariableStatuses: LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(blockStack$5[blockStack$5.length - 1].localVariableStatuses, lvStatusesAfterTryCatch), block: this}));
	lvStatusesAfterFinally = null;
	try {
		for (i = 0; i < this._finallyStatements.length; ++i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._finallyStatements[i], context)) {
				return false;
			}
		}
		lvStatusesAfterFinally = (blockStack$4 = context.blockStack)[blockStack$4.length - 1].localVariableStatuses;
	} finally {
		context.blockStack.pop();
	}
	(blockStack$6 = context.blockStack)[blockStack$6.length - 1].localVariableStatuses = LocalVariableStatuses$mergeFinally$LLocalVariableStatuses$LLocalVariableStatuses$(lvStatusesAfterTryCatch, lvStatusesAfterFinally);
	return true;
};


TryStatement.prototype.forEachStatement$F$LStatement$F$LStatement$V$B$ = function (cb) {
	var $this = this;
	return (! Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$(cb, this._tryStatements) ? false : ! Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$(cb, this._catchStatements.map((function (s) {
		return s;
	}))) ? false : ! Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$(cb, this._finallyStatements) ? false : true);
};


TryStatement.prototype.handleStatements$F$ALStatement$B$ = function (cb) {
	var $this = this;
	return (! cb(this._tryStatements) ? false : ! cb(this._catchStatements.map((function (s) {
		return s;
	}))) ? false : ! cb(this._finallyStatements) ? false : true);
};


TryStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function DefaultStatement(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([DefaultStatement], Statement);
DefaultStatement.prototype.clone$ = function () {
	return new DefaultStatement(this._token);
};


DefaultStatement.prototype.getToken$ = function () {
	return this._token;
};


DefaultStatement.prototype.serialize$ = function () {
	return [ "DefaultStatement" ];
};


DefaultStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var this$0$0;
	var blockStack$0;
	(blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses = (this$0$0 = blockStack$0[blockStack$0.length - 2].localVariableStatuses, new LocalVariableStatuses$0(this$0$0));
	return true;
};


DefaultStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function CaseStatement(token, expr) {
	this._stash = {};
	this._token = token;
	this._expr = expr;
};

$__jsx_extend([CaseStatement], Statement);
CaseStatement.prototype.clone$ = function () {
	return new CaseStatement(this._token, this._expr.clone$());
};


CaseStatement.prototype.getToken$ = function () {
	return this._token;
};


CaseStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function CaseStatement$getExpr$LCaseStatement$($this) {
	return $this._expr;
};

CaseStatement.getExpr$LCaseStatement$ = CaseStatement$getExpr$LCaseStatement$;

CaseStatement.prototype.serialize$ = function () {
	return [ "CaseStatement", this._expr.serialize$() ];
};


CaseStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var statement;
	var expectedType;
	var exprType;
	var this$0;
	var this$0$0;
	var this$0$1;
	var this$0$2;
	var blockStack$0;
	var blockStack$1;
	if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		return true;
	}
	statement = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].block;
	if (! (statement instanceof SwitchStatement)) {
		throw new Error("logic flaw");
	}
	expectedType = (this$0 = statement, this$0._expr).getType$();
	if (expectedType == null) {
		return true;
	}
	expectedType = (expectedType instanceof NullableType ? (this$0$0 = expectedType, this$0$0._baseType) : expectedType);
	exprType = this._expr.getType$();
	if (exprType == null) {
		return true;
	}
	exprType = (exprType instanceof NullableType ? (this$0$1 = exprType, this$0$1._baseType) : exprType);
	if (exprType.equals$LType$(expectedType)) {
	} else if ((exprType instanceof IntegerType || exprType instanceof NumberType) && (expectedType instanceof IntegerType || expectedType instanceof NumberType)) {
	} else if (expectedType.equals$LType$(Type.stringType) && exprType.equals$LType$(Type.nullType)) {
	} else {
		context.errors.push(new CompileError(this._token, "type mismatch; expected type was '" + expectedType.toString() + "' but got '" + exprType.toString() + "'"));
	}
	(blockStack$1 = context.blockStack)[blockStack$1.length - 1].localVariableStatuses = (this$0$2 = blockStack$1[blockStack$1.length - 2].localVariableStatuses, new LocalVariableStatuses$0(this$0$2));
	return true;
};


CaseStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function IfStatement(token, expr, onTrueStatements, onFalseStatements) {
	this._stash = {};
	this._token = token;
	this._expr = expr;
	this._onTrueStatements = onTrueStatements;
	this._onFalseStatements = onFalseStatements;
};

$__jsx_extend([IfStatement], Statement);
$__jsx_merge_interface(IfStatement, Block);

IfStatement.prototype.clone$ = function () {
	return new IfStatement(this._token, this._expr.clone$(), Util$cloneArray$ALStatement$(this._onTrueStatements), Util$cloneArray$ALStatement$(this._onFalseStatements));
};


IfStatement.prototype.getToken$ = function () {
	return this._token;
};


IfStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function IfStatement$getExpr$LIfStatement$($this) {
	return $this._expr;
};

IfStatement.getExpr$LIfStatement$ = IfStatement$getExpr$LIfStatement$;

IfStatement.prototype.setExpr$LExpression$ = function (expr) {
	this._expr = expr;
};


function IfStatement$setExpr$LIfStatement$LExpression$($this, expr) {
	$this._expr = expr;
};

IfStatement.setExpr$LIfStatement$LExpression$ = IfStatement$setExpr$LIfStatement$LExpression$;

IfStatement.prototype.getOnTrueStatements$ = function () {
	return this._onTrueStatements;
};


function IfStatement$getOnTrueStatements$LIfStatement$($this) {
	return $this._onTrueStatements;
};

IfStatement.getOnTrueStatements$LIfStatement$ = IfStatement$getOnTrueStatements$LIfStatement$;

IfStatement.prototype.getOnFalseStatements$ = function () {
	return this._onFalseStatements;
};


function IfStatement$getOnFalseStatements$LIfStatement$($this) {
	return $this._onFalseStatements;
};

IfStatement.getOnFalseStatements$LIfStatement$ = IfStatement$getOnFalseStatements$LIfStatement$;

IfStatement.prototype.serialize$ = function () {
	return [ "IfStatement", this._expr.serialize$(), Util$serializeArray$ALStatement$(this._onTrueStatements), Util$serializeArray$ALStatement$(this._onFalseStatements) ];
};


IfStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var lvStatusesOnTrueStmts;
	var lvStatusesOnFalseStmts;
	var i;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$0$0;
	var blockStack$0;
	var blockStack$1;
	var blockStack$2;
	var blockStack$3;
	var blockStack$4;
	if (Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		if ((this$3 = this._expr.getType$(), this$3 instanceof NullableType ? (this$0$0 = this$3, this$0$0._baseType) : this$3).equals$LType$(Type.voidType)) {
			context.errors.push(new CompileError((this$0 = this._expr, this$0._token), "expression of the if statement should not return void"));
		}
	}
	(blockStack$1 = context.blockStack).push(({localVariableStatuses: (this$1 = blockStack$1[blockStack$1.length - 1].localVariableStatuses, new LocalVariableStatuses$0(this$1)), block: this}));
	(lvStatusesOnTrueStmts = null, lvStatusesOnFalseStmts = null);
	try {
		for (i = 0; i < this._onTrueStatements.length; ++i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._onTrueStatements[i], context)) {
				return false;
			}
		}
		lvStatusesOnTrueStmts = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
	} finally {
		context.blockStack.pop();
	}
	try {
		(blockStack$2 = context.blockStack).push(({localVariableStatuses: (this$2 = blockStack$2[blockStack$2.length - 1].localVariableStatuses, new LocalVariableStatuses$0(this$2)), block: this}));
		for (i = 0; i < this._onFalseStatements.length; ++i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._onFalseStatements[i], context)) {
				return false;
			}
		}
		lvStatusesOnFalseStmts = (blockStack$3 = context.blockStack)[blockStack$3.length - 1].localVariableStatuses;
	} finally {
		context.blockStack.pop();
	}
	(blockStack$4 = context.blockStack)[blockStack$4.length - 1].localVariableStatuses = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(lvStatusesOnTrueStmts, lvStatusesOnFalseStmts);
	return true;
};


IfStatement.prototype.forEachStatement$F$LStatement$F$LStatement$V$B$ = function (cb) {
	return (! Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$(cb, this._onTrueStatements) ? false : ! Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$(cb, this._onFalseStatements) ? false : true);
};


IfStatement.prototype.handleStatements$F$ALStatement$B$ = function (cb) {
	return (! cb(this._onTrueStatements) ? false : ! cb(this._onFalseStatements) ? false : true);
};


IfStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function LabellableStatement(token, label) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
};

$__jsx_extend([LabellableStatement], Statement);
$__jsx_merge_interface(LabellableStatement, Block);

LabellableStatement.prototype.getToken$ = function () {
	return this._token;
};


LabellableStatement.prototype.getLabel$ = function () {
	return this._label;
};


function LabellableStatement$getLabel$LLabellableStatement$($this) {
	return $this._label;
};

LabellableStatement.getLabel$LLabellableStatement$ = LabellableStatement$getLabel$LLabellableStatement$;

LabellableStatement.prototype._serialize$ = function () {
	var v$0;
	return [ (v$0 = this._label, v$0 == null ? null : [ v$0._value, v$0._isIdentifier, v$0._filename, v$0._lineNumber, v$0._columnNumber ]) ];
};


function LabellableStatement$_serialize$LLabellableStatement$($this) {
	var v$0;
	return [ (v$0 = $this._label, v$0 == null ? null : [ v$0._value, v$0._isIdentifier, v$0._filename, v$0._lineNumber, v$0._columnNumber ]) ];
};

LabellableStatement._serialize$LLabellableStatement$ = LabellableStatement$_serialize$LLabellableStatement$;

LabellableStatement.prototype._prepareBlockAnalysis$LAnalysisContext$ = function (context) {
	var i;
	var statement;
	var ls;
	var error;
	var note$0;
	var this$1;
	var this$2;
	var this$4;
	var this$5;
	var _label$0;
	var blockStack$0;
	var blockStack$1;
	var _lvStatusesOnBreak$0;
	if (this._label) {
		for (i = context.blockStack.length - 1; ! (context.blockStack[i].block instanceof MemberFunctionDefinition); --i) {
			statement = context.blockStack[i].block;
			if (! (statement instanceof LabellableStatement)) {
				continue;
			}
			ls = statement;
			if (ls._label && (this$4 = ls._label, this$4._value) === (this$5 = this._label, this$5._value)) {
				error = new CompileError(_label$0 = this._label, Util$format$SAS("label '%1' has already been defined", [ (_label$0, _label$0._value) ]));
				note$0 = new CompileNote(ls._label, "defined here");
				error._notes.push(note$0);
				context.errors.push(error);
				break;
			}
		}
	}
	(blockStack$0 = context.blockStack).push(({localVariableStatuses: (this$1 = blockStack$0[blockStack$0.length - 1].localVariableStatuses, new LocalVariableStatuses$0(this$1)), block: this}));
	this$2 = (blockStack$1 = context.blockStack)[blockStack$1.length - 1].localVariableStatuses;
	_lvStatusesOnBreak$0 = this._lvStatusesOnBreak = new LocalVariableStatuses$0(this$2);
	_lvStatusesOnBreak$0._isReachable = false;
};


LabellableStatement.prototype._abortBlockAnalysis$LAnalysisContext$ = function (context) {
	context.blockStack.pop();
	this._lvStatusesOnBreak = null;
};


LabellableStatement.prototype._finalizeBlockAnalysis$LAnalysisContext$ = function (context) {
	var blockStack$0;
	context.blockStack.pop();
	(blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses = this._lvStatusesOnBreak;
	this._lvStatusesOnBreak = null;
};


LabellableStatement.prototype.registerVariableStatusesOnBreak$LLocalVariableStatuses$ = function (statuses) {
	if (statuses != null) {
		if (this._lvStatusesOnBreak == null) {
			this._lvStatusesOnBreak = new LocalVariableStatuses$0(statuses);
		} else {
			this._lvStatusesOnBreak = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(this._lvStatusesOnBreak, statuses);
		}
	}
};


function LabellableStatement$registerVariableStatusesOnBreak$LLabellableStatement$LLocalVariableStatuses$($this, statuses) {
	if (statuses != null) {
		if ($this._lvStatusesOnBreak == null) {
			$this._lvStatusesOnBreak = new LocalVariableStatuses$0(statuses);
		} else {
			$this._lvStatusesOnBreak = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$($this._lvStatusesOnBreak, statuses);
		}
	}
};

LabellableStatement.registerVariableStatusesOnBreak$LLabellableStatement$LLocalVariableStatuses$ = LabellableStatement$registerVariableStatusesOnBreak$LLabellableStatement$LLocalVariableStatuses$;

function SwitchStatement(token, label, expr, statements) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
	this._expr = expr;
	this._statements = statements;
};

$__jsx_extend([SwitchStatement], LabellableStatement);
SwitchStatement.prototype.clone$ = function () {
	return new SwitchStatement(this._token, this._label, this._expr.clone$(), Util$cloneArray$ALStatement$(this._statements));
};


SwitchStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function SwitchStatement$getExpr$LSwitchStatement$($this) {
	return $this._expr;
};

SwitchStatement.getExpr$LSwitchStatement$ = SwitchStatement$getExpr$LSwitchStatement$;

SwitchStatement.prototype.setExpr$LExpression$ = function (expr) {
	this._expr = expr;
};


function SwitchStatement$setExpr$LSwitchStatement$LExpression$($this, expr) {
	$this._expr = expr;
};

SwitchStatement.setExpr$LSwitchStatement$LExpression$ = SwitchStatement$setExpr$LSwitchStatement$LExpression$;

SwitchStatement.prototype.getStatements$ = function () {
	return this._statements;
};


function SwitchStatement$getStatements$LSwitchStatement$($this) {
	return $this._statements;
};

SwitchStatement.getStatements$LSwitchStatement$ = SwitchStatement$getStatements$LSwitchStatement$;

SwitchStatement.prototype.serialize$ = function () {
	var v$0$0;
	return [ "SwitchStatement" ].concat([ (v$0$0 = this._label, v$0$0 == null ? null : [ v$0$0._value, v$0$0._isIdentifier, v$0$0._filename, v$0$0._lineNumber, v$0$0._columnNumber ]) ]).concat([ this._expr.serialize$(), Util$serializeArray$ALStatement$(this._statements) ]);
};


SwitchStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var exprType;
	var hasDefaultLabel;
	var caseMap;
	var i;
	var statement;
	var caseExpr;
	var caseStr;
	var this$0;
	var this$0$0;
	var this$1;
	var this$2;
	var this$0$1;
	var this$3;
	var this$0$2;
	var this$5;
	var statuses$0;
	var statuses$1;
	var _token$0;
	var blockStack$0;
	var blockStack$1;
	var blockStack$2;
	if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		return true;
	}
	this$0 = this._expr.getType$();
	exprType = (this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0);
	if (! (exprType.equals$LType$(Type.booleanType) || exprType.equals$LType$(Type.integerType) || exprType.equals$LType$(Type.numberType) || exprType.equals$LType$(Type.stringType))) {
		context.errors.push(new CompileError(this._token, "switch statement only accepts boolean, number, or string expressions"));
		return true;
	}
	this._prepareBlockAnalysis$LAnalysisContext$(context);
	try {
		hasDefaultLabel = false;
		caseMap = {};
		for (i = 0; i < this._statements.length; ++i) {
			statement = this._statements[i];
			if (! Statement$analyze$LStatement$LAnalysisContext$(statement, context)) {
				return false;
			}
			if (statement instanceof DefaultStatement) {
				hasDefaultLabel = true;
			} else if (statement instanceof CaseStatement) {
				this$1 = statement;
				caseExpr = this$1._expr;
				if (caseExpr instanceof IntegerLiteralExpression) {
					caseStr = (this$2 = caseExpr, (this$0$1 = this$2._token, this$0$1._value) | 0) + "";
				} else if (caseExpr instanceof NumberLiteralExpression) {
					caseStr = caseExpr.getDecoded$() + "";
				} else if (caseExpr instanceof BooleanLiteralExpression) {
					caseStr = (this$3 = caseExpr, (this$0$2 = this$3._token, this$0$2._value) !== "false") + "";
				} else if (caseExpr instanceof StringLiteralExpression) {
					caseStr = caseExpr.getDecoded$();
				} else {
					caseStr = null;
				}
				if (caseStr != null && $__jsx_ObjectHasOwnProperty.call(caseMap, caseStr)) {
					context.errors.push(new CompileError(_token$0 = caseExpr._token, "duplicate case value " + (_token$0, _token$0._value)));
					return false;
				}
				caseMap[caseStr] = true;
			}
		}
		this$5 = (blockStack$1 = context.blockStack)[blockStack$1.length - 1].localVariableStatuses;
		if (this$5._isReachable) {
			statuses$0 = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
			if (statuses$0 != null) {
				if (this._lvStatusesOnBreak == null) {
					this._lvStatusesOnBreak = new LocalVariableStatuses$0(statuses$0);
				} else {
					this._lvStatusesOnBreak = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(this._lvStatusesOnBreak, statuses$0);
				}
			}
		}
		if (! hasDefaultLabel) {
			statuses$1 = (blockStack$2 = context.blockStack)[blockStack$2.length - 2].localVariableStatuses;
			if (statuses$1 != null) {
				if (this._lvStatusesOnBreak == null) {
					this._lvStatusesOnBreak = new LocalVariableStatuses$0(statuses$1);
				} else {
					this._lvStatusesOnBreak = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(this._lvStatusesOnBreak, statuses$1);
				}
			}
		}
		this._finalizeBlockAnalysis$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			this._abortBlockAnalysis$LAnalysisContext$(context);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	return true;
};


SwitchStatement.prototype.forEachStatement$F$LStatement$F$LStatement$V$B$ = function (cb) {
	return (! Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$(cb, this._statements) ? false : true);
};


SwitchStatement.prototype.handleStatements$F$ALStatement$B$ = function (cb) {
	return (! cb(this._statements) ? false : true);
};


SwitchStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function SwitchStatement$resetLocalVariableStatuses$LAnalysisContext$(context) {
	var this$0;
	var blockStack$0;
	(blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses = (this$0 = blockStack$0[blockStack$0.length - 2].localVariableStatuses, new LocalVariableStatuses$0(this$0));
};

SwitchStatement.resetLocalVariableStatuses$LAnalysisContext$ = SwitchStatement$resetLocalVariableStatuses$LAnalysisContext$;

function ContinuableStatement(token, label, statements) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
	this._lvStatusesOnContinue = null;
	this._statements = statements;
};

$__jsx_extend([ContinuableStatement], LabellableStatement);
ContinuableStatement.prototype.getStatements$ = function () {
	return this._statements;
};


ContinuableStatement.prototype.forEachStatement$F$LStatement$F$LStatement$V$B$ = function (cb) {
	return (! Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$(cb, this._statements) ? false : true);
};


ContinuableStatement.prototype.handleStatements$F$ALStatement$B$ = function (cb) {
	return (! cb(this._statements) ? false : true);
};


ContinuableStatement.prototype._prepareBlockAnalysis$LAnalysisContext$ = function (context) {
	LabellableStatement.prototype._prepareBlockAnalysis$LAnalysisContext$.call(this, context);
	this._lvStatusesOnContinue = null;
};


ContinuableStatement.prototype._abortBlockAnalysis$LAnalysisContext$ = function (context) {
	LabellableStatement.prototype._abortBlockAnalysis$LAnalysisContext$.call(this, context);
	this._lvStatusesOnContinue = null;
};


ContinuableStatement.prototype._finalizeBlockAnalysis$LAnalysisContext$ = function (context) {
	LabellableStatement.prototype._finalizeBlockAnalysis$LAnalysisContext$.call(this, context);
	ContinuableStatement$_restoreContinueVariableStatuses$LContinuableStatement$LAnalysisContext$(this, context);
};


ContinuableStatement.prototype._restoreContinueVariableStatuses$LAnalysisContext$ = function (context) {
	var blockStack$0;
	if (this._lvStatusesOnContinue != null) {
		(blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(blockStack$0[blockStack$0.length - 1].localVariableStatuses, this._lvStatusesOnContinue);
		this._lvStatusesOnContinue = null;
	}
};


function ContinuableStatement$_restoreContinueVariableStatuses$LContinuableStatement$LAnalysisContext$($this, context) {
	var blockStack$0;
	if ($this._lvStatusesOnContinue != null) {
		(blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(blockStack$0[blockStack$0.length - 1].localVariableStatuses, $this._lvStatusesOnContinue);
		$this._lvStatusesOnContinue = null;
	}
};

ContinuableStatement._restoreContinueVariableStatuses$LContinuableStatement$LAnalysisContext$ = ContinuableStatement$_restoreContinueVariableStatuses$LContinuableStatement$LAnalysisContext$;

ContinuableStatement.prototype.registerVariableStatusesOnContinue$LLocalVariableStatuses$ = function (statuses) {
	if (statuses != null) {
		if (this._lvStatusesOnContinue == null) {
			this._lvStatusesOnContinue = new LocalVariableStatuses$0(statuses);
		} else {
			this._lvStatusesOnContinue = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(this._lvStatusesOnContinue, statuses);
		}
	}
};


function ContinuableStatement$registerVariableStatusesOnContinue$LContinuableStatement$LLocalVariableStatuses$($this, statuses) {
	if (statuses != null) {
		if ($this._lvStatusesOnContinue == null) {
			$this._lvStatusesOnContinue = new LocalVariableStatuses$0(statuses);
		} else {
			$this._lvStatusesOnContinue = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$($this._lvStatusesOnContinue, statuses);
		}
	}
};

ContinuableStatement.registerVariableStatusesOnContinue$LContinuableStatement$LLocalVariableStatuses$ = ContinuableStatement$registerVariableStatusesOnContinue$LContinuableStatement$LLocalVariableStatuses$;

function WhileStatement(token, label, expr, statements) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
	this._lvStatusesOnContinue = null;
	this._statements = statements;
	this._expr = expr;
};

$__jsx_extend([WhileStatement], ContinuableStatement);
WhileStatement.prototype.clone$ = function () {
	return new WhileStatement(this._token, this._label, this._expr.clone$(), Util$cloneArray$ALStatement$(this._statements));
};


WhileStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function WhileStatement$getExpr$LWhileStatement$($this) {
	return $this._expr;
};

WhileStatement.getExpr$LWhileStatement$ = WhileStatement$getExpr$LWhileStatement$;

WhileStatement.prototype.getStatements$ = function () {
	return this._statements;
};


WhileStatement.prototype.serialize$ = function () {
	var v$0$0;
	return [ "WhileStatement" ].concat([ (v$0$0 = this._label, v$0$0 == null ? null : [ v$0$0._value, v$0$0._isIdentifier, v$0$0._filename, v$0$0._lineNumber, v$0$0._columnNumber ]) ]).concat([ this._expr.serialize$(), Util$serializeArray$ALStatement$(this._statements) ]);
};


WhileStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var i;
	var this$0;
	var statuses$0;
	var this$1;
	var this$0$0;
	var blockStack$0;
	if (Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		if ((this$1 = this._expr.getType$(), this$1 instanceof NullableType ? (this$0$0 = this$1, this$0$0._baseType) : this$1).equals$LType$(Type.voidType)) {
			context.errors.push(new CompileError((this$0 = this._expr, this$0._token), "expression of the while statement should not return void"));
		}
	}
	this._prepareBlockAnalysis$LAnalysisContext$(context);
	try {
		for (i = 0; i < this._statements.length; ++i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._statements[i], context)) {
				return false;
			}
		}
		statuses$0 = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
		if (statuses$0 != null) {
			if (this._lvStatusesOnContinue == null) {
				this._lvStatusesOnContinue = new LocalVariableStatuses$0(statuses$0);
			} else {
				this._lvStatusesOnContinue = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(this._lvStatusesOnContinue, statuses$0);
			}
		}
		this._finalizeBlockAnalysis$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			this._abortBlockAnalysis$LAnalysisContext$(context);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	return true;
};


WhileStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function ForStatement(token, label, initExpr, condExpr, postExpr, statements) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
	this._lvStatusesOnContinue = null;
	this._statements = statements;
	this._initExpr = initExpr;
	this._condExpr = condExpr;
	this._postExpr = postExpr;
};

$__jsx_extend([ForStatement], ContinuableStatement);
ForStatement.prototype.clone$ = function () {
	var o$0;
	var o$1;
	var o$2;
	return new ForStatement(this._token, this._label, (o$0 = this._initExpr, o$0 == null ? null : o$0.clone$()), (o$1 = this._condExpr, o$1 == null ? null : o$1.clone$()), (o$2 = this._postExpr, o$2 == null ? null : o$2.clone$()), Util$cloneArray$ALStatement$(this._statements));
};


ForStatement.prototype.getInitExpr$ = function () {
	return this._initExpr;
};


function ForStatement$getInitExpr$LForStatement$($this) {
	return $this._initExpr;
};

ForStatement.getInitExpr$LForStatement$ = ForStatement$getInitExpr$LForStatement$;

ForStatement.prototype.setInitExpr$LExpression$ = function (expr) {
	this._initExpr = expr;
};


function ForStatement$setInitExpr$LForStatement$LExpression$($this, expr) {
	$this._initExpr = expr;
};

ForStatement.setInitExpr$LForStatement$LExpression$ = ForStatement$setInitExpr$LForStatement$LExpression$;

ForStatement.prototype.getCondExpr$ = function () {
	return this._condExpr;
};


function ForStatement$getCondExpr$LForStatement$($this) {
	return $this._condExpr;
};

ForStatement.getCondExpr$LForStatement$ = ForStatement$getCondExpr$LForStatement$;

ForStatement.prototype.getPostExpr$ = function () {
	return this._postExpr;
};


function ForStatement$getPostExpr$LForStatement$($this) {
	return $this._postExpr;
};

ForStatement.getPostExpr$LForStatement$ = ForStatement$getPostExpr$LForStatement$;

ForStatement.prototype.getStatements$ = function () {
	return this._statements;
};


ForStatement.prototype.serialize$ = function () {
	var v$0$0;
	var v$0;
	var v$1;
	var v$2;
	return [ "ForStatement" ].concat([ (v$0$0 = this._label, v$0$0 == null ? null : [ v$0$0._value, v$0$0._isIdentifier, v$0$0._filename, v$0$0._lineNumber, v$0$0._columnNumber ]) ]).concat([ (v$0 = this._initExpr, v$0 == null ? null : v$0.serialize$()), (v$1 = this._condExpr, v$1 == null ? null : v$1.serialize$()), (v$2 = this._postExpr, v$2 == null ? null : v$2.serialize$()), Util$serializeArray$ALStatement$(this._statements) ]);
};


ForStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var i;
	var this$0;
	var this$1;
	var statuses$0;
	var this$2;
	var this$0$0;
	var blockStack$0;
	if (this._initExpr != null) {
		Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._initExpr);
	}
	if (this._condExpr != null) {
		if (Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._condExpr)) {
			if ((this$2 = this._condExpr.getType$(), this$2 instanceof NullableType ? (this$0$0 = this$2, this$0$0._baseType) : this$2).equals$LType$(Type.voidType)) {
				context.errors.push(new CompileError((this$0 = this._condExpr, this$0._token), "condition expression of the for statement should not return void"));
			}
		}
	}
	this._prepareBlockAnalysis$LAnalysisContext$(context);
	try {
		for (i = 0; i < this._statements.length; ++i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._statements[i], context)) {
				return false;
			}
		}
		ContinuableStatement$_restoreContinueVariableStatuses$LContinuableStatement$LAnalysisContext$(this, context);
		if (this._postExpr != null) {
			if (! Statement$assertIsReachable$LAnalysisContext$LToken$(context, (this$1 = this._postExpr, this$1._token))) {
				return false;
			}
			Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._postExpr);
		}
		statuses$0 = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
		if (statuses$0 != null) {
			if (this._lvStatusesOnBreak == null) {
				this._lvStatusesOnBreak = new LocalVariableStatuses$0(statuses$0);
			} else {
				this._lvStatusesOnBreak = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(this._lvStatusesOnBreak, statuses$0);
			}
		}
		this._finalizeBlockAnalysis$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			this._abortBlockAnalysis$LAnalysisContext$(context);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	return true;
};


ForStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (this._initExpr != null && ! cb(this._initExpr, (function (expr) {
		$this._initExpr = expr;
	})) ? false : this._condExpr != null && ! cb(this._condExpr, (function (expr) {
		$this._condExpr = expr;
	})) ? false : this._postExpr != null && ! cb(this._postExpr, (function (expr) {
		$this._postExpr = expr;
	})) ? false : true);
};


function ForInStatement(token, label, lhsExpr, listExpr, statements) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
	this._lvStatusesOnContinue = null;
	this._statements = statements;
	this._lhsExpr = lhsExpr;
	this._listExpr = listExpr;
};

$__jsx_extend([ForInStatement], ContinuableStatement);
ForInStatement.prototype.clone$ = function () {
	return new ForInStatement(this._token, this._label, this._lhsExpr.clone$(), this._listExpr.clone$(), Util$cloneArray$ALStatement$(this._statements));
};


ForInStatement.prototype.getLHSExpr$ = function () {
	return this._lhsExpr;
};


function ForInStatement$getLHSExpr$LForInStatement$($this) {
	return $this._lhsExpr;
};

ForInStatement.getLHSExpr$LForInStatement$ = ForInStatement$getLHSExpr$LForInStatement$;

ForInStatement.prototype.getListExpr$ = function () {
	return this._listExpr;
};


function ForInStatement$getListExpr$LForInStatement$($this) {
	return $this._listExpr;
};

ForInStatement.getListExpr$LForInStatement$ = ForInStatement$getListExpr$LForInStatement$;

ForInStatement.prototype.getStatements$ = function () {
	return this._statements;
};


ForInStatement.prototype.serialize$ = function () {
	var v$0$0;
	return [ "ForInStatement" ].concat([ (v$0$0 = this._label, v$0$0 == null ? null : [ v$0$0._value, v$0$0._isIdentifier, v$0$0._filename, v$0$0._lineNumber, v$0$0._columnNumber ]) ]).concat([ this._lhsExpr.serialize$(), this._listExpr.serialize$(), Util$serializeArray$ALStatement$(this._statements) ]);
};


ForInStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var listType;
	var listClassDef;
	var listTypeName;
	var i;
	var this$0;
	var this$0$0;
	var statuses$0;
	var this$1;
	var this$0$1;
	var blockStack$0;
	if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._listExpr)) {
		return true;
	}
	this$0 = this._listExpr.getType$();
	listType = (this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0);
	if (listType instanceof ObjectType && (listClassDef = listType.getClassDef$()) instanceof InstantiatedClassDefinition && ((listTypeName = (this$1 = listClassDef, this$0$1 = this$1._templateClassDef, this$0$1._className)) === "Array" || listTypeName === "Map")) {
	} else {
		context.errors.push(new CompileError(this._token, "list expression of the for..in statement should be an array or a map"));
		return true;
	}
	this._prepareBlockAnalysis$LAnalysisContext$(context);
	try {
		Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._lhsExpr);
		if (! this._lhsExpr.assertIsAssignable$LAnalysisContext$LToken$LType$(context, this._token, listTypeName === "Array" ? Type.numberType : Type.stringType)) {
			return false;
		}
		for (i = 0; i < this._statements.length; ++i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._statements[i], context)) {
				return false;
			}
		}
		statuses$0 = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
		if (statuses$0 != null) {
			if (this._lvStatusesOnContinue == null) {
				this._lvStatusesOnContinue = new LocalVariableStatuses$0(statuses$0);
			} else {
				this._lvStatusesOnContinue = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(this._lvStatusesOnContinue, statuses$0);
			}
		}
		this._finalizeBlockAnalysis$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			this._abortBlockAnalysis$LAnalysisContext$(context);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	return true;
};


ForInStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._lhsExpr, (function (expr) {
		$this._lhsExpr = expr;
	})) ? false : ! cb(this._listExpr, (function (expr) {
		$this._listExpr = expr;
	})) ? false : true);
};


function DoWhileStatement(token, label, expr, statements) {
	this._stash = {};
	this._lvStatusesOnBreak = null;
	this._token = token;
	this._label = label;
	this._lvStatusesOnContinue = null;
	this._statements = statements;
	this._expr = expr;
};

$__jsx_extend([DoWhileStatement], ContinuableStatement);
DoWhileStatement.prototype.clone$ = function () {
	return new DoWhileStatement(this._token, this._label, this._expr.clone$(), Util$cloneArray$ALStatement$(this._statements));
};


DoWhileStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function DoWhileStatement$getExpr$LDoWhileStatement$($this) {
	return $this._expr;
};

DoWhileStatement.getExpr$LDoWhileStatement$ = DoWhileStatement$getExpr$LDoWhileStatement$;

DoWhileStatement.prototype.serialize$ = function () {
	var v$0$0;
	return [ "DoWhileStatement" ].concat([ (v$0$0 = this._label, v$0$0 == null ? null : [ v$0$0._value, v$0$0._isIdentifier, v$0$0._filename, v$0$0._lineNumber, v$0$0._columnNumber ]) ]).concat([ this._expr.serialize$(), Util$serializeArray$ALStatement$(this._statements) ]);
};


DoWhileStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var i;
	var this$0;
	var this$1;
	var statuses$0;
	var this$2;
	var this$0$0;
	var blockStack$0;
	this._prepareBlockAnalysis$LAnalysisContext$(context);
	try {
		for (i = 0; i < this._statements.length; ++i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._statements[i], context)) {
				return false;
			}
		}
		ContinuableStatement$_restoreContinueVariableStatuses$LContinuableStatement$LAnalysisContext$(this, context);
		if (! Statement$assertIsReachable$LAnalysisContext$LToken$(context, (this$0 = this._expr, this$0._token))) {
			return false;
		}
		if (Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
			if ((this$2 = this._expr.getType$(), this$2 instanceof NullableType ? (this$0$0 = this$2, this$0$0._baseType) : this$2).equals$LType$(Type.voidType)) {
				context.errors.push(new CompileError((this$1 = this._expr, this$1._token), "expression of the do-while statement should not return void"));
			}
		}
		statuses$0 = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
		if (statuses$0 != null) {
			if (this._lvStatusesOnBreak == null) {
				this._lvStatusesOnBreak = new LocalVariableStatuses$0(statuses$0);
			} else {
				this._lvStatusesOnBreak = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(this._lvStatusesOnBreak, statuses$0);
			}
		}
		this._finalizeBlockAnalysis$LAnalysisContext$(context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			this._abortBlockAnalysis$LAnalysisContext$(context);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	return true;
};


DoWhileStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function JumpStatement(token, label) {
	this._stash = {};
	this._token = token;
	this._label = label;
};

$__jsx_extend([JumpStatement], Statement);
JumpStatement.prototype.getToken$ = function () {
	return this._token;
};


JumpStatement.prototype.getLabel$ = function () {
	return this._label;
};


function JumpStatement$getLabel$LJumpStatement$($this) {
	return $this._label;
};

JumpStatement.getLabel$LJumpStatement$ = JumpStatement$getLabel$LJumpStatement$;

JumpStatement.prototype.serialize$ = function () {
	var this$0;
	var v$0;
	return [ this._getName$(), (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), (v$0 = this._label, v$0 == null ? null : [ v$0._value, v$0._isIdentifier, v$0._filename, v$0._lineNumber, v$0._columnNumber ]) ];
};


JumpStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var targetBlock;
	var this$0;
	var statuses$0;
	var this$1;
	var statuses$1;
	var this$2;
	var blockStack$0;
	var blockStack$1;
	var blockStack$2;
	targetBlock = JumpStatement$_determineDestination$LJumpStatement$LAnalysisContext$(this, context);
	if (targetBlock == null) {
		return true;
	}
	if (this instanceof BreakStatement) {
		this$0 = targetBlock.block;
		statuses$0 = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
		if (statuses$0 != null) {
			if (this$0._lvStatusesOnBreak == null) {
				this$0._lvStatusesOnBreak = new LocalVariableStatuses$0(statuses$0);
			} else {
				this$0._lvStatusesOnBreak = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(this$0._lvStatusesOnBreak, statuses$0);
			}
		}
	} else {
		this$1 = targetBlock.block;
		statuses$1 = (blockStack$1 = context.blockStack)[blockStack$1.length - 1].localVariableStatuses;
		if (statuses$1 != null) {
			if (this$1._lvStatusesOnContinue == null) {
				this$1._lvStatusesOnContinue = new LocalVariableStatuses$0(statuses$1);
			} else {
				this$1._lvStatusesOnContinue = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$(this$1._lvStatusesOnContinue, statuses$1);
			}
		}
	}
	this$2 = (blockStack$2 = context.blockStack)[blockStack$2.length - 1].localVariableStatuses;
	this$2._isReachable = false;
	return true;
};


JumpStatement.prototype._determineDestination$LAnalysisContext$ = function (context) {
	var i;
	var statement;
	var statementLabel;
	var this$0;
	var this$1;
	var this$2;
	var this$5;
	var _label$0;
	var _token$0;
	for (i = context.blockStack.length - 1; ! (context.blockStack[i].block instanceof MemberFunctionDefinition); --i) {
		statement = context.blockStack[i].block;
		if (! (statement instanceof LabellableStatement)) {
			continue;
		}
		if (this._label != null) {
			this$0 = statement;
			statementLabel = this$0._label;
			if (statementLabel != null && statementLabel._value === (this$5 = this._label, this$5._value)) {
				if ((this$1 = this._token, this$1._value) === "continue" && statement instanceof SwitchStatement) {
					context.errors.push(new CompileError(this._token, "cannot 'continue' to a switch statement"));
					return null;
				}
			} else {
				continue;
			}
		} else if ((this$2 = this._token, this$2._value) === "continue" && statement instanceof SwitchStatement) {
			continue;
		}
		return context.blockStack[i];
	}
	if (this._label != null) {
		context.errors.push(new CompileError(_label$0 = this._label, "label '" + (_label$0, _label$0._value) + "' is either not defined or invalid as the destination"));
	} else {
		context.errors.push(new CompileError(_token$0 = this._token, "cannot '" + (_token$0, _token$0._value) + "' at this point"));
	}
	return null;
};


function JumpStatement$_determineDestination$LJumpStatement$LAnalysisContext$($this, context) {
	var i;
	var statement;
	var statementLabel;
	var this$0;
	var this$1;
	var this$2;
	var this$5;
	var _label$0;
	var _token$0;
	for (i = context.blockStack.length - 1; ! (context.blockStack[i].block instanceof MemberFunctionDefinition); --i) {
		statement = context.blockStack[i].block;
		if (! (statement instanceof LabellableStatement)) {
			continue;
		}
		if ($this._label != null) {
			this$0 = statement;
			statementLabel = this$0._label;
			if (statementLabel != null && statementLabel._value === (this$5 = $this._label, this$5._value)) {
				if ((this$1 = $this._token, this$1._value) === "continue" && statement instanceof SwitchStatement) {
					context.errors.push(new CompileError($this._token, "cannot 'continue' to a switch statement"));
					return null;
				}
			} else {
				continue;
			}
		} else if ((this$2 = $this._token, this$2._value) === "continue" && statement instanceof SwitchStatement) {
			continue;
		}
		return context.blockStack[i];
	}
	if ($this._label != null) {
		context.errors.push(new CompileError(_label$0 = $this._label, "label '" + (_label$0, _label$0._value) + "' is either not defined or invalid as the destination"));
	} else {
		context.errors.push(new CompileError(_token$0 = $this._token, "cannot '" + (_token$0, _token$0._value) + "' at this point"));
	}
	return null;
};

JumpStatement._determineDestination$LJumpStatement$LAnalysisContext$ = JumpStatement$_determineDestination$LJumpStatement$LAnalysisContext$;

JumpStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function ContinueStatement(token, label) {
	this._stash = {};
	this._token = token;
	this._label = label;
};

$__jsx_extend([ContinueStatement], JumpStatement);
ContinueStatement.prototype.clone$ = function () {
	return new ContinueStatement(this._token, this._label);
};


ContinueStatement.prototype._getName$ = function () {
	return "ContinueStatement";
};


ContinueStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function BreakStatement(token, label) {
	this._stash = {};
	this._token = token;
	this._label = label;
};

$__jsx_extend([BreakStatement], JumpStatement);
BreakStatement.prototype.clone$ = function () {
	return new BreakStatement(this._token, this._label);
};


BreakStatement.prototype._getName$ = function () {
	return "BreakStatement";
};


BreakStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function ReturnStatement(token, expr) {
	this._stash = {};
	this._token = token;
	this._expr = expr;
};

$__jsx_extend([ReturnStatement], Statement);
ReturnStatement.prototype.clone$ = function () {
	var o$0;
	return new ReturnStatement(this._token, (o$0 = this._expr, o$0 == null ? null : o$0.clone$()));
};


ReturnStatement.prototype.getToken$ = function () {
	return this._token;
};


ReturnStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function ReturnStatement$getExpr$LReturnStatement$($this) {
	return $this._expr;
};

ReturnStatement.getExpr$LReturnStatement$ = ReturnStatement$getExpr$LReturnStatement$;

ReturnStatement.prototype.setExpr$LExpression$ = function (expr) {
	this._expr = expr;
};


function ReturnStatement$setExpr$LReturnStatement$LExpression$($this, expr) {
	$this._expr = expr;
};

ReturnStatement.setExpr$LReturnStatement$LExpression$ = ReturnStatement$setExpr$LReturnStatement$LExpression$;

ReturnStatement.prototype.serialize$ = function () {
	var v$0;
	return [ "ReturnStatement", (v$0 = this._expr, v$0 == null ? null : v$0.serialize$()) ];
};


ReturnStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var returnType;
	var exprType;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var type$0;
	var this$4;
	var type$1;
	var this$5;
	var blockStack$0;
	this$0 = context.funcDef;
	if ((this$0._flags & 8192) !== 0) {
		context.errors.push(new CompileError(this._token, "return statement in generator is not allowed"));
		return true;
	}
	this$1 = context.funcDef;
	returnType = this$1._returnType;
	if (returnType == null) {
		if (this._expr != null) {
			if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
				return true;
			}
			exprType = this._expr.getType$();
			if (exprType == null) {
				return true;
			}
			this$2 = context.funcDef;
			this$2._returnType = exprType;
		} else {
			this$3 = context.funcDef;
			type$0 = Type.voidType;
			this$3._returnType = type$0;
		}
	} else if (returnType.equals$LType$(Type.voidType)) {
		if (this._expr != null) {
			if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
				return true;
			}
			exprType = this._expr.getType$();
			if (exprType == null) {
				return true;
			}
			if (! exprType.equals$LType$(Type.voidType)) {
				context.errors.push(new CompileError(this._token, "unmatched return type, expected a void expression"));
				return true;
			}
		}
	} else {
		if (this._expr == null) {
			context.errors.push(new CompileError(this._token, "cannot return void, the function is declared to return a value of type '" + returnType.toString() + "'"));
			return true;
		}
		if (this._expr instanceof FunctionExpression && ! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(this._expr) && returnType instanceof StaticFunctionType) {
			if (! (this$4 = this._expr, type$1 = returnType, ! MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$(this$4._funcDef, context, type$1) ? false : true)) {
				return false;
			}
		}
		if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
			return true;
		}
		exprType = this._expr.getType$();
		if (exprType == null) {
			return true;
		}
		if (! exprType.isConvertibleTo$LType$(returnType)) {
			context.errors.push(new CompileError(this._token, "cannot convert '" + exprType.toString() + "' to return type '" + returnType.toString() + "'"));
			return false;
		}
	}
	this$5 = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
	this$5._isReachable = false;
	return true;
};


ReturnStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (this._expr != null && ! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function FunctionStatement(token, funcDef) {
	this._stash = {};
	this._token = token;
	this._funcDef = funcDef;
};

$__jsx_extend([FunctionStatement], Statement);
FunctionStatement.prototype.clone$ = function () {
	return new FunctionStatement(this._token, this._funcDef);
};


FunctionStatement.prototype.getToken$ = function () {
	return this._token;
};


FunctionStatement.prototype.getFuncDef$ = function () {
	return this._funcDef;
};


function FunctionStatement$getFuncDef$LFunctionStatement$($this) {
	return $this._funcDef;
};

FunctionStatement.getFuncDef$LFunctionStatement$ = FunctionStatement$getFuncDef$LFunctionStatement$;

FunctionStatement.prototype.setFuncDef$LMemberFunctionDefinition$ = function (funcDef) {
	this._funcDef = funcDef;
};


function FunctionStatement$setFuncDef$LFunctionStatement$LMemberFunctionDefinition$($this, funcDef) {
	$this._funcDef = funcDef;
};

FunctionStatement.setFuncDef$LFunctionStatement$LMemberFunctionDefinition$ = FunctionStatement$setFuncDef$LFunctionStatement$LMemberFunctionDefinition$;

FunctionStatement.prototype.serialize$ = function () {
	return [ "FunctionStatement", this._funcDef.serialize$() ];
};


FunctionStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var returnType;
	var classDef;
	var this$0;
	var this$2;
	var type$0;
	var this$3;
	var local$0;
	var name$0;
	var this$0$0;
	var token$0;
	var typeArguments$0;
	var this$4;
	var this$5;
	var this$0$1;
	var _funcDef$0;
	var blockStack$0;
	if (! FunctionStatement$_typesAreIdentified$LFunctionStatement$(this)) {
		context.errors.push(new CompileError(this._token, "argument / return types were not automatically deductable, please specify them by hand"));
		return false;
	}
	this$0 = _funcDef$0 = this._funcDef;
	returnType = this$0._returnType;
	if ((_funcDef$0._flags & 8192) !== 0) {
		if (! (returnType instanceof ObjectType && (classDef = returnType.getClassDef$()) instanceof InstantiatedClassDefinition && (this$5 = classDef, this$0$1 = this$5._templateClassDef, this$0$1._className) === "Generator")) {
			this$2 = this._funcDef;
			type$0 = new ObjectType((token$0 = this._token, typeArguments$0 = [ Type.voidType, returnType ], Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: token$0, _className: "Generator", _typeArgs: typeArguments$0}), context.postInstantiationCallback)));
			this$2._returnType = type$0;
		}
	}
	MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$(this._funcDef, context);
	this$3 = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
	this$4 = this._funcDef;
	local$0 = this$4._funcLocal;
	this$0$0 = local$0._name;
	name$0 = this$0$0._value;
	if (this$3._statuses[name$0] == null) {
		throw new Error("logic flaw, could not find status for local variable: " + name$0);
	}
	this$3._statuses[name$0] = 1;
	return true;
};


FunctionStatement.prototype._typesAreIdentified$ = function () {
	var argTypes;
	var i;
	var this$0;
	var argTypes$0;
	var i$0;
	var this$0$0;
	var this$1;
	var argTypes$len$0;
	this$0 = this._funcDef;
	argTypes$0 = [];
	for (i$0 = 0; i$0 < this$0._args.length; ++i$0) {
		this$0$0 = this$0._args[i$0];
		argTypes$0[i$0] = this$0$0._type;
	}
	argTypes = argTypes$0;
	for ((i = 0, argTypes$len$0 = argTypes.length); i < argTypes$len$0; ++i) {
		if (argTypes[i] == null) {
			return false;
		}
	}
	return ((this$1 = this._funcDef, this$1._returnType) == null ? false : true);
};


function FunctionStatement$_typesAreIdentified$LFunctionStatement$($this) {
	var argTypes;
	var i;
	var this$0;
	var argTypes$0;
	var i$0;
	var this$0$0;
	var this$1;
	var argTypes$len$0;
	this$0 = $this._funcDef;
	argTypes$0 = [];
	for (i$0 = 0; i$0 < this$0._args.length; ++i$0) {
		this$0$0 = this$0._args[i$0];
		argTypes$0[i$0] = this$0$0._type;
	}
	argTypes = argTypes$0;
	for ((i = 0, argTypes$len$0 = argTypes.length); i < argTypes$len$0; ++i) {
		if (argTypes[i] == null) {
			return false;
		}
	}
	return ((this$1 = $this._funcDef, this$1._returnType) == null ? false : true);
};

FunctionStatement._typesAreIdentified$LFunctionStatement$ = FunctionStatement$_typesAreIdentified$LFunctionStatement$;

FunctionStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function UnaryExpressionStatement(expr) {
	this._stash = {};
	this._expr = null;
	if (expr == null) {
		throw new Error("logic flaw");
	}
	this._expr = expr;
};

$__jsx_extend([UnaryExpressionStatement], Statement);
UnaryExpressionStatement.prototype.getToken$ = function () {
	var this$0;
	this$0 = this._expr;
	return this$0._token;
};


UnaryExpressionStatement.prototype.getExpr$ = function () {
	return this._expr;
};


function UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$($this) {
	return $this._expr;
};

UnaryExpressionStatement.getExpr$LUnaryExpressionStatement$ = UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$;

UnaryExpressionStatement.prototype.setExpr$LExpression$ = function (expr) {
	this._expr = expr;
};


function UnaryExpressionStatement$setExpr$LUnaryExpressionStatement$LExpression$($this, expr) {
	$this._expr = expr;
};

UnaryExpressionStatement.setExpr$LUnaryExpressionStatement$LExpression$ = UnaryExpressionStatement$setExpr$LUnaryExpressionStatement$LExpression$;

UnaryExpressionStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr);
	return true;
};


UnaryExpressionStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : true);
};


function DeleteStatement(token, expr) {
	this._stash = {};
	this._expr = null;
	if (expr == null) {
		throw new Error("logic flaw");
	}
	this._expr = expr;
	this._token = token;
};

$__jsx_extend([DeleteStatement], UnaryExpressionStatement);
DeleteStatement.prototype.clone$ = function () {
	return new DeleteStatement(this._token, this._expr.clone$());
};


DeleteStatement.prototype.getToken$ = function () {
	return this._token;
};


DeleteStatement.prototype.serialize$ = function () {
	return [ "DeleteStatement", this._expr.serialize$() ];
};


DeleteStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var secondExprType;
	var this$0;
	var this$0$0;
	if (! Statement$_analyzeExpr$LStatement$LAnalysisContext$LExpression$(this, context, this._expr)) {
		return true;
	}
	if (! (this._expr instanceof ArrayExpression)) {
		context.errors.push(new CompileError(this._token, "only properties of a map object can be deleted"));
		return true;
	}
	secondExprType = (this$0 = this._expr, this$0._expr2).getType$();
	if (secondExprType == null) {
		return true;
	}
	if (! (secondExprType instanceof NullableType ? (this$0$0 = secondExprType, this$0$0._baseType) : secondExprType).equals$LType$(Type.stringType)) {
		context.errors.push(new CompileError(this._token, "only properties of a map object can be deleted"));
		return true;
	}
	return true;
};


function ExpressionStatement(expr) {
	this._stash = {};
	this._expr = null;
	if (expr == null) {
		throw new Error("logic flaw");
	}
	this._expr = expr;
};

$__jsx_extend([ExpressionStatement], UnaryExpressionStatement);
ExpressionStatement.prototype.clone$ = function () {
	return new ExpressionStatement(this._expr.clone$());
};


ExpressionStatement.prototype.serialize$ = function () {
	return [ "ExpressionStatement", this._expr.serialize$() ];
};


function ConstructorInvocationStatement(token, ctorClassType, args) {
	ConstructorInvocationStatement$0.call(this, token, ctorClassType, args, null);
};

function ConstructorInvocationStatement$0(token, ctorClassType, args, ctorFunctionType) {
	this._stash = {};
	this._token = token;
	this._ctorClassType = ctorClassType;
	this._args = args;
	this._ctorFunctionType = (ctorFunctionType != null ? ctorFunctionType : null);
};

$__jsx_extend([ConstructorInvocationStatement, ConstructorInvocationStatement$0], Statement);
ConstructorInvocationStatement.prototype.clone$ = function () {
	return new ConstructorInvocationStatement$0(this._token, this._ctorClassType, Util$cloneArray$ALExpression$(this._args), this._ctorFunctionType);
};


ConstructorInvocationStatement.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	if (this._ctorFunctionType != null) {
		throw new Error("instantiation after analysis?");
	}
	return new ConstructorInvocationStatement$0(this._token, this._ctorClassType.instantiate$LInstantiationContext$B(instantiationContext, false), Util$cloneArray$ALExpression$(this._args), null);
};


function ConstructorInvocationStatement$instantiate$LConstructorInvocationStatement$LInstantiationContext$($this, instantiationContext) {
	if ($this._ctorFunctionType != null) {
		throw new Error("instantiation after analysis?");
	}
	return new ConstructorInvocationStatement$0($this._token, $this._ctorClassType.instantiate$LInstantiationContext$B(instantiationContext, false), Util$cloneArray$ALExpression$($this._args), null);
};

ConstructorInvocationStatement.instantiate$LConstructorInvocationStatement$LInstantiationContext$ = ConstructorInvocationStatement$instantiate$LConstructorInvocationStatement$LInstantiationContext$;

ConstructorInvocationStatement.prototype.getToken$ = function () {
	return this._token;
};


ConstructorInvocationStatement.prototype.getArguments$ = function () {
	return this._args;
};


function ConstructorInvocationStatement$getArguments$LConstructorInvocationStatement$($this) {
	return $this._args;
};

ConstructorInvocationStatement.getArguments$LConstructorInvocationStatement$ = ConstructorInvocationStatement$getArguments$LConstructorInvocationStatement$;

ConstructorInvocationStatement.prototype.getConstructingClassDef$ = function () {
	return this._ctorClassType.getClassDef$();
};


function ConstructorInvocationStatement$getConstructingClassDef$LConstructorInvocationStatement$($this) {
	return $this._ctorClassType.getClassDef$();
};

ConstructorInvocationStatement.getConstructingClassDef$LConstructorInvocationStatement$ = ConstructorInvocationStatement$getConstructingClassDef$LConstructorInvocationStatement$;

ConstructorInvocationStatement.prototype.getConstructorType$ = function () {
	return this._ctorFunctionType;
};


function ConstructorInvocationStatement$getConstructorType$LConstructorInvocationStatement$($this) {
	return $this._ctorFunctionType;
};

ConstructorInvocationStatement.getConstructorType$LConstructorInvocationStatement$ = ConstructorInvocationStatement$getConstructorType$LConstructorInvocationStatement$;

ConstructorInvocationStatement.prototype.serialize$ = function () {
	var this$0;
	return [ "ConstructorInvocationStatement", (this$0 = this._ctorClassType, this$0.toString()), Util$serializeArray$ALExpression$(this._args) ];
};


ConstructorInvocationStatement.prototype.doAnalyze$LAnalysisContext$ = function (context) {
	var ctorType;
	var argTypes;
	var _args$0;
	ctorType = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(this._ctorClassType.getClassDef$(), context.errors, this._token, "constructor", false, [], 1);
	if (ctorType == null) {
		if (this._args.length !== 0) {
			context.errors.push(new CompileError(this._token, "no function with matching arguments"));
			return true;
		}
		ctorType = new MemberFunctionType(this._ctorClassType.getClassDef$().getToken$(), new ObjectType(this._ctorClassType.getClassDef$()), Type.voidType, [], false);
	} else {
		argTypes = Util$analyzeArgs$LAnalysisContext$ALExpression$LExpression$ALUtil$x2EArgumentTypeRequest$(context, _args$0 = this._args, null, ctorType.getExpectedTypes$NB(_args$0.length, false));
		if (argTypes == null) {
			return true;
		}
		if ((ctorType = ctorType.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, this._token, argTypes, false)) == null) {
			return true;
		}
	}
	this._ctorFunctionType = ctorType;
	return true;
};


ConstructorInvocationStatement.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return (! Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, this._args) ? false : true);
};


function Expression(token) {
	this._stash = {};
	this._token = token;
};

function Expression$0(that) {
	var k;
	this._stash = {};
	this._token = that._token;
	for (k in that._stash) {
		this._stash[k] = that._stash[k].clone$();
	}
};

$__jsx_extend([Expression, Expression$0], Object);
$__jsx_merge_interface(Expression, Stashable);

Expression.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var $this = this;
	var onExpr;
	function onExpr(expr) {
		var srcType;
		var propertyExpr;
		var srcTypes;
		var instanceofExpr;
		var this$0;
		var type$0;
		var this$1;
		var type$1;
		var type$2;
		var types$0;
		var this$2;
		var type$3;
		var this$3;
		var type$4;
		var this$4;
		var type$5;
		var this$5;
		var type$6;
		var this$6;
		var type$7;
		var this$7;
		var local$0;
		var type$8;
		var this$8;
		var this$0$0;
		var this$9;
		var _instantiated$0;
		if (expr instanceof NullExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$0 = expr;
				type$0 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$0._type = type$0;
			}
		} else if (expr instanceof NewExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$1 = expr;
				type$1 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$1._type = type$1;
			}
		} else if (expr instanceof PropertyExpression) {
			propertyExpr = expr;
			srcType = expr.getType$();
			if (srcType != null) {
				type$2 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				propertyExpr._type = type$2;
			}
			srcTypes = propertyExpr._typeArgs;
			if (srcTypes != null) {
				types$0 = srcTypes.map((function (type) {
					return type.instantiate$LInstantiationContext$B(instantiationContext, false);
				}));
				propertyExpr._typeArgs = types$0;
			}
		} else if (expr instanceof ArrayLiteralExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$2 = expr;
				type$3 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$2._type = type$3;
			}
		} else if (expr instanceof MapLiteralExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$3 = expr;
				type$4 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$3._type = type$4;
			}
		} else if (expr instanceof AsExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$4 = expr;
				type$5 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$4._type = type$5;
			}
		} else if (expr instanceof AsNoConvertExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$5 = expr;
				type$6 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$5._type = type$6;
			}
		} else if (expr instanceof ClassExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$6 = expr;
				type$7 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$6._parsedType = type$7;
			}
		} else if (expr instanceof LocalExpression) {
			this$7 = expr;
			this$9 = expr;
			this$8 = this$9._local;
			if (this$8._instantiated.length === 0) {
				throw new Error("logic flaw, no instantiation for " + (this$0$0 = this$8._name, this$0$0._value) + "," + (this$8.isInstantiated + ""));
			}
			local$0 = (_instantiated$0 = this$8._instantiated)[_instantiated$0.length - 1];
			this$7._local = local$0;
		} else if (expr instanceof InstanceofExpression) {
			instanceofExpr = expr;
			type$8 = instanceofExpr._expectedType.instantiate$LInstantiationContext$B(instantiationContext, false);
			instanceofExpr._expectedType = type$8;
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}
	return onExpr(this);
};


function Expression$instantiate$LExpression$LInstantiationContext$($this, instantiationContext) {
	var onExpr;
	function onExpr(expr) {
		var srcType;
		var propertyExpr;
		var srcTypes;
		var instanceofExpr;
		var this$0;
		var type$0;
		var this$1;
		var type$1;
		var type$2;
		var types$0;
		var this$2;
		var type$3;
		var this$3;
		var type$4;
		var this$4;
		var type$5;
		var this$5;
		var type$6;
		var this$6;
		var type$7;
		var this$7;
		var local$0;
		var type$8;
		var this$8;
		var this$0$0;
		var this$9;
		var _instantiated$0;
		if (expr instanceof NullExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$0 = expr;
				type$0 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$0._type = type$0;
			}
		} else if (expr instanceof NewExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$1 = expr;
				type$1 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$1._type = type$1;
			}
		} else if (expr instanceof PropertyExpression) {
			propertyExpr = expr;
			srcType = expr.getType$();
			if (srcType != null) {
				type$2 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				propertyExpr._type = type$2;
			}
			srcTypes = propertyExpr._typeArgs;
			if (srcTypes != null) {
				types$0 = srcTypes.map((function (type) {
					return type.instantiate$LInstantiationContext$B(instantiationContext, false);
				}));
				propertyExpr._typeArgs = types$0;
			}
		} else if (expr instanceof ArrayLiteralExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$2 = expr;
				type$3 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$2._type = type$3;
			}
		} else if (expr instanceof MapLiteralExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$3 = expr;
				type$4 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$3._type = type$4;
			}
		} else if (expr instanceof AsExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$4 = expr;
				type$5 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$4._type = type$5;
			}
		} else if (expr instanceof AsNoConvertExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$5 = expr;
				type$6 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$5._type = type$6;
			}
		} else if (expr instanceof ClassExpression) {
			srcType = expr.getType$();
			if (srcType != null) {
				this$6 = expr;
				type$7 = srcType.instantiate$LInstantiationContext$B(instantiationContext, false);
				this$6._parsedType = type$7;
			}
		} else if (expr instanceof LocalExpression) {
			this$7 = expr;
			this$9 = expr;
			this$8 = this$9._local;
			if (this$8._instantiated.length === 0) {
				throw new Error("logic flaw, no instantiation for " + (this$0$0 = this$8._name, this$0$0._value) + "," + (this$8.isInstantiated + ""));
			}
			local$0 = (_instantiated$0 = this$8._instantiated)[_instantiated$0.length - 1];
			this$7._local = local$0;
		} else if (expr instanceof InstanceofExpression) {
			instanceofExpr = expr;
			type$8 = instanceofExpr._expectedType.instantiate$LInstantiationContext$B(instantiationContext, false);
			instanceofExpr._expectedType = type$8;
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}
	return onExpr($this);
};

Expression.instantiate$LExpression$LInstantiationContext$ = Expression$instantiate$LExpression$LInstantiationContext$;

Expression.prototype.getToken$ = function () {
	return this._token;
};


function Expression$getToken$LExpression$($this) {
	return $this._token;
};

Expression.getToken$LExpression$ = Expression$getToken$LExpression$;

Expression.prototype.getHolderType$ = function () {
	return null;
};


Expression.prototype.isClassSpecifier$ = function () {
	return false;
};


Expression.prototype.forEachExpression$F$LExpression$B$ = function (cb) {
	var $this = this;
	return this.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, _) {
		return cb(expr);
	}));
};


function Expression$forEachExpression$LExpression$F$LExpression$B$($this, cb) {
	return $this.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, _) {
		return cb(expr);
	}));
};

Expression.forEachExpression$LExpression$F$LExpression$B$ = Expression$forEachExpression$LExpression$F$LExpression$B$;

Expression.prototype.assertIsAssignable$LAnalysisContext$LToken$LType$ = function (context, token, type) {
	context.errors.push(new CompileError(token, "left-hand-side expression is not assignable"));
	return false;
};


function Expression$assertIsAssignable$LAnalysisContext$LToken$LType$LType$(context, token, lhsType, rhsType) {
	if (! lhsType.isAssignable$()) {
		context.errors.push(new CompileError(token, "left-hand-side expression is not assignable"));
		return false;
	}
	if (! rhsType.isConvertibleTo$LType$(lhsType)) {
		context.errors.push(new CompileError(token, "cannot assign a value of type '" + rhsType.toString() + "' to '" + lhsType.toString() + "'"));
		return false;
	}
	return true;
};

Expression.assertIsAssignable$LAnalysisContext$LToken$LType$LType$ = Expression$assertIsAssignable$LAnalysisContext$LToken$LType$LType$;

Expression.prototype.hasSideEffects$ = function () {
	var $this = this;
	var preCheckCb$0;
	var r$0;
	preCheckCb$0 = (function (expr) {
		return null;
	});
	r$0 = preCheckCb$0(this);
	return (r$0 != null ? r$0 : this._doHasSideEffects$F$LExpression$UB$(preCheckCb$0));
};


function Expression$hasSideEffects$LExpression$($this) {
	var preCheckCb$0;
	var r$0;
	preCheckCb$0 = (function (expr) {
		return null;
	});
	r$0 = preCheckCb$0($this);
	return (r$0 != null ? r$0 : $this._doHasSideEffects$F$LExpression$UB$(preCheckCb$0));
};

Expression.hasSideEffects$LExpression$ = Expression$hasSideEffects$LExpression$;

Expression.prototype.hasSideEffects$F$LExpression$UB$ = function (preCheckCb) {
	var r;
	r = preCheckCb(this);
	return (r != null ? r : this._doHasSideEffects$F$LExpression$UB$(preCheckCb));
};


function Expression$hasSideEffects$LExpression$F$LExpression$UB$($this, preCheckCb) {
	var r;
	r = preCheckCb($this);
	return (r != null ? r : $this._doHasSideEffects$F$LExpression$UB$(preCheckCb));
};

Expression.hasSideEffects$LExpression$F$LExpression$UB$ = Expression$hasSideEffects$LExpression$F$LExpression$UB$;

Expression.prototype._doHasSideEffects$F$LExpression$UB$ = function (preCheckCb) {
	var $this = this;
	return ! Expression$forEachExpression$LExpression$F$LExpression$B$(this, (function (expr) {
		var r$0;
		return ! (r$0 = preCheckCb(expr), r$0 != null ? r$0 : expr._doHasSideEffects$F$LExpression$UB$(preCheckCb));
	}));
};


function Expression$getDefaultValueExpressionOf$LType$(type) {
	return (type.equals$LType$(Type.booleanType) ? new BooleanLiteralExpression(new Token$2("false", false)) : type.equals$LType$(Type.integerType) ? new IntegerLiteralExpression(new Token$2("0", false)) : type.equals$LType$(Type.numberType) ? new NumberLiteralExpression(new Token$2("0", false)) : type.equals$LType$(Type.stringType) ? new StringLiteralExpression(new Token$2("\"\"", false)) : new NullExpression(new Token$2("null", false), type));
};

Expression.getDefaultValueExpressionOf$LType$ = Expression$getDefaultValueExpressionOf$LType$;

function CommaExpression(token, expr1, expr2) {
	this._stash = {};
	this._token = token;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([CommaExpression], Expression);
CommaExpression.prototype.clone$ = function () {
	return new CommaExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


CommaExpression.prototype.getFirstExpr$ = function () {
	return this._expr1;
};


function CommaExpression$getFirstExpr$LCommaExpression$($this) {
	return $this._expr1;
};

CommaExpression.getFirstExpr$LCommaExpression$ = CommaExpression$getFirstExpr$LCommaExpression$;

CommaExpression.prototype.getSecondExpr$ = function () {
	return this._expr2;
};


function CommaExpression$getSecondExpr$LCommaExpression$($this) {
	return $this._expr2;
};

CommaExpression.getSecondExpr$LCommaExpression$ = CommaExpression$getSecondExpr$LCommaExpression$;

CommaExpression.prototype.serialize$ = function () {
	return [ "CommaExpression", this._expr1.serialize$(), this._expr2.serialize$() ];
};


CommaExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return this._expr1.analyze$LAnalysisContext$LExpression$(context, this) && this._expr2.analyze$LAnalysisContext$LExpression$(context, this);
};


CommaExpression.prototype.getType$ = function () {
	return this._expr2.getType$();
};


CommaExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr1, (function (expr) {
		$this._expr1 = expr;
	})) ? false : ! cb(this._expr2, (function (expr) {
		$this._expr2 = expr;
	})) ? false : true);
};


function FunctionExpression(token, funcDef) {
	this._stash = {};
	this._token = token;
	this._funcDef = funcDef;
};

$__jsx_extend([FunctionExpression], Expression);
FunctionExpression.prototype.clone$ = function () {
	return new FunctionExpression(this._token, this._funcDef);
};


FunctionExpression.prototype.getFuncDef$ = function () {
	return this._funcDef;
};


function FunctionExpression$getFuncDef$LFunctionExpression$($this) {
	return $this._funcDef;
};

FunctionExpression.getFuncDef$LFunctionExpression$ = FunctionExpression$getFuncDef$LFunctionExpression$;

FunctionExpression.prototype.setFuncDef$LMemberFunctionDefinition$ = function (funcDef) {
	this._funcDef = funcDef;
};


function FunctionExpression$setFuncDef$LFunctionExpression$LMemberFunctionDefinition$($this, funcDef) {
	$this._funcDef = funcDef;
};

FunctionExpression.setFuncDef$LFunctionExpression$LMemberFunctionDefinition$ = FunctionExpression$setFuncDef$LFunctionExpression$LMemberFunctionDefinition$;

FunctionExpression.prototype.serialize$ = function () {
	return [ "FunctionExpression", this._funcDef.serialize$() ];
};


FunctionExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var returnType;
	var classDef;
	var this$0;
	var this$2;
	var type$0;
	var token$0;
	var typeArguments$0;
	var this$3;
	var this$0$0;
	var _funcDef$0;
	if (! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(this)) {
		context.errors.push(new CompileError(this._token, "argument types were not automatically deductable, please specify them by hand"));
		return false;
	}
	this$0 = _funcDef$0 = this._funcDef;
	returnType = this$0._returnType;
	if ((_funcDef$0._flags & 8192) !== 0) {
		if (returnType == null) {
			context.errors.push(new CompileError(this._token, "return type was not automatically deductable, please specify them by hand"));
			return false;
		} else if (! (returnType instanceof ObjectType && (classDef = returnType.getClassDef$()) instanceof InstantiatedClassDefinition && (this$3 = classDef, this$0$0 = this$3._templateClassDef, this$0$0._className) === "Generator")) {
			this$2 = this._funcDef;
			type$0 = new ObjectType((token$0 = this._token, typeArguments$0 = [ Type.voidType, returnType ], Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: token$0, _className: "Generator", _typeArgs: typeArguments$0}), context.postInstantiationCallback)));
			this$2._returnType = type$0;
		}
	}
	MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$(this._funcDef, context);
	return true;
};


FunctionExpression.prototype.getType$ = function () {
	return this._funcDef.getType$();
};


FunctionExpression.prototype.argumentTypesAreIdentified$ = function () {
	var argTypes;
	var i;
	var this$0;
	var argTypes$0;
	var i$0;
	var this$0$0;
	var argTypes$len$0;
	this$0 = this._funcDef;
	argTypes$0 = [];
	for (i$0 = 0; i$0 < this$0._args.length; ++i$0) {
		this$0$0 = this$0._args[i$0];
		argTypes$0[i$0] = this$0$0._type;
	}
	argTypes = argTypes$0;
	for ((i = 0, argTypes$len$0 = argTypes.length); i < argTypes$len$0; ++i) {
		if (argTypes[i] == null) {
			return false;
		}
	}
	return true;
};


function FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$($this) {
	var argTypes;
	var i;
	var this$0;
	var argTypes$0;
	var i$0;
	var this$0$0;
	var argTypes$len$0;
	this$0 = $this._funcDef;
	argTypes$0 = [];
	for (i$0 = 0; i$0 < this$0._args.length; ++i$0) {
		this$0$0 = this$0._args[i$0];
		argTypes$0[i$0] = this$0$0._type;
	}
	argTypes = argTypes$0;
	for ((i = 0, argTypes$len$0 = argTypes.length); i < argTypes$len$0; ++i) {
		if (argTypes[i] == null) {
			return false;
		}
	}
	return true;
};

FunctionExpression.argumentTypesAreIdentified$LFunctionExpression$ = FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$;

FunctionExpression.prototype.typesAreIdentified$ = function () {
	var this$0;
	return (! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(this) ? false : (this$0 = this._funcDef, this$0._returnType) == null ? false : true);
};


function FunctionExpression$typesAreIdentified$LFunctionExpression$($this) {
	var this$0;
	return (! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$($this) ? false : (this$0 = $this._funcDef, this$0._returnType) == null ? false : true);
};

FunctionExpression.typesAreIdentified$LFunctionExpression$ = FunctionExpression$typesAreIdentified$LFunctionExpression$;

FunctionExpression.prototype.deductTypeIfUnknown$LAnalysisContext$LResolvedFunctionType$ = function (context, type) {
	return (! MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$(this._funcDef, context, type) ? false : true);
};


function FunctionExpression$deductTypeIfUnknown$LFunctionExpression$LAnalysisContext$LResolvedFunctionType$($this, context, type) {
	return (! MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$($this._funcDef, context, type) ? false : true);
};

FunctionExpression.deductTypeIfUnknown$LFunctionExpression$LAnalysisContext$LResolvedFunctionType$ = FunctionExpression$deductTypeIfUnknown$LFunctionExpression$LAnalysisContext$LResolvedFunctionType$;

FunctionExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function MapLiteralExpression(token, elements, type) {
	this._stash = {};
	this._token = token;
	this._elements = elements;
	this._type = type;
};

$__jsx_extend([MapLiteralExpression], Expression);
MapLiteralExpression.prototype.clone$ = function () {
	var ret;
	var i;
	var this$0;
	var this$1;
	ret = new MapLiteralExpression(this._token, [], this._type);
	for (i = 0; i < this._elements.length; ++i) {
		ret._elements[i] = ({_key: (this$0 = this._elements[i], this$0._key), _expr: (this$1 = this._elements[i], this$1._expr).clone$()});
	}
	return ret;
};


MapLiteralExpression.prototype.getElements$ = function () {
	return this._elements;
};


function MapLiteralExpression$getElements$LMapLiteralExpression$($this) {
	return $this._elements;
};

MapLiteralExpression.getElements$LMapLiteralExpression$ = MapLiteralExpression$getElements$LMapLiteralExpression$;

MapLiteralExpression.prototype.getType$ = function () {
	return this._type;
};


MapLiteralExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function MapLiteralExpression$setType$LMapLiteralExpression$LType$($this, type) {
	$this._type = type;
};

MapLiteralExpression.setType$LMapLiteralExpression$LType$ = MapLiteralExpression$setType$LMapLiteralExpression$LType$;

MapLiteralExpression.prototype.serialize$ = function () {
	var this$0;
	var v$0;
	return [ "MapLiteralExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), Util$serializeArray$ALMapLiteralElement$(this._elements), (v$0 = this._type, v$0 == null ? null : v$0.toString()) ];
};


MapLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var $this = this;
	var succeeded;
	var i;
	var classDef;
	var expectedType;
	var elementType;
	var this$0;
	var this$1;
	var this$0$0;
	var this$2;
	var this$3;
	var this$0$1;
	var token$0;
	var typeArguments$0;
	var this$4;
	var this$5;
	var _type$0;
	var _type$1;
	succeeded = true;
	for (i = 0; i < this._elements.length; ++i) {
		if (! (this$4 = this._elements[i], this$4._expr).analyze$LAnalysisContext$LExpression$(context, this)) {
			succeeded = false;
		} else if ((this$0 = this._elements[i], this$0._expr).getType$().equals$LType$(Type.voidType)) {
			context.errors.push(new CompileError(this._token, "cannot assign void to a map"));
			succeeded = false;
		}
	}
	if (! succeeded) {
		return false;
	}
	if ((_type$1 = this._type) != null && _type$1 == Type.variantType) {
	} else if ((_type$0 = this._type) != null && _type$0 instanceof ObjectType) {
		classDef = this._type.getClassDef$();
		if (! (classDef instanceof InstantiatedClassDefinition && (this$1 = classDef, this$0$0 = this$1._templateClassDef, this$0$0._className) === "Map")) {
			context.errors.push(new CompileError(this._token, "specified type is not a map type"));
			return false;
		}
		this$2 = (this$5 = this._type, this$5._typeArguments)[0];
		expectedType = (this$2 instanceof PrimitiveType || this$2.equals$LType$(Type.voidType) ? new NullableType(this$2) : this$2);
		for (i = 0; i < this._elements.length; ++i) {
			elementType = (this$3 = this._elements[i], this$3._expr).getType$();
			if (! elementType.isConvertibleTo$LType$(expectedType)) {
				context.errors.push(new CompileError(this._token, "cannot assign '" + elementType.toString() + "' to a map of '" + expectedType.toString() + "'"));
				succeeded = false;
			}
		}
	} else if (this._type != null) {
		context.errors.push(new CompileError(this._token, "invalid type for a map literal"));
		return false;
	} else {
		elementType = Type$calcLeastCommonAncestor$ALType$B(this._elements.map((function (elt) {
			return elt._expr.getType$();
		})), true);
		if (elementType == null || elementType.equals$LType$(Type.nullType)) {
			context.errors.push(new CompileError(this._token, "could not deduce map type, please specify"));
			return false;
		}
		if (elementType.equals$LType$(Type.integerType)) {
			elementType = Type.numberType;
		}
		elementType = (elementType instanceof NullableType ? (this$0$1 = elementType, this$0$1._baseType) : elementType);
		this._type = new ObjectType((token$0 = this._token, typeArguments$0 = [ elementType ], Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: token$0, _className: "Map", _typeArgs: typeArguments$0}), context.postInstantiationCallback)));
	}
	return succeeded;
};


MapLiteralExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	var i;
	var this$0;
	for (i = 0; i < this._elements.length; ++i) {
		if (! cb((this$0 = this._elements[i], this$0._expr), (function (elements, index) {
			return (function (expr) {
				MapLiteralElement$setExpr$LMapLiteralElement$LExpression$(elements[index], expr);
			});
		})(this._elements, i))) {
			return false;
		}
	}
	return true;
};


function ArrayLiteralExpression(token, exprs, type) {
	this._stash = {};
	this._token = token;
	this._exprs = exprs;
	this._type = type;
};

$__jsx_extend([ArrayLiteralExpression], Expression);
ArrayLiteralExpression.prototype.clone$ = function () {
	return new ArrayLiteralExpression(this._token, Util$cloneArray$ALExpression$(this._exprs), this._type);
};


ArrayLiteralExpression.prototype.getExprs$ = function () {
	return this._exprs;
};


function ArrayLiteralExpression$getExprs$LArrayLiteralExpression$($this) {
	return $this._exprs;
};

ArrayLiteralExpression.getExprs$LArrayLiteralExpression$ = ArrayLiteralExpression$getExprs$LArrayLiteralExpression$;

ArrayLiteralExpression.prototype.getType$ = function () {
	return this._type;
};


ArrayLiteralExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function ArrayLiteralExpression$setType$LArrayLiteralExpression$LType$($this, type) {
	$this._type = type;
};

ArrayLiteralExpression.setType$LArrayLiteralExpression$LType$ = ArrayLiteralExpression$setType$LArrayLiteralExpression$LType$;

ArrayLiteralExpression.prototype.serialize$ = function () {
	var this$0;
	var v$0;
	return [ "ArrayLiteralExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), Util$serializeArray$ALExpression$(this._exprs), (v$0 = this._type, v$0 == null ? null : v$0.toString()) ];
};


ArrayLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var $this = this;
	var succeeded;
	var i;
	var classDef;
	var expectedType;
	var elementType;
	var this$0;
	var this$0$0;
	var this$1;
	var this$0$1;
	var token$0;
	var typeArguments$0;
	var this$2;
	succeeded = true;
	for (i = 0; i < this._exprs.length; ++i) {
		if (! this._exprs[i].analyze$LAnalysisContext$LExpression$(context, this)) {
			succeeded = false;
		} else if (this._exprs[i].getType$().equals$LType$(Type.voidType)) {
			context.errors.push(new CompileError(this._token, "cannot assign void to an array"));
			succeeded = false;
		}
	}
	if (! succeeded) {
		return false;
	}
	if (this._type != null) {
		if (this._type instanceof ObjectType && (classDef = this._type.getClassDef$()) instanceof InstantiatedClassDefinition && (this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) === "Array") {
		} else {
			context.errors.push(new CompileError(this._token, "the type specified after ':' is not an array type"));
			return false;
		}
		this$1 = (this$2 = this._type.getClassDef$(), this$2._typeArguments)[0];
		expectedType = (this$1 instanceof PrimitiveType || this$1.equals$LType$(Type.voidType) ? new NullableType(this$1) : this$1);
		for (i = 0; i < this._exprs.length; ++i) {
			elementType = this._exprs[i].getType$();
			if (! elementType.isConvertibleTo$LType$(expectedType)) {
				context.errors.push(new CompileError(this._token, "cannot assign '" + elementType.toString() + "' to an array of '" + expectedType.toString() + "'"));
				succeeded = false;
			}
		}
	} else {
		elementType = Type$calcLeastCommonAncestor$ALType$B(this._exprs.map((function (expr) {
			return expr.getType$();
		})), true);
		if (elementType == null || elementType.equals$LType$(Type.nullType)) {
			context.errors.push(new CompileError(this._token, "could not deduce array type, please specify"));
			return false;
		}
		elementType = (elementType instanceof NullableType ? (this$0$1 = elementType, this$0$1._baseType) : elementType);
		this._type = new ObjectType((token$0 = this._token, typeArguments$0 = [ elementType ], Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: token$0, _className: "Array", _typeArgs: typeArguments$0}), context.postInstantiationCallback)));
	}
	return succeeded;
};


ArrayLiteralExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return (! Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, this._exprs) ? false : true);
};


function OperatorExpression(token) {
	this._stash = {};
	this._token = token;
};

function OperatorExpression$0(that) {
	var k$0;
	this._stash = {};
	this._token = that._token;
	for (k$0 in that._stash) {
		this._stash[k$0] = that._stash[k$0].clone$();
	}
};

$__jsx_extend([OperatorExpression, OperatorExpression$0], Expression);
OperatorExpression.prototype.isConvertibleTo$LAnalysisContext$LExpression$LType$B = function (context, expr, type, mayUnbox) {
	var exprType;
	var this$0;
	var this$0$0;
	this$0 = expr.getType$();
	exprType = (this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0);
	return (mayUnbox && type instanceof PrimitiveType && exprType instanceof ObjectType && exprType.getClassDef$() == type.getClassDef$() ? true : exprType.isConvertibleTo$LType$(type));
};


function OperatorExpression$isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B($this, context, expr, type, mayUnbox) {
	var exprType;
	var this$0;
	var this$0$0;
	this$0 = expr.getType$();
	exprType = (this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0);
	return (mayUnbox && type instanceof PrimitiveType && exprType instanceof ObjectType && exprType.getClassDef$() == type.getClassDef$() ? true : exprType.isConvertibleTo$LType$(type));
};

OperatorExpression.isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B = OperatorExpression$isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B;

OperatorExpression.prototype.assertIsConvertibleTo$LAnalysisContext$LExpression$LType$B = function (context, expr, type, mayUnbox) {
	var _token$0;
	if (! OperatorExpression$isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, expr, type, mayUnbox)) {
		context.errors.push(new CompileError(_token$0 = this._token, "cannot apply operator '" + (_token$0, _token$0._value) + "' to type '" + expr.getType$().toString() + "'"));
		return false;
	}
	return true;
};


function OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B($this, context, expr, type, mayUnbox) {
	var _token$0;
	if (! OperatorExpression$isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B($this, context, expr, type, mayUnbox)) {
		context.errors.push(new CompileError(_token$0 = $this._token, "cannot apply operator '" + (_token$0, _token$0._value) + "' to type '" + expr.getType$().toString() + "'"));
		return false;
	}
	return true;
};

OperatorExpression.assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B = OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B;

function NewExpression(token, type, args) {
	this._stash = {};
	this._token = token;
	this._type = type;
	this._args = args;
	this._constructor = null;
};

function NewExpression$0(that) {
	var k$0$0;
	var a$0;
	var r$0;
	var i$0;
	this._stash = {};
	this._token = that._token;
	for (k$0$0 in that._stash) {
		this._stash[k$0$0] = that._stash[k$0$0].clone$();
	}
	this._type = that._type;
	a$0 = that._args;
	r$0 = [  ];
	for (i$0 = 0; i$0 < a$0.length; ++i$0) {
		r$0[i$0] = a$0[i$0].clone$();
	}
	this._args = r$0;
	this._constructor = that._constructor;
};

$__jsx_extend([NewExpression, NewExpression$0], OperatorExpression);
NewExpression.prototype.clone$ = function () {
	return new NewExpression$0(this);
};


NewExpression.prototype.getArguments$ = function () {
	return this._args;
};


function NewExpression$getArguments$LNewExpression$($this) {
	return $this._args;
};

NewExpression.getArguments$LNewExpression$ = NewExpression$getArguments$LNewExpression$;

NewExpression.prototype.serialize$ = function () {
	var this$0;
	var this$1;
	return [ "NewExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), (this$1 = this._type, this$1.toString()), Util$serializeArray$ALExpression$(this._args) ];
};


NewExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var classDef;
	var ctors;
	var argTypes;
	var _args$0;
	if (! (this._type instanceof ObjectType)) {
		context.errors.push(new CompileError(this._token, "cannot instantiate a non-object type: " + this._type.toString()));
		return false;
	}
	classDef = this._type.getClassDef$();
	if (classDef == null) {
		return false;
	}
	if ((classDef.flags$() & 192) !== 0) {
		context.errors.push(new CompileError(this._token, "cannot instantiate an interface or a mixin"));
		return false;
	}
	if ((classDef.flags$() & 2) !== 0) {
		context.errors.push(new CompileError(this._token, "cannot instantiate an abstract class"));
		return false;
	}
	ctors = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(classDef, context.errors, this._token, "constructor", false, [], 1);
	if (ctors == null) {
		context.errors.push(new CompileError(this._token, "the class cannot be instantiated"));
		return false;
	}
	argTypes = Util$analyzeArgs$LAnalysisContext$ALExpression$LExpression$ALUtil$x2EArgumentTypeRequest$(context, _args$0 = this._args, this, ctors.getExpectedTypes$NB(_args$0.length, false));
	if (argTypes == null) {
		return false;
	}
	if ((this._constructor = ctors.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, this._token, argTypes, false)) == null) {
		context.errors.push(new CompileError(this._token, "cannot create an object of type '" + this._type.toString() + "', arguments mismatch"));
		return false;
	}
	return true;
};


NewExpression.prototype.getType$ = function () {
	return this._type;
};


NewExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function NewExpression$setType$LNewExpression$LType$($this, type) {
	$this._type = type;
};

NewExpression.setType$LNewExpression$LType$ = NewExpression$setType$LNewExpression$LType$;

NewExpression.prototype.getConstructor$ = function () {
	return this._constructor;
};


function NewExpression$getConstructor$LNewExpression$($this) {
	return $this._constructor;
};

NewExpression.getConstructor$LNewExpression$ = NewExpression$getConstructor$LNewExpression$;

NewExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return (! Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, this._args) ? false : true);
};


NewExpression.prototype._doHasSideEffects$F$LExpression$UB$ = function (preCheckCb) {
	var classDef;
	var className;
	classDef = this._type.getClassDef$();
	className = classDef.className$().replace(/\.<.*/, "");
	switch (className) {
	case "Object":
	case "Map":
		return false;
	case "Array":
		return false;
	}
	return true;
};


function SuperExpression(token, name, args) {
	this._stash = {};
	this._token = token;
	this._name = name;
	this._args = args;
	this._funcType = null;
};

function SuperExpression$0(that) {
	var k$0$0;
	var a$0;
	var r$0;
	var i$0;
	this._stash = {};
	this._token = that._token;
	for (k$0$0 in that._stash) {
		this._stash[k$0$0] = that._stash[k$0$0].clone$();
	}
	this._name = that._name;
	a$0 = that._args;
	r$0 = [  ];
	for (i$0 = 0; i$0 < a$0.length; ++i$0) {
		r$0[i$0] = a$0[i$0].clone$();
	}
	this._args = r$0;
	this._funcType = that._funcType;
};

$__jsx_extend([SuperExpression, SuperExpression$0], OperatorExpression);
SuperExpression.prototype.clone$ = function () {
	return new SuperExpression$0(this);
};


SuperExpression.prototype.getName$ = function () {
	return this._name;
};


function SuperExpression$getName$LSuperExpression$($this) {
	return $this._name;
};

SuperExpression.getName$LSuperExpression$ = SuperExpression$getName$LSuperExpression$;

SuperExpression.prototype.getArguments$ = function () {
	return this._args;
};


function SuperExpression$getArguments$LSuperExpression$($this) {
	return $this._args;
};

SuperExpression.getArguments$LSuperExpression$ = SuperExpression$getArguments$LSuperExpression$;

SuperExpression.prototype.getFunctionType$ = function () {
	return this._funcType;
};


function SuperExpression$getFunctionType$LSuperExpression$($this) {
	return $this._funcType;
};

SuperExpression.getFunctionType$LSuperExpression$ = SuperExpression$getFunctionType$LSuperExpression$;

SuperExpression.prototype.serialize$ = function () {
	var this$0;
	var this$1;
	return [ "SuperExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), (this$1 = this._name, [ this$1._value, this$1._isIdentifier, this$1._filename, this$1._lineNumber, this$1._columnNumber ]), Util$serializeArray$ALExpression$(this._args) ];
};


SuperExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var classDef;
	var funcType;
	var argTypes;
	var this$0;
	var this$1;
	var this$2;
	var _args$0;
	if (((this$0 = context.funcDef, this$0._flags) & 8) !== 0) {
		context.errors.push(new CompileError(this._token, "cannot use 'super' keyword in a static function"));
		return false;
	}
	this$1 = context.funcDef;
	classDef = this$1._classDef;
	funcType = null;
	if ((funcType = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(classDef, context.errors, this._token, (this$2 = this._name, this$2._value), false, [], 2)) == null) {
		context.errors.push(new CompileError(this._token, "could not find a member function with given name in super classes of class '" + classDef.className$() + "'"));
		return false;
	}
	argTypes = Util$analyzeArgs$LAnalysisContext$ALExpression$LExpression$ALUtil$x2EArgumentTypeRequest$(context, _args$0 = this._args, this, funcType.getExpectedTypes$NB(_args$0.length, false));
	if (argTypes == null) {
		return false;
	}
	if ((funcType = funcType.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, this._token, argTypes, false)) == null) {
		return false;
	}
	this._funcType = funcType;
	return true;
};


SuperExpression.prototype.getType$ = function () {
	var this$0;
	this$0 = this._funcType;
	return this$0._returnType;
};


SuperExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return (! Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, this._args) ? false : true);
};


SuperExpression.prototype._doHasSideEffects$F$LExpression$UB$ = function (preCheckCb) {
	return true;
};


function CallExpression(token, expr, args) {
	this._stash = {};
	this._token = token;
	this._expr = expr;
	this._args = args;
};

function CallExpression$0(that) {
	var k$0$0;
	var a$0;
	var r$0;
	var i$0;
	this._stash = {};
	this._token = that._token;
	for (k$0$0 in that._stash) {
		this._stash[k$0$0] = that._stash[k$0$0].clone$();
	}
	this._expr = that._expr.clone$();
	a$0 = that._args;
	r$0 = [  ];
	for (i$0 = 0; i$0 < a$0.length; ++i$0) {
		r$0[i$0] = a$0[i$0].clone$();
	}
	this._args = r$0;
};

$__jsx_extend([CallExpression, CallExpression$0], OperatorExpression);
CallExpression.prototype.clone$ = function () {
	return new CallExpression$0(this);
};


CallExpression.prototype.getExpr$ = function () {
	return this._expr;
};


function CallExpression$getExpr$LCallExpression$($this) {
	return $this._expr;
};

CallExpression.getExpr$LCallExpression$ = CallExpression$getExpr$LCallExpression$;

CallExpression.prototype.setExpr$LExpression$ = function (expr) {
	this._expr = expr;
};


function CallExpression$setExpr$LCallExpression$LExpression$($this, expr) {
	$this._expr = expr;
};

CallExpression.setExpr$LCallExpression$LExpression$ = CallExpression$setExpr$LCallExpression$LExpression$;

CallExpression.prototype.getArguments$ = function () {
	return this._args;
};


function CallExpression$getArguments$LCallExpression$($this) {
	return $this._args;
};

CallExpression.getArguments$LCallExpression$ = CallExpression$getArguments$LCallExpression$;

CallExpression.prototype.serialize$ = function () {
	var this$0;
	return [ "CallExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), this._expr.serialize$(), Util$serializeArray$ALExpression$(this._args) ];
};


CallExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var exprType;
	var argTypes;
	var isCallingStatic;
	var this$0;
	var this$0$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var _args$0;
	if (! this._expr.analyze$LAnalysisContext$LExpression$(context, this)) {
		return false;
	}
	this$0 = this._expr.getType$();
	exprType = (this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0);
	if (! (exprType instanceof FunctionType)) {
		context.errors.push(new CompileError(this._token, "cannot call a non-function"));
		return false;
	}
	argTypes = Util$analyzeArgs$LAnalysisContext$ALExpression$LExpression$ALUtil$x2EArgumentTypeRequest$(context, _args$0 = this._args, this, exprType.getExpectedTypes$NB(_args$0.length, ! (this._expr instanceof PropertyExpression && ! exprType.isAssignable$() && ! (this$1 = this._expr, this$1._expr).isClassSpecifier$())));
	if (argTypes == null) {
		return false;
	}
	if (this._expr instanceof PropertyExpression && ! exprType.isAssignable$()) {
		isCallingStatic = (this$2 = this._expr, this$2._expr).isClassSpecifier$();
		if (! isCallingStatic && (this$4 = (this$3 = this._expr, this$3._identifierToken), this$4._value) === "constructor") {
			context.errors.push(new CompileError(this._token, "cannot call a constructor other than by using 'new'"));
			return false;
		}
		if (PropertyExpression$deduceByArgumentTypes$LPropertyExpression$LAnalysisContext$LToken$ALType$B(this._expr, context, this._token, argTypes, isCallingStatic) == null) {
			return false;
		}
	} else if (exprType.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, this._token, argTypes, true) == null) {
		return false;
	}
	return true;
};


CallExpression.prototype.getType$ = function () {
	var type;
	var this$0$0;
	var this$0;
	type = this._expr.getType$();
	return (type == null ? null : (this$0 = (type instanceof NullableType ? (this$0$0 = type, this$0$0._baseType) : type), this$0._returnType));
};


CallExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr, (function (expr) {
		$this._expr = expr;
	})) ? false : ! Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(cb, this._args) ? false : true);
};


CallExpression.prototype._doHasSideEffects$F$LExpression$UB$ = function (preCheckCb) {
	return true;
};


function ConditionalExpression(operatorToken, condExpr, ifTrueExpr, ifFalseExpr) {
	ConditionalExpression$0.call(this, operatorToken, condExpr, ifTrueExpr, ifFalseExpr, null);
};

function ConditionalExpression$0(operatorToken, condExpr, ifTrueExpr, ifFalseExpr, type) {
	this._stash = {};
	this._token = operatorToken;
	this._condExpr = condExpr;
	this._ifTrueExpr = ifTrueExpr;
	this._ifFalseExpr = ifFalseExpr;
	this._type = (type != null ? type : null);
};

$__jsx_extend([ConditionalExpression, ConditionalExpression$0], OperatorExpression);
ConditionalExpression.prototype.clone$ = function () {
	return new ConditionalExpression$0(this._token, this._condExpr.clone$(), this._ifTrueExpr != null ? this._ifTrueExpr.clone$() : null, this._ifFalseExpr.clone$(), this._type);
};


ConditionalExpression.prototype.getCondExpr$ = function () {
	return this._condExpr;
};


function ConditionalExpression$getCondExpr$LConditionalExpression$($this) {
	return $this._condExpr;
};

ConditionalExpression.getCondExpr$LConditionalExpression$ = ConditionalExpression$getCondExpr$LConditionalExpression$;

ConditionalExpression.prototype.setCondExpr$LExpression$ = function (expr) {
	this._condExpr = expr;
};


function ConditionalExpression$setCondExpr$LConditionalExpression$LExpression$($this, expr) {
	$this._condExpr = expr;
};

ConditionalExpression.setCondExpr$LConditionalExpression$LExpression$ = ConditionalExpression$setCondExpr$LConditionalExpression$LExpression$;

ConditionalExpression.prototype.getIfTrueExpr$ = function () {
	return this._ifTrueExpr;
};


function ConditionalExpression$getIfTrueExpr$LConditionalExpression$($this) {
	return $this._ifTrueExpr;
};

ConditionalExpression.getIfTrueExpr$LConditionalExpression$ = ConditionalExpression$getIfTrueExpr$LConditionalExpression$;

ConditionalExpression.prototype.getIfFalseExpr$ = function () {
	return this._ifFalseExpr;
};


function ConditionalExpression$getIfFalseExpr$LConditionalExpression$($this) {
	return $this._ifFalseExpr;
};

ConditionalExpression.getIfFalseExpr$LConditionalExpression$ = ConditionalExpression$getIfFalseExpr$LConditionalExpression$;

ConditionalExpression.prototype.serialize$ = function () {
	var this$0;
	var v$0;
	return [ "ConditionalExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), this._condExpr.serialize$(), (v$0 = this._ifTrueExpr, v$0 == null ? null : v$0.serialize$()), this._ifFalseExpr.serialize$() ];
};


ConditionalExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var typeIfTrue;
	var typeIfFalse;
	var _type$0;
	if (! this._condExpr.analyze$LAnalysisContext$LExpression$(context, this)) {
		return false;
	}
	if (this._ifTrueExpr != null && ! this._ifTrueExpr.analyze$LAnalysisContext$LExpression$(context, this)) {
		return false;
	}
	if (! this._ifFalseExpr.analyze$LAnalysisContext$LExpression$(context, this)) {
		return false;
	}
	if (this._condExpr.getType$().equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(this._token, "condition cannot be void"));
		return false;
	}
	if (this._ifTrueExpr != null) {
		typeIfTrue = this._ifTrueExpr.getType$();
	} else {
		typeIfTrue = this._condExpr.getType$();
	}
	typeIfFalse = this._ifFalseExpr.getType$();
	_type$0 = this._type = Type$calcLeastCommonAncestor$LType$LType$B(typeIfTrue, typeIfFalse, false);
	if (_type$0 == null) {
		context.errors.push(new CompileError(this._token, "could not get the join type of '" + typeIfTrue.toString() + "' and '" + typeIfFalse.toString() + "'"));
		return false;
	}
	return true;
};


ConditionalExpression.prototype.getType$ = function () {
	return this._type;
};


ConditionalExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._condExpr, (function (expr) {
		$this._condExpr = expr;
	})) ? false : this._ifTrueExpr != null && ! cb(this._ifTrueExpr, (function (expr) {
		$this._ifTrueExpr = expr;
	})) ? false : ! cb(this._ifFalseExpr, (function (expr) {
		$this._ifFalseExpr = expr;
	})) ? false : true);
};


function BinaryExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([BinaryExpression], OperatorExpression);
BinaryExpression.prototype.getFirstExpr$ = function () {
	return this._expr1;
};


function BinaryExpression$getFirstExpr$LBinaryExpression$($this) {
	return $this._expr1;
};

BinaryExpression.getFirstExpr$LBinaryExpression$ = BinaryExpression$getFirstExpr$LBinaryExpression$;

BinaryExpression.prototype.setFirstExpr$LExpression$ = function (expr) {
	this._expr1 = expr;
};


function BinaryExpression$setFirstExpr$LBinaryExpression$LExpression$($this, expr) {
	$this._expr1 = expr;
};

BinaryExpression.setFirstExpr$LBinaryExpression$LExpression$ = BinaryExpression$setFirstExpr$LBinaryExpression$LExpression$;

BinaryExpression.prototype.getSecondExpr$ = function () {
	return this._expr2;
};


function BinaryExpression$getSecondExpr$LBinaryExpression$($this) {
	return $this._expr2;
};

BinaryExpression.getSecondExpr$LBinaryExpression$ = BinaryExpression$getSecondExpr$LBinaryExpression$;

BinaryExpression.prototype.setSecondExpr$LExpression$ = function (expr) {
	this._expr2 = expr;
};


function BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$($this, expr) {
	$this._expr2 = expr;
};

BinaryExpression.setSecondExpr$LBinaryExpression$LExpression$ = BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$;

BinaryExpression.prototype.serialize$ = function () {
	var this$0;
	return [ "BinaryExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), this._expr1.serialize$(), this._expr2.serialize$() ];
};


BinaryExpression.prototype._analyze$LAnalysisContext$ = function (context) {
	return (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true);
};


function BinaryExpression$_analyze$LBinaryExpression$LAnalysisContext$($this, context) {
	return (! $this._expr1.analyze$LAnalysisContext$LExpression$(context, $this) ? false : ! $this._expr2.analyze$LAnalysisContext$LExpression$(context, $this) ? false : true);
};

BinaryExpression._analyze$LBinaryExpression$LAnalysisContext$ = BinaryExpression$_analyze$LBinaryExpression$LAnalysisContext$;

BinaryExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return (! cb(this._expr1, (function (expr) {
		$this._expr1 = expr;
	})) ? false : ! cb(this._expr2, (function (expr) {
		$this._expr2 = expr;
	})) ? false : true);
};


function ShiftExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([ShiftExpression], BinaryExpression);
ShiftExpression.prototype.clone$ = function () {
	return new ShiftExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


ShiftExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true) ? false : ! OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr1, Type.integerType, true) ? false : ! OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr2, Type.integerType, true) ? false : true);
};


ShiftExpression.prototype.getType$ = function () {
	return Type.integerType;
};


function LogicalExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([LogicalExpression], BinaryExpression);
LogicalExpression.prototype.clone$ = function () {
	return new LogicalExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


LogicalExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var this$2;
	var this$0$0;
	var this$3;
	var this$0$1;
	var _token$0;
	var _token$1;
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	if ((this$2 = this._expr1.getType$(), this$2 instanceof NullableType ? (this$0$0 = this$2, this$0$0._baseType) : this$2).equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(_token$0 = this._token, "left argument of operator '" + (_token$0, _token$0._value) + "' cannot be void"));
		return false;
	}
	if ((this$3 = this._expr2.getType$(), this$3 instanceof NullableType ? (this$0$1 = this$3, this$0$1._baseType) : this$3).equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(_token$1 = this._token, "right argument of operator '" + (_token$1, _token$1._value) + "' cannot be void"));
		return false;
	}
	return true;
};


LogicalExpression.prototype.getType$ = function () {
	return Type.booleanType;
};


function InExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([InExpression], BinaryExpression);
InExpression.prototype.clone$ = function () {
	return new InExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


InExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var expr2Type;
	var expr2ClassDef;
	var this$0;
	var this$0$0;
	var this$1;
	var this$0$1;
	var this$2;
	var this$0$2;
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	if (! (this$0 = this._expr1.getType$(), this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0).equals$LType$(Type.stringType)) {
		context.errors.push(new CompileError(this._token, "left operand of 'in' expression should be a string"));
		return false;
	}
	if ((expr2Type = (this$1 = this._expr2.getType$(), this$1 instanceof NullableType ? (this$0$1 = this$1, this$0$1._baseType) : this$1)) instanceof ObjectType && (expr2ClassDef = expr2Type.getClassDef$()) instanceof InstantiatedClassDefinition && (this$2 = expr2ClassDef, this$0$2 = this$2._templateClassDef, this$0$2._className) === "Map") {
	} else {
		context.errors.push(new CompileError(this._token, "right operand of 'in' expression should be a map"));
		return false;
	}
	return true;
};


InExpression.prototype.getType$ = function () {
	return Type.booleanType;
};


function EqualityExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([EqualityExpression], BinaryExpression);
EqualityExpression.prototype.clone$ = function () {
	return new EqualityExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


EqualityExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var $this = this;
	var bool;
	var expr1Type;
	var expr2Type;
	var this$0$0;
	var this$0$1;
	function bool(x) {
		return (x ? 1 : 0);
	}
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	expr1Type = this._expr1.getType$();
	expr2Type = this._expr2.getType$();
	if ((expr1Type instanceof NullableType ? (this$0$0 = expr1Type, this$0$0._baseType) : expr1Type).equals$LType$(expr2Type instanceof NullableType ? (this$0$1 = expr2Type, this$0$1._baseType) : expr2Type)) {
	} else if (expr1Type.isConvertibleTo$LType$(expr2Type) || expr2Type.isConvertibleTo$LType$(expr1Type)) {
	} else if (bool(expr1Type instanceof ObjectType) + bool(expr2Type instanceof ObjectType) === 1 && expr1Type.getClassDef$() == expr2Type.getClassDef$()) {
	} else {
		context.errors.push(new CompileError(this._token, "either side of operator == should be convertible from the other"));
		return false;
	}
	return true;
};


EqualityExpression.prototype.getType$ = function () {
	return Type.booleanType;
};


function BinaryNumberExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([BinaryNumberExpression], BinaryExpression);
BinaryNumberExpression.prototype.clone$ = function () {
	return new BinaryNumberExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


BinaryNumberExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var this$1;
	var _token$0;
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	switch ((this$1 = this._token, this$1._value)) {
	case "<":
	case "<=":
	case ">":
	case ">=":
		if (OperatorExpression$isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr1, Type.numberType, true)) {
			return OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr2, Type.numberType, true);
		}
		if (OperatorExpression$isConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr1, Type.stringType, true)) {
			return OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr2, Type.stringType, true);
		}
		context.errors.push(new CompileError(_token$0 = this._token, "cannot apply operator '" + (_token$0, _token$0._value) + "' to type '" + this._expr1.getType$().toString() + "'"));
		return false;
	default:
		if (! OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr1, Type.numberType, true)) {
			return false;
		}
		if (! OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr2, Type.numberType, true)) {
			return false;
		}
		return true;
	}
};


BinaryNumberExpression.prototype.getType$ = function () {
	var this$0;
	var this$0$0;
	var this$1;
	var this$0$1;
	var this$2;
	var this$3;
	switch ((this$3 = this._token, this$3._value)) {
	case "+":
	case "-":
	case "*":
		if ((this$0 = this._expr1.getType$(), this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0).equals$LType$(Type.numberType) || (this$1 = this._expr2.getType$(), this$1 instanceof NullableType ? (this$0$1 = this$1, this$0$1._baseType) : this$1).equals$LType$(Type.numberType)) {
			return Type.numberType;
		} else {
			return Type.integerType;
		}
	case "/":
	case "%":
		return Type.numberType;
	case "<":
	case "<=":
	case ">":
	case ">=":
		return Type.booleanType;
	case "&":
	case "|":
	case "^":
		return Type.integerType;
	default:
		throw new Error("unexpected operator:" + (this$2 = this._token, this$2._value));
	}
};


function FusedAssignmentExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([FusedAssignmentExpression], BinaryExpression);
FusedAssignmentExpression.prototype.clone$ = function () {
	return new FusedAssignmentExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


FusedAssignmentExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var lhsType;
	var rhsType;
	var this$0;
	var this$0$0;
	var this$1;
	var this$0$1;
	var this$2;
	var _token$0;
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	this$0 = this._expr1.getType$();
	lhsType = (this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0);
	this$1 = this._expr2.getType$();
	rhsType = (this$1 instanceof NullableType ? (this$0$1 = this$1, this$0$1._baseType) : this$1);
	if (! this._expr1.assertIsAssignable$LAnalysisContext$LToken$LType$(context, this._token, lhsType)) {
		return false;
	}
	if ((this$2 = this._token, this$2._value) === "+=" && lhsType.equals$LType$(Type.stringType) && rhsType.equals$LType$(Type.stringType)) {
		return true;
	}
	if ((lhsType instanceof IntegerType || lhsType instanceof NumberType) && (rhsType instanceof IntegerType || rhsType instanceof NumberType)) {
		return true;
	}
	context.errors.push(new CompileError(_token$0 = this._token, "cannot apply operator '" + (_token$0, _token$0._value) + "' against '" + this._expr1.getType$().toString() + "' and '" + this._expr2.getType$().toString() + "'"));
	return false;
};


FusedAssignmentExpression.prototype.getType$ = function () {
	return this._expr1.getType$();
};


FusedAssignmentExpression.prototype._doHasSideEffects$F$LExpression$UB$ = function (preCheckCb) {
	return true;
};


function AssignmentExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
};

$__jsx_extend([AssignmentExpression], BinaryExpression);
AssignmentExpression.prototype.clone$ = function () {
	return new AssignmentExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
};


AssignmentExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var rhsType;
	var lhsType;
	var this$0;
	var this$1;
	var this$0$0;
	var this$2;
	if (this._expr2 instanceof FunctionExpression) {
		return AssignmentExpression$_analyzeFunctionExpressionAssignment$LAssignmentExpression$LAnalysisContext$LExpression$(this, context, parentExpr);
	}
	if (this._expr2 instanceof ArrayLiteralExpression && (this$0 = this._expr2, this$0._exprs).length === 0 && this._expr2.getType$() == null || this._expr2 instanceof MapLiteralExpression && (this$1 = this._expr2, this$1._elements).length === 0 && this._expr2.getType$() == null) {
		if (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this)) {
			return false;
		}
		if (! AssignmentExpression$analyzeEmptyLiteralAssignment$LAnalysisContext$LToken$LType$LExpression$(context, this._token, this._expr1.getType$(), this._expr2)) {
			return false;
		}
		if (! this._expr1.assertIsAssignable$LAnalysisContext$LToken$LType$(context, this._token, this._expr2.getType$())) {
			return false;
		}
		if (! this._expr2.analyze$LAnalysisContext$LExpression$(context, this)) {
			return false;
		}
		return true;
	}
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	rhsType = this._expr2.getType$();
	if (rhsType == null) {
		return false;
	}
	if (rhsType.equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(this._token, "cannot assign void"));
		return false;
	}
	if (this._expr2.isClassSpecifier$()) {
		context.errors.push(new CompileError(this._token, "cannot assign a class"));
		return false;
	}
	if ((rhsType instanceof NullableType ? (this$0$0 = rhsType, this$0$0._baseType) : rhsType).equals$LType$(Type.nullType) && this._expr1.getType$() == null) {
		context.errors.push(new CompileError(this._token, "cannot assign null to an unknown type"));
		return false;
	}
	if (rhsType instanceof FunctionChoiceType) {
		lhsType = this._expr1.getType$();
		if (lhsType != null) {
			if (! (lhsType instanceof ResolvedFunctionType)) {
				context.errors.push(new CompileError(this._token, "cannot assign a function reference to '" + this._expr1.getType$().toString() + "'"));
				return false;
			}
			if ((rhsType = PropertyExpression$deduceByArgumentTypes$LPropertyExpression$LAnalysisContext$LToken$ALType$B(this._expr2, context, this._token, (this$2 = lhsType, this$2._argTypes), lhsType instanceof StaticFunctionType)) == null) {
				return false;
			}
		} else {
			context.errors.push(new CompileError(this._token, "function reference is ambiguous"));
			return false;
		}
	}
	if (rhsType instanceof MemberFunctionType) {
		context.errors.push(new CompileError(this._token, "cannot assign a member function"));
		return false;
	}
	return (! this._expr1.assertIsAssignable$LAnalysisContext$LToken$LType$(context, this._token, rhsType) ? false : true);
};


function AssignmentExpression$analyzeEmptyLiteralAssignment$LAnalysisContext$LToken$LType$LExpression$(context, token, lhsType, rhs) {
	var classDef;
	var this$0;
	var this$0$0;
	var this$1;
	var this$2;
	var this$0$1;
	var this$3;
	if (lhsType == null) {
		context.errors.push(new CompileError(token, "either side of the operator should be fully type-qualified"));
		return false;
	}
	if (rhs instanceof ArrayLiteralExpression) {
		if (! (lhsType instanceof ObjectType && (classDef = lhsType.getClassDef$()) instanceof InstantiatedClassDefinition && (this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) === "Array")) {
			context.errors.push(new CompileError(token, "cannot deduce the type of [] because left-hand-side expression is not of Array type"));
			return false;
		}
		this$1 = rhs;
		this$1._type = lhsType;
	} else {
		if (! (lhsType instanceof ObjectType && (classDef = lhsType.getClassDef$()) instanceof InstantiatedClassDefinition && (this$2 = classDef, this$0$1 = this$2._templateClassDef, this$0$1._className) === "Map")) {
			context.errors.push(new CompileError(token, "cannot deduce the type of {} because left-hand-side expression is not of Map type"));
			return false;
		}
		this$3 = rhs;
		this$3._type = lhsType;
	}
	return true;
};

AssignmentExpression.analyzeEmptyLiteralAssignment$LAnalysisContext$LToken$LType$LExpression$ = AssignmentExpression$analyzeEmptyLiteralAssignment$LAnalysisContext$LToken$LType$LExpression$;

AssignmentExpression.prototype._analyzeFunctionExpressionAssignment$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var this$0;
	var this$0$0;
	var this$1;
	var type$0;
	if (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this)) {
		return false;
	}
	if (this._expr1.getType$() == null) {
		if (! (this$0 = this._expr2, ! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(this$0) ? false : (this$0$0 = this$0._funcDef, this$0$0._returnType) == null ? false : true)) {
			context.errors.push(new CompileError(this._token, "either side of the operator should be fully type-qualified : " + (FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(this._expr2) ? "return type not declared" : "argument / return types not declared")));
			return false;
		}
	} else if (! this._expr1.getType$().equals$LType$(Type.variantType)) {
		if (this._expr1.getType$() instanceof ResolvedFunctionType) {
			if (! (this$1 = this._expr2, type$0 = this._expr1.getType$(), ! MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$(this$1._funcDef, context, type$0) ? false : true)) {
				return false;
			}
		} else {
			context.errors.push(new CompileError(this._token, Util$format$SAS("%1 is not convertible to %2", [ this._expr2.getType$().toString(), this._expr1.getType$().toString() ])));
			return false;
		}
	}
	return (! this._expr1.assertIsAssignable$LAnalysisContext$LToken$LType$(context, this._token, this._expr2.getType$()) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true);
};


function AssignmentExpression$_analyzeFunctionExpressionAssignment$LAssignmentExpression$LAnalysisContext$LExpression$($this, context, parentExpr) {
	var this$0;
	var this$0$0;
	var this$1;
	var type$0;
	if (! $this._expr1.analyze$LAnalysisContext$LExpression$(context, $this)) {
		return false;
	}
	if ($this._expr1.getType$() == null) {
		if (! (this$0 = $this._expr2, ! FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$(this$0) ? false : (this$0$0 = this$0._funcDef, this$0$0._returnType) == null ? false : true)) {
			context.errors.push(new CompileError($this._token, "either side of the operator should be fully type-qualified : " + (FunctionExpression$argumentTypesAreIdentified$LFunctionExpression$($this._expr2) ? "return type not declared" : "argument / return types not declared")));
			return false;
		}
	} else if (! $this._expr1.getType$().equals$LType$(Type.variantType)) {
		if ($this._expr1.getType$() instanceof ResolvedFunctionType) {
			if (! (this$1 = $this._expr2, type$0 = $this._expr1.getType$(), ! MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$(this$1._funcDef, context, type$0) ? false : true)) {
				return false;
			}
		} else {
			context.errors.push(new CompileError($this._token, Util$format$SAS("%1 is not convertible to %2", [ $this._expr2.getType$().toString(), $this._expr1.getType$().toString() ])));
			return false;
		}
	}
	return (! $this._expr1.assertIsAssignable$LAnalysisContext$LToken$LType$(context, $this._token, $this._expr2.getType$()) ? false : ! $this._expr2.analyze$LAnalysisContext$LExpression$(context, $this) ? false : true);
};

AssignmentExpression._analyzeFunctionExpressionAssignment$LAssignmentExpression$LAnalysisContext$LExpression$ = AssignmentExpression$_analyzeFunctionExpressionAssignment$LAssignmentExpression$LAnalysisContext$LExpression$;

AssignmentExpression.prototype.getType$ = function () {
	return this._expr1.getType$();
};


AssignmentExpression.prototype._doHasSideEffects$F$LExpression$UB$ = function (preCheckCb) {
	return true;
};


function ArrayExpression(operatorToken, expr1, expr2) {
	ArrayExpression$0.call(this, operatorToken, expr1, expr2, null);
};

function ArrayExpression$0(operatorToken, expr1, expr2, type) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
	this._type = type;
};

$__jsx_extend([ArrayExpression, ArrayExpression$0], BinaryExpression);
ArrayExpression.prototype.clone$ = function () {
	return new ArrayExpression$0(this._token, this._expr1.clone$(), this._expr2.clone$(), this._type);
};


ArrayExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var expr1Type;
	var this$0;
	var this$0$0;
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	if (this._expr1.getType$() == null) {
		context.errors.push(new CompileError(this._token, "cannot determine type due to preceding errors"));
		return false;
	}
	this$0 = this._expr1.getType$();
	expr1Type = (this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0);
	if (expr1Type instanceof ObjectType) {
		return ArrayExpression$_analyzeApplicationOnObject$LArrayExpression$LAnalysisContext$LType$(this, context, expr1Type);
	} else if (expr1Type.equals$LType$(Type.variantType)) {
		return ArrayExpression$_analyzeApplicationOnVariant$LArrayExpression$LAnalysisContext$(this, context);
	}
	context.errors.push(new CompileError(this._token, "cannot apply []; the operator is only applicable against an array or an variant"));
	return false;
};


ArrayExpression.prototype._analyzeApplicationOnObject$LAnalysisContext$LType$ = function (context, expr1Type) {
	var expr1ClassDef;
	var funcType;
	var deducedFuncType;
	expr1ClassDef = expr1Type.getClassDef$();
	funcType = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(expr1ClassDef, context.errors, this._token, "__native_index_operator__", false, [], 0);
	if (funcType == null) {
		context.errors.push(new CompileError(this._token, "cannot apply operator[] on an instance of class '" + expr1ClassDef.className$() + "'"));
		return false;
	}
	deducedFuncType = funcType.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, this._token, [ this._expr2.getType$() ], false);
	if (deducedFuncType == null) {
		return false;
	}
	this._type = deducedFuncType._returnType;
	return true;
};


function ArrayExpression$_analyzeApplicationOnObject$LArrayExpression$LAnalysisContext$LType$($this, context, expr1Type) {
	var expr1ClassDef;
	var funcType;
	var deducedFuncType;
	expr1ClassDef = expr1Type.getClassDef$();
	funcType = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(expr1ClassDef, context.errors, $this._token, "__native_index_operator__", false, [], 0);
	if (funcType == null) {
		context.errors.push(new CompileError($this._token, "cannot apply operator[] on an instance of class '" + expr1ClassDef.className$() + "'"));
		return false;
	}
	deducedFuncType = funcType.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, $this._token, [ $this._expr2.getType$() ], false);
	if (deducedFuncType == null) {
		return false;
	}
	$this._type = deducedFuncType._returnType;
	return true;
};

ArrayExpression._analyzeApplicationOnObject$LArrayExpression$LAnalysisContext$LType$ = ArrayExpression$_analyzeApplicationOnObject$LArrayExpression$LAnalysisContext$LType$;

ArrayExpression.prototype._analyzeApplicationOnVariant$LAnalysisContext$ = function (context) {
	var expr2Type;
	var this$0;
	var this$0$0;
	this$0 = this._expr2.getType$();
	expr2Type = (this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0);
	if (! (expr2Type.equals$LType$(Type.stringType) || expr2Type.isConvertibleTo$LType$(Type.numberType))) {
		context.errors.push(new CompileError(this._token, "the argument of variant[] should be a string or a number"));
		return false;
	}
	this._type = Type.variantType;
	return true;
};


function ArrayExpression$_analyzeApplicationOnVariant$LArrayExpression$LAnalysisContext$($this, context) {
	var expr2Type;
	var this$0;
	var this$0$0;
	this$0 = $this._expr2.getType$();
	expr2Type = (this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0);
	if (! (expr2Type.equals$LType$(Type.stringType) || expr2Type.isConvertibleTo$LType$(Type.numberType))) {
		context.errors.push(new CompileError($this._token, "the argument of variant[] should be a string or a number"));
		return false;
	}
	$this._type = Type.variantType;
	return true;
};

ArrayExpression._analyzeApplicationOnVariant$LArrayExpression$LAnalysisContext$ = ArrayExpression$_analyzeApplicationOnVariant$LArrayExpression$LAnalysisContext$;

ArrayExpression.prototype.getType$ = function () {
	return this._type;
};


ArrayExpression.prototype.assertIsAssignable$LAnalysisContext$LToken$LType$ = function (context, token, type) {
	return Expression$assertIsAssignable$LAnalysisContext$LToken$LType$LType$(context, token, this._type, type);
};


ArrayExpression.prototype._doHasSideEffects$F$LExpression$UB$ = function (preCheckCb) {
	var type$0;
	return (! (type$0 = this._expr1.getType$(), Util$_isBuiltInObjectType$LType$HB(type$0, Util._builtInClass)) && Util$rootIsNativeClass$LType$(this._expr1.getType$()) ? true : Expression.prototype._doHasSideEffects$F$LExpression$UB$.call(this, preCheckCb));
};


function AdditiveExpression(operatorToken, expr1, expr2) {
	this._stash = {};
	this._token = operatorToken;
	this._expr1 = expr1;
	this._expr2 = expr2;
	this._type = null;
};

$__jsx_extend([AdditiveExpression], BinaryExpression);
AdditiveExpression.prototype.clone$ = function () {
	var ret;
	ret = new AdditiveExpression(this._token, this._expr1.clone$(), this._expr2.clone$());
	ret._type = this._type;
	return ret;
};


AdditiveExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var $this = this;
	var typeIsNumber;
	var typeIsString;
	var expr1Type;
	var expr2Type;
	var this$0;
	var this$0$0;
	var this$1;
	var this$0$1;
	if (! (! this._expr1.analyze$LAnalysisContext$LExpression$(context, this) ? false : ! this._expr2.analyze$LAnalysisContext$LExpression$(context, this) ? false : true)) {
		return false;
	}
	function typeIsNumber(type) {
		return type.isConvertibleTo$LType$(Type.numberType) || type instanceof ObjectType && type.getClassDef$() == (Type.numberType, NumberType._classDef);
	}
	function typeIsString(type) {
		return type.equals$LType$(Type.stringType) || type instanceof ObjectType && type.getClassDef$() == (Type.stringType, StringType._classDef);
	}
	this$0 = this._expr1.getType$();
	expr1Type = (this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0);
	this$1 = this._expr2.getType$();
	expr2Type = (this$1 instanceof NullableType ? (this$0$1 = this$1, this$0$1._baseType) : this$1);
	if (typeIsNumber(expr1Type) && typeIsNumber(expr2Type)) {
		this._type = (expr1Type instanceof NumberType || expr2Type instanceof NumberType ? Type.numberType : Type.integerType);
	} else if (typeIsString(expr1Type) && typeIsString(expr2Type)) {
		this._type = expr1Type;
	} else if (typeIsString(expr1Type) && typeIsNumber(expr2Type) || typeIsNumber(expr1Type) && typeIsString(expr2Type)) {
		if (typeIsNumber(expr1Type)) {
			this._expr1 = new AsExpression(new Token$2("as", false), this._expr1, Type.stringType);
		} else {
			this._expr2 = new AsExpression(new Token$2("as", false), this._expr2, Type.stringType);
		}
		this._type = Type.stringType;
	} else {
		context.errors.push(new CompileError(this._token, "cannot apply operator '+' to '" + expr1Type.toString() + "' and '" + expr2Type.toString() + "'"));
		return false;
	}
	return true;
};


AdditiveExpression.prototype.getType$ = function () {
	return this._type;
};


function UnaryExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([UnaryExpression], OperatorExpression);
UnaryExpression.prototype.getExpr$ = function () {
	return this._expr;
};


function UnaryExpression$getExpr$LUnaryExpression$($this) {
	return $this._expr;
};

UnaryExpression.getExpr$LUnaryExpression$ = UnaryExpression$getExpr$LUnaryExpression$;

UnaryExpression.prototype.setExpr$LExpression$ = function (expr) {
	this._expr = expr;
};


function UnaryExpression$setExpr$LUnaryExpression$LExpression$($this, expr) {
	$this._expr = expr;
};

UnaryExpression.setExpr$LUnaryExpression$LExpression$ = UnaryExpression$setExpr$LUnaryExpression$LExpression$;

UnaryExpression.prototype.serialize$ = function () {
	var this$0;
	return [ "UnaryExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), this._expr.serialize$() ];
};


UnaryExpression.prototype._analyze$LAnalysisContext$ = function (context) {
	var _token$0;
	if (! this._expr.analyze$LAnalysisContext$LExpression$(context, this)) {
		return false;
	}
	if (this._expr.getType$().equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(_token$0 = this._token, "cannot apply operator '" + (_token$0, _token$0._value) + "' against void"));
		return false;
	}
	return true;
};


function UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$($this, context) {
	var _token$0;
	if (! $this._expr.analyze$LAnalysisContext$LExpression$(context, $this)) {
		return false;
	}
	if ($this._expr.getType$().equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(_token$0 = $this._token, "cannot apply operator '" + (_token$0, _token$0._value) + "' against void"));
		return false;
	}
	return true;
};

UnaryExpression._analyze$LUnaryExpression$LAnalysisContext$ = UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$;

UnaryExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	var $this = this;
	return cb(this._expr, (function (expr) {
		$this._expr = expr;
	}));
};


function YieldExpression(operatorToken, expr) {
	YieldExpression$0.call(this, operatorToken, expr, null, null);
};

function YieldExpression$0(operatorToken, expr, seedType, genType) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
	this._seedType = seedType;
	this._genType = genType;
};

$__jsx_extend([YieldExpression, YieldExpression$0], UnaryExpression);
YieldExpression.prototype.clone$ = function () {
	return new YieldExpression$0(this._token, this._expr.clone$(), this._seedType, this._genType);
};


YieldExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var returnType;
	var genType;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$0$0;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	this$0 = context.funcDef;
	returnType = this$0._returnType;
	if (returnType == null) {
		context.errors.push(new CompileError(this._token, "cannot deduce yield expression type"));
		return false;
	} else if (returnType instanceof ObjectType && returnType.getClassDef$() instanceof InstantiatedClassDefinition && (this$3 = returnType.getClassDef$(), this$0$0 = this$3._templateClassDef, this$0$0._className) === "Generator") {
		this._seedType = (this$1 = returnType.getClassDef$(), this$1._typeArguments)[0];
		genType = (this$2 = returnType.getClassDef$(), this$2._typeArguments)[1];
	} else {
		context.errors.push(new CompileError(this._token, "cannot convert 'Generator' to return type '" + returnType.toString() + "'"));
		return false;
	}
	if (! this._expr.getType$().isConvertibleTo$LType$(genType)) {
		context.errors.push(new CompileError(this._token, "cannot convert '" + this._expr.getType$().toString() + "' to yield type '" + genType.toString() + "'"));
		return false;
	}
	this._genType = genType;
	return true;
};


YieldExpression.prototype.getType$ = function () {
	var this$0;
	this$0 = this._seedType;
	return (this$0 instanceof PrimitiveType || this$0.equals$LType$(Type.voidType) ? new NullableType(this$0) : this$0);
};


YieldExpression.prototype.getSeedType$ = function () {
	return this._seedType;
};


function YieldExpression$getSeedType$LYieldExpression$($this) {
	return $this._seedType;
};

YieldExpression.getSeedType$LYieldExpression$ = YieldExpression$getSeedType$LYieldExpression$;

YieldExpression.prototype.getGenType$ = function () {
	return this._genType;
};


function YieldExpression$getGenType$LYieldExpression$($this) {
	return $this._genType;
};

YieldExpression.getGenType$LYieldExpression$ = YieldExpression$getGenType$LYieldExpression$;

YieldExpression.prototype._doHasSideEffects$F$LExpression$UB$ = function (preCheckCb) {
	return true;
};


function SignExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([SignExpression], UnaryExpression);
SignExpression.prototype.clone$ = function () {
	return new SignExpression(this._token, this._expr.clone$());
};


SignExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context) ? false : ! OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr, Type.numberType, true) ? false : true);
};


SignExpression.prototype.getType$ = function () {
	var type;
	var this$0;
	var this$0$0;
	if ((this$0 = this._token, this$0._value) === "-") {
		return Type.numberType;
	}
	type = this._expr.getType$();
	return ((type instanceof NullableType ? (this$0$0 = type, this$0$0._baseType) : type).equals$LType$(Type.numberType) ? Type.numberType : Type.integerType);
};


function TypeofExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([TypeofExpression], UnaryExpression);
TypeofExpression.prototype.clone$ = function () {
	return new TypeofExpression(this._token, this._expr.clone$());
};


TypeofExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var exprType;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	exprType = this._expr.getType$();
	if (! exprType.equals$LType$(Type.variantType)) {
		context.errors.push(new CompileError(this._token, "cannot apply operator 'typeof' to '" + this._expr.getType$().toString() + "'"));
		return false;
	}
	return true;
};


TypeofExpression.prototype.getType$ = function () {
	return Type.stringType;
};


function PropertyExpression(operatorToken, expr1, identifierToken, typeArgs) {
	PropertyExpression$0.call(this, operatorToken, expr1, identifierToken, typeArgs, null);
};

function PropertyExpression$0(operatorToken, expr1, identifierToken, typeArgs, type) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr1;
	this._identifierToken = identifierToken;
	this._typeArgs = typeArgs;
	this._type = (type != null ? type : null);
	this._isInner = false;
};

$__jsx_extend([PropertyExpression, PropertyExpression$0], UnaryExpression);
PropertyExpression.prototype.clone$ = function () {
	var propExpr;
	propExpr = new PropertyExpression$0(this._token, this._expr.clone$(), this._identifierToken, this._typeArgs, this._type);
	propExpr._isInner = this._isInner;
	return propExpr;
};


PropertyExpression.prototype.getIdentifierToken$ = function () {
	return this._identifierToken;
};


function PropertyExpression$getIdentifierToken$LPropertyExpression$($this) {
	return $this._identifierToken;
};

PropertyExpression.getIdentifierToken$LPropertyExpression$ = PropertyExpression$getIdentifierToken$LPropertyExpression$;

PropertyExpression.prototype.getTypeArguments$ = function () {
	return this._typeArgs;
};


function PropertyExpression$getTypeArguments$LPropertyExpression$($this) {
	return $this._typeArgs;
};

PropertyExpression.getTypeArguments$LPropertyExpression$ = PropertyExpression$getTypeArguments$LPropertyExpression$;

PropertyExpression.prototype.setTypeArguments$ALType$ = function (types) {
	this._typeArgs = types;
};


function PropertyExpression$setTypeArguments$LPropertyExpression$ALType$($this, types) {
	$this._typeArgs = types;
};

PropertyExpression.setTypeArguments$LPropertyExpression$ALType$ = PropertyExpression$setTypeArguments$LPropertyExpression$ALType$;

PropertyExpression.prototype.serialize$ = function () {
	var this$0;
	var v$0;
	return [ "PropertyExpression", this._expr.serialize$(), (this$0 = this._identifierToken, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), (v$0 = this._type, v$0 == null ? null : v$0.toString()) ];
};


PropertyExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var $this = this;
	var exprType;
	var classDef;
	var innerClassDef;
	var objectType;
	var error;
	var this$0$0;
	var this$0;
	var this$2;
	var _identifierToken$0;
	var _type$0;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	exprType = this._expr.getType$();
	if (exprType.equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(this._identifierToken, "cannot obtain a member of void"));
		return false;
	}
	if (exprType.equals$LType$(Type.nullType)) {
		context.errors.push(new CompileError(this._identifierToken, "cannot obtain a member of null"));
		return false;
	}
	if ((exprType instanceof NullableType ? (this$0$0 = exprType, this$0$0._baseType) : exprType).equals$LType$(Type.variantType)) {
		context.errors.push(new CompileError(this._identifierToken, "property of a variant should be referred to by using the [] operator"));
		return false;
	}
	classDef = exprType.getClassDef$();
	if (classDef == null) {
		context.errors.push(new CompileError(this._identifierToken, "cannot determine type due to preceding errors"));
		return false;
	}
	if (this._expr.isClassSpecifier$()) {
		innerClassDef = ClassDefinition$lookupInnerClass$LClassDefinition$S(classDef, (this$0 = this._identifierToken, this$0._value));
		if (innerClassDef == null) {
			ClassDefinition$forEachTemplateInnerClass$LClassDefinition$F$LTemplateClassDefinition$B$(classDef, (function (classDef) {
				var this$0;
				if (classDef._className === (this$0 = $this._identifierToken, this$0._value)) {
					innerClassDef = classDef;
					return false;
				}
				return true;
			}));
		}
		if (innerClassDef) {
			objectType = new ParsedObjectType(new QualifiedName$1(this._identifierToken, exprType), this._typeArgs);
			if (objectType._classDef == null) {
				objectType._classDef = QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$(objectType._qualifiedName, context, objectType._typeArguments);
			}
			this._type = objectType;
			this._isInner = true;
			return true;
		}
	}
	_type$0 = this._type = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(classDef, context.errors, _identifierToken$0 = this._identifierToken, (_identifierToken$0, _identifierToken$0._value), this._expr.isClassSpecifier$(), this._typeArgs, (this._expr.isClassSpecifier$() ? 1 : 0));
	if (_type$0 == null) {
		error = new CompileError(this._identifierToken, "'" + exprType.toString() + "' does not have a property or inner class named '" + (this$2 = this._identifierToken, this$2._value) + "'");
		ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(classDef, (function (classDef) {
			return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
				if (Util$ld$SS(MemberDefinition$name$LMemberDefinition$(member), Token$getValue$LToken$($this._identifierToken)) < 2) {
					CompileError$addCompileNote$LCompileError$LCompileNote$(error, new CompileNote(MemberDefinition$getNameToken$LMemberDefinition$(member), "candidates: " + member.getNotation$()));
					if (CompileError$getCompileNotes$LCompileError$(error).length > 3) {
						return false;
					}
				}
				return true;
			}));
		}));
		context.errors.push(error);
		return false;
	}
	return true;
};


PropertyExpression.prototype.getType$ = function () {
	return this._type;
};


PropertyExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function PropertyExpression$setType$LPropertyExpression$LType$($this, type) {
	$this._type = type;
};

PropertyExpression.setType$LPropertyExpression$LType$ = PropertyExpression$setType$LPropertyExpression$LType$;

PropertyExpression.prototype.getHolderType$ = function () {
	var type;
	type = this._expr.getType$();
	if (type instanceof PrimitiveType) {
		type = new ObjectType(type.getClassDef$());
	}
	return type;
};


PropertyExpression.prototype.isClassSpecifier$ = function () {
	return this._isInner;
};


PropertyExpression.prototype.assertIsAssignable$LAnalysisContext$LToken$LType$ = function (context, token, type) {
	var $this = this;
	var holderType;
	var varFlags;
	var type$0;
	var this$0;
	if (! Expression$assertIsAssignable$LAnalysisContext$LToken$LType$LType$(context, token, this._type, type)) {
		return false;
	}
	type$0 = this._expr.getType$();
	if (type$0 instanceof PrimitiveType) {
		type$0 = new ObjectType(type$0.getClassDef$());
	}
	holderType = type$0;
	varFlags = 0;
	if (! type$0.equals$LType$(Type.variantType)) {
		if (ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(holderType.getClassDef$(), (function (classDef) {
			return ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
				if (MemberDefinition$name$LMemberDefinition$(varDef) === Token$getValue$LToken$($this._identifierToken)) {
					varFlags = MemberDefinition$flags$LMemberDefinition$(varDef);
					return false;
				}
				return true;
			}));
		}))) {
			throw new Error("logic flaw, could not find definition for " + holderType.getClassDef$().className$() + "#" + (this$0 = this._identifierToken, this$0._value));
		}
	}
	if ((varFlags & 1) !== 0) {
		context.errors.push(new CompileError(token, "cannot modify a constant"));
		return false;
	} else if ((varFlags & 512) !== 0) {
		context.errors.push(new CompileError(token, "cannot modify a readonly variable"));
		return false;
	}
	return true;
};


PropertyExpression.prototype._doHasSideEffects$F$LExpression$UB$ = function (preCheckCb) {
	var type$0;
	return (this._isInner ? false : ! (type$0 = this._expr.getType$(), Util$_isBuiltInObjectType$LType$HB(type$0, Util._builtInClass)) && Util$rootIsNativeClass$LType$(this._expr.getType$()) ? true : Expression.prototype._doHasSideEffects$F$LExpression$UB$.call(this, preCheckCb));
};


PropertyExpression.prototype.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B = function (context, operatorToken, argTypes, isStatic) {
	var i;
	var rhsType;
	for (i = 0; i < argTypes.length; ++i) {
		if (argTypes[i] instanceof FunctionChoiceType) {
			context.errors.push(new CompileError(operatorToken, "type deduction of overloaded function passed in as an argument is not supported; use 'as' to specify the function"));
			return null;
		}
	}
	rhsType = this._type.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, operatorToken, argTypes, isStatic);
	if (rhsType == null) {
		return null;
	}
	this._type = rhsType;
	return rhsType;
};


function PropertyExpression$deduceByArgumentTypes$LPropertyExpression$LAnalysisContext$LToken$ALType$B($this, context, operatorToken, argTypes, isStatic) {
	var i;
	var rhsType;
	for (i = 0; i < argTypes.length; ++i) {
		if (argTypes[i] instanceof FunctionChoiceType) {
			context.errors.push(new CompileError(operatorToken, "type deduction of overloaded function passed in as an argument is not supported; use 'as' to specify the function"));
			return null;
		}
	}
	rhsType = $this._type.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B(context, operatorToken, argTypes, isStatic);
	if (rhsType == null) {
		return null;
	}
	$this._type = rhsType;
	return rhsType;
};

PropertyExpression.deduceByArgumentTypes$LPropertyExpression$LAnalysisContext$LToken$ALType$B = PropertyExpression$deduceByArgumentTypes$LPropertyExpression$LAnalysisContext$LToken$ALType$B;

function IncrementExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([IncrementExpression], UnaryExpression);
IncrementExpression.prototype.serialize$ = function () {
	var this$0;
	return [ this._getClassName$(), (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), this._expr.serialize$() ];
};


IncrementExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var exprType;
	var this$0$0;
	var this$0$1;
	var _token$0;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	exprType = this._expr.getType$();
	if ((exprType instanceof NullableType ? (this$0$0 = exprType, this$0$0._baseType) : exprType).equals$LType$(Type.integerType) || (exprType instanceof NullableType ? (this$0$1 = exprType, this$0$1._baseType) : exprType).equals$LType$(Type.numberType)) {
	} else {
		context.errors.push(new CompileError(_token$0 = this._token, "cannot apply operator '" + (_token$0, _token$0._value) + "' to a non-number"));
		return false;
	}
	return (! this._expr.assertIsAssignable$LAnalysisContext$LToken$LType$(context, this._token, exprType) ? false : true);
};


IncrementExpression.prototype.getType$ = function () {
	var this$0;
	var this$0$0;
	this$0 = this._expr.getType$();
	return (this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0);
};


IncrementExpression.prototype._doHasSideEffects$F$LExpression$UB$ = function (preCheckCb) {
	return true;
};


function PreIncrementExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([PreIncrementExpression], IncrementExpression);
PreIncrementExpression.prototype.clone$ = function () {
	return new PreIncrementExpression(this._token, this._expr.clone$());
};


PreIncrementExpression.prototype._getClassName$ = function () {
	return "PreIncrementExpression";
};


function PostIncrementExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([PostIncrementExpression], IncrementExpression);
PostIncrementExpression.prototype.clone$ = function () {
	return new PostIncrementExpression(this._token, this._expr.clone$());
};


PostIncrementExpression.prototype._getClassName$ = function () {
	return "PostIncrementExpression";
};


function LogicalNotExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([LogicalNotExpression], UnaryExpression);
LogicalNotExpression.prototype.clone$ = function () {
	return new LogicalNotExpression(this._token, this._expr.clone$());
};


LogicalNotExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var this$0;
	var this$0$0;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	if ((this$0 = this._expr.getType$(), this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0).equals$LType$(Type.voidType)) {
		context.errors.push(new CompileError(this._token, "cannot apply operator '!' against void"));
		return false;
	}
	return true;
};


LogicalNotExpression.prototype.getType$ = function () {
	return Type.booleanType;
};


function AsNoConvertExpression(operatorToken, expr, type) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
	this._type = type;
};

$__jsx_extend([AsNoConvertExpression], UnaryExpression);
AsNoConvertExpression.prototype.clone$ = function () {
	return new AsNoConvertExpression(this._token, this._expr.clone$(), this._type);
};


AsNoConvertExpression.prototype.serialize$ = function () {
	var this$0;
	return [ "AsNoConvertExpression", this._expr.serialize$(), (this$0 = this._type, this$0.toString()) ];
};


AsNoConvertExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var srcType;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	srcType = this._expr.getType$();
	if (srcType.equals$LType$(Type.nullType) && ! (this._type instanceof NullableType || this._type instanceof ObjectType || this._type instanceof FunctionType)) {
		context.errors.push(new CompileError(this._token, "'" + srcType.toString() + "' cannot be treated as a value of type '" + this._type.toString() + "'"));
		return false;
	}
	return true;
};


AsNoConvertExpression.prototype.getType$ = function () {
	return this._type;
};


AsNoConvertExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function AsNoConvertExpression$setType$LAsNoConvertExpression$LType$($this, type) {
	$this._type = type;
};

AsNoConvertExpression.setType$LAsNoConvertExpression$LType$ = AsNoConvertExpression$setType$LAsNoConvertExpression$LType$;

function AsExpression(operatorToken, expr, type) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
	this._type = type;
};

$__jsx_extend([AsExpression], UnaryExpression);
AsExpression.prototype.clone$ = function () {
	return new AsExpression(this._token, this._expr.clone$(), this._type);
};


AsExpression.prototype.serialize$ = function () {
	var this$0;
	return [ "AsExpression", this._expr.serialize$(), (this$0 = this._type, this$0.toString()) ];
};


AsExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var exprType;
	var success;
	var deducedType;
	var this$0;
	var this$0$0;
	var this$1;
	var this$2;
	var _type$0;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	if (this._type instanceof NullableType) {
		context.errors.push(new CompileError(this._token, "right operand of 'as' expression cannot be a Nullable<T> type"));
		return false;
	}
	if (this._expr.getType$().isConvertibleTo$LType$(this._type)) {
		return true;
	}
	this$0 = this._expr.getType$();
	exprType = (this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0);
	success = false;
	if (exprType.equals$LType$(Type.nullType)) {
		if ((_type$0 = this._type) instanceof ObjectType || _type$0 instanceof FunctionType) {
			success = true;
		}
	} else if (exprType instanceof PrimitiveType) {
		if (this._type instanceof PrimitiveType) {
			success = true;
		}
	} else if (exprType.equals$LType$(Type.variantType)) {
		success = true;
	} else if (exprType instanceof ObjectType) {
		if (this._type instanceof ObjectType && this._type.isConvertibleTo$LType$(exprType)) {
			success = true;
		}
	} else if (this._expr instanceof PropertyExpression && exprType instanceof FunctionType && this._type instanceof StaticFunctionType) {
		deducedType = PropertyExpression$deduceByArgumentTypes$LPropertyExpression$LAnalysisContext$LToken$ALType$B(this._expr, context, this._token, (this$1 = this._type, this$1._argTypes), true);
		if (deducedType != null) {
			exprType = deducedType;
			if (deducedType._returnType.equals$LType$((this$2 = this._type, this$2._returnType))) {
				success = true;
			}
		}
	}
	if (! success) {
		context.errors.push(new CompileError(this._token, "cannot convert a value of type '" + exprType.toString() + "' to '" + this._type.toString() + "'"));
		return false;
	}
	return true;
};


AsExpression.prototype.getType$ = function () {
	return this._type;
};


AsExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function AsExpression$setType$LAsExpression$LType$($this, type) {
	$this._type = type;
};

AsExpression.setType$LAsExpression$LType$ = AsExpression$setType$LAsExpression$LType$;

function InstanceofExpression(operatorToken, expr, expectedType) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
	this._expectedType = expectedType;
};

$__jsx_extend([InstanceofExpression], UnaryExpression);
InstanceofExpression.prototype.clone$ = function () {
	return new InstanceofExpression(this._token, this._expr.clone$(), this._expectedType);
};


InstanceofExpression.prototype.getExpectedType$ = function () {
	return this._expectedType;
};


function InstanceofExpression$getExpectedType$LInstanceofExpression$($this) {
	return $this._expectedType;
};

InstanceofExpression.getExpectedType$LInstanceofExpression$ = InstanceofExpression$getExpectedType$LInstanceofExpression$;

InstanceofExpression.prototype.setExpectedType$LType$ = function (type) {
	this._expectedType = type;
};


function InstanceofExpression$setExpectedType$LInstanceofExpression$LType$($this, type) {
	$this._expectedType = type;
};

InstanceofExpression.setExpectedType$LInstanceofExpression$LType$ = InstanceofExpression$setExpectedType$LInstanceofExpression$LType$;

InstanceofExpression.prototype.serialize$ = function () {
	var this$0;
	return [ "InstanceofExpression", this._expr.serialize$(), (this$0 = this._expectedType, this$0.toString()) ];
};


InstanceofExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var exprType;
	if (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context)) {
		return false;
	}
	exprType = this._expr.getType$();
	if (exprType instanceof ObjectType) {
	} else if (exprType.equals$LType$(Type.variantType)) {
	} else {
		context.errors.push(new CompileError(this._token, "operator 'instanceof' is only applicable to an object or a variant"));
		return false;
	}
	if (this._expectedType.getClassDef$().flags$() & 256) {
		context.errors.push(new CompileError(this._token, "operator 'instanceof' is not applicable to a fake class " + this._expectedType.toString()));
		return false;
	}
	return true;
};


InstanceofExpression.prototype.getType$ = function () {
	return Type.booleanType;
};


function BitwiseNotExpression(operatorToken, expr) {
	this._stash = {};
	this._token = operatorToken;
	this._expr = expr;
};

$__jsx_extend([BitwiseNotExpression], UnaryExpression);
BitwiseNotExpression.prototype.clone$ = function () {
	return new BitwiseNotExpression(this._token, this._expr.clone$());
};


BitwiseNotExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return (! UnaryExpression$_analyze$LUnaryExpression$LAnalysisContext$(this, context) ? false : ! OperatorExpression$assertIsConvertibleTo$LOperatorExpression$LAnalysisContext$LExpression$LType$B(this, context, this._expr, Type.numberType, false) ? false : true);
};


BitwiseNotExpression.prototype.getType$ = function () {
	return Type.integerType;
};


function LeafExpression(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([LeafExpression], Expression);
LeafExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function ThisExpression(token, classDef) {
	this._stash = {};
	this._token = token;
	this._classDef = classDef;
};

$__jsx_extend([ThisExpression], LeafExpression);
ThisExpression.prototype.clone$ = function () {
	return new ThisExpression(this._token, this._classDef);
};


ThisExpression.prototype.serialize$ = function () {
	var this$0;
	var this$1;
	return [ "ThisExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), this._classDef != null ? (this$1 = this._classDef.getToken$(), [ this$1._value, this$1._isIdentifier, this$1._filename, this$1._lineNumber, this$1._columnNumber ]) : null ];
};


ThisExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var rootFuncDef;
	rootFuncDef = context.funcDef;
	if (rootFuncDef != null) {
		while (rootFuncDef._parent != null) {
			rootFuncDef = rootFuncDef._parent;
		}
	}
	if (rootFuncDef == null || (rootFuncDef._flags & 8) !== 0) {
		context.errors.push(new CompileError(this._token, "cannot use 'this' outside of a member function"));
		return false;
	}
	this._classDef = rootFuncDef._classDef;
	return true;
};


ThisExpression.prototype.getType$ = function () {
	return new ObjectType(this._classDef);
};


ThisExpression.prototype.forEachExpression$F$LExpression$F$LExpression$V$B$ = function (cb) {
	return true;
};


function RegExpLiteralExpression(token) {
	RegExpLiteralExpression$0.call(this, token, null);
};

function RegExpLiteralExpression$0(token, type) {
	this._stash = {};
	this._token = token;
	this._type = type;
};

$__jsx_extend([RegExpLiteralExpression, RegExpLiteralExpression$0], LeafExpression);
RegExpLiteralExpression.prototype.clone$ = function () {
	return new RegExpLiteralExpression$0(this._token, this._type);
};


RegExpLiteralExpression.prototype.serialize$ = function () {
	var this$0;
	return [ "RegExpLiteralExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]) ];
};


RegExpLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var classDef;
	classDef = Parser$lookup$LParser$ALCompileError$LToken$S(context.parser, context.errors, this._token, "RegExp");
	if (classDef == null) {
		throw new Error("could not find definition for RegExp");
	}
	this._type = new ObjectType(classDef);
	return true;
};


RegExpLiteralExpression.prototype.getType$ = function () {
	return this._type;
};


function PrimitiveLiteralExpression(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([PrimitiveLiteralExpression], LeafExpression);
function StringLiteralExpression(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([StringLiteralExpression], PrimitiveLiteralExpression);
StringLiteralExpression.prototype.clone$ = function () {
	return new StringLiteralExpression(this._token);
};


StringLiteralExpression.prototype.serialize$ = function () {
	var this$0;
	return [ "StringLiteralExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]) ];
};


StringLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return true;
};


StringLiteralExpression.prototype.getType$ = function () {
	return Type.stringType;
};


StringLiteralExpression.prototype.toNormalizedString$ = function () {
	return this.getDecoded$();
};


StringLiteralExpression.prototype.tokenIsECMA262Conformant$ = function () {
	var this$0;
	return (this$0 = this._token, this$0._value).match(/^(?:"""|''')/) == null;
};


StringLiteralExpression.prototype.getDecoded$ = function () {
	var this$0;
	return Util$decodeStringLiteral$S((this$0 = this._token, this$0._value));
};


function FileMacroExpression(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([FileMacroExpression], StringLiteralExpression);
FileMacroExpression.prototype.clone$ = function () {
	return new FileMacroExpression(this._token);
};


FileMacroExpression.prototype.serialize$ = function () {
	var json;
	json = StringLiteralExpression.prototype.serialize$.call(this);
	json[0] = "FileMacroExpression";
	return json;
};


FileMacroExpression.prototype.tokenIsECMA262Conformant$ = function () {
	return false;
};


FileMacroExpression.prototype.getDecoded$ = function () {
	var this$0;
	this$0 = this._token;
	return this$0._filename;
};


function NumberLiteralExpression(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([NumberLiteralExpression], PrimitiveLiteralExpression);
NumberLiteralExpression.prototype.clone$ = function () {
	return new NumberLiteralExpression(this._token);
};


NumberLiteralExpression.prototype.serialize$ = function () {
	var this$0;
	return [ "NumberLiteralExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]) ];
};


NumberLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return true;
};


NumberLiteralExpression.prototype.getType$ = function () {
	return Type.numberType;
};


NumberLiteralExpression.prototype.toNormalizedString$ = function () {
	return this.getDecoded$() + "";
};


NumberLiteralExpression.prototype.tokenIsECMA262Conformant$ = function () {
	return true;
};


NumberLiteralExpression.prototype.getDecoded$ = function () {
	var this$0;
	return +(this$0 = this._token, this$0._value);
};


function LineMacroExpression(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([LineMacroExpression], NumberLiteralExpression);
LineMacroExpression.prototype.clone$ = function () {
	return new LineMacroExpression(this._token);
};


LineMacroExpression.prototype.serialize$ = function () {
	var json;
	json = NumberLiteralExpression.prototype.serialize$.call(this);
	json[0] = "LineMacroExpression";
	return json;
};


LineMacroExpression.prototype.tokenIsECMA262Conformant$ = function () {
	return false;
};


LineMacroExpression.prototype.getDecoded$ = function () {
	var this$0;
	this$0 = this._token;
	return this$0._lineNumber;
};


function IntegerLiteralExpression(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([IntegerLiteralExpression], PrimitiveLiteralExpression);
IntegerLiteralExpression.prototype.clone$ = function () {
	return new IntegerLiteralExpression(this._token);
};


IntegerLiteralExpression.prototype.serialize$ = function () {
	var this$0;
	return [ "IntegerLiteralExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]) ];
};


IntegerLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return true;
};


IntegerLiteralExpression.prototype.getType$ = function () {
	return Type.integerType;
};


IntegerLiteralExpression.prototype.toNormalizedString$ = function () {
	var this$0$0;
	return ((this$0$0 = this._token, this$0$0._value) | 0) + "";
};


IntegerLiteralExpression.prototype.getDecoded$ = function () {
	var this$0;
	return (this$0 = this._token, this$0._value) | 0;
};


function IntegerLiteralExpression$getDecoded$LIntegerLiteralExpression$($this) {
	var this$0;
	return (this$0 = $this._token, this$0._value) | 0;
};

IntegerLiteralExpression.getDecoded$LIntegerLiteralExpression$ = IntegerLiteralExpression$getDecoded$LIntegerLiteralExpression$;

function BooleanLiteralExpression(token) {
	this._stash = {};
	this._token = token;
};

$__jsx_extend([BooleanLiteralExpression], PrimitiveLiteralExpression);
BooleanLiteralExpression.prototype.clone$ = function () {
	return new BooleanLiteralExpression(this._token);
};


BooleanLiteralExpression.prototype.serialize$ = function () {
	var this$0;
	return [ "BooleanLiteralExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]) ];
};


BooleanLiteralExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return true;
};


BooleanLiteralExpression.prototype.getType$ = function () {
	return Type.booleanType;
};


BooleanLiteralExpression.prototype.toNormalizedString$ = function () {
	var this$0;
	this$0 = this._token;
	return this$0._value;
};


BooleanLiteralExpression.prototype.getDecoded$ = function () {
	var this$0;
	return (this$0 = this._token, this$0._value) !== "false";
};


function BooleanLiteralExpression$getDecoded$LBooleanLiteralExpression$($this) {
	var this$0;
	return (this$0 = $this._token, this$0._value) !== "false";
};

BooleanLiteralExpression.getDecoded$LBooleanLiteralExpression$ = BooleanLiteralExpression$getDecoded$LBooleanLiteralExpression$;

function NullExpression(token, type) {
	this._stash = {};
	this._token = token;
	this._type = type;
};

$__jsx_extend([NullExpression], LeafExpression);
NullExpression.prototype.clone$ = function () {
	return new NullExpression(this._token, this._type);
};


NullExpression.prototype.serialize$ = function () {
	var this$0;
	var this$1;
	return [ "NullExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), (this$1 = this._type, this$1.toString()) ];
};


NullExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return true;
};


NullExpression.prototype.getType$ = function () {
	return this._type;
};


NullExpression.prototype.setType$LType$ = function (type) {
	this._type = type;
};


function NullExpression$setType$LNullExpression$LType$($this, type) {
	$this._type = type;
};

NullExpression.setType$LNullExpression$LType$ = NullExpression$setType$LNullExpression$LType$;

function ClassExpression(token, parsedType) {
	this._stash = {};
	this._token = token;
	this._parsedType = parsedType;
};

$__jsx_extend([ClassExpression], LeafExpression);
ClassExpression.prototype.clone$ = function () {
	return new ClassExpression(this._token, this._parsedType);
};


ClassExpression.prototype.serialize$ = function () {
	var this$0;
	var this$1;
	return [ "ClassExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), (this$1 = this._parsedType, this$1.toString()) ];
};


ClassExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	return true;
};


ClassExpression.prototype.getType$ = function () {
	return this._parsedType;
};


ClassExpression.prototype.setType$LType$ = function (type) {
	this._parsedType = type;
};


function ClassExpression$setType$LClassExpression$LType$($this, type) {
	$this._parsedType = type;
};

ClassExpression.setType$LClassExpression$LType$ = ClassExpression$setType$LClassExpression$LType$;

ClassExpression.prototype.isClassSpecifier$ = function () {
	return true;
};


ClassExpression.prototype.assertIsAssignable$LAnalysisContext$LToken$LType$ = function (context, token, type) {
	context.errors.push(new CompileError(token, "cannot modify a class definition"));
	return false;
};


function LocalExpression(token, local) {
	this._stash = {};
	this._token = token;
	this._cloned = false;
	this._local = local;
};

$__jsx_extend([LocalExpression], LeafExpression);
LocalExpression.prototype.clone$ = function () {
	var that;
	that = new LocalExpression(this._token, this._local);
	that._cloned = true;
	return that;
};


LocalExpression.prototype.getLocal$ = function () {
	return this._local;
};


function LocalExpression$getLocal$LLocalExpression$($this) {
	return $this._local;
};

LocalExpression.getLocal$LLocalExpression$ = LocalExpression$getLocal$LLocalExpression$;

LocalExpression.prototype.setLocal$LLocalVariable$ = function (local) {
	this._local = local;
};


function LocalExpression$setLocal$LLocalExpression$LLocalVariable$($this, local) {
	$this._local = local;
};

LocalExpression.setLocal$LLocalExpression$LLocalVariable$ = LocalExpression$setLocal$LLocalExpression$LLocalVariable$;

LocalExpression.prototype.serialize$ = function () {
	var this$0;
	var this$1;
	var v$0$0;
	return [ "LocalExpression", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), (this$1 = this._local, [ this$1._name, (v$0$0 = this$1._type, v$0$0 == null ? null : v$0$0.toString()) ]) ];
};


LocalExpression.prototype.analyze$LAnalysisContext$LExpression$ = function (context, parentExpr) {
	var this$0;
	var this$1;
	var this$2;
	if (parentExpr instanceof AssignmentExpression && (this$1 = parentExpr, this$1._expr1) == this || parentExpr == null && context.statement instanceof ForInStatement && (this$2 = context.statement, this$2._lhsExpr) == this) {
	} else {
		this._local.touchVariable$LAnalysisContext$LToken$B(context, this._token, false);
		if ((this$0 = this._local, this$0._type) == null) {
			return false;
		}
	}
	return true;
};


LocalExpression.prototype.getType$ = function () {
	var this$0;
	this$0 = this._local;
	return this$0._type;
};


LocalExpression.prototype.assertIsAssignable$LAnalysisContext$LToken$LType$ = function (context, token, type) {
	var this$0;
	var this$1;
	var this$2;
	if ((this$2 = this._local, this$2._type) == null) {
		if (type.equals$LType$(Type.nullType)) {
			context.errors.push(new CompileError(token, "cannot assign null without type annotation to a value of undetermined type"));
			return false;
		}
		LocalVariable$setType$LLocalVariable$LType$(this._local, type.asAssignableType$());
	} else if (! type.isConvertibleTo$LType$((this$1 = this._local, this$1._type))) {
		context.errors.push(new CompileError(token, "cannot assign a value of type '" + type.toString() + "' to '" + (this$0 = this._local, this$0._type).toString() + "'"));
		return false;
	}
	this._local.touchVariable$LAnalysisContext$LToken$B(context, this._token, true);
	return true;
};


function Emitter() {
	this._stash = {};
};

$__jsx_extend([Emitter], Object);
$__jsx_merge_interface(Emitter, Stashable);

Emitter.prototype.$__jsx_implements_Emitter = true;

function JavaScriptEmitter(platform) {
	this._stash = {};
	this._fileHeader = "var JSX = {};\n(function (JSX) {\n";
	this._fileFooter = "})(JSX);\n";
	this._runenv = "";
	this._output = "";
	this._outputEndsWithReturn = false;
	this._outputFile = null;
	this._indent = 0;
	this._emittingClass = null;
	this._emittingFunction = null;
	this._usesGenerator = false;
	this._enableProfiler = false;
	this._enableMinifier = false;
	this._enableRunTimeTypeCheck = true;
	this._bootstrapBuilder = null;
	this._sourceMapper = null;
	this._mangler = ({});
	this._namer = null;
	JavaScriptEmitter$_initialize$();
	this._platform = platform;
};

$__jsx_extend([JavaScriptEmitter], Object);
$__jsx_merge_interface(JavaScriptEmitter, Emitter);

JavaScriptEmitter.prototype.isSpecialCall$LCallExpression$ = function (callExpr) {
	var calleeExpr;
	var propExpr;
	calleeExpr = callExpr._expr;
	if (! (calleeExpr instanceof PropertyExpression)) {
		return false;
	}
	propExpr = calleeExpr;
	return JavaScriptEmitter$_isJsEval$LJavaScriptEmitter$LPropertyExpression$(this, propExpr) || JavaScriptEmitter$_isJsInvoke$LJavaScriptEmitter$LPropertyExpression$(this, propExpr) || JavaScriptEmitter$_isCallToMap$LJavaScriptEmitter$LPropertyExpression$(this, propExpr);
};


JavaScriptEmitter.prototype.isJsModule$LClassDefinition$ = function (classDef) {
	var this$0;
	var path$0;
	return classDef.className$() === "js" && (this$0 = classDef.getToken$(), this$0._filename) === (path$0 = this._platform.getRoot$() + "/lib/js/js.jsx", Util$_resolvedPathParts$S(path$0).join("/"));
};


function JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$($this, classDef) {
	var this$0;
	var path$0;
	return classDef.className$() === "js" && (this$0 = classDef.getToken$(), this$0._filename) === (path$0 = $this._platform.getRoot$() + "/lib/js/js.jsx", Util$_resolvedPathParts$S(path$0).join("/"));
};

JavaScriptEmitter.isJsModule$LJavaScriptEmitter$LClassDefinition$ = JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$;

JavaScriptEmitter.prototype._isJsEval$LPropertyExpression$ = function (calleeExpr) {
	var classDef;
	var this$0;
	if (! (calleeExpr._type instanceof StaticFunctionType)) {
		return false;
	}
	if ((this$0 = calleeExpr._identifierToken, this$0._value) !== "eval") {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	return (! JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$(this, classDef) ? false : true);
};


function JavaScriptEmitter$_isJsEval$LJavaScriptEmitter$LPropertyExpression$($this, calleeExpr) {
	var classDef;
	var this$0;
	if (! (calleeExpr._type instanceof StaticFunctionType)) {
		return false;
	}
	if ((this$0 = calleeExpr._identifierToken, this$0._value) !== "eval") {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	return (! JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$($this, classDef) ? false : true);
};

JavaScriptEmitter._isJsEval$LJavaScriptEmitter$LPropertyExpression$ = JavaScriptEmitter$_isJsEval$LJavaScriptEmitter$LPropertyExpression$;

JavaScriptEmitter.prototype._isJsInvoke$LPropertyExpression$ = function (calleeExpr) {
	var classDef;
	var this$0;
	if (! (calleeExpr._type instanceof StaticFunctionType)) {
		return false;
	}
	if ((this$0 = calleeExpr._identifierToken, this$0._value) !== "invoke") {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	return (! JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$(this, classDef) ? false : true);
};


function JavaScriptEmitter$_isJsInvoke$LJavaScriptEmitter$LPropertyExpression$($this, calleeExpr) {
	var classDef;
	var this$0;
	if (! (calleeExpr._type instanceof StaticFunctionType)) {
		return false;
	}
	if ((this$0 = calleeExpr._identifierToken, this$0._value) !== "invoke") {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	return (! JavaScriptEmitter$isJsModule$LJavaScriptEmitter$LClassDefinition$($this, classDef) ? false : true);
};

JavaScriptEmitter._isJsInvoke$LJavaScriptEmitter$LPropertyExpression$ = JavaScriptEmitter$_isJsInvoke$LJavaScriptEmitter$LPropertyExpression$;

JavaScriptEmitter.prototype._isCallToMap$LPropertyExpression$ = function (calleeExpr) {
	var classDef;
	var this$0;
	var this$0$0;
	var this$1;
	if (calleeExpr._type instanceof StaticFunctionType) {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! (classDef instanceof InstantiatedClassDefinition)) {
		return false;
	}
	if ((this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) !== "Map") {
		return false;
	}
	switch ((this$1 = calleeExpr._identifierToken, this$1._value)) {
	case "toString":
	case "hasOwnProperty":
	case "keys":
		return true;
	default:
		return false;
	}
};


function JavaScriptEmitter$_isCallToMap$LJavaScriptEmitter$LPropertyExpression$($this, calleeExpr) {
	var classDef;
	var this$0;
	var this$0$0;
	var this$1;
	if (calleeExpr._type instanceof StaticFunctionType) {
		return false;
	}
	classDef = calleeExpr._expr.getType$().getClassDef$();
	if (! (classDef instanceof InstantiatedClassDefinition)) {
		return false;
	}
	if ((this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) !== "Map") {
		return false;
	}
	switch ((this$1 = calleeExpr._identifierToken, this$1._value)) {
	case "toString":
	case "hasOwnProperty":
	case "keys":
		return true;
	default:
		return false;
	}
};

JavaScriptEmitter._isCallToMap$LJavaScriptEmitter$LPropertyExpression$ = JavaScriptEmitter$_isCallToMap$LJavaScriptEmitter$LPropertyExpression$;

JavaScriptEmitter.prototype.setRunEnv$S = function (runenv) {
	this._runenv = runenv;
};


JavaScriptEmitter.prototype.getSearchPaths$ = function () {
	return [ this._platform.getRoot$() + "/lib/js" ];
};


JavaScriptEmitter.prototype.setOutputFile$US = function (name) {
	if (name == null) {
		return;
	}
	this._outputFile = Util$_resolvedPathParts$S(name).join("/");
};


JavaScriptEmitter.prototype.getSourceMappingFiles$ = function () {
	var $this = this;
	var files;
	var sourceMapper;
	files = {};
	sourceMapper = this._sourceMapper;
	if (sourceMapper != null && this._outputFile != null) {
		Object.keys(sourceMapper._sourceFiles).forEach((function (filename) {
			var sourceContent$0;
			try {
				sourceContent$0 = $this._platform.load$S(filename);
				sourceMapper._impl.setSourceContent(filename, sourceContent$0);
			} catch ($__jsx_catch_0) {
				if ($__jsx_catch_0 instanceof Error) {
				} else {
					throw $__jsx_catch_0;
				}
			}
		}));
		files[sourceMapper._outputFile + ".mapping"] = sourceMapper._impl.toString();
	}
	return files;
};


JavaScriptEmitter.prototype.getMangler$ = function () {
	return this._mangler;
};


function JavaScriptEmitter$getMangler$LJavaScriptEmitter$($this) {
	return $this._mangler;
};

JavaScriptEmitter.getMangler$LJavaScriptEmitter$ = JavaScriptEmitter$getMangler$LJavaScriptEmitter$;

JavaScriptEmitter.prototype.getNamer$ = function () {
	return this._namer;
};


function JavaScriptEmitter$getNamer$LJavaScriptEmitter$($this) {
	return $this._namer;
};

JavaScriptEmitter.getNamer$LJavaScriptEmitter$ = JavaScriptEmitter$getNamer$LJavaScriptEmitter$;

JavaScriptEmitter.prototype.setEnableRunTimeTypeCheck$B = function (enable) {
	this._enableRunTimeTypeCheck = enable;
};


JavaScriptEmitter.prototype.getEnableSourceMap$ = function () {
	return this._sourceMapper != null;
};


JavaScriptEmitter.prototype.setEnableSourceMap$B = function (enable) {
	this._sourceMapper = (enable ? new SourceMapper(this._platform.getRoot$(), this._outputFile, this._runenv) : null);
};


JavaScriptEmitter.prototype.setEnableProfiler$B = function (enable) {
	this._enableProfiler = enable;
};


JavaScriptEmitter.prototype.getEnableMinifier$ = function () {
	return this._enableMinifier;
};


JavaScriptEmitter.prototype.setEnableMinifier$B = function (enable) {
	this._enableMinifier = enable;
};


JavaScriptEmitter.prototype.emit$ALClassDefinition$ = function (classDefs) {
	var minifier;
	var this$0;
	_Util$setOutputClassNames$ALClassDefinition$(classDefs);
	if (this._enableMinifier) {
		minifier = ({_emitter: this, _classDefs: classDefs, _propertyUseCount: {}, _propertyConversionTable: null, _globalUseCount: {}, _globalConversionTable: null, _outerLocals: []});
		this._namer = new _Minifier$x2E_MinifyingNamer().setup$L_Minifier$(minifier);
		JavaScriptEmitter$_emitInit$LJavaScriptEmitter$(this);
		JavaScriptEmitter$_emitCore$LJavaScriptEmitter$ALClassDefinition$(this, classDefs);
		_Minifier$_minifyProperties$L_Minifier$(minifier);
		_Minifier$_minifyStaticVariables$L_Minifier$(minifier);
		_Minifier$_minifyGlobals$L_Minifier$(minifier);
		this._namer = new _Minifier$x2E_MinifyingNamer().setup$L_Minifier$(minifier);
		JavaScriptEmitter$_emitInit$LJavaScriptEmitter$(this);
		JavaScriptEmitter$_emitCore$LJavaScriptEmitter$ALClassDefinition$(this, classDefs);
	} else {
		this$0 = new _Namer();
		this$0._emitter = this;
		this._namer = this$0;
		JavaScriptEmitter$_emitInit$LJavaScriptEmitter$(this);
		JavaScriptEmitter$_emitCore$LJavaScriptEmitter$ALClassDefinition$(this, classDefs);
	}
	JavaScriptEmitter$_emitClassMap$LJavaScriptEmitter$ALClassDefinition$(this, classDefs);
};


JavaScriptEmitter.prototype._emitInit$ = function () {
	var stash;
	var _platform$0;
	this._output = "";
	this._outputEndsWithReturn = true;
	this._indent = 0;
	this._emittingClass = null;
	this._emittingFunction = null;
	this._output += "// generatedy by JSX compiler " + Meta.IDENTIFIER + "\n";
	this._output += this._fileHeader;
	this._output += (_platform$0 = this._platform).load$S(_platform$0.getRoot$() + "/lib/js/rt/bootstrap.js");
	stash = this.getStash$S("no-debug");
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "JSX.DEBUG = " + (stash == null || stash.debugValue ? "true" : "false") + ";\n", null);
};


function JavaScriptEmitter$_emitInit$LJavaScriptEmitter$($this) {
	var stash;
	var _platform$0;
	$this._output = "";
	$this._outputEndsWithReturn = true;
	$this._indent = 0;
	$this._emittingClass = null;
	$this._emittingFunction = null;
	$this._output += "// generatedy by JSX compiler " + Meta.IDENTIFIER + "\n";
	$this._output += $this._fileHeader;
	$this._output += (_platform$0 = $this._platform).load$S(_platform$0.getRoot$() + "/lib/js/rt/bootstrap.js");
	stash = $this.getStash$S("no-debug");
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "JSX.DEBUG = " + (stash == null || stash.debugValue ? "true" : "false") + ";\n", null);
};

JavaScriptEmitter._emitInit$LJavaScriptEmitter$ = JavaScriptEmitter$_emitInit$LJavaScriptEmitter$;

JavaScriptEmitter.prototype._emitCore$ALClassDefinition$ = function (classDefs) {
	var $this = this;
	var i;
	for (i = 0; i < classDefs.length; ++i) {
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDefs[i], (function onFuncDef(funcDef) {
			MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, onFuncDef);
			if ((funcDef._flags & 8192) !== 0) {
				$this._usesGenerator = true;
			}
			JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
			return true;
		}));
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDefs[i], (function (varDef) {
			if ((varDef._flags & 8) !== 0 && varDef._initialValue != null) {
				JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LExpression$($this, varDef._initialValue);
			}
			return true;
		}));
	}
	for (i = 0; i < classDefs.length; ++i) {
		JavaScriptEmitter$_emitClassDefinition$LJavaScriptEmitter$LClassDefinition$(this, classDefs[i]);
	}
	for (i = 0; i < classDefs.length; ++i) {
		JavaScriptEmitter$_emitStaticInitializationCode$LJavaScriptEmitter$LClassDefinition$(this, classDefs[i]);
	}
};


function JavaScriptEmitter$_emitCore$LJavaScriptEmitter$ALClassDefinition$($this, classDefs) {
	var i;
	for (i = 0; i < classDefs.length; ++i) {
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDefs[i], (function onFuncDef(funcDef) {
			MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, onFuncDef);
			if ((funcDef._flags & 8192) !== 0) {
				$this._usesGenerator = true;
			}
			JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
			return true;
		}));
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDefs[i], (function (varDef) {
			if ((varDef._flags & 8) !== 0 && varDef._initialValue != null) {
				JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LExpression$($this, varDef._initialValue);
			}
			return true;
		}));
	}
	for (i = 0; i < classDefs.length; ++i) {
		JavaScriptEmitter$_emitClassDefinition$LJavaScriptEmitter$LClassDefinition$($this, classDefs[i]);
	}
	for (i = 0; i < classDefs.length; ++i) {
		JavaScriptEmitter$_emitStaticInitializationCode$LJavaScriptEmitter$LClassDefinition$($this, classDefs[i]);
	}
};

JavaScriptEmitter._emitCore$LJavaScriptEmitter$ALClassDefinition$ = JavaScriptEmitter$_emitCore$LJavaScriptEmitter$ALClassDefinition$;

JavaScriptEmitter.prototype.setBootstrapMode$NSS = function (mode, sourceFile, executableFor) {
	var this$0;
	switch (mode) {
	case 0:
		this._bootstrapBuilder = null;
		break;
	case 1:
		this._bootstrapBuilder = new _ExecutableBootstrapBuilder();
		break;
	case 2:
		this._bootstrapBuilder = new _TestBootstrapBuilder();
		break;
	default:
		throw new Error("unexpected bootstrap mode:" + (mode + ""));
	}
	if (this._bootstrapBuilder != null) {
		this$0 = this._bootstrapBuilder;
		this$0._emitter = this;
		this$0._entrySourceFile = sourceFile;
		this$0._executableFor = executableFor;
	}
};


function JavaScriptEmitter$setBootstrapMode$LJavaScriptEmitter$NSS($this, mode, sourceFile, executableFor) {
	var this$0;
	switch (mode) {
	case 0:
		$this._bootstrapBuilder = null;
		break;
	case 1:
		$this._bootstrapBuilder = new _ExecutableBootstrapBuilder();
		break;
	case 2:
		$this._bootstrapBuilder = new _TestBootstrapBuilder();
		break;
	default:
		throw new Error("unexpected bootstrap mode:" + (mode + ""));
	}
	if ($this._bootstrapBuilder != null) {
		this$0 = $this._bootstrapBuilder;
		this$0._emitter = $this;
		this$0._entrySourceFile = sourceFile;
		this$0._executableFor = executableFor;
	}
};

JavaScriptEmitter.setBootstrapMode$LJavaScriptEmitter$NSS = JavaScriptEmitter$setBootstrapMode$LJavaScriptEmitter$NSS;

JavaScriptEmitter.prototype.getStash$LStashable$ = function (stashable) {
	var stash;
	stash = stashable.getStash$S("jsemitter");
	if (stash == null) {
		stash = stashable.setStash$SLStash$("jsemitter", new _JSEmitterStash());
	}
	return stash;
};


function JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, stashable) {
	var stash;
	stash = stashable.getStash$S("jsemitter");
	if (stash == null) {
		stash = stashable.setStash$SLStash$("jsemitter", new _JSEmitterStash());
	}
	return stash;
};

JavaScriptEmitter.getStash$LJavaScriptEmitter$LStashable$ = JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$;

JavaScriptEmitter.prototype._setupBooleanizeFlags$LExpression$ = function (expr) {
	var $this = this;
	var exprReturnsBoolean;
	var parentExpr;
	var onExpr;
	exprReturnsBoolean = (function (expr) {
		return (expr instanceof LogicalExpression ? JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).returnsBoolean : expr.getType$().equals$LType$(Type.booleanType));
	});
	parentExpr = [];
	onExpr = (function (expr) {
		var shouldBooleanize;
		var returnsBoolean;
		var this$0;
		var this$1;
		var this$2;
		parentExpr.unshift(expr);
		Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		parentExpr.shift();
		if (expr instanceof LogicalExpression) {
			shouldBooleanize = true;
			returnsBoolean = false;
			if (exprReturnsBoolean((this$1 = expr, this$1._expr1)) && exprReturnsBoolean((this$2 = expr, this$2._expr2))) {
				returnsBoolean = true;
				shouldBooleanize = false;
			} else if (parentExpr.length === 0) {
			} else if (parentExpr[0] instanceof LogicalExpression || parentExpr[0] instanceof LogicalNotExpression) {
				shouldBooleanize = false;
			} else if (parentExpr[0] instanceof ConditionalExpression && (this$0 = parentExpr[0], this$0._condExpr) == expr) {
				shouldBooleanize = false;
			}
			JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).shouldBooleanize = shouldBooleanize;
			JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).returnsBoolean = returnsBoolean;
		}
		return true;
	});
	onExpr(expr);
};


function JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LExpression$($this, expr) {
	var exprReturnsBoolean;
	var parentExpr;
	var onExpr;
	exprReturnsBoolean = (function (expr) {
		return (expr instanceof LogicalExpression ? JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).returnsBoolean : expr.getType$().equals$LType$(Type.booleanType));
	});
	parentExpr = [];
	onExpr = (function (expr) {
		var shouldBooleanize;
		var returnsBoolean;
		var this$0;
		var this$1;
		var this$2;
		parentExpr.unshift(expr);
		Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		parentExpr.shift();
		if (expr instanceof LogicalExpression) {
			shouldBooleanize = true;
			returnsBoolean = false;
			if (exprReturnsBoolean((this$1 = expr, this$1._expr1)) && exprReturnsBoolean((this$2 = expr, this$2._expr2))) {
				returnsBoolean = true;
				shouldBooleanize = false;
			} else if (parentExpr.length === 0) {
			} else if (parentExpr[0] instanceof LogicalExpression || parentExpr[0] instanceof LogicalNotExpression) {
				shouldBooleanize = false;
			} else if (parentExpr[0] instanceof ConditionalExpression && (this$0 = parentExpr[0], this$0._condExpr) == expr) {
				shouldBooleanize = false;
			}
			JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).shouldBooleanize = shouldBooleanize;
			JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).returnsBoolean = returnsBoolean;
		}
		return true;
	});
	onExpr(expr);
};

JavaScriptEmitter._setupBooleanizeFlags$LJavaScriptEmitter$LExpression$ = JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LExpression$;

JavaScriptEmitter.prototype._setupBooleanizeFlags$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
			JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LExpression$($this, expr);
			if (statement instanceof ExpressionStatement || statement instanceof IfStatement || statement instanceof DoWhileStatement || statement instanceof WhileStatement || statement instanceof ForStatement) {
				JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).shouldBooleanize = false;
			}
			return true;
		}));
		return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), funcDef._statements);
};


function JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef) {
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
			JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LExpression$($this, expr);
			if (statement instanceof ExpressionStatement || statement instanceof IfStatement || statement instanceof DoWhileStatement || statement instanceof WhileStatement || statement instanceof ForStatement) {
				JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, expr).shouldBooleanize = false;
			}
			return true;
		}));
		return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), funcDef._statements);
};

JavaScriptEmitter._setupBooleanizeFlags$LJavaScriptEmitter$LMemberFunctionDefinition$ = JavaScriptEmitter$_setupBooleanizeFlags$LJavaScriptEmitter$LMemberFunctionDefinition$;

JavaScriptEmitter.prototype.shouldBooleanize$LExpression$ = function (logicalExpr) {
	return JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$(this, logicalExpr).shouldBooleanize;
};


function JavaScriptEmitter$shouldBooleanize$LJavaScriptEmitter$LExpression$($this, logicalExpr) {
	return JavaScriptEmitter$getStash$LJavaScriptEmitter$LStashable$($this, logicalExpr).shouldBooleanize;
};

JavaScriptEmitter.shouldBooleanize$LJavaScriptEmitter$LExpression$ = JavaScriptEmitter$shouldBooleanize$LJavaScriptEmitter$LExpression$;

JavaScriptEmitter.prototype._emitClassDefinition$LClassDefinition$ = function (classDef) {
	var ctors;
	var i;
	var members;
	var member;
	var this$0;
	var this$0$0;
	var this$1;
	if ((classDef.flags$() & 16) !== 0) {
		if (classDef._nativeSource != null) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "var " + this._namer.getNameOfClass$LClassDefinition$(classDef) + " = " + Util$decodeStringLiteral$S((this$0 = classDef._nativeSource, this$0._value)) + ";\n", classDef._nativeSource);
		}
		return;
	}
	this._emittingClass = classDef;
	try {
		ctors = _Util$findFunctions$LClassDefinition$SB(classDef, "constructor", false);
		for (i = 0; i < ctors.length; ++i) {
			JavaScriptEmitter$_emitConstructor$LJavaScriptEmitter$LMemberFunctionDefinition$(this, ctors[i]);
		}
		JavaScriptEmitter$_emitClassObjectAmendments$LJavaScriptEmitter$LClassDefinition$ALMemberFunctionDefinition$(this, classDef, ctors);
		members = classDef._members;
		for (i = 0; i < members.length; ++i) {
			member = members[i];
			if (member instanceof MemberFunctionDefinition) {
				if (! ((this$0$0 = member._nameToken, this$0$0._value) === "constructor" && (member._flags & 8) === 0) && (this$1 = member, this$1._statements) != null) {
					if (member instanceof TemplateFunctionDefinition) {
					} else {
						JavaScriptEmitter$_emitFunction$LJavaScriptEmitter$LMemberFunctionDefinition$(this, member);
					}
				}
			}
		}
	} finally {
		this._emittingClass = null;
	}
};


function JavaScriptEmitter$_emitClassDefinition$LJavaScriptEmitter$LClassDefinition$($this, classDef) {
	var ctors;
	var i;
	var members;
	var member;
	var this$0;
	var this$0$0;
	var this$1;
	if ((classDef.flags$() & 16) !== 0) {
		if (classDef._nativeSource != null) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "var " + $this._namer.getNameOfClass$LClassDefinition$(classDef) + " = " + Util$decodeStringLiteral$S((this$0 = classDef._nativeSource, this$0._value)) + ";\n", classDef._nativeSource);
		}
		return;
	}
	$this._emittingClass = classDef;
	try {
		ctors = _Util$findFunctions$LClassDefinition$SB(classDef, "constructor", false);
		for (i = 0; i < ctors.length; ++i) {
			JavaScriptEmitter$_emitConstructor$LJavaScriptEmitter$LMemberFunctionDefinition$($this, ctors[i]);
		}
		JavaScriptEmitter$_emitClassObjectAmendments$LJavaScriptEmitter$LClassDefinition$ALMemberFunctionDefinition$($this, classDef, ctors);
		members = classDef._members;
		for (i = 0; i < members.length; ++i) {
			member = members[i];
			if (member instanceof MemberFunctionDefinition) {
				if (! ((this$0$0 = member._nameToken, this$0$0._value) === "constructor" && (member._flags & 8) === 0) && (this$1 = member, this$1._statements) != null) {
					if (member instanceof TemplateFunctionDefinition) {
					} else {
						JavaScriptEmitter$_emitFunction$LJavaScriptEmitter$LMemberFunctionDefinition$($this, member);
					}
				}
			}
		}
	} finally {
		$this._emittingClass = null;
	}
};

JavaScriptEmitter._emitClassDefinition$LJavaScriptEmitter$LClassDefinition$ = JavaScriptEmitter$_emitClassDefinition$LJavaScriptEmitter$LClassDefinition$;

JavaScriptEmitter.prototype._emitStaticInitializationCode$LClassDefinition$ = function (classDef) {
	var members;
	var i;
	var member;
	if ((classDef.flags$() & 16) !== 0) {
		return;
	}
	members = classDef._members;
	for (i = 0; i < members.length; ++i) {
		member = members[i];
		if (member instanceof MemberVariableDefinition && (member._flags & 24) === 8) {
			JavaScriptEmitter$_emitStaticMemberVariable$LJavaScriptEmitter$LMemberVariableDefinition$(this, member);
		}
	}
};


function JavaScriptEmitter$_emitStaticInitializationCode$LJavaScriptEmitter$LClassDefinition$($this, classDef) {
	var members;
	var i;
	var member;
	if ((classDef.flags$() & 16) !== 0) {
		return;
	}
	members = classDef._members;
	for (i = 0; i < members.length; ++i) {
		member = members[i];
		if (member instanceof MemberVariableDefinition && (member._flags & 24) === 8) {
			JavaScriptEmitter$_emitStaticMemberVariable$LJavaScriptEmitter$LMemberVariableDefinition$($this, member);
		}
	}
};

JavaScriptEmitter._emitStaticInitializationCode$LJavaScriptEmitter$LClassDefinition$ = JavaScriptEmitter$_emitStaticInitializationCode$LJavaScriptEmitter$LClassDefinition$;

JavaScriptEmitter.prototype._emitClassMap$ALClassDefinition$ = function (classDefs) {
	var $this = this;
	var i;
	var isFirstEntry;
	var list;
	var pushClass;
	var filename;
	var escapedFilename;
	var this$0;
	var this$1;
	var s$0;
	classDefs = classDefs.concat([]);
	for (i = 0; i < classDefs.length; ) {
		if (classDefs[i].getToken$() == null || (classDefs[i].flags$() & 16) !== 0) {
			classDefs.splice(i, 1);
		} else {
			++i;
		}
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "\nvar $__jsx_classMap = {", null);
	isFirstEntry = true;
	while (classDefs.length !== 0) {
		list = [];
		pushClass = (function (classDef) {
			var ctors;
			var exportedCtor;
			var i;
			var push;
			var this$0;
			var ctors$len$0;
			ctors = _Util$findFunctions$LClassDefinition$SB(classDef, "constructor", false);
			if ((classDef.flags$() & 16384) !== 0) {
				if (ctors.length !== 0) {
					exportedCtor = null;
					for ((i = 0, ctors$len$0 = ctors.length); i < ctors$len$0; ++i) {
						if (((this$0 = ctors[i], this$0._flags) & 16384) !== 0) {
							exportedCtor = ctors[i];
						}
					}
					if (exportedCtor == null) {
						exportedCtor = ctors[0];
					}
					list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef), $this._namer.getNameOfConstructor$LClassDefinition$ALType$(classDef, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(exportedCtor)) ]);
				} else {
					list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef), $this._namer.getNameOfClass$LClassDefinition$(classDef) ]);
				}
			}
			if (! $this._enableMinifier) {
				if ((classDef.flags$() & 16384) === 0) {
					list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef), $this._namer.getNameOfClass$LClassDefinition$(classDef) ]);
				}
				push = (function (argTypes) {
					list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef) + _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this._mangler, argTypes), $this._namer.getNameOfConstructor$LClassDefinition$ALType$(classDef, argTypes) ]);
				});
				for (i = 0; i < ctors.length; ++i) {
					push(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(ctors[i]));
				}
			}
		});
		this$0 = classDefs[0].getToken$();
		filename = this$0._filename;
		pushClass(classDefs.shift());
		for (i = 0; i < classDefs.length; ) {
			if ((this$1 = classDefs[i].getToken$(), this$1._filename) === filename) {
				pushClass(classDefs[i]);
				classDefs.splice(i, 1);
			} else {
				++i;
			}
		}
		if (list.length !== 0 || ! this._enableMinifier) {
			if (isFirstEntry) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "\n", null);
				++this._indent;
				isFirstEntry = false;
			} else {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ",\n", null);
			}
			escapedFilename = JSON.stringify(Platform$encodeFilename$LPlatform$S(this._platform, filename));
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, escapedFilename + ": ", null);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "{\n", null);
			++this._indent;
			for (i = 0; i < list.length; ++i) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, (s$0 = list[i][0], s$0.length === 0 || s$0.match(/^[A-Za-z_$][A-Za-z0-9_$]*$/) ? s$0 : Util$encodeStringLiteral$S(s$0)) + ": " + list[i][1], null);
				if (i !== list.length - 1) {
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ",", null);
				}
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "\n", null);
			}
			if (--this._indent < 0) {
				throw new Error("indent mistach");
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "}", null);
		}
	}
	if (! isFirstEntry) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "\n", null);
		if (--this._indent < 0) {
			throw new Error("indent mistach");
		}
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "};\n\n", null);
};


function JavaScriptEmitter$_emitClassMap$LJavaScriptEmitter$ALClassDefinition$($this, classDefs) {
	var i;
	var isFirstEntry;
	var list;
	var pushClass;
	var filename;
	var escapedFilename;
	var this$0;
	var this$1;
	var s$0;
	classDefs = classDefs.concat([]);
	for (i = 0; i < classDefs.length; ) {
		if (classDefs[i].getToken$() == null || (classDefs[i].flags$() & 16) !== 0) {
			classDefs.splice(i, 1);
		} else {
			++i;
		}
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "\nvar $__jsx_classMap = {", null);
	isFirstEntry = true;
	while (classDefs.length !== 0) {
		list = [];
		pushClass = (function (classDef) {
			var ctors;
			var exportedCtor;
			var i;
			var push;
			var this$0;
			var ctors$len$0;
			ctors = _Util$findFunctions$LClassDefinition$SB(classDef, "constructor", false);
			if ((classDef.flags$() & 16384) !== 0) {
				if (ctors.length !== 0) {
					exportedCtor = null;
					for ((i = 0, ctors$len$0 = ctors.length); i < ctors$len$0; ++i) {
						if (((this$0 = ctors[i], this$0._flags) & 16384) !== 0) {
							exportedCtor = ctors[i];
						}
					}
					if (exportedCtor == null) {
						exportedCtor = ctors[0];
					}
					list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef), $this._namer.getNameOfConstructor$LClassDefinition$ALType$(classDef, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(exportedCtor)) ]);
				} else {
					list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef), $this._namer.getNameOfClass$LClassDefinition$(classDef) ]);
				}
			}
			if (! $this._enableMinifier) {
				if ((classDef.flags$() & 16384) === 0) {
					list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef), $this._namer.getNameOfClass$LClassDefinition$(classDef) ]);
				}
				push = (function (argTypes) {
					list.push([ ClassDefinition$classFullName$LClassDefinition$(classDef) + _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this._mangler, argTypes), $this._namer.getNameOfConstructor$LClassDefinition$ALType$(classDef, argTypes) ]);
				});
				for (i = 0; i < ctors.length; ++i) {
					push(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(ctors[i]));
				}
			}
		});
		this$0 = classDefs[0].getToken$();
		filename = this$0._filename;
		pushClass(classDefs.shift());
		for (i = 0; i < classDefs.length; ) {
			if ((this$1 = classDefs[i].getToken$(), this$1._filename) === filename) {
				pushClass(classDefs[i]);
				classDefs.splice(i, 1);
			} else {
				++i;
			}
		}
		if (list.length !== 0 || ! $this._enableMinifier) {
			if (isFirstEntry) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "\n", null);
				++$this._indent;
				isFirstEntry = false;
			} else {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ",\n", null);
			}
			escapedFilename = JSON.stringify(Platform$encodeFilename$LPlatform$S($this._platform, filename));
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, escapedFilename + ": ", null);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "{\n", null);
			++$this._indent;
			for (i = 0; i < list.length; ++i) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, (s$0 = list[i][0], s$0.length === 0 || s$0.match(/^[A-Za-z_$][A-Za-z0-9_$]*$/) ? s$0 : Util$encodeStringLiteral$S(s$0)) + ": " + list[i][1], null);
				if (i !== list.length - 1) {
					JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ",", null);
				}
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "\n", null);
			}
			if (--$this._indent < 0) {
				throw new Error("indent mistach");
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "}", null);
		}
	}
	if (! isFirstEntry) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "\n", null);
		if (--$this._indent < 0) {
			throw new Error("indent mistach");
		}
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "};\n\n", null);
};

JavaScriptEmitter._emitClassMap$LJavaScriptEmitter$ALClassDefinition$ = JavaScriptEmitter$_emitClassMap$LJavaScriptEmitter$ALClassDefinition$;

JavaScriptEmitter.prototype.getOutput$ = function () {
	var output;
	var this$0;
	var ast$0;
	var _platform$0;
	output = "";
	if (this._sourceMapper) {
		output += (this$0 = this._sourceMapper, this$0._header);
	}
	output += this._output + "\n";
	if (this._enableProfiler) {
		output += (_platform$0 = this._platform).load$S(_platform$0.getRoot$() + "/lib/js/rt/profiler.js");
	}
	if (this._bootstrapBuilder != null) {
		output = _BootstrapBuilder$addBootstrap$L_BootstrapBuilder$S(this._bootstrapBuilder, output);
	}
	output += this._fileFooter;
	if (this._sourceMapper) {
		output += SourceMapper$getSourceMapFooter$LSourceMapper$(this._sourceMapper);
	}
	if (this._enableMinifier) {
		if (! this._usesGenerator) {
			ast$0 = esprima$0.parse(output);
			ast$0 = esmangle$0.mangle(ast$0, ({ destructive: true }));
			output = escodegen$0.generate(ast$0, ({ format: ({ renumber: true, hexadecimal: true, escapeless: true, compact: true, semicolons: false, parentheses: false }), directive: true }));
		}
	}
	return output;
};


JavaScriptEmitter.prototype._emitClassObjectAmendments$LClassDefinition$ALMemberFunctionDefinition$ = function (classDef, constructors) {
	var $this = this;
	var extendClassDef;
	var i;
	var implementTypes;
	var unresolvedExports;
	var this$0;
	var this$1;
	var this$2;
	if (classDef._extendType != null) {
		this$0 = classDef._extendType;
		extendClassDef = this$0._classDef;
	} else {
		extendClassDef = null;
	}
	if (constructors.length !== 0) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "$__jsx_extend([", null);
		for (i = 0; i < constructors.length; ++i) {
			if (i !== 0) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ", ", null);
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfConstructor$LClassDefinition$ALType$(classDef, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(constructors[i])), null);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "], " + (extendClassDef != null ? this._namer.getNameOfClass$LClassDefinition$(extendClassDef) : "Object") + ");\n", null);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "function " + this._namer.getNameOfClass$LClassDefinition$(classDef) + "() {}\n", null);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "$__jsx_extend([" + this._namer.getNameOfClass$LClassDefinition$(classDef) + "], " + (extendClassDef != null ? this._namer.getNameOfClass$LClassDefinition$(extendClassDef) : "Object") + ");\n", null);
	}
	implementTypes = classDef._implementTypes;
	if (implementTypes.length !== 0) {
		for (i = 0; i < implementTypes.length; ++i) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "$__jsx_merge_interface(" + this._namer.getNameOfClass$LClassDefinition$(classDef) + ", " + this._namer.getNameOfClass$LClassDefinition$((this$1 = implementTypes[i], this$1._classDef)) + ");\n", null);
		}
		unresolvedExports = {};
		(function buildUnresolvedExports(baseClassDef) {
			var this$0;
			if (baseClassDef._extendType != null) {
				buildUnresolvedExports((this$0 = baseClassDef._extendType, this$0._classDef));
			}
			baseClassDef._implementTypes.forEach((function (implType) {
				buildUnresolvedExports(implType.getClassDef$());
			}));
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(baseClassDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_EXPORT)) === ClassDefinition.IS_EXPORT && MemberDefinition$name$LMemberDefinition$(funcDef) !== "constructor") {
					if (classDef == baseClassDef && MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef) != null) {
						delete unresolvedExports[MemberDefinition$name$LMemberDefinition$(funcDef)];
					} else {
						unresolvedExports[MemberDefinition$name$LMemberDefinition$(funcDef)] = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef);
					}
				}
				return true;
			}));
		})(classDef);
		for (i = implementTypes.length - 1; i >= 0 && Object.keys(unresolvedExports).length !== 0; --i) {
			ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$((this$2 = implementTypes[i], this$2._classDef), (function (baseClassDef) {
				var name;
				for (name in unresolvedExports) {
					if (Util$findFunctionInClass$LClassDefinition$SALType$B(baseClassDef, name, unresolvedExports[name], false)) {
						JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(classDef) + ".prototype." + name + " = " + $this._namer.getNameOfClass$LClassDefinition$(classDef) + ".prototype." + $this._namer.getNameOfMethod$LClassDefinition$SALType$(classDef, name, unresolvedExports[name]) + ";\n", null);
						delete unresolvedExports[name];
					}
				}
				return Object.keys(unresolvedExports).length !== 0;
			}));
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "\n", null);
	}
	if ((classDef.flags$() & 192) !== 0) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(classDef) + ".prototype.$__jsx_implements_" + this._namer.getNameOfClass$LClassDefinition$(classDef) + " = true;\n\n", null);
	}
};


function JavaScriptEmitter$_emitClassObjectAmendments$LJavaScriptEmitter$LClassDefinition$ALMemberFunctionDefinition$($this, classDef, constructors) {
	var extendClassDef;
	var i;
	var implementTypes;
	var unresolvedExports;
	var this$0;
	var this$1;
	var this$2;
	if (classDef._extendType != null) {
		this$0 = classDef._extendType;
		extendClassDef = this$0._classDef;
	} else {
		extendClassDef = null;
	}
	if (constructors.length !== 0) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "$__jsx_extend([", null);
		for (i = 0; i < constructors.length; ++i) {
			if (i !== 0) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ", ", null);
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfConstructor$LClassDefinition$ALType$(classDef, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(constructors[i])), null);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "], " + (extendClassDef != null ? $this._namer.getNameOfClass$LClassDefinition$(extendClassDef) : "Object") + ");\n", null);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "function " + $this._namer.getNameOfClass$LClassDefinition$(classDef) + "() {}\n", null);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "$__jsx_extend([" + $this._namer.getNameOfClass$LClassDefinition$(classDef) + "], " + (extendClassDef != null ? $this._namer.getNameOfClass$LClassDefinition$(extendClassDef) : "Object") + ");\n", null);
	}
	implementTypes = classDef._implementTypes;
	if (implementTypes.length !== 0) {
		for (i = 0; i < implementTypes.length; ++i) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "$__jsx_merge_interface(" + $this._namer.getNameOfClass$LClassDefinition$(classDef) + ", " + $this._namer.getNameOfClass$LClassDefinition$((this$1 = implementTypes[i], this$1._classDef)) + ");\n", null);
		}
		unresolvedExports = {};
		(function buildUnresolvedExports(baseClassDef) {
			var this$0;
			if (baseClassDef._extendType != null) {
				buildUnresolvedExports((this$0 = baseClassDef._extendType, this$0._classDef));
			}
			baseClassDef._implementTypes.forEach((function (implType) {
				buildUnresolvedExports(implType.getClassDef$());
			}));
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(baseClassDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_EXPORT)) === ClassDefinition.IS_EXPORT && MemberDefinition$name$LMemberDefinition$(funcDef) !== "constructor") {
					if (classDef == baseClassDef && MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef) != null) {
						delete unresolvedExports[MemberDefinition$name$LMemberDefinition$(funcDef)];
					} else {
						unresolvedExports[MemberDefinition$name$LMemberDefinition$(funcDef)] = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef);
					}
				}
				return true;
			}));
		})(classDef);
		for (i = implementTypes.length - 1; i >= 0 && Object.keys(unresolvedExports).length !== 0; --i) {
			ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$((this$2 = implementTypes[i], this$2._classDef), (function (baseClassDef) {
				var name;
				for (name in unresolvedExports) {
					if (Util$findFunctionInClass$LClassDefinition$SALType$B(baseClassDef, name, unresolvedExports[name], false)) {
						JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(classDef) + ".prototype." + name + " = " + $this._namer.getNameOfClass$LClassDefinition$(classDef) + ".prototype." + $this._namer.getNameOfMethod$LClassDefinition$SALType$(classDef, name, unresolvedExports[name]) + ";\n", null);
						delete unresolvedExports[name];
					}
				}
				return Object.keys(unresolvedExports).length !== 0;
			}));
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "\n", null);
	}
	if ((classDef.flags$() & 192) !== 0) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(classDef) + ".prototype.$__jsx_implements_" + $this._namer.getNameOfClass$LClassDefinition$(classDef) + " = true;\n\n", null);
	}
};

JavaScriptEmitter._emitClassObjectAmendments$LJavaScriptEmitter$LClassDefinition$ALMemberFunctionDefinition$ = JavaScriptEmitter$_emitClassObjectAmendments$LJavaScriptEmitter$LClassDefinition$ALMemberFunctionDefinition$;

JavaScriptEmitter.prototype._emitConstructor$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var funcName;
	funcName = this._namer.getNameOfConstructor$LClassDefinition$ALType$(funcDef._classDef, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "function ", null);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, funcName + "(", funcDef._classDef.getToken$());
	this._namer.enterFunction$LMemberFunctionDefinition$F$V$(funcDef, (function () {
		JavaScriptEmitter$_emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ") {\n", null);
		++$this._indent;
		JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		if (--$this._indent < 0) {
			throw new Error("indent mistach");
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "};\n\n", null);
	}));
};


function JavaScriptEmitter$_emitConstructor$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef) {
	var funcName;
	funcName = $this._namer.getNameOfConstructor$LClassDefinition$ALType$(funcDef._classDef, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef));
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "function ", null);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, funcName + "(", funcDef._classDef.getToken$());
	$this._namer.enterFunction$LMemberFunctionDefinition$F$V$(funcDef, (function () {
		JavaScriptEmitter$_emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ") {\n", null);
		++$this._indent;
		JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		if (--$this._indent < 0) {
			throw new Error("indent mistach");
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "};\n\n", null);
	}));
};

JavaScriptEmitter._emitConstructor$LJavaScriptEmitter$LMemberFunctionDefinition$ = JavaScriptEmitter$_emitConstructor$LJavaScriptEmitter$LMemberFunctionDefinition$;

JavaScriptEmitter.prototype._emitFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var isStatic;
	var this$0$0;
	var this$0$1;
	var this$0$2;
	var this$0$4;
	var this$0$5;
	var this$0$6;
	var this$0$7;
	var this$0$8;
	var this$0$9;
	var _nameToken$0;
	isStatic = (funcDef._flags & 8) !== 0;
	if (isStatic) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "function " + this._namer.getNameOfStaticFunction$LClassDefinition$SALType$(funcDef._classDef, (this$0$0 = funcDef._nameToken, this$0$0._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + "(", funcDef._nameToken);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + ".prototype." + this._namer.getNameOfMethod$LClassDefinition$SALType$(funcDef._classDef, (this$0$1 = funcDef._nameToken, this$0$1._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + " = function (", funcDef._nameToken);
	}
	this._namer.enterFunction$LMemberFunctionDefinition$F$V$(funcDef, (function () {
		JavaScriptEmitter$_emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ") {\n", null);
		++$this._indent;
		JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		if (--$this._indent < 0) {
			throw new Error("indent mistach");
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "};\n\n", null);
	}));
	if (isStatic) {
		if (Util$memberIsExported$LClassDefinition$SALType$B(funcDef._classDef, (this$0$8 = funcDef._nameToken, this$0$8._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), true)) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + "." + (this$0$2 = _nameToken$0 = funcDef._nameToken, this$0$2._value) + " = " + this._namer.getNameOfStaticFunction$LClassDefinition$SALType$(funcDef._classDef, (_nameToken$0, _nameToken$0._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + ";\n", null);
		}
		if (! this._enableMinifier) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + "." + (this$0$4 = funcDef._nameToken, this$0$4._value) + _Mangler$mangleFunctionArguments$L_Mangler$ALType$(this._mangler, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + " = " + this._namer.getNameOfStaticFunction$LClassDefinition$SALType$(funcDef._classDef, (this$0$5 = funcDef._nameToken, this$0$5._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + ";\n", null);
		}
	} else if (Util$memberIsExported$LClassDefinition$SALType$B(funcDef._classDef, (this$0$9 = funcDef._nameToken, this$0$9._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), false)) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + ".prototype." + (this$0$6 = funcDef._nameToken, this$0$6._value) + " = " + this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + ".prototype." + this._namer.getNameOfMethod$LClassDefinition$SALType$(funcDef._classDef, (this$0$7 = funcDef._nameToken, this$0$7._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + ";\n", null);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "\n", null);
};


function JavaScriptEmitter$_emitFunction$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef) {
	var isStatic;
	var this$0$0;
	var this$0$1;
	var this$0$2;
	var this$0$4;
	var this$0$5;
	var this$0$6;
	var this$0$7;
	var this$0$8;
	var this$0$9;
	var _nameToken$0;
	isStatic = (funcDef._flags & 8) !== 0;
	if (isStatic) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "function " + $this._namer.getNameOfStaticFunction$LClassDefinition$SALType$(funcDef._classDef, (this$0$0 = funcDef._nameToken, this$0$0._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + "(", funcDef._nameToken);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + ".prototype." + $this._namer.getNameOfMethod$LClassDefinition$SALType$(funcDef._classDef, (this$0$1 = funcDef._nameToken, this$0$1._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + " = function (", funcDef._nameToken);
	}
	$this._namer.enterFunction$LMemberFunctionDefinition$F$V$(funcDef, (function () {
		JavaScriptEmitter$_emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ") {\n", null);
		++$this._indent;
		JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef);
		if (--$this._indent < 0) {
			throw new Error("indent mistach");
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "};\n\n", null);
	}));
	if (isStatic) {
		if (Util$memberIsExported$LClassDefinition$SALType$B(funcDef._classDef, (this$0$8 = funcDef._nameToken, this$0$8._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), true)) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + "." + (this$0$2 = _nameToken$0 = funcDef._nameToken, this$0$2._value) + " = " + $this._namer.getNameOfStaticFunction$LClassDefinition$SALType$(funcDef._classDef, (_nameToken$0, _nameToken$0._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + ";\n", null);
		}
		if (! $this._enableMinifier) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + "." + (this$0$4 = funcDef._nameToken, this$0$4._value) + _Mangler$mangleFunctionArguments$L_Mangler$ALType$($this._mangler, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + " = " + $this._namer.getNameOfStaticFunction$LClassDefinition$SALType$(funcDef._classDef, (this$0$5 = funcDef._nameToken, this$0$5._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + ";\n", null);
		}
	} else if (Util$memberIsExported$LClassDefinition$SALType$B(funcDef._classDef, (this$0$9 = funcDef._nameToken, this$0$9._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), false)) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + ".prototype." + (this$0$6 = funcDef._nameToken, this$0$6._value) + " = " + $this._namer.getNameOfClass$LClassDefinition$(funcDef._classDef) + ".prototype." + $this._namer.getNameOfMethod$LClassDefinition$SALType$(funcDef._classDef, (this$0$7 = funcDef._nameToken, this$0$7._value), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)) + ";\n", null);
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "\n", null);
};

JavaScriptEmitter._emitFunction$LJavaScriptEmitter$LMemberFunctionDefinition$ = JavaScriptEmitter$_emitFunction$LJavaScriptEmitter$LMemberFunctionDefinition$;

JavaScriptEmitter.prototype._emitFunctionArguments$LMemberFunctionDefinition$ = function (funcDef) {
	var args;
	var i;
	var this$0;
	args = funcDef._args;
	for (i = 0; i < args.length; ++i) {
		if (i !== 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ", ", null);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfLocalVariable$LLocalVariable$(args[i]), (this$0 = args[i], this$0._name));
	}
};


function JavaScriptEmitter$_emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef) {
	var args;
	var i;
	var this$0;
	args = funcDef._args;
	for (i = 0; i < args.length; ++i) {
		if (i !== 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ", ", null);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfLocalVariable$LLocalVariable$(args[i]), (this$0 = args[i], this$0._name));
	}
};

JavaScriptEmitter._emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$ = JavaScriptEmitter$_emitFunctionArguments$LJavaScriptEmitter$LMemberFunctionDefinition$;

JavaScriptEmitter.prototype._emitFunctionBody$LMemberFunctionDefinition$ = function (funcDef) {
	var prevEmittingFunction;
	var locals;
	var i;
	var type;
	var tempVars;
	var statements;
	var this$0;
	var this$1;
	var varNames$0;
	var k$0;
	var statement$0;
	var emitter$0;
	prevEmittingFunction = this._emittingFunction;
	try {
		this._emittingFunction = funcDef;
		if (this._enableProfiler) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "var $__jsx_profiler_ctx = $__jsx_profiler.enter(" + Util$encodeStringLiteral$S(funcDef.getNotation$()) + ");\n", null);
		}
		if (funcDef._parent == null && (funcDef._flags & 8) === 0 && funcDef._closures.length !== 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "var $this = this;\n", null);
		}
		locals = funcDef._locals;
		for (i = 0; i < locals.length; ++i) {
			this$0 = locals[i];
			type = this$0._type;
			if (type == null) {
				continue;
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "var " + this._namer.getNameOfLocalVariable$LLocalVariable$(locals[i]) + ";\n", null);
		}
		this$1 = _TempVarLister$update$L_TempVarLister$LMemberFunctionDefinition$(({_varNameMap: {}}), funcDef);
		varNames$0 = [];
		for (k$0 in this$1._varNameMap) {
			varNames$0.push(k$0);
		}
		tempVars = varNames$0;
		for (i = 0; i !== tempVars.length; ++i) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "var " + tempVars[i] + ";\n", null);
		}
		statements = funcDef._statements;
		for (i = 0; i < statements.length; ++i) {
			statement$0 = statements[i];
			emitter$0 = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$(this, statement$0);
			emitter$0.emit$();
		}
		if (this._enableProfiler) {
			if (statements.length === 0 || ! (statements[statements.length - 1] instanceof ReturnStatement)) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "$__jsx_profiler.exit();\n", null);
			}
		}
	} finally {
		this._emittingFunction = prevEmittingFunction;
	}
};


function JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$($this, funcDef) {
	var prevEmittingFunction;
	var locals;
	var i;
	var type;
	var tempVars;
	var statements;
	var this$0;
	var this$1;
	var varNames$0;
	var k$0;
	var statement$0;
	var emitter$0;
	prevEmittingFunction = $this._emittingFunction;
	try {
		$this._emittingFunction = funcDef;
		if ($this._enableProfiler) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "var $__jsx_profiler_ctx = $__jsx_profiler.enter(" + Util$encodeStringLiteral$S(funcDef.getNotation$()) + ");\n", null);
		}
		if (funcDef._parent == null && (funcDef._flags & 8) === 0 && funcDef._closures.length !== 0) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "var $this = this;\n", null);
		}
		locals = funcDef._locals;
		for (i = 0; i < locals.length; ++i) {
			this$0 = locals[i];
			type = this$0._type;
			if (type == null) {
				continue;
			}
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "var " + $this._namer.getNameOfLocalVariable$LLocalVariable$(locals[i]) + ";\n", null);
		}
		this$1 = _TempVarLister$update$L_TempVarLister$LMemberFunctionDefinition$(({_varNameMap: {}}), funcDef);
		varNames$0 = [];
		for (k$0 in this$1._varNameMap) {
			varNames$0.push(k$0);
		}
		tempVars = varNames$0;
		for (i = 0; i !== tempVars.length; ++i) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "var " + tempVars[i] + ";\n", null);
		}
		statements = funcDef._statements;
		for (i = 0; i < statements.length; ++i) {
			statement$0 = statements[i];
			emitter$0 = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$($this, statement$0);
			emitter$0.emit$();
		}
		if ($this._enableProfiler) {
			if (statements.length === 0 || ! (statements[statements.length - 1] instanceof ReturnStatement)) {
				JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "$__jsx_profiler.exit();\n", null);
			}
		}
	} finally {
		$this._emittingFunction = prevEmittingFunction;
	}
};

JavaScriptEmitter._emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$ = JavaScriptEmitter$_emitFunctionBody$LJavaScriptEmitter$LMemberFunctionDefinition$;

JavaScriptEmitter.prototype._emitStaticMemberVariable$LMemberVariableDefinition$ = function (variable) {
	var $this = this;
	var initialValue;
	var tempVars;
	var i;
	var this$0$0;
	var this$0;
	var varNames$0;
	var k$0;
	var this$0$1;
	var preCheckCb$0;
	var r$0;
	initialValue = variable._initialValue;
	if (initialValue != null && (preCheckCb$0 = (function (expr) {
		var holderExpr;
		var this$0;
		var this$1;
		if (expr instanceof PropertyExpression) {
			this$0 = expr;
			holderExpr = this$0._expr;
			if (holderExpr instanceof ClassExpression || holderExpr instanceof PropertyExpression && (this$1 = holderExpr, this$1._isInner)) {
				return true;
			}
		} else if (expr instanceof NewExpression) {
			if (_Util$getNewExpressionInliner$LNewExpression$(expr) != null) {
				return false;
			}
		}
		return null;
	}), r$0 = preCheckCb$0(initialValue), r$0 != null ? r$0 : initialValue._doHasSideEffects$F$LExpression$UB$(preCheckCb$0))) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "$__jsx_lazy_init(", variable._nameToken);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(variable._classDef) + ", \"" + this._namer.getNameOfStaticVariable$LClassDefinition$S(variable._classDef, (this$0$0 = variable._nameToken, this$0$0._value)) + "\", function () {\n", variable._nameToken);
		++this._indent;
		this$0 = _TempVarLister$update$L_TempVarLister$LExpression$(({_varNameMap: {}}), initialValue);
		varNames$0 = [];
		for (k$0 in this$0._varNameMap) {
			varNames$0.push(k$0);
		}
		tempVars = varNames$0;
		for (i = 0; i !== tempVars.length; ++i) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "var " + tempVars[i] + ";\n", variable._nameToken);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "return ", variable._nameToken);
		JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$(this, initialValue, variable.getType$());
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ";\n", variable._nameToken);
		if (--this._indent < 0) {
			throw new Error("indent mistach");
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "});\n", variable._nameToken);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, this._namer.getNameOfClass$LClassDefinition$(variable._classDef) + "." + this._namer.getNameOfStaticVariable$LClassDefinition$S(variable._classDef, (this$0$1 = variable._nameToken, this$0$1._value)) + " = ", variable._nameToken);
		JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$(this, initialValue, variable.getType$());
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ";\n", initialValue._token);
	}
};


function JavaScriptEmitter$_emitStaticMemberVariable$LJavaScriptEmitter$LMemberVariableDefinition$($this, variable) {
	var initialValue;
	var tempVars;
	var i;
	var this$0$0;
	var this$0;
	var varNames$0;
	var k$0;
	var this$0$1;
	var preCheckCb$0;
	var r$0;
	initialValue = variable._initialValue;
	if (initialValue != null && (preCheckCb$0 = (function (expr) {
		var holderExpr;
		var this$0;
		var this$1;
		if (expr instanceof PropertyExpression) {
			this$0 = expr;
			holderExpr = this$0._expr;
			if (holderExpr instanceof ClassExpression || holderExpr instanceof PropertyExpression && (this$1 = holderExpr, this$1._isInner)) {
				return true;
			}
		} else if (expr instanceof NewExpression) {
			if (_Util$getNewExpressionInliner$LNewExpression$(expr) != null) {
				return false;
			}
		}
		return null;
	}), r$0 = preCheckCb$0(initialValue), r$0 != null ? r$0 : initialValue._doHasSideEffects$F$LExpression$UB$(preCheckCb$0))) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "$__jsx_lazy_init(", variable._nameToken);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(variable._classDef) + ", \"" + $this._namer.getNameOfStaticVariable$LClassDefinition$S(variable._classDef, (this$0$0 = variable._nameToken, this$0$0._value)) + "\", function () {\n", variable._nameToken);
		++$this._indent;
		this$0 = _TempVarLister$update$L_TempVarLister$LExpression$(({_varNameMap: {}}), initialValue);
		varNames$0 = [];
		for (k$0 in this$0._varNameMap) {
			varNames$0.push(k$0);
		}
		tempVars = varNames$0;
		for (i = 0; i !== tempVars.length; ++i) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "var " + tempVars[i] + ";\n", variable._nameToken);
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "return ", variable._nameToken);
		JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$($this, initialValue, variable.getType$());
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ";\n", variable._nameToken);
		if (--$this._indent < 0) {
			throw new Error("indent mistach");
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "});\n", variable._nameToken);
	} else {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, $this._namer.getNameOfClass$LClassDefinition$(variable._classDef) + "." + $this._namer.getNameOfStaticVariable$LClassDefinition$S(variable._classDef, (this$0$1 = variable._nameToken, this$0$1._value)) + " = ", variable._nameToken);
		JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$($this, initialValue, variable.getType$());
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ";\n", initialValue._token);
	}
};

JavaScriptEmitter._emitStaticMemberVariable$LJavaScriptEmitter$LMemberVariableDefinition$ = JavaScriptEmitter$_emitStaticMemberVariable$LJavaScriptEmitter$LMemberVariableDefinition$;

JavaScriptEmitter.prototype._emitStatements$ALStatement$ = function (statements) {
	var i;
	var statement$0;
	var emitter$0;
	++this._indent;
	for (i = 0; i < statements.length; ++i) {
		statement$0 = statements[i];
		emitter$0 = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$(this, statement$0);
		emitter$0.emit$();
	}
	if (--this._indent < 0) {
		throw new Error("indent mistach");
	}
};


function JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$($this, statements) {
	var i;
	var statement$0;
	var emitter$0;
	++$this._indent;
	for (i = 0; i < statements.length; ++i) {
		statement$0 = statements[i];
		emitter$0 = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$($this, statement$0);
		emitter$0.emit$();
	}
	if (--$this._indent < 0) {
		throw new Error("indent mistach");
	}
};

JavaScriptEmitter._emitStatements$LJavaScriptEmitter$ALStatement$ = JavaScriptEmitter$_emitStatements$LJavaScriptEmitter$ALStatement$;

JavaScriptEmitter.prototype._emitStatement$LStatement$ = function (statement) {
	var emitter;
	emitter = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$(this, statement);
	emitter.emit$();
};


function JavaScriptEmitter$_emitStatement$LJavaScriptEmitter$LStatement$($this, statement) {
	var emitter;
	emitter = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$($this, statement);
	emitter.emit$();
};

JavaScriptEmitter._emitStatement$LJavaScriptEmitter$LStatement$ = JavaScriptEmitter$_emitStatement$LJavaScriptEmitter$LStatement$;

JavaScriptEmitter.prototype._addSourceMapping$LToken$ = function (token) {
	SourceMapper$add$LSourceMapper$SNNUSUS(this._sourceMapper, this._output, token._lineNumber, token._columnNumber, token._isIdentifier ? token._value : null, token._filename);
};


function JavaScriptEmitter$_addSourceMapping$LJavaScriptEmitter$LToken$($this, token) {
	SourceMapper$add$LSourceMapper$SNNUSUS($this._sourceMapper, $this._output, token._lineNumber, token._columnNumber, token._isIdentifier ? token._value : null, token._filename);
};

JavaScriptEmitter._addSourceMapping$LJavaScriptEmitter$LToken$ = JavaScriptEmitter$_addSourceMapping$LJavaScriptEmitter$LToken$;

JavaScriptEmitter.prototype._emit$SLToken$ = function (str, token) {
	var $this = this;
	if (str === "") {
		return;
	}
	if (this._outputEndsWithReturn && this._indent !== 0) {
		this._output += JavaScriptEmitter$_getIndent$LJavaScriptEmitter$(this);
		this._outputEndsWithReturn = false;
	}
	if (this._sourceMapper != null && token != null) {
		SourceMapper$add$LSourceMapper$SNNUSUS(this._sourceMapper, this._output, token._lineNumber, token._columnNumber, token._isIdentifier ? token._value : null, token._filename);
	}
	str = str.replace(/\n(.)/g, (function (m) {
		return "\n" + JavaScriptEmitter$_getIndent$LJavaScriptEmitter$($this) + m.substring(1);
	}));
	this._output += str;
	this._outputEndsWithReturn = str.charAt(str.length - 1) === "\n";
};


function JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, str, token) {
	if (str === "") {
		return;
	}
	if ($this._outputEndsWithReturn && $this._indent !== 0) {
		$this._output += JavaScriptEmitter$_getIndent$LJavaScriptEmitter$($this);
		$this._outputEndsWithReturn = false;
	}
	if ($this._sourceMapper != null && token != null) {
		SourceMapper$add$LSourceMapper$SNNUSUS($this._sourceMapper, $this._output, token._lineNumber, token._columnNumber, token._isIdentifier ? token._value : null, token._filename);
	}
	str = str.replace(/\n(.)/g, (function (m) {
		return "\n" + JavaScriptEmitter$_getIndent$LJavaScriptEmitter$($this) + m.substring(1);
	}));
	$this._output += str;
	$this._outputEndsWithReturn = str.charAt(str.length - 1) === "\n";
};

JavaScriptEmitter._emit$LJavaScriptEmitter$SLToken$ = JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$;

JavaScriptEmitter.prototype._advanceIndent$ = function () {
	++this._indent;
};


function JavaScriptEmitter$_advanceIndent$LJavaScriptEmitter$($this) {
	++$this._indent;
};

JavaScriptEmitter._advanceIndent$LJavaScriptEmitter$ = JavaScriptEmitter$_advanceIndent$LJavaScriptEmitter$;

JavaScriptEmitter.prototype._reduceIndent$ = function () {
	if (--this._indent < 0) {
		throw new Error("indent mistach");
	}
};


function JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$($this) {
	if (--$this._indent < 0) {
		throw new Error("indent mistach");
	}
};

JavaScriptEmitter._reduceIndent$LJavaScriptEmitter$ = JavaScriptEmitter$_reduceIndent$LJavaScriptEmitter$;

JavaScriptEmitter.prototype._getIndent$ = function () {
	var s;
	var i;
	s = "";
	for (i = 0; i < this._indent; ++i) {
		s += "\t";
	}
	return s;
};


function JavaScriptEmitter$_getIndent$LJavaScriptEmitter$($this) {
	var s;
	var i;
	s = "";
	for (i = 0; i < $this._indent; ++i) {
		s += "\t";
	}
	return s;
};

JavaScriptEmitter._getIndent$LJavaScriptEmitter$ = JavaScriptEmitter$_getIndent$LJavaScriptEmitter$;

JavaScriptEmitter.prototype._getStatementEmitterFor$LStatement$ = function (statement) {
	if (statement instanceof ConstructorInvocationStatement) {
		return new _ConstructorInvocationStatementEmitter(this, statement);
	} else if (statement instanceof ExpressionStatement) {
		return new _ExpressionStatementEmitter(this, statement);
	} else if (statement instanceof FunctionStatement) {
		return new _FunctionStatementEmitter(this, statement);
	} else if (statement instanceof ReturnStatement) {
		return new _ReturnStatementEmitter(this, statement);
	} else if (statement instanceof DeleteStatement) {
		return new _DeleteStatementEmitter(this, statement);
	} else if (statement instanceof BreakStatement) {
		return new _BreakStatementEmitter(this, statement);
	} else if (statement instanceof ContinueStatement) {
		return new _ContinueStatementEmitter(this, statement);
	} else if (statement instanceof DoWhileStatement) {
		return new _DoWhileStatementEmitter(this, statement);
	} else if (statement instanceof ForInStatement) {
		return new _ForInStatementEmitter(this, statement);
	} else if (statement instanceof ForStatement) {
		return new _ForStatementEmitter(this, statement);
	} else if (statement instanceof IfStatement) {
		return new _IfStatementEmitter(this, statement);
	} else if (statement instanceof SwitchStatement) {
		return new _SwitchStatementEmitter(this, statement);
	} else if (statement instanceof CaseStatement) {
		return new _CaseStatementEmitter(this, statement);
	} else if (statement instanceof DefaultStatement) {
		return new _DefaultStatementEmitter(this, statement);
	} else if (statement instanceof WhileStatement) {
		return new _WhileStatementEmitter(this, statement);
	} else if (statement instanceof TryStatement) {
		return new _TryStatementEmitter(this, statement);
	} else if (statement instanceof CatchStatement) {
		return new _CatchStatementEmitter(this, statement);
	} else if (statement instanceof ThrowStatement) {
		return new _ThrowStatementEmitter(this, statement);
	} else if (statement instanceof AssertStatement) {
		return new _AssertStatementEmitter(this, statement);
	} else if (statement instanceof LogStatement) {
		return new _LogStatementEmitter(this, statement);
	} else if (statement instanceof DebuggerStatement) {
		return new _DebuggerStatementEmitter(this, statement);
	}
	throw new Error("got unexpected type of statement: " + JSON.stringify(statement.serialize$()));
};


function JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$($this, statement) {
	if (statement instanceof ConstructorInvocationStatement) {
		return new _ConstructorInvocationStatementEmitter($this, statement);
	} else if (statement instanceof ExpressionStatement) {
		return new _ExpressionStatementEmitter($this, statement);
	} else if (statement instanceof FunctionStatement) {
		return new _FunctionStatementEmitter($this, statement);
	} else if (statement instanceof ReturnStatement) {
		return new _ReturnStatementEmitter($this, statement);
	} else if (statement instanceof DeleteStatement) {
		return new _DeleteStatementEmitter($this, statement);
	} else if (statement instanceof BreakStatement) {
		return new _BreakStatementEmitter($this, statement);
	} else if (statement instanceof ContinueStatement) {
		return new _ContinueStatementEmitter($this, statement);
	} else if (statement instanceof DoWhileStatement) {
		return new _DoWhileStatementEmitter($this, statement);
	} else if (statement instanceof ForInStatement) {
		return new _ForInStatementEmitter($this, statement);
	} else if (statement instanceof ForStatement) {
		return new _ForStatementEmitter($this, statement);
	} else if (statement instanceof IfStatement) {
		return new _IfStatementEmitter($this, statement);
	} else if (statement instanceof SwitchStatement) {
		return new _SwitchStatementEmitter($this, statement);
	} else if (statement instanceof CaseStatement) {
		return new _CaseStatementEmitter($this, statement);
	} else if (statement instanceof DefaultStatement) {
		return new _DefaultStatementEmitter($this, statement);
	} else if (statement instanceof WhileStatement) {
		return new _WhileStatementEmitter($this, statement);
	} else if (statement instanceof TryStatement) {
		return new _TryStatementEmitter($this, statement);
	} else if (statement instanceof CatchStatement) {
		return new _CatchStatementEmitter($this, statement);
	} else if (statement instanceof ThrowStatement) {
		return new _ThrowStatementEmitter($this, statement);
	} else if (statement instanceof AssertStatement) {
		return new _AssertStatementEmitter($this, statement);
	} else if (statement instanceof LogStatement) {
		return new _LogStatementEmitter($this, statement);
	} else if (statement instanceof DebuggerStatement) {
		return new _DebuggerStatementEmitter($this, statement);
	}
	throw new Error("got unexpected type of statement: " + JSON.stringify(statement.serialize$()));
};

JavaScriptEmitter._getStatementEmitterFor$LJavaScriptEmitter$LStatement$ = JavaScriptEmitter$_getStatementEmitterFor$LJavaScriptEmitter$LStatement$;

JavaScriptEmitter.prototype._getExpressionEmitterFor$LExpression$ = function (expr) {
	if (expr instanceof LocalExpression) {
		return new _LocalExpressionEmitter(this, expr);
	} else if (expr instanceof ClassExpression) {
		return new _ClassExpressionEmitter(this, expr);
	} else if (expr instanceof NullExpression) {
		return new _NullExpressionEmitter(this, expr);
	} else if (expr instanceof BooleanLiteralExpression) {
		return new _BooleanLiteralExpressionEmitter(this, expr);
	} else if (expr instanceof IntegerLiteralExpression) {
		return new _IntegerLiteralExpressionEmitter(this, expr);
	} else if (expr instanceof NumberLiteralExpression) {
		return new _NumberLiteralExpressionEmitter(this, expr);
	} else if (expr instanceof StringLiteralExpression) {
		return new _StringLiteralExpressionEmitter(this, expr);
	} else if (expr instanceof RegExpLiteralExpression) {
		return new _RegExpLiteralExpressionEmitter(this, expr);
	} else if (expr instanceof ArrayLiteralExpression) {
		return new _ArrayLiteralExpressionEmitter(this, expr);
	} else if (expr instanceof MapLiteralExpression) {
		return new _MapLiteralExpressionEmitter(this, expr);
	} else if (expr instanceof ThisExpression) {
		return new _ThisExpressionEmitter(this, expr);
	} else if (expr instanceof BitwiseNotExpression) {
		return new _UnaryExpressionEmitter(this, expr);
	} else if (expr instanceof InstanceofExpression) {
		return new _InstanceofExpressionEmitter(this, expr);
	} else if (expr instanceof AsExpression) {
		return new _AsExpressionEmitter(this, expr);
	} else if (expr instanceof AsNoConvertExpression) {
		return new _AsNoConvertExpressionEmitter(this, expr);
	} else if (expr instanceof LogicalNotExpression) {
		return new _UnaryExpressionEmitter(this, expr);
	} else if (expr instanceof TypeofExpression) {
		return new _UnaryExpressionEmitter(this, expr);
	} else if (expr instanceof PostIncrementExpression) {
		return new _PostIncrementExpressionEmitter(this, expr);
	} else if (expr instanceof PreIncrementExpression) {
		return new _PreIncrementExpressionEmitter(this, expr);
	} else if (expr instanceof PropertyExpression) {
		return new _PropertyExpressionEmitter(this, expr);
	} else if (expr instanceof SignExpression) {
		return new _UnaryExpressionEmitter(this, expr);
	} else if (expr instanceof YieldExpression) {
		return new _UnaryExpressionEmitter(this, expr);
	} else if (expr instanceof AdditiveExpression) {
		return new _AdditiveExpressionEmitter(this, expr);
	} else if (expr instanceof ArrayExpression) {
		return new _ArrayExpressionEmitter(this, expr);
	} else if (expr instanceof AssignmentExpression) {
		return new _AssignmentExpressionEmitter(this, expr);
	} else if (expr instanceof FusedAssignmentExpression) {
		return new _FusedAssignmentExpressionEmitter(this, expr);
	} else if (expr instanceof BinaryNumberExpression) {
		return new _BinaryNumberExpressionEmitter(this, expr);
	} else if (expr instanceof EqualityExpression) {
		return new _EqualityExpressionEmitter(this, expr);
	} else if (expr instanceof InExpression) {
		return new _InExpressionEmitter(this, expr);
	} else if (expr instanceof LogicalExpression) {
		return new _LogicalExpressionEmitter(this, expr);
	} else if (expr instanceof ShiftExpression) {
		return new _ShiftExpressionEmitter(this, expr);
	} else if (expr instanceof ConditionalExpression) {
		return new _ConditionalExpressionEmitter(this, expr);
	} else if (expr instanceof CallExpression) {
		return new _CallExpressionEmitter(this, expr);
	} else if (expr instanceof SuperExpression) {
		return new _SuperExpressionEmitter(this, expr);
	} else if (expr instanceof NewExpression) {
		return new _NewExpressionEmitter(this, expr);
	} else if (expr instanceof FunctionExpression) {
		return new _FunctionExpressionEmitter(this, expr);
	} else if (expr instanceof CommaExpression) {
		return new _CommaExpressionEmitter(this, expr);
	}
	throw new Error("got unexpected type of expression: " + (expr != null ? JSON.stringify(expr.serialize$()) : expr.toString()));
};


function JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, expr) {
	if (expr instanceof LocalExpression) {
		return new _LocalExpressionEmitter($this, expr);
	} else if (expr instanceof ClassExpression) {
		return new _ClassExpressionEmitter($this, expr);
	} else if (expr instanceof NullExpression) {
		return new _NullExpressionEmitter($this, expr);
	} else if (expr instanceof BooleanLiteralExpression) {
		return new _BooleanLiteralExpressionEmitter($this, expr);
	} else if (expr instanceof IntegerLiteralExpression) {
		return new _IntegerLiteralExpressionEmitter($this, expr);
	} else if (expr instanceof NumberLiteralExpression) {
		return new _NumberLiteralExpressionEmitter($this, expr);
	} else if (expr instanceof StringLiteralExpression) {
		return new _StringLiteralExpressionEmitter($this, expr);
	} else if (expr instanceof RegExpLiteralExpression) {
		return new _RegExpLiteralExpressionEmitter($this, expr);
	} else if (expr instanceof ArrayLiteralExpression) {
		return new _ArrayLiteralExpressionEmitter($this, expr);
	} else if (expr instanceof MapLiteralExpression) {
		return new _MapLiteralExpressionEmitter($this, expr);
	} else if (expr instanceof ThisExpression) {
		return new _ThisExpressionEmitter($this, expr);
	} else if (expr instanceof BitwiseNotExpression) {
		return new _UnaryExpressionEmitter($this, expr);
	} else if (expr instanceof InstanceofExpression) {
		return new _InstanceofExpressionEmitter($this, expr);
	} else if (expr instanceof AsExpression) {
		return new _AsExpressionEmitter($this, expr);
	} else if (expr instanceof AsNoConvertExpression) {
		return new _AsNoConvertExpressionEmitter($this, expr);
	} else if (expr instanceof LogicalNotExpression) {
		return new _UnaryExpressionEmitter($this, expr);
	} else if (expr instanceof TypeofExpression) {
		return new _UnaryExpressionEmitter($this, expr);
	} else if (expr instanceof PostIncrementExpression) {
		return new _PostIncrementExpressionEmitter($this, expr);
	} else if (expr instanceof PreIncrementExpression) {
		return new _PreIncrementExpressionEmitter($this, expr);
	} else if (expr instanceof PropertyExpression) {
		return new _PropertyExpressionEmitter($this, expr);
	} else if (expr instanceof SignExpression) {
		return new _UnaryExpressionEmitter($this, expr);
	} else if (expr instanceof YieldExpression) {
		return new _UnaryExpressionEmitter($this, expr);
	} else if (expr instanceof AdditiveExpression) {
		return new _AdditiveExpressionEmitter($this, expr);
	} else if (expr instanceof ArrayExpression) {
		return new _ArrayExpressionEmitter($this, expr);
	} else if (expr instanceof AssignmentExpression) {
		return new _AssignmentExpressionEmitter($this, expr);
	} else if (expr instanceof FusedAssignmentExpression) {
		return new _FusedAssignmentExpressionEmitter($this, expr);
	} else if (expr instanceof BinaryNumberExpression) {
		return new _BinaryNumberExpressionEmitter($this, expr);
	} else if (expr instanceof EqualityExpression) {
		return new _EqualityExpressionEmitter($this, expr);
	} else if (expr instanceof InExpression) {
		return new _InExpressionEmitter($this, expr);
	} else if (expr instanceof LogicalExpression) {
		return new _LogicalExpressionEmitter($this, expr);
	} else if (expr instanceof ShiftExpression) {
		return new _ShiftExpressionEmitter($this, expr);
	} else if (expr instanceof ConditionalExpression) {
		return new _ConditionalExpressionEmitter($this, expr);
	} else if (expr instanceof CallExpression) {
		return new _CallExpressionEmitter($this, expr);
	} else if (expr instanceof SuperExpression) {
		return new _SuperExpressionEmitter($this, expr);
	} else if (expr instanceof NewExpression) {
		return new _NewExpressionEmitter($this, expr);
	} else if (expr instanceof FunctionExpression) {
		return new _FunctionExpressionEmitter($this, expr);
	} else if (expr instanceof CommaExpression) {
		return new _CommaExpressionEmitter($this, expr);
	}
	throw new Error("got unexpected type of expression: " + (expr != null ? JSON.stringify(expr.serialize$()) : expr.toString()));
};

JavaScriptEmitter._getExpressionEmitterFor$LJavaScriptEmitter$LExpression$ = JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$;

JavaScriptEmitter.prototype._emitCallArguments$LToken$SALExpression$ALType$ = function (token, prefix, args, argTypes) {
	var i;
	var argType;
	var this$0;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, prefix, token);
	for (i = 0; i < args.length; ++i) {
		if (i !== 0 || prefix.charAt(prefix.length - 1) !== '(') {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ", ", null);
		}
		argType = null;
		if (argTypes != null) {
			if (i < argTypes.length) {
				argType = argTypes[i];
			} else if (argTypes.length !== 0 && argTypes[argTypes.length - 1] instanceof VariableLengthArgumentType) {
				argType = argTypes[argTypes.length - 1];
			}
			if (argType instanceof VariableLengthArgumentType) {
				this$0 = argType;
				argType = this$0._baseType;
			}
		}
		if (argType != null && ! (Type.nullType, argType instanceof NullableType || argType instanceof ObjectType || argType instanceof VariantType || argType instanceof StaticFunctionType)) {
			JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$(this, args[i], argType);
		} else {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, args[i]).emit$N(0);
		}
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ")", token);
};


function JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$($this, token, prefix, args, argTypes) {
	var i;
	var argType;
	var this$0;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, prefix, token);
	for (i = 0; i < args.length; ++i) {
		if (i !== 0 || prefix.charAt(prefix.length - 1) !== '(') {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ", ", null);
		}
		argType = null;
		if (argTypes != null) {
			if (i < argTypes.length) {
				argType = argTypes[i];
			} else if (argTypes.length !== 0 && argTypes[argTypes.length - 1] instanceof VariableLengthArgumentType) {
				argType = argTypes[argTypes.length - 1];
			}
			if (argType instanceof VariableLengthArgumentType) {
				this$0 = argType;
				argType = this$0._baseType;
			}
		}
		if (argType != null && ! (Type.nullType, argType instanceof NullableType || argType instanceof ObjectType || argType instanceof VariantType || argType instanceof StaticFunctionType)) {
			JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$($this, args[i], argType);
		} else {
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, args[i]).emit$N(0);
		}
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ")", token);
};

JavaScriptEmitter._emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$ = JavaScriptEmitter$_emitCallArguments$LJavaScriptEmitter$LToken$SALExpression$ALType$;

JavaScriptEmitter.prototype._emitAssertion$F$V$LToken$S = function (emitTestExpr, token, message) {
	var s;
	var err;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "if (! (", token);
	emitTestExpr();
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ")) {\n", null);
	++this._indent;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "debugger;\n", null);
	s = Util$makeErrorMessage$LPlatform$SUSNNN(this._platform, message, token._filename, token._lineNumber, token._columnNumber, token._value.length);
	err = Util$format$SAS('throw new Error(%1);\n', [ Util$encodeStringLiteral$S(s) ]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, err, token);
	if (--this._indent < 0) {
		throw new Error("indent mistach");
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "}\n", null);
};


function JavaScriptEmitter$_emitAssertion$LJavaScriptEmitter$F$V$LToken$S($this, emitTestExpr, token, message) {
	var s;
	var err;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "if (! (", token);
	emitTestExpr();
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ")) {\n", null);
	++$this._indent;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "debugger;\n", null);
	s = Util$makeErrorMessage$LPlatform$SUSNNN($this._platform, message, token._filename, token._lineNumber, token._columnNumber, token._value.length);
	err = Util$format$SAS('throw new Error(%1);\n', [ Util$encodeStringLiteral$S(s) ]);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, err, token);
	if (--$this._indent < 0) {
		throw new Error("indent mistach");
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "}\n", null);
};

JavaScriptEmitter._emitAssertion$LJavaScriptEmitter$F$V$LToken$S = JavaScriptEmitter$_emitAssertion$LJavaScriptEmitter$F$V$LToken$S;

JavaScriptEmitter.prototype._emitAssertionWithMsg$F$V$LToken$SLExpression$ = function (emitTestExpr, token, message, msgExpr) {
	var s;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "if (! (", token);
	emitTestExpr();
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ")) {\n", null);
	++this._indent;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "debugger;\n", null);
	s = Util$makeErrorMessage$LPlatform$SUSNNN(this._platform, message + ": {MSG}", token._filename, token._lineNumber, token._columnNumber, token._value.length).split("{MSG}");
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, Util$format$SAS('throw new Error(%1 + ', [ Util$encodeStringLiteral$S(s[0]) ]), token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, msgExpr).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, Util$format$SAS(' + %1);\n', [ Util$encodeStringLiteral$S(s[1]) ]), token);
	if (--this._indent < 0) {
		throw new Error("indent mistach");
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "}\n", null);
};


function JavaScriptEmitter$_emitAssertionWithMsg$LJavaScriptEmitter$F$V$LToken$SLExpression$($this, emitTestExpr, token, message, msgExpr) {
	var s;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "if (! (", token);
	emitTestExpr();
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ")) {\n", null);
	++$this._indent;
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "debugger;\n", null);
	s = Util$makeErrorMessage$LPlatform$SUSNNN($this._platform, message + ": {MSG}", token._filename, token._lineNumber, token._columnNumber, token._value.length).split("{MSG}");
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, Util$format$SAS('throw new Error(%1 + ', [ Util$encodeStringLiteral$S(s[0]) ]), token);
	JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, msgExpr).emit$N(0);
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, Util$format$SAS(' + %1);\n', [ Util$encodeStringLiteral$S(s[1]) ]), token);
	if (--$this._indent < 0) {
		throw new Error("indent mistach");
	}
	JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "}\n", null);
};

JavaScriptEmitter._emitAssertionWithMsg$LJavaScriptEmitter$F$V$LToken$SLExpression$ = JavaScriptEmitter$_emitAssertionWithMsg$LJavaScriptEmitter$F$V$LToken$SLExpression$;

JavaScriptEmitter.prototype._emitWithNullableGuard$LExpression$N = function (expr, outerOpPrecedence) {
	var $this = this;
	var token;
	if (this._enableRunTimeTypeCheck && expr.getType$() instanceof NullableType) {
		token = expr._token;
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "(function (v) {\n", token);
		++this._indent;
		JavaScriptEmitter$_emitAssertion$LJavaScriptEmitter$F$V$LToken$S(this, (function () {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "v != null", token);
		}), token, "null access");
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "return v;\n", token);
		if (--this._indent < 0) {
			throw new Error("indent mistach");
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "}(", token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, expr).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "))", token);
	} else {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, expr).emit$N(outerOpPrecedence);
	}
};


function JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this, expr, outerOpPrecedence) {
	var token;
	if ($this._enableRunTimeTypeCheck && expr.getType$() instanceof NullableType) {
		token = expr._token;
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "(function (v) {\n", token);
		++$this._indent;
		JavaScriptEmitter$_emitAssertion$LJavaScriptEmitter$F$V$LToken$S($this, (function () {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "v != null", token);
		}), token, "null access");
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "return v;\n", token);
		if (--$this._indent < 0) {
			throw new Error("indent mistach");
		}
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "}(", token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, expr).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "))", token);
	} else {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, expr).emit$N(outerOpPrecedence);
	}
};

JavaScriptEmitter._emitWithNullableGuard$LJavaScriptEmitter$LExpression$N = JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N;

JavaScriptEmitter.prototype._emitRHSOfAssignment$LExpression$LType$ = function (expr, lhsType) {
	var exprType;
	var this$0;
	var this$0$0;
	var this$0$1;
	var this$0$2;
	var this$1;
	var this$2;
	exprType = expr.getType$();
	if ((lhsType instanceof NullableType ? (this$0$1 = lhsType, this$0$1._baseType) : lhsType).equals$LType$(Type.integerType) && exprType.equals$LType$(Type.numberType)) {
		if (expr instanceof NumberLiteralExpression) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, (expr.getDecoded$() | 0) + "", expr._token);
		} else if (expr instanceof IntegerLiteralExpression) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, (this$0 = expr, (this$0$0 = this$0._token, this$0$0._value) | 0) + "", expr._token);
		} else {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "(", expr._token);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, expr).emit$N(_BinaryNumberExpressionEmitter._operatorPrecedence["|"]);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, " | 0)", expr._token);
		}
		return;
	}
	if (lhsType.equals$LType$(Type.integerType) && (exprType instanceof NullableType ? (this$0$2 = exprType, this$0$2._baseType) : exprType).equals$LType$(Type.numberType)) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "(", expr._token);
		JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this, expr, _BinaryNumberExpressionEmitter._operatorPrecedence["|"]);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, " | 0)", expr._token);
		return;
	}
	if (lhsType instanceof NullableType && (this$1 = lhsType, this$1._baseType).equals$LType$(Type.integerType) && (exprType instanceof NullableType && (this$2 = exprType, this$2._baseType).equals$LType$(Type.numberType))) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, "(function (v) { return v != null ? v | 0 : v; })(", expr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, expr).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$(this, ")", expr._token);
		return;
	}
	if (lhsType.equals$LType$(Type.variantType) || lhsType instanceof NullableType) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$(this, expr).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
	} else {
		JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N(this, expr, _AssignmentExpressionEmitter._operatorPrecedence["="]);
	}
};


function JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$($this, expr, lhsType) {
	var exprType;
	var this$0;
	var this$0$0;
	var this$0$1;
	var this$0$2;
	var this$1;
	var this$2;
	exprType = expr.getType$();
	if ((lhsType instanceof NullableType ? (this$0$1 = lhsType, this$0$1._baseType) : lhsType).equals$LType$(Type.integerType) && exprType.equals$LType$(Type.numberType)) {
		if (expr instanceof NumberLiteralExpression) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, (expr.getDecoded$() | 0) + "", expr._token);
		} else if (expr instanceof IntegerLiteralExpression) {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, (this$0 = expr, (this$0$0 = this$0._token, this$0$0._value) | 0) + "", expr._token);
		} else {
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "(", expr._token);
			JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, expr).emit$N(_BinaryNumberExpressionEmitter._operatorPrecedence["|"]);
			JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, " | 0)", expr._token);
		}
		return;
	}
	if (lhsType.equals$LType$(Type.integerType) && (exprType instanceof NullableType ? (this$0$2 = exprType, this$0$2._baseType) : exprType).equals$LType$(Type.numberType)) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "(", expr._token);
		JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this, expr, _BinaryNumberExpressionEmitter._operatorPrecedence["|"]);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, " | 0)", expr._token);
		return;
	}
	if (lhsType instanceof NullableType && (this$1 = lhsType, this$1._baseType).equals$LType$(Type.integerType) && (exprType instanceof NullableType && (this$2 = exprType, this$2._baseType).equals$LType$(Type.numberType))) {
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, "(function (v) { return v != null ? v | 0 : v; })(", expr._token);
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, expr).emit$N(0);
		JavaScriptEmitter$_emit$LJavaScriptEmitter$SLToken$($this, ")", expr._token);
		return;
	}
	if (lhsType.equals$LType$(Type.variantType) || lhsType instanceof NullableType) {
		JavaScriptEmitter$_getExpressionEmitterFor$LJavaScriptEmitter$LExpression$($this, expr).emit$N(_AssignmentExpressionEmitter._operatorPrecedence["="]);
	} else {
		JavaScriptEmitter$_emitWithNullableGuard$LJavaScriptEmitter$LExpression$N($this, expr, _AssignmentExpressionEmitter._operatorPrecedence["="]);
	}
};

JavaScriptEmitter._emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$ = JavaScriptEmitter$_emitRHSOfAssignment$LJavaScriptEmitter$LExpression$LType$;

function JavaScriptEmitter$_initialize$() {
	var precedence;
	var i;
	var opTypeList;
	var j;
	var key;
	if (JavaScriptEmitter._initialized) {
		return;
	}
	JavaScriptEmitter._initialized = true;
	precedence = [ [ ({ "new": _NewExpressionEmitter$_setOperatorPrecedence$SN }), ({ "[": _ArrayExpressionEmitter$_setOperatorPrecedence$SN }), ({ ".": _PropertyExpressionEmitter$_setOperatorPrecedence$SN }), ({ "(": _CallExpressionEmitter$_setOperatorPrecedence$SN }), ({ "super": _SuperExpressionEmitter$_setOperatorPrecedence$SN }), ({ "function": _FunctionExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "++": _PostIncrementExpressionEmitter$_setOperatorPrecedence$SN }), ({ "--": _PostIncrementExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "void": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }), ({ "typeof": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }), ({ "++": _PreIncrementExpressionEmitter$_setOperatorPrecedence$SN }), ({ "--": _PreIncrementExpressionEmitter$_setOperatorPrecedence$SN }), ({ "+": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }), ({ "-": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }), ({ "~": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }), ({ "!": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "*": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }), ({ "/": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }), ({ "%": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "+": _AdditiveExpressionEmitter$_setOperatorPrecedence$SN }), ({ "-": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "<<": _ShiftExpressionEmitter$_setOperatorPrecedence$SN }), ({ ">>": _ShiftExpressionEmitter$_setOperatorPrecedence$SN }), ({ ">>>": _ShiftExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "<": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }), ({ ">": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }), ({ "<=": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }), ({ ">=": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }), ({ "instanceof": _InstanceofExpressionEmitter$_setOperatorPrecedence$SN }), ({ "in": _InExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "==": _EqualityExpressionEmitter$_setOperatorPrecedence$SN }), ({ "!=": _EqualityExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "&": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "^": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "|": _BinaryNumberExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "&&": _LogicalExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "||": _LogicalExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "=": _AssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "*=": _FusedAssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "/=": _FusedAssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "%=": _FusedAssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "+=": _FusedAssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "-=": _FusedAssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "<<=": _FusedAssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ ">>=": _FusedAssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ ">>>=": _FusedAssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "&=": _FusedAssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "^=": _FusedAssignmentExpressionEmitter$_setOperatorPrecedence$SN }), ({ "|=": _FusedAssignmentExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "?": _ConditionalExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ "yield": _UnaryExpressionEmitter$_setOperatorPrecedence$SN }) ], [ ({ ",": _CommaExpressionEmitter$_setOperatorPrecedence$SN }) ] ];
	for (i = 0; i < precedence.length; ++i) {
		opTypeList = precedence[i];
		for (j = 0; j < opTypeList.length; ++j) {
			for (key in opTypeList[j]) {
				opTypeList[j][key](key, - (precedence.length - i));
			}
		}
	}
};

JavaScriptEmitter._initialize$ = JavaScriptEmitter$_initialize$;

function LocalVariable(name, type, isConst) {
	this._stash = {};
	this._instantiated = [];
	this.isInstantiated = false;
	this._isUsedAsRHS = false;
	this._name = name;
	this._type = type;
	this._isConstant = isConst;
};

$__jsx_extend([LocalVariable], Object);
$__jsx_merge_interface(LocalVariable, Stashable);

LocalVariable.prototype.serialize$ = function () {
	var v$0;
	return [ this._name, (v$0 = this._type, v$0 == null ? null : v$0.toString()) ];
};


function LocalVariable$serialize$LLocalVariable$($this) {
	var v$0;
	return [ $this._name, (v$0 = $this._type, v$0 == null ? null : v$0.toString()) ];
};

LocalVariable.serialize$LLocalVariable$ = LocalVariable$serialize$LLocalVariable$;

LocalVariable.prototype.getName$ = function () {
	return this._name;
};


function LocalVariable$getName$LLocalVariable$($this) {
	return $this._name;
};

LocalVariable.getName$LLocalVariable$ = LocalVariable$getName$LLocalVariable$;

LocalVariable.prototype.getType$ = function () {
	return this._type;
};


function LocalVariable$getType$LLocalVariable$($this) {
	return $this._type;
};

LocalVariable.getType$LLocalVariable$ = LocalVariable$getType$LLocalVariable$;

LocalVariable.prototype.isUsedAsRHS$ = function () {
	return this._isUsedAsRHS;
};


function LocalVariable$isUsedAsRHS$LLocalVariable$($this) {
	return $this._isUsedAsRHS;
};

LocalVariable.isUsedAsRHS$LLocalVariable$ = LocalVariable$isUsedAsRHS$LLocalVariable$;

LocalVariable.prototype.isConstant$ = function () {
	return this._isConstant;
};


function LocalVariable$isConstant$LLocalVariable$($this) {
	return $this._isConstant;
};

LocalVariable.isConstant$LLocalVariable$ = LocalVariable$isConstant$LLocalVariable$;

LocalVariable.prototype.setType$LType$ = function (type) {
	var this$0$0;
	if (this._type != null) {
		throw new Error("type is already set for " + ((this$0$0 = this._name, this$0$0._value) + " : " + this._type.toString()));
	}
	if (type.equals$LType$(Type.integerType)) {
		type = Type.numberType;
	}
	this._type = type;
};


function LocalVariable$setType$LLocalVariable$LType$($this, type) {
	var this$0$0;
	if ($this._type != null) {
		throw new Error("type is already set for " + ((this$0$0 = $this._name, this$0$0._value) + " : " + $this._type.toString()));
	}
	if (type.equals$LType$(Type.integerType)) {
		type = Type.numberType;
	}
	$this._type = type;
};

LocalVariable.setType$LLocalVariable$LType$ = LocalVariable$setType$LLocalVariable$LType$;

LocalVariable.prototype.setTypeForced$LType$ = function (type) {
	this._type = type;
};


function LocalVariable$setTypeForced$LLocalVariable$LType$($this, type) {
	$this._type = type;
};

LocalVariable.setTypeForced$LLocalVariable$LType$ = LocalVariable$setTypeForced$LLocalVariable$LType$;

LocalVariable.prototype._findVarTokenFromFuncDef$LAnalysisContext$ = function (context) {
	var locals;
	var i;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var locals$len$0;
	this$0 = context.funcDef;
	locals = this$0._locals;
	for ((i = 0, locals$len$0 = locals.length); i < locals$len$0; ++i) {
		if ((this$2 = this._name, this$2._value) === (this$4 = (this$3 = locals[i], this$3._name), this$4._value)) {
			this$1 = locals[i];
			return this$1._name;
		}
	}
	return this._name;
};


function LocalVariable$_findVarTokenFromFuncDef$LLocalVariable$LAnalysisContext$($this, context) {
	var locals;
	var i;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var locals$len$0;
	this$0 = context.funcDef;
	locals = this$0._locals;
	for ((i = 0, locals$len$0 = locals.length); i < locals$len$0; ++i) {
		if ((this$2 = $this._name, this$2._value) === (this$4 = (this$3 = locals[i], this$3._name), this$4._value)) {
			this$1 = locals[i];
			return this$1._name;
		}
	}
	return $this._name;
};

LocalVariable._findVarTokenFromFuncDef$LLocalVariable$LAnalysisContext$ = LocalVariable$_findVarTokenFromFuncDef$LLocalVariable$LAnalysisContext$;

LocalVariable.prototype.touchVariable$LAnalysisContext$LToken$B = function (context, token, isAssignment) {
	var error;
	var this$0;
	var name$0;
	var this$0$0;
	var note$0;
	var note$1;
	var blockStack$0;
	var blockStack$1;
	if (isAssignment) {
		if (this._isConstant && LocalVariableStatuses$getStatus$LLocalVariableStatuses$LLocalVariable$(context.blockStack[context.blockStack.length - 1].localVariableStatuses, this) !== 0) {
			context.errors.push(new CompileError(token, "assignment of read-only variable"));
			return false;
		}
		this$0 = (blockStack$0 = context.blockStack)[blockStack$0.length - 1].localVariableStatuses;
		this$0$0 = this._name;
		name$0 = this$0$0._value;
		if (this$0._statuses[name$0] == null) {
			throw new Error("logic flaw, could not find status for local variable: " + name$0);
		}
		this$0._statuses[name$0] = 1;
	} else {
		switch (LocalVariableStatuses$getStatus$LLocalVariableStatuses$LLocalVariable$((blockStack$1 = context.blockStack)[blockStack$1.length - 1].localVariableStatuses, this)) {
		case -1:
			context.errors.push(new CompileError(token, "the return type of recursive function needs to be explicitly declared"));
			return false;
		case 1:
			this._isUsedAsRHS = true;
			break;
		case 0:
			error = new CompileError(token, "variable is not initialized");
			note$0 = new CompileNote(LocalVariable$_findVarTokenFromFuncDef$LLocalVariable$LAnalysisContext$(this, context), "declared here");
			error._notes.push(note$0);
			context.errors.push(error);
			return false;
		case 2:
			error = new CompileError(token, "variable may not be initialized");
			note$1 = new CompileNote(LocalVariable$_findVarTokenFromFuncDef$LLocalVariable$LAnalysisContext$(this, context), "declared here");
			error._notes.push(note$1);
			context.errors.push(error);
			return false;
		default:
			throw new Error("logic flaw");
		}
	}
	return true;
};


LocalVariable.prototype.toString = function () {
	var this$0;
	return (this$0 = this._name, this$0._value) + " : " + this._type.toString();
};


LocalVariable.prototype.popInstantiated$ = function () {
	this._instantiated.pop();
};


function LocalVariable$popInstantiated$LLocalVariable$($this) {
	$this._instantiated.pop();
};

LocalVariable.popInstantiated$LLocalVariable$ = LocalVariable$popInstantiated$LLocalVariable$;

LocalVariable.prototype.getInstantiated$ = function () {
	var this$0;
	var _instantiated$0;
	if (this._instantiated.length === 0) {
		throw new Error("logic flaw, no instantiation for " + (this$0 = this._name, this$0._value) + "," + (this.isInstantiated + ""));
	}
	return (_instantiated$0 = this._instantiated)[_instantiated$0.length - 1];
};


function LocalVariable$getInstantiated$LLocalVariable$($this) {
	var this$0;
	var _instantiated$0;
	if ($this._instantiated.length === 0) {
		throw new Error("logic flaw, no instantiation for " + (this$0 = $this._name, this$0._value) + "," + ($this.isInstantiated + ""));
	}
	return (_instantiated$0 = $this._instantiated)[_instantiated$0.length - 1];
};

LocalVariable.getInstantiated$LLocalVariable$ = LocalVariable$getInstantiated$LLocalVariable$;

LocalVariable.prototype.instantiateAndPush$LInstantiationContext$ = function (instantiationContext) {
	var instantiated;
	instantiated = this._instantiate$LInstantiationContext$(instantiationContext);
	instantiated.isInstantiated = true;
	this._instantiated.push(instantiated);
	return instantiated;
};


LocalVariable.prototype._instantiate$LInstantiationContext$ = function (instantiationContext) {
	var type;
	type = (this._type != null ? this._type.instantiate$LInstantiationContext$B(instantiationContext, false) : null);
	return new LocalVariable(this._name, type, this._isConstant);
};


function CaughtVariable(name, type) {
	this._stash = {};
	this._instantiated = [];
	this.isInstantiated = false;
	this._isUsedAsRHS = false;
	this._name = name;
	this._type = type;
	this._isConstant = false;
};

$__jsx_extend([CaughtVariable], LocalVariable);
CaughtVariable.prototype.clone$ = function () {
	return new CaughtVariable(this._name, this._type);
};


function CaughtVariable$clone$LCaughtVariable$($this) {
	return new CaughtVariable($this._name, $this._type);
};

CaughtVariable.clone$LCaughtVariable$ = CaughtVariable$clone$LCaughtVariable$;

CaughtVariable.prototype.touchVariable$LAnalysisContext$LToken$B = function (context, token, isAssignment) {
	return true;
};


CaughtVariable.prototype._instantiate$LInstantiationContext$ = function (instantiationContext) {
	return new CaughtVariable(this._name, this._type.instantiate$LInstantiationContext$B(instantiationContext, false));
};


CaughtVariable.prototype.instantiateAndPush$LInstantiationContext$ = function (instantiationContext) {
	return LocalVariable.prototype.instantiateAndPush$LInstantiationContext$.call(this, instantiationContext);
};


function ArgumentDeclaration(name, type) {
	this._stash = {};
	this._instantiated = [];
	this.isInstantiated = false;
	this._isUsedAsRHS = false;
	this._name = name;
	this._type = type;
	this._isConstant = false;
	this._defaultValue = null;
};

function ArgumentDeclaration$0(name, type, defaultValue) {
	this._stash = {};
	this._instantiated = [];
	this.isInstantiated = false;
	this._isUsedAsRHS = false;
	this._name = name;
	this._type = type;
	this._isConstant = false;
	this._defaultValue = defaultValue;
};

$__jsx_extend([ArgumentDeclaration, ArgumentDeclaration$0], LocalVariable);
ArgumentDeclaration.prototype.clone$ = function () {
	var o$0;
	return new ArgumentDeclaration$0(this._name, this._type, (o$0 = this._defaultValue, o$0 == null ? null : o$0.clone$()));
};


function ArgumentDeclaration$clone$LArgumentDeclaration$($this) {
	var o$0;
	return new ArgumentDeclaration$0($this._name, $this._type, (o$0 = $this._defaultValue, o$0 == null ? null : o$0.clone$()));
};

ArgumentDeclaration.clone$LArgumentDeclaration$ = ArgumentDeclaration$clone$LArgumentDeclaration$;

ArgumentDeclaration.prototype.getDefaultValue$ = function () {
	return this._defaultValue;
};


function ArgumentDeclaration$getDefaultValue$LArgumentDeclaration$($this) {
	return $this._defaultValue;
};

ArgumentDeclaration.getDefaultValue$LArgumentDeclaration$ = ArgumentDeclaration$getDefaultValue$LArgumentDeclaration$;

ArgumentDeclaration.prototype._instantiate$LInstantiationContext$ = function (instantiationContext) {
	var type;
	type = (this._type != null ? this._type.instantiate$LInstantiationContext$B(instantiationContext, false) : null);
	return new ArgumentDeclaration$0(this._name, type, this._defaultValue);
};


ArgumentDeclaration.prototype.instantiateAndPush$LInstantiationContext$ = function (instantiationContext) {
	return LocalVariable.prototype.instantiateAndPush$LInstantiationContext$.call(this, instantiationContext);
};


function LocalVariableStatuses(funcDef, base) {
	var k;
	var args;
	var i;
	var locals;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	this._isReachable = false;
	this._statuses = {};
	if (base != null) {
		for (k in base._statuses) {
			this._statuses[k] = (base._statuses[k] === 0 ? 2 : base._statuses[k]);
		}
	}
	args = funcDef._args;
	for (i = 0; i < args.length; ++i) {
		this._statuses[(this$1 = (this$0 = args[i], this$0._name), this$1._value)] = 1;
	}
	locals = funcDef._locals;
	for (i = 0; i < locals.length; ++i) {
		this._statuses[(this$3 = (this$2 = locals[i], this$2._name), this$3._value)] = 0;
	}
	this._isReachable = true;
};

function LocalVariableStatuses$0(srcStatus) {
	var k$0;
	this._isReachable = false;
	this._statuses = {};
	for (k$0 in srcStatus._statuses) {
		this._statuses[k$0] = srcStatus._statuses[k$0];
	}
	this._isReachable = srcStatus._isReachable;
};

$__jsx_extend([LocalVariableStatuses, LocalVariableStatuses$0], Object);
LocalVariableStatuses.prototype.clone$ = function () {
	return new LocalVariableStatuses$0(this);
};


function LocalVariableStatuses$clone$LLocalVariableStatuses$($this) {
	return new LocalVariableStatuses$0($this);
};

LocalVariableStatuses.clone$LLocalVariableStatuses$ = LocalVariableStatuses$clone$LLocalVariableStatuses$;

LocalVariableStatuses.prototype.merge$LLocalVariableStatuses$ = function (that) {
	var ret;
	var k;
	if (this._isReachable !== that._isReachable) {
		if (this._isReachable) {
			return new LocalVariableStatuses$0(this);
		} else {
			return new LocalVariableStatuses$0(that);
		}
	}
	ret = new LocalVariableStatuses$0(this);
	for (k in ret._statuses) {
		if (ret._statuses[k] === 0 && that._statuses[k] === 0) {
		} else if (ret._statuses[k] === 1 && that._statuses[k] === 1) {
		} else {
			ret._statuses[k] = 2;
		}
	}
	return ret;
};


function LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$($this, that) {
	var ret;
	var k;
	if ($this._isReachable !== that._isReachable) {
		if ($this._isReachable) {
			return new LocalVariableStatuses$0($this);
		} else {
			return new LocalVariableStatuses$0(that);
		}
	}
	ret = new LocalVariableStatuses$0($this);
	for (k in ret._statuses) {
		if (ret._statuses[k] === 0 && that._statuses[k] === 0) {
		} else if (ret._statuses[k] === 1 && that._statuses[k] === 1) {
		} else {
			ret._statuses[k] = 2;
		}
	}
	return ret;
};

LocalVariableStatuses.merge$LLocalVariableStatuses$LLocalVariableStatuses$ = LocalVariableStatuses$merge$LLocalVariableStatuses$LLocalVariableStatuses$;

LocalVariableStatuses.prototype.mergeFinally$LLocalVariableStatuses$ = function (postFinallyStats) {
	var ret;
	var k;
	ret = new LocalVariableStatuses$0(this);
	for (k in ret._statuses) {
		switch (postFinallyStats._statuses[k]) {
		case 1:
			ret._statuses[k] = 1;
			break;
		case 2:
			if (ret._statuses[k] !== 1) {
				ret._statuses[k] = 2;
			}
			break;
		}
	}
	if (! postFinallyStats._isReachable) {
		ret._isReachable = false;
	}
	return ret;
};


function LocalVariableStatuses$mergeFinally$LLocalVariableStatuses$LLocalVariableStatuses$($this, postFinallyStats) {
	var ret;
	var k;
	ret = new LocalVariableStatuses$0($this);
	for (k in ret._statuses) {
		switch (postFinallyStats._statuses[k]) {
		case 1:
			ret._statuses[k] = 1;
			break;
		case 2:
			if (ret._statuses[k] !== 1) {
				ret._statuses[k] = 2;
			}
			break;
		}
	}
	if (! postFinallyStats._isReachable) {
		ret._isReachable = false;
	}
	return ret;
};

LocalVariableStatuses.mergeFinally$LLocalVariableStatuses$LLocalVariableStatuses$ = LocalVariableStatuses$mergeFinally$LLocalVariableStatuses$LLocalVariableStatuses$;

LocalVariableStatuses.prototype.setStatus$LLocalVariable$ = function (local) {
	var name;
	var this$0;
	this$0 = local._name;
	name = this$0._value;
	if (this._statuses[name] == null) {
		throw new Error("logic flaw, could not find status for local variable: " + name);
	}
	this._statuses[name] = 1;
};


function LocalVariableStatuses$setStatus$LLocalVariableStatuses$LLocalVariable$($this, local) {
	var name;
	var this$0;
	this$0 = local._name;
	name = this$0._value;
	if ($this._statuses[name] == null) {
		throw new Error("logic flaw, could not find status for local variable: " + name);
	}
	$this._statuses[name] = 1;
};

LocalVariableStatuses.setStatus$LLocalVariableStatuses$LLocalVariable$ = LocalVariableStatuses$setStatus$LLocalVariableStatuses$LLocalVariable$;

LocalVariableStatuses.prototype.getStatus$LLocalVariable$ = function (local) {
	var name;
	var this$0;
	this$0 = local._name;
	name = this$0._value;
	if (this._statuses[name] == null) {
		throw new Error("logic flaw, could not find status for local variable: " + name);
	}
	return this._statuses[name];
};


function LocalVariableStatuses$getStatus$LLocalVariableStatuses$LLocalVariable$($this, local) {
	var name;
	var this$0;
	this$0 = local._name;
	name = this$0._value;
	if ($this._statuses[name] == null) {
		throw new Error("logic flaw, could not find status for local variable: " + name);
	}
	return $this._statuses[name];
};

LocalVariableStatuses.getStatus$LLocalVariableStatuses$LLocalVariable$ = LocalVariableStatuses$getStatus$LLocalVariableStatuses$LLocalVariable$;

LocalVariableStatuses.prototype.isReachable$ = function () {
	return this._isReachable;
};


function LocalVariableStatuses$isReachable$LLocalVariableStatuses$($this) {
	return $this._isReachable;
};

LocalVariableStatuses.isReachable$LLocalVariableStatuses$ = LocalVariableStatuses$isReachable$LLocalVariableStatuses$;

LocalVariableStatuses.prototype.setIsReachable$B = function (isReachable) {
	this._isReachable = isReachable;
};


function LocalVariableStatuses$setIsReachable$LLocalVariableStatuses$B($this, isReachable) {
	$this._isReachable = isReachable;
};

LocalVariableStatuses.setIsReachable$LLocalVariableStatuses$B = LocalVariableStatuses$setIsReachable$LLocalVariableStatuses$B;

LocalVariableStatuses.prototype._copyFrom$LLocalVariableStatuses$ = function (that) {
	var k;
	for (k in that._statuses) {
		this._statuses[k] = that._statuses[k];
	}
};


function LocalVariableStatuses$_copyFrom$LLocalVariableStatuses$LLocalVariableStatuses$($this, that) {
	var k;
	for (k in that._statuses) {
		$this._statuses[k] = that._statuses[k];
	}
};

LocalVariableStatuses._copyFrom$LLocalVariableStatuses$LLocalVariableStatuses$ = LocalVariableStatuses$_copyFrom$LLocalVariableStatuses$LLocalVariableStatuses$;

function CompileIssue(token, message) {
	this._filename = null;
	this._lineNumber = 0;
	this._columnNumber = 0;
	this._message = "";
	this._size = 0;
	if (token != null) {
		this._filename = token._filename;
		this._lineNumber = token._lineNumber;
		this._columnNumber = token._columnNumber;
		this._size = token._value.length;
		this._message = message;
	} else {
		this._filename = null;
		this._lineNumber = 0;
		this._columnNumber = -1;
		this._message = message;
		this._size = 1;
	}
};

function CompileIssue$0(filename, lineNumber, columnNumber, message) {
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
	this._message = message;
	this._size = 1;
};

$__jsx_extend([CompileIssue, CompileIssue$0], Object);
CompileIssue.prototype.format$LPlatform$ = function (platform) {
	return Util$makeErrorMessage$LPlatform$SUSNNN(platform, this.getPrefix$() + this._message, this._filename, this._lineNumber, this._columnNumber, this._size);
};


function CompileIssue$format$LCompileIssue$LPlatform$($this, platform) {
	return Util$makeErrorMessage$LPlatform$SUSNNN(platform, $this.getPrefix$() + $this._message, $this._filename, $this._lineNumber, $this._columnNumber, $this._size);
};

CompileIssue.format$LCompileIssue$LPlatform$ = CompileIssue$format$LCompileIssue$LPlatform$;

function CompileError(token, message) {
	CompileIssue.call(this, token, message);
	this._notes = [];
};

function CompileError$0(filename, lineNumber, columnNumber, message) {
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
	this._message = message;
	this._size = 1;
	this._notes = [];
};

$__jsx_extend([CompileError, CompileError$0], CompileIssue);
CompileError.prototype.addCompileNote$LCompileNote$ = function (note) {
	this._notes.push(note);
	return this;
};


function CompileError$addCompileNote$LCompileError$LCompileNote$($this, note) {
	$this._notes.push(note);
	return $this;
};

CompileError.addCompileNote$LCompileError$LCompileNote$ = CompileError$addCompileNote$LCompileError$LCompileNote$;

CompileError.prototype.addCompileNotes$ALCompileNote$ = function (notes) {
	var $this = this;
	notes.forEach((function (note) {
		$this._notes.push(note);
	}));
};


function CompileError$addCompileNotes$LCompileError$ALCompileNote$($this, notes) {
	notes.forEach((function (note) {
		$this._notes.push(note);
	}));
};

CompileError.addCompileNotes$LCompileError$ALCompileNote$ = CompileError$addCompileNotes$LCompileError$ALCompileNote$;

CompileError.prototype.getCompileNotes$ = function () {
	return this._notes;
};


function CompileError$getCompileNotes$LCompileError$($this) {
	return $this._notes;
};

CompileError.getCompileNotes$LCompileError$ = CompileError$getCompileNotes$LCompileError$;

CompileError.prototype.getPrefix$ = function () {
	return "";
};


function CompileWarning(token, message) {
	CompileError.call(this, token, message);
};

function CompileWarning$0(filename, lineNumber, columnNumber, message) {
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
	this._message = message;
	this._size = 1;
	this._notes = [];
};

$__jsx_extend([CompileWarning, CompileWarning$0], CompileError);
CompileWarning.prototype.getPrefix$ = function () {
	return "Warning: ";
};


function UnusedWarning(token, message) {
	CompileWarning.call(this, token, message);
};

function UnusedWarning$0(filename, lineNumber, columnNumber, message) {
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
	this._message = message;
	this._size = 1;
	this._notes = [];
};

$__jsx_extend([UnusedWarning, UnusedWarning$0], CompileWarning);
function DeprecatedWarning(token, message) {
	CompileWarning.call(this, token, message);
};

function DeprecatedWarning$0(filename, lineNumber, columnNumber, message) {
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
	this._message = message;
	this._size = 1;
	this._notes = [];
};

$__jsx_extend([DeprecatedWarning, DeprecatedWarning$0], CompileWarning);
function ExperimentalWarning(token, feature) {
	CompileWarning.call(this, token, "'" + feature + "' is experimental");
};

function ExperimentalWarning$0(filename, lineNumber, columnNumber, feature) {
	var message$0;
	message$0 = "'" + feature + "' is experimental";
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
	this._message = message$0;
	this._size = 1;
	this._notes = [];
};

$__jsx_extend([ExperimentalWarning, ExperimentalWarning$0], CompileWarning);
function CompileNote(token, message) {
	CompileIssue.call(this, token, message);
};

function CompileNote$0(filename, lineNumber, columnNumber, message) {
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
	this._message = message;
	this._size = 1;
};

$__jsx_extend([CompileNote, CompileNote$0], CompileIssue);
CompileNote.prototype.getPrefix$ = function () {
	return "Note: ";
};


function TemplateDefinition() {
};

$__jsx_extend([TemplateDefinition], Object);
TemplateDefinition.prototype.$__jsx_implements_TemplateDefinition = true;

TemplateDefinition.prototype.buildInstantiationContext$ALCompileError$LToken$ALToken$ALType$ = function (errors, token, formalTypeArgs, actualTypeArgs) {
	var typemap;
	var i;
	var this$0;
	if (formalTypeArgs.length !== actualTypeArgs.length) {
		errors.push(new CompileError(token, "wrong number of template arguments (expected " + (formalTypeArgs.length + "") + ", got " + (actualTypeArgs.length + "") + ")"));
		return null;
	}
	typemap = {};
	for (i = 0; i < formalTypeArgs.length; ++i) {
		typemap[(this$0 = formalTypeArgs[i], this$0._value)] = actualTypeArgs[i];
	}
	return ({errors: errors, typemap: typemap, objectTypesUsed: []});
};


function ClassDefinition(token, className, flags, extendType, implementTypes, members, inners, templateInners, objectTypesUsed, docComment) {
	this._stash = {};
	this._baseClassDef = null;
	this._outerClassDef = null;
	this._nativeSource = null;
	this._analized = false;
	this._parser = null;
	this._token = token;
	this._className = className;
	this._flags = flags;
	this._extendType = extendType;
	this._implementTypes = implementTypes;
	this._members = members;
	this._inners = inners;
	this._templateInners = templateInners;
	this._objectTypesUsed = objectTypesUsed;
	this._docComment = docComment;
	ClassDefinition$_resetMembersClassDef$LClassDefinition$(this);
	if (! (this instanceof TemplateClassDefinition || this instanceof InstantiatedClassDefinition)) {
		ClassDefinition$_generateWrapperFunctions$LClassDefinition$(this);
	}
};

$__jsx_extend([ClassDefinition], Object);
$__jsx_merge_interface(ClassDefinition, Stashable);

ClassDefinition.prototype._generateWrapperFunctions$ = function () {
	var $this = this;
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(this, (function (funcDef) {
		MemberFunctionDefinition$generateWrappersForDefaultParameters$LMemberFunctionDefinition$(funcDef);
		return true;
	}));
	ClassDefinition$forEachTemplateFunction$LClassDefinition$F$LTemplateFunctionDefinition$B$(this, (function (funcDef) {
		MemberFunctionDefinition$generateWrappersForDefaultParameters$LMemberFunctionDefinition$(funcDef);
		return true;
	}));
};


function ClassDefinition$_generateWrapperFunctions$LClassDefinition$($this) {
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$($this, (function (funcDef) {
		MemberFunctionDefinition$generateWrappersForDefaultParameters$LMemberFunctionDefinition$(funcDef);
		return true;
	}));
	ClassDefinition$forEachTemplateFunction$LClassDefinition$F$LTemplateFunctionDefinition$B$($this, (function (funcDef) {
		MemberFunctionDefinition$generateWrappersForDefaultParameters$LMemberFunctionDefinition$(funcDef);
		return true;
	}));
};

ClassDefinition._generateWrapperFunctions$LClassDefinition$ = ClassDefinition$_generateWrapperFunctions$LClassDefinition$;

ClassDefinition.prototype.serialize$ = function () {
	var v$0;
	return ({ "token": this._token, "name": this._className, "flags": this._flags, "extends": (v$0 = this._extendType, v$0 == null ? null : v$0.toString()), "implements": Util$serializeArray$ALParsedObjectType$(this._implementTypes), "members": Util$serializeArray$ALMemberDefinition$(this._members), "inners": Util$serializeArray$ALClassDefinition$(this._inners), "templateInners": Util$serializeArray$ALTemplateClassDefinition$(this._templateInners) });
};


function ClassDefinition$serialize$LClassDefinition$($this) {
	var v$0;
	return ({ "token": $this._token, "name": $this._className, "flags": $this._flags, "extends": (v$0 = $this._extendType, v$0 == null ? null : v$0.toString()), "implements": Util$serializeArray$ALParsedObjectType$($this._implementTypes), "members": Util$serializeArray$ALMemberDefinition$($this._members), "inners": Util$serializeArray$ALClassDefinition$($this._inners), "templateInners": Util$serializeArray$ALTemplateClassDefinition$($this._templateInners) });
};

ClassDefinition.serialize$LClassDefinition$ = ClassDefinition$serialize$LClassDefinition$;

function ClassDefinition$serialize$ALClassDefinition$(classDefs) {
	var s;
	var i;
	s = [];
	for (i = 0; i < classDefs.length; ++i) {
		s[i] = ClassDefinition$serialize$LClassDefinition$(classDefs[i]);
	}
	return s;
};

ClassDefinition.serialize$ALClassDefinition$ = ClassDefinition$serialize$ALClassDefinition$;

ClassDefinition.prototype.getParser$ = function () {
	return this._parser;
};


function ClassDefinition$getParser$LClassDefinition$($this) {
	return $this._parser;
};

ClassDefinition.getParser$LClassDefinition$ = ClassDefinition$getParser$LClassDefinition$;

ClassDefinition.prototype.setParser$LParser$ = function (parser) {
	this._parser = parser;
};


function ClassDefinition$setParser$LClassDefinition$LParser$($this, parser) {
	$this._parser = parser;
};

ClassDefinition.setParser$LClassDefinition$LParser$ = ClassDefinition$setParser$LClassDefinition$LParser$;

ClassDefinition.prototype.getNativeSource$ = function () {
	return this._nativeSource;
};


function ClassDefinition$getNativeSource$LClassDefinition$($this) {
	return $this._nativeSource;
};

ClassDefinition.getNativeSource$LClassDefinition$ = ClassDefinition$getNativeSource$LClassDefinition$;

ClassDefinition.prototype.setNativeSource$LToken$ = function (nativeSource) {
	this._nativeSource = nativeSource;
};


function ClassDefinition$setNativeSource$LClassDefinition$LToken$($this, nativeSource) {
	$this._nativeSource = nativeSource;
};

ClassDefinition.setNativeSource$LClassDefinition$LToken$ = ClassDefinition$setNativeSource$LClassDefinition$LToken$;

ClassDefinition.prototype.getToken$ = function () {
	return this._token;
};


ClassDefinition.prototype.className$ = function () {
	return this._className;
};


ClassDefinition.prototype.classFullName$ = function () {
	return (this._outerClassDef != null ? ClassDefinition$classFullName$LClassDefinition$(this._outerClassDef) + "." + this._className : this.className$());
};


function ClassDefinition$classFullName$LClassDefinition$($this) {
	return ($this._outerClassDef != null ? ClassDefinition$classFullName$LClassDefinition$($this._outerClassDef) + "." + $this._className : $this.className$());
};

ClassDefinition.classFullName$LClassDefinition$ = ClassDefinition$classFullName$LClassDefinition$;

ClassDefinition.prototype.flags$ = function () {
	return this._flags;
};


ClassDefinition.prototype.setFlags$N = function (flags) {
	this._flags = flags;
};


function ClassDefinition$setFlags$LClassDefinition$N($this, flags) {
	$this._flags = flags;
};

ClassDefinition.setFlags$LClassDefinition$N = ClassDefinition$setFlags$LClassDefinition$N;

ClassDefinition.prototype.extendType$ = function () {
	return this._extendType;
};


function ClassDefinition$extendType$LClassDefinition$($this) {
	return $this._extendType;
};

ClassDefinition.extendType$LClassDefinition$ = ClassDefinition$extendType$LClassDefinition$;

ClassDefinition.prototype.implementTypes$ = function () {
	return this._implementTypes;
};


function ClassDefinition$implementTypes$LClassDefinition$($this) {
	return $this._implementTypes;
};

ClassDefinition.implementTypes$LClassDefinition$ = ClassDefinition$implementTypes$LClassDefinition$;

ClassDefinition.prototype.members$ = function () {
	return this._members;
};


function ClassDefinition$members$LClassDefinition$($this) {
	return $this._members;
};

ClassDefinition.members$LClassDefinition$ = ClassDefinition$members$LClassDefinition$;

ClassDefinition.prototype.setOuterClassDef$LClassDefinition$ = function (outer) {
	this._outerClassDef = outer;
};


function ClassDefinition$setOuterClassDef$LClassDefinition$LClassDefinition$($this, outer) {
	$this._outerClassDef = outer;
};

ClassDefinition.setOuterClassDef$LClassDefinition$LClassDefinition$ = ClassDefinition$setOuterClassDef$LClassDefinition$LClassDefinition$;

ClassDefinition.prototype.getOuterClassDef$ = function () {
	return this._outerClassDef;
};


function ClassDefinition$getOuterClassDef$LClassDefinition$($this) {
	return $this._outerClassDef;
};

ClassDefinition.getOuterClassDef$LClassDefinition$ = ClassDefinition$getOuterClassDef$LClassDefinition$;

ClassDefinition.prototype.getInnerClasses$ = function () {
	return this._inners;
};


function ClassDefinition$getInnerClasses$LClassDefinition$($this) {
	return $this._inners;
};

ClassDefinition.getInnerClasses$LClassDefinition$ = ClassDefinition$getInnerClasses$LClassDefinition$;

ClassDefinition.prototype.getTemplateInnerClasses$ = function () {
	return this._templateInners;
};


function ClassDefinition$getTemplateInnerClasses$LClassDefinition$($this) {
	return $this._templateInners;
};

ClassDefinition.getTemplateInnerClasses$LClassDefinition$ = ClassDefinition$getTemplateInnerClasses$LClassDefinition$;

ClassDefinition.prototype.getDocComment$ = function () {
	return this._docComment;
};


function ClassDefinition$getDocComment$LClassDefinition$($this) {
	return $this._docComment;
};

ClassDefinition.getDocComment$LClassDefinition$ = ClassDefinition$getDocComment$LClassDefinition$;

ClassDefinition.prototype.setDocComment$LDocComment$ = function (docComment) {
	this._docComment = docComment;
};


function ClassDefinition$setDocComment$LClassDefinition$LDocComment$($this, docComment) {
	$this._docComment = docComment;
};

ClassDefinition.setDocComment$LClassDefinition$LDocComment$ = ClassDefinition$setDocComment$LClassDefinition$LDocComment$;

ClassDefinition.prototype.forEachClassToBase$F$LClassDefinition$B$ = function (cb) {
	var i;
	var this$0;
	var this$1;
	if (! cb(this)) {
		return false;
	}
	for (i = this._implementTypes.length - 1; i >= 0; --i) {
		if (! cb((this$0 = this._implementTypes[i], this$0._classDef))) {
			return false;
		}
	}
	if (this._extendType != null) {
		if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$((this$1 = this._extendType, this$1._classDef), cb)) {
			return false;
		}
	}
	return true;
};


function ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$($this, cb) {
	var i;
	var this$0;
	var this$1;
	if (! cb($this)) {
		return false;
	}
	for (i = $this._implementTypes.length - 1; i >= 0; --i) {
		if (! cb((this$0 = $this._implementTypes[i], this$0._classDef))) {
			return false;
		}
	}
	if ($this._extendType != null) {
		if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$((this$1 = $this._extendType, this$1._classDef), cb)) {
			return false;
		}
	}
	return true;
};

ClassDefinition.forEachClassToBase$LClassDefinition$F$LClassDefinition$B$ = ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$;

ClassDefinition.prototype.forEachClassFromBase$F$LClassDefinition$B$ = function (cb) {
	var i;
	var this$0;
	var this$1;
	if (this._extendType != null) {
		if (! ClassDefinition$forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$((this$0 = this._extendType, this$0._classDef), cb)) {
			return false;
		}
	}
	for (i = 0; i < this._implementTypes.length; ++i) {
		if (! cb((this$1 = this._implementTypes[i], this$1._classDef))) {
			return false;
		}
	}
	return (! cb(this) ? false : true);
};


function ClassDefinition$forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$($this, cb) {
	var i;
	var this$0;
	var this$1;
	if ($this._extendType != null) {
		if (! ClassDefinition$forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$((this$0 = $this._extendType, this$0._classDef), cb)) {
			return false;
		}
	}
	for (i = 0; i < $this._implementTypes.length; ++i) {
		if (! cb((this$1 = $this._implementTypes[i], this$1._classDef))) {
			return false;
		}
	}
	return (! cb($this) ? false : true);
};

ClassDefinition.forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$ = ClassDefinition$forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$;

ClassDefinition.prototype.forEachMember$F$LMemberDefinition$B$ = function (cb) {
	var i;
	for (i = 0; i < this._members.length; ++i) {
		if (! cb(this._members[i])) {
			return false;
		}
	}
	return true;
};


function ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$($this, cb) {
	var i;
	for (i = 0; i < $this._members.length; ++i) {
		if (! cb($this._members[i])) {
			return false;
		}
	}
	return true;
};

ClassDefinition.forEachMember$LClassDefinition$F$LMemberDefinition$B$ = ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$;

ClassDefinition.prototype.forEachMemberVariable$F$LMemberVariableDefinition$B$ = function (cb) {
	var i;
	for (i = 0; i < this._members.length; ++i) {
		if (this._members[i] instanceof MemberVariableDefinition) {
			if (! cb(this._members[i])) {
				return false;
			}
		}
	}
	return true;
};


function ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$($this, cb) {
	var i;
	for (i = 0; i < $this._members.length; ++i) {
		if ($this._members[i] instanceof MemberVariableDefinition) {
			if (! cb($this._members[i])) {
				return false;
			}
		}
	}
	return true;
};

ClassDefinition.forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$ = ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$;

ClassDefinition.prototype.forEachMemberFunction$F$LMemberFunctionDefinition$B$ = function (cb) {
	var i;
	var member;
	for (i = 0; i < this._members.length; ++i) {
		member = this._members[i];
		if (member instanceof MemberFunctionDefinition && ! (member instanceof TemplateFunctionDefinition)) {
			if (! cb(member)) {
				return false;
			}
		}
	}
	return true;
};


function ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$($this, cb) {
	var i;
	var member;
	for (i = 0; i < $this._members.length; ++i) {
		member = $this._members[i];
		if (member instanceof MemberFunctionDefinition && ! (member instanceof TemplateFunctionDefinition)) {
			if (! cb(member)) {
				return false;
			}
		}
	}
	return true;
};

ClassDefinition.forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$ = ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$;

ClassDefinition.prototype.forEachTemplateFunction$F$LTemplateFunctionDefinition$B$ = function (cb) {
	var i;
	for (i = 0; i < this._members.length; ++i) {
		if (this._members[i] instanceof TemplateFunctionDefinition) {
			if (! cb(this._members[i])) {
				return false;
			}
		}
	}
	return true;
};


function ClassDefinition$forEachTemplateFunction$LClassDefinition$F$LTemplateFunctionDefinition$B$($this, cb) {
	var i;
	for (i = 0; i < $this._members.length; ++i) {
		if ($this._members[i] instanceof TemplateFunctionDefinition) {
			if (! cb($this._members[i])) {
				return false;
			}
		}
	}
	return true;
};

ClassDefinition.forEachTemplateFunction$LClassDefinition$F$LTemplateFunctionDefinition$B$ = ClassDefinition$forEachTemplateFunction$LClassDefinition$F$LTemplateFunctionDefinition$B$;

ClassDefinition.prototype.forEachInnerClass$F$LClassDefinition$B$ = function (cb) {
	var i;
	for (i = 0; i < this._inners.length; ++i) {
		if (! cb(this._inners[i])) {
			return false;
		}
	}
	return true;
};


function ClassDefinition$forEachInnerClass$LClassDefinition$F$LClassDefinition$B$($this, cb) {
	var i;
	for (i = 0; i < $this._inners.length; ++i) {
		if (! cb($this._inners[i])) {
			return false;
		}
	}
	return true;
};

ClassDefinition.forEachInnerClass$LClassDefinition$F$LClassDefinition$B$ = ClassDefinition$forEachInnerClass$LClassDefinition$F$LClassDefinition$B$;

ClassDefinition.prototype.forEachTemplateInnerClass$F$LTemplateClassDefinition$B$ = function (cb) {
	var i;
	for (i = 0; i < this._templateInners.length; ++i) {
		if (! cb(this._templateInners[i])) {
			return false;
		}
	}
	return true;
};


function ClassDefinition$forEachTemplateInnerClass$LClassDefinition$F$LTemplateClassDefinition$B$($this, cb) {
	var i;
	for (i = 0; i < $this._templateInners.length; ++i) {
		if (! cb($this._templateInners[i])) {
			return false;
		}
	}
	return true;
};

ClassDefinition.forEachTemplateInnerClass$LClassDefinition$F$LTemplateClassDefinition$B$ = ClassDefinition$forEachTemplateInnerClass$LClassDefinition$F$LTemplateClassDefinition$B$;

ClassDefinition.prototype._resetMembersClassDef$ = function () {
	var $this = this;
	var i;
	var this$0;
	var this$1;
	var this$2;
	var _members$0;
	var _inners$0;
	for (i = 0; i < this._members.length; ++i) {
		this$0 = (_members$0 = this._members)[i];
		this$0._classDef = this;
		MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(_members$0[i], (function setClassDef(funcDef) {
			funcDef._classDef = $this;
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, setClassDef);
		}));
	}
	for (i = 0; i < this._inners.length; ++i) {
		this$1 = (_inners$0 = this._inners)[i];
		this$1._outerClassDef = this;
		ClassDefinition$_resetMembersClassDef$LClassDefinition$(_inners$0[i]);
	}
	for (i = 0; i < this._templateInners.length; ++i) {
		this$2 = this._templateInners[i];
		this$2._outerClassDef = this;
	}
};


function ClassDefinition$_resetMembersClassDef$LClassDefinition$($this) {
	var i;
	var this$0;
	var this$1;
	var this$2;
	var _members$0;
	var _inners$0;
	for (i = 0; i < $this._members.length; ++i) {
		this$0 = (_members$0 = $this._members)[i];
		this$0._classDef = $this;
		MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(_members$0[i], (function setClassDef(funcDef) {
			funcDef._classDef = $this;
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, setClassDef);
		}));
	}
	for (i = 0; i < $this._inners.length; ++i) {
		this$1 = (_inners$0 = $this._inners)[i];
		this$1._outerClassDef = $this;
		ClassDefinition$_resetMembersClassDef$LClassDefinition$(_inners$0[i]);
	}
	for (i = 0; i < $this._templateInners.length; ++i) {
		this$2 = $this._templateInners[i];
		this$2._outerClassDef = $this;
	}
};

ClassDefinition._resetMembersClassDef$LClassDefinition$ = ClassDefinition$_resetMembersClassDef$LClassDefinition$;

ClassDefinition.prototype.getMemberTypeByName$ALCompileError$LToken$SBALType$N = function (errors, token, name, isStatic, typeArgs, mode) {
	var $this = this;
	var types;
	var pushMatchingMember;
	types = [];
	function pushMatchingMember(classDef) {
		var i;
		var member;
		var type;
		var j;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var this$4;
		var this$0$0;
		var _nameToken$0;
		if (mode !== 2) {
			for (i = 0; i < classDef._members.length; ++i) {
				member = classDef._members[i];
				if ((member._flags & 4096) !== 0) {
				} else if (((member._flags & 8) !== 0) === isStatic && name === (this$0$0 = member._nameToken, this$0$0._value)) {
					if (member instanceof MemberVariableDefinition) {
						if ((member._flags & 32) === 0) {
							this$0 = member;
							switch (this$0._analyzeState) {
							case 0:
								MemberVariableDefinition$_lazyAnalyze$LMemberVariableDefinition$(this$0);
								break;
							case 1:
								this$0._analysisContext.errors.push(new CompileError(_nameToken$0 = this$0._nameToken, "please declare type of variable '" + (_nameToken$0, _nameToken$0._value) + "' (detected recursion while trying to reduce type)"));
								break;
							default:
								break;
							}
							type = this$0._type;
							if (type != null && types.length === 0) {
								types[0] = type;
							}
						}
					} else if (member instanceof MemberFunctionDefinition) {
						if (member instanceof InstantiatedMemberFunctionDefinition) {
						} else {
							if (member instanceof TemplateFunctionDefinition && typeArgs.length !== 0) {
								if ((member = TemplateFunctionDefinition$instantiateTemplateFunction$LTemplateFunctionDefinition$ALCompileError$LToken$ALType$(member, errors, token, typeArgs)) == null) {
									return;
								}
							}
							if ((this$4 = member, this$4._statements) != null || mode !== 3 || (member._flags & 18) === 16) {
								for (j = 0; j < types.length; ++j) {
									if (Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member), (this$1 = types[j], this$1._argTypes))) {
										break;
									}
								}
								if (j === types.length) {
									types.push(member.getType$());
								}
							}
						}
					} else {
						throw new Error("logic flaw");
					}
				}
			}
		} else {
			mode = 3;
		}
		if (mode !== 1) {
			if (classDef._extendType != null) {
				pushMatchingMember((this$2 = classDef._extendType, this$2._classDef));
			}
			for (i = 0; i < classDef._implementTypes.length; ++i) {
				pushMatchingMember((this$3 = classDef._implementTypes[i], this$3._classDef));
			}
		}
	}
	pushMatchingMember(this);
	switch (types.length) {
	case 0:
		return null;
	case 1:
		return types[0];
	default:
		return new FunctionChoiceType(types.map((function (t) {
			return t;
		})));
	}
};


function ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N($this, errors, token, name, isStatic, typeArgs, mode) {
	var types;
	var pushMatchingMember;
	types = [];
	function pushMatchingMember(classDef) {
		var i;
		var member;
		var type;
		var j;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var this$4;
		var this$0$0;
		var _nameToken$0;
		if (mode !== 2) {
			for (i = 0; i < classDef._members.length; ++i) {
				member = classDef._members[i];
				if ((member._flags & 4096) !== 0) {
				} else if (((member._flags & 8) !== 0) === isStatic && name === (this$0$0 = member._nameToken, this$0$0._value)) {
					if (member instanceof MemberVariableDefinition) {
						if ((member._flags & 32) === 0) {
							this$0 = member;
							switch (this$0._analyzeState) {
							case 0:
								MemberVariableDefinition$_lazyAnalyze$LMemberVariableDefinition$(this$0);
								break;
							case 1:
								this$0._analysisContext.errors.push(new CompileError(_nameToken$0 = this$0._nameToken, "please declare type of variable '" + (_nameToken$0, _nameToken$0._value) + "' (detected recursion while trying to reduce type)"));
								break;
							default:
								break;
							}
							type = this$0._type;
							if (type != null && types.length === 0) {
								types[0] = type;
							}
						}
					} else if (member instanceof MemberFunctionDefinition) {
						if (member instanceof InstantiatedMemberFunctionDefinition) {
						} else {
							if (member instanceof TemplateFunctionDefinition && typeArgs.length !== 0) {
								if ((member = TemplateFunctionDefinition$instantiateTemplateFunction$LTemplateFunctionDefinition$ALCompileError$LToken$ALType$(member, errors, token, typeArgs)) == null) {
									return;
								}
							}
							if ((this$4 = member, this$4._statements) != null || mode !== 3 || (member._flags & 18) === 16) {
								for (j = 0; j < types.length; ++j) {
									if (Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member), (this$1 = types[j], this$1._argTypes))) {
										break;
									}
								}
								if (j === types.length) {
									types.push(member.getType$());
								}
							}
						}
					} else {
						throw new Error("logic flaw");
					}
				}
			}
		} else {
			mode = 3;
		}
		if (mode !== 1) {
			if (classDef._extendType != null) {
				pushMatchingMember((this$2 = classDef._extendType, this$2._classDef));
			}
			for (i = 0; i < classDef._implementTypes.length; ++i) {
				pushMatchingMember((this$3 = classDef._implementTypes[i], this$3._classDef));
			}
		}
	}
	pushMatchingMember($this);
	switch (types.length) {
	case 0:
		return null;
	case 1:
		return types[0];
	default:
		return new FunctionChoiceType(types.map((function (t) {
			return t;
		})));
	}
};

ClassDefinition.getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N = ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N;

ClassDefinition.prototype.lookupInnerClass$S = function (className) {
	var i;
	var inner;
	for (i = 0; i < this._inners.length; ++i) {
		inner = this._inners[i];
		if (inner.className$() === className) {
			return inner;
		}
	}
	return null;
};


function ClassDefinition$lookupInnerClass$LClassDefinition$S($this, className) {
	var i;
	var inner;
	for (i = 0; i < $this._inners.length; ++i) {
		inner = $this._inners[i];
		if (inner.className$() === className) {
			return inner;
		}
	}
	return null;
};

ClassDefinition.lookupInnerClass$LClassDefinition$S = ClassDefinition$lookupInnerClass$LClassDefinition$S;

ClassDefinition.prototype.lookupTemplateInnerClass$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = function (errors, request, postInstantiationCallback) {
	var instantiateCallback;
	instantiateCallback = ClassDefinition$createGetTemplateClassCallback$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(this, errors, request, postInstantiationCallback);
	return (instantiateCallback != null ? instantiateCallback(errors, request, postInstantiationCallback) : null);
};


function ClassDefinition$lookupTemplateInnerClass$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback) {
	var instantiateCallback;
	instantiateCallback = ClassDefinition$createGetTemplateClassCallback$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback);
	return (instantiateCallback != null ? instantiateCallback(errors, request, postInstantiationCallback) : null);
};

ClassDefinition.lookupTemplateInnerClass$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = ClassDefinition$lookupTemplateInnerClass$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$;

ClassDefinition.prototype.createGetTemplateClassCallback$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = function (errors, request, postInstantiationCallback) {
	var $this = this;
	var i;
	var classDef;
	var templateDef;
	var this$0;
	var this$0$0;
	var this$1;
	for (i = 0; i < this._inners.length; ++i) {
		classDef = this._inners[i];
		if (classDef instanceof InstantiatedClassDefinition && (this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) === request._className && Util$typesAreEqual$ALType$ALType$((this$1 = classDef, this$1._typeArguments), request._typeArgs)) {
			return (function (_, __, ___) {
				return classDef;
			});
		}
	}
	for (i = 0; i < this._templateInners.length; ++i) {
		templateDef = this._templateInners[i];
		if (templateDef._className === request._className) {
			return (function (_, __, ___) {
				var classDef;
				var parser$0;
				var _parser$0;
				classDef = TemplateClassDefinition$instantiateTemplateClass$LTemplateClassDefinition$ALCompileError$LTemplateInstantiationRequest$(templateDef, errors, request);
				if (classDef == null) {
					return null;
				}
				$this._inners.push(classDef);
				parser$0 = _parser$0 = $this._parser;
				classDef._parser = parser$0;
				ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(classDef, ({errors: errors, parser: _parser$0, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}));
				postInstantiationCallback($this._parser, classDef);
				return classDef;
			});
		}
	}
	return null;
};


function ClassDefinition$createGetTemplateClassCallback$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback) {
	var i;
	var classDef;
	var templateDef;
	var this$0;
	var this$0$0;
	var this$1;
	for (i = 0; i < $this._inners.length; ++i) {
		classDef = $this._inners[i];
		if (classDef instanceof InstantiatedClassDefinition && (this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) === request._className && Util$typesAreEqual$ALType$ALType$((this$1 = classDef, this$1._typeArguments), request._typeArgs)) {
			return (function (_, __, ___) {
				return classDef;
			});
		}
	}
	for (i = 0; i < $this._templateInners.length; ++i) {
		templateDef = $this._templateInners[i];
		if (templateDef._className === request._className) {
			return (function (_, __, ___) {
				var classDef;
				var parser$0;
				var _parser$0;
				classDef = TemplateClassDefinition$instantiateTemplateClass$LTemplateClassDefinition$ALCompileError$LTemplateInstantiationRequest$(templateDef, errors, request);
				if (classDef == null) {
					return null;
				}
				$this._inners.push(classDef);
				parser$0 = _parser$0 = $this._parser;
				classDef._parser = parser$0;
				ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(classDef, ({errors: errors, parser: _parser$0, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}));
				postInstantiationCallback($this._parser, classDef);
				return classDef;
			});
		}
	}
	return null;
};

ClassDefinition.createGetTemplateClassCallback$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = ClassDefinition$createGetTemplateClassCallback$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$;

ClassDefinition.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var context;
	var succeeded;
	var members;
	var i;
	var member;
	var inners;
	var inner;
	var templateInners;
	var templateInner;
	var extendType;
	var type;
	var implementTypes;
	var this$0;
	var this$0$0;
	var this$1;
	var this$0$1;
	context = ({errors: instantiationContext.errors, typemap: instantiationContext.typemap, objectTypesUsed: []});
	succeeded = true;
	members = [];
	for (i = 0; i < this._members.length; ++i) {
		member = this._members[i].instantiate$LInstantiationContext$(context);
		if (member == null) {
			succeeded = false;
		}
		members[i] = member;
	}
	inners = [];
	for (i = 0; i < this._inners.length; ++i) {
		inner = this._inners[i].instantiate$LInstantiationContext$(context);
		if (inner == null) {
			succeeded = false;
		}
		inners[i] = inner;
	}
	templateInners = [];
	for (i = 0; i < this._templateInners.length; ++i) {
		templateInner = this._templateInners[i].instantiate$LInstantiationContext$(context);
		if (templateInner == null) {
			succeeded = false;
		}
		templateInners[i] = templateInner;
	}
	if (! succeeded) {
		return null;
	}
	extendType = null;
	if (this._extendType != null) {
		type = this._extendType.instantiate$LInstantiationContext$B(instantiationContext, false);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError((this$0 = this._extendType, this$0$0 = this$0._qualifiedName, this$0$0._token), "non-object type is not extensible"));
			return null;
		}
		extendType = type;
	}
	implementTypes = [];
	for (i = 0; i < this._implementTypes.length; ++i) {
		type = this._implementTypes[i].instantiate$LInstantiationContext$B(instantiationContext, false);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError((this$1 = this._implementTypes[i], this$0$1 = this$1._qualifiedName, this$0$1._token), "non-object type is not extensible"));
			return null;
		}
		implementTypes[i] = type;
	}
	return new ClassDefinition(this._token, this._className, this._flags, extendType, implementTypes, members, inners, templateInners, context.objectTypesUsed, this._docComment);
};


ClassDefinition.prototype.normalizeClassDefs$ALCompileError$ = function (errors) {
	var x;
	var y;
	var errorMsg;
	var error;
	var this$0;
	var this$1;
	var note$0;
	var this$2;
	var this$3;
	var this$0$0;
	var this$4;
	var this$0$1;
	var this$5;
	var this$6;
	var _members$0;
	for (x = 0; x < this._members.length; ++x) {
		for (y = 0; y < x; ++y) {
			if ((this$3 = this._members[x], this$0$0 = this$3._nameToken, this$0$0._value) === (this$4 = this._members[y], this$0$1 = this$4._nameToken, this$0$1._value) && ((this$5 = this._members[x], this$5._flags) & 8) === ((this$6 = this._members[y], this$6._flags) & 8)) {
				errorMsg = null;
				if ((_members$0 = this._members)[x] instanceof MemberFunctionDefinition && _members$0[y] instanceof MemberFunctionDefinition) {
					if (Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this._members[x]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this._members[y]))) {
						errorMsg = "a " + (((this$0 = this._members[x], this$0._flags) & 8) !== 0 ? "static" : "member") + " function with same name and arguments is already defined";
						errorMsg += ":" + (x + "") + ":" + (MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this._members[x]).length + "");
						errorMsg += ":" + (y + "") + ":" + (MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this._members[y]).length + "");
					}
				} else {
					errorMsg = "a property with same name already exists (note: only functions may be overloaded)";
				}
				if (errorMsg != null) {
					error = new CompileError((this$1 = this._members[x], this$1._nameToken), errorMsg);
					note$0 = new CompileNote((this$2 = this._members[y], this$2._nameToken), "conflicting definition found here");
					error._notes.push(note$0);
					errors.push(error);
					break;
				}
			}
		}
	}
};


function ClassDefinition$normalizeClassDefs$LClassDefinition$ALCompileError$($this, errors) {
	var x;
	var y;
	var errorMsg;
	var error;
	var this$0;
	var this$1;
	var note$0;
	var this$2;
	var this$3;
	var this$0$0;
	var this$4;
	var this$0$1;
	var this$5;
	var this$6;
	var _members$0;
	for (x = 0; x < $this._members.length; ++x) {
		for (y = 0; y < x; ++y) {
			if ((this$3 = $this._members[x], this$0$0 = this$3._nameToken, this$0$0._value) === (this$4 = $this._members[y], this$0$1 = this$4._nameToken, this$0$1._value) && ((this$5 = $this._members[x], this$5._flags) & 8) === ((this$6 = $this._members[y], this$6._flags) & 8)) {
				errorMsg = null;
				if ((_members$0 = $this._members)[x] instanceof MemberFunctionDefinition && _members$0[y] instanceof MemberFunctionDefinition) {
					if (Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this._members[x]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this._members[y]))) {
						errorMsg = "a " + (((this$0 = $this._members[x], this$0._flags) & 8) !== 0 ? "static" : "member") + " function with same name and arguments is already defined";
						errorMsg += ":" + (x + "") + ":" + (MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this._members[x]).length + "");
						errorMsg += ":" + (y + "") + ":" + (MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this._members[y]).length + "");
					}
				} else {
					errorMsg = "a property with same name already exists (note: only functions may be overloaded)";
				}
				if (errorMsg != null) {
					error = new CompileError((this$1 = $this._members[x], this$1._nameToken), errorMsg);
					note$0 = new CompileNote((this$2 = $this._members[y], this$2._nameToken), "conflicting definition found here");
					error._notes.push(note$0);
					errors.push(error);
					break;
				}
			}
		}
	}
};

ClassDefinition.normalizeClassDefs$LClassDefinition$ALCompileError$ = ClassDefinition$normalizeClassDefs$LClassDefinition$ALCompileError$;

ClassDefinition.prototype.resolveTypes$LAnalysisContext$ = function (context) {
	var $this = this;
	var i;
	var baseClass;
	var j;
	var isNative;
	var func;
	var this$0;
	var this$1;
	var this$2;
	var this$0$0;
	var this$3;
	var this$0$1;
	var this$4;
	var this$0$2;
	var this$5;
	var this$6;
	var this$0$3;
	var this$7;
	var this$0$4;
	var this$8;
	var this$0$5;
	var this$9;
	var this$10;
	for (i = 0; i < this._objectTypesUsed.length; ++i) {
		this$0 = this._objectTypesUsed[i];
		if (this$0._classDef == null) {
			this$0._classDef = QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$(this$0._qualifiedName, context, this$0._typeArguments);
		}
	}
	for (i = 0; i < this._inners.length; ++i) {
		ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(this._inners[i], context);
	}
	if (this._extendType != null) {
		this$1 = this._extendType;
		baseClass = this$1._classDef;
		if (baseClass != null) {
			if ((baseClass.flags$() & 4) !== 0) {
				context.errors.push(new CompileError((this$2 = this._extendType, this$0$0 = this$2._qualifiedName, this$0$0._token), "cannot extend a final class"));
			} else if ((baseClass.flags$() & 64) !== 0) {
				context.errors.push(new CompileError((this$3 = this._extendType, this$0$1 = this$3._qualifiedName, this$0$1._token), "cannot extend an interface, use the 'implements' keyword"));
			} else if ((baseClass.flags$() & 128) !== 0) {
				context.errors.push(new CompileError((this$4 = this._extendType, this$0$2 = this$4._qualifiedName, this$0$2._token), "cannot extend an mixin, use the 'implements' keyword"));
			}
		}
	}
	for (i = 0; i < this._implementTypes.length; ++i) {
		this$5 = this._implementTypes[i];
		baseClass = this$5._classDef;
		if (baseClass != null) {
			if ((baseClass.flags$() & 192) === 0) {
				context.errors.push(new CompileError((this$6 = this._implementTypes[i], this$0$3 = this$6._qualifiedName, this$0$3._token), "cannot implement a class (only interfaces can be implemented)"));
			} else {
				for (j = i + 1; j < this._implementTypes.length; ++j) {
					if ((this$10 = this._implementTypes[j], this$10._classDef) == baseClass) {
						context.errors.push(new CompileError((this$7 = this._implementTypes[i], this$0$4 = this$7._qualifiedName, this$0$4._token), "cannot implement the same interface more than once"));
						break;
					}
				}
			}
		}
	}
	if (ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(this, (function (funcDef) {
		var this$0$0;
		return (this$0$0 = funcDef._nameToken, this$0$0._value) !== "constructor";
	}))) {
		isNative = (this.flags$() & 16) !== 0;
		func = new MemberFunctionDefinition(this._token, new Token$2("constructor", true), 4 | this.flags$() & 16400, Type.voidType, [], isNative ? null : [], isNative ? null : [], [], this._token, null);
		func._classDef = this;
		this._members.push(func);
	}
	for (i = 0; i !== this._members.length; ++i) {
		if (this._members[i] instanceof MemberFunctionDefinition && (this$8 = this._members[i], this$0$5 = this$8._nameToken, this$0$5._value) === "constructor" && ((this$9 = this._members[i], this$9._flags) & 4104) === 4096) {
			this._members.splice(i, 1);
			break;
		}
	}
};


function ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$($this, context) {
	var i;
	var baseClass;
	var j;
	var isNative;
	var func;
	var this$0;
	var this$1;
	var this$2;
	var this$0$0;
	var this$3;
	var this$0$1;
	var this$4;
	var this$0$2;
	var this$5;
	var this$6;
	var this$0$3;
	var this$7;
	var this$0$4;
	var this$8;
	var this$0$5;
	var this$9;
	var this$10;
	for (i = 0; i < $this._objectTypesUsed.length; ++i) {
		this$0 = $this._objectTypesUsed[i];
		if (this$0._classDef == null) {
			this$0._classDef = QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$(this$0._qualifiedName, context, this$0._typeArguments);
		}
	}
	for (i = 0; i < $this._inners.length; ++i) {
		ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$($this._inners[i], context);
	}
	if ($this._extendType != null) {
		this$1 = $this._extendType;
		baseClass = this$1._classDef;
		if (baseClass != null) {
			if ((baseClass.flags$() & 4) !== 0) {
				context.errors.push(new CompileError((this$2 = $this._extendType, this$0$0 = this$2._qualifiedName, this$0$0._token), "cannot extend a final class"));
			} else if ((baseClass.flags$() & 64) !== 0) {
				context.errors.push(new CompileError((this$3 = $this._extendType, this$0$1 = this$3._qualifiedName, this$0$1._token), "cannot extend an interface, use the 'implements' keyword"));
			} else if ((baseClass.flags$() & 128) !== 0) {
				context.errors.push(new CompileError((this$4 = $this._extendType, this$0$2 = this$4._qualifiedName, this$0$2._token), "cannot extend an mixin, use the 'implements' keyword"));
			}
		}
	}
	for (i = 0; i < $this._implementTypes.length; ++i) {
		this$5 = $this._implementTypes[i];
		baseClass = this$5._classDef;
		if (baseClass != null) {
			if ((baseClass.flags$() & 192) === 0) {
				context.errors.push(new CompileError((this$6 = $this._implementTypes[i], this$0$3 = this$6._qualifiedName, this$0$3._token), "cannot implement a class (only interfaces can be implemented)"));
			} else {
				for (j = i + 1; j < $this._implementTypes.length; ++j) {
					if ((this$10 = $this._implementTypes[j], this$10._classDef) == baseClass) {
						context.errors.push(new CompileError((this$7 = $this._implementTypes[i], this$0$4 = this$7._qualifiedName, this$0$4._token), "cannot implement the same interface more than once"));
						break;
					}
				}
			}
		}
	}
	if (ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$($this, (function (funcDef) {
		var this$0$0;
		return (this$0$0 = funcDef._nameToken, this$0$0._value) !== "constructor";
	}))) {
		isNative = ($this.flags$() & 16) !== 0;
		func = new MemberFunctionDefinition($this._token, new Token$2("constructor", true), 4 | $this.flags$() & 16400, Type.voidType, [], isNative ? null : [], isNative ? null : [], [], $this._token, null);
		func._classDef = $this;
		$this._members.push(func);
	}
	for (i = 0; i !== $this._members.length; ++i) {
		if ($this._members[i] instanceof MemberFunctionDefinition && (this$8 = $this._members[i], this$0$5 = this$8._nameToken, this$0$5._value) === "constructor" && ((this$9 = $this._members[i], this$9._flags) & 4104) === 4096) {
			$this._members.splice(i, 1);
			break;
		}
	}
};

ClassDefinition.resolveTypes$LClassDefinition$LAnalysisContext$ = ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$;

ClassDefinition.prototype.setAnalysisContextOfVariables$LAnalysisContext$ = function (context) {
	var $this = this;
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(this, (function (member) {
		var this$0$0$0;
		var funcDef$0$0$0;
		this$0$0$0 = ({errors: context.errors, parser: context.parser, postInstantiationCallback: context.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
		funcDef$0$0$0 = context.funcDef;
		this$0$0$0.funcDef = funcDef$0$0$0;
		member._analysisContext = this$0$0$0;
		return true;
	}));
};


function ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$($this, context) {
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$($this, (function (member) {
		var this$0$0$0;
		var funcDef$0$0$0;
		this$0$0$0 = ({errors: context.errors, parser: context.parser, postInstantiationCallback: context.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
		funcDef$0$0$0 = context.funcDef;
		this$0$0$0.funcDef = funcDef$0$0$0;
		member._analysisContext = this$0$0$0;
		return true;
	}));
};

ClassDefinition.setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$ = ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$;

ClassDefinition.prototype.analyze$LAnalysisContext$ = function (context) {
	var token;
	var srcPos;
	if (this._analized) {
		return;
	}
	this._analized = true;
	try {
		ClassDefinition$_analyzeClassDef$LClassDefinition$LAnalysisContext$(this, context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			token = this.getToken$();
			srcPos = (token != null ? Util$format$SAS(" at file %1, line %2", [ token._filename, token._lineNumber + "" ]) : "");
			$__jsx_catch_0.message = Util$format$SAS("fatal error while analyzing class %1%2\n%3", [ ClassDefinition$classFullName$LClassDefinition$(this), srcPos, $__jsx_catch_0.message ]);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	ClassDefinition$_analyzeMembers$LClassDefinition$LAnalysisContext$(this, context);
};


function ClassDefinition$analyze$LClassDefinition$LAnalysisContext$($this, context) {
	var token;
	var srcPos;
	if ($this._analized) {
		return;
	}
	$this._analized = true;
	try {
		ClassDefinition$_analyzeClassDef$LClassDefinition$LAnalysisContext$($this, context);
	} catch ($__jsx_catch_0) {
		if ($__jsx_catch_0 instanceof Error) {
			token = $this.getToken$();
			srcPos = (token != null ? Util$format$SAS(" at file %1, line %2", [ token._filename, token._lineNumber + "" ]) : "");
			$__jsx_catch_0.message = Util$format$SAS("fatal error while analyzing class %1%2\n%3", [ ClassDefinition$classFullName$LClassDefinition$($this), srcPos, $__jsx_catch_0.message ]);
			throw $__jsx_catch_0;
		} else {
			throw $__jsx_catch_0;
		}
	}
	ClassDefinition$_analyzeMembers$LClassDefinition$LAnalysisContext$($this, context);
};

ClassDefinition.analyze$LClassDefinition$LAnalysisContext$ = ClassDefinition$analyze$LClassDefinition$LAnalysisContext$;

ClassDefinition.prototype._analyzeClassDef$LAnalysisContext$ = function (context) {
	var $this = this;
	var implementClassDefs;
	var i;
	var allMixins;
	var interfaceDef;
	var j;
	var theMixin;
	var overrideFunctions;
	var done;
	var k;
	var abstractMembers;
	var msg;
	var usedNames;
	var existingExportedCtor;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$0$0;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	var this$9;
	var _members$0;
	var abstractMembers$len$0;
	this._baseClassDef = (this._extendType != null ? (this$0 = this._extendType, this$0._classDef) : null);
	implementClassDefs = this._implementTypes.map((function (type) {
		return type._classDef;
	}));
	if ((this.flags$() & 192) === 0) {
		if (this._baseClassDef != null) {
			if ((this._baseClassDef.flags$() & 4) !== 0) {
				context.errors.push(new CompileError(this.getToken$(), "cannot extend final class '" + ClassDefinition$classFullName$LClassDefinition$(this._baseClassDef) + "'"));
				return;
			}
			if ((this._baseClassDef.flags$() & 192) !== 0) {
				context.errors.push(new CompileError(this.getToken$(), "interfaces (or mixins) should be implemented, not extended"));
				return;
			}
			if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(this._baseClassDef, (function (classDef) {
				if ($this == classDef) {
					context.errors.push(new CompileError($this.getToken$(), "class inheritance is in loop"));
					return false;
				}
				return true;
			}))) {
				return;
			}
		}
	} else {
		for (i = 0; i < implementClassDefs.length; ++i) {
			if ((implementClassDefs[i].flags$() & 192) === 0) {
				context.errors.push(new CompileError(this.getToken$(), "class '" + ClassDefinition$classFullName$LClassDefinition$(implementClassDefs[i]) + "' can only be extended, not implemented"));
				return;
			}
			if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(implementClassDefs[i], (function (classDef) {
				if ($this == classDef) {
					context.errors.push(new CompileError($this.getToken$(), "class inheritance is in loop"));
					return false;
				}
				return true;
			}))) {
				return;
			}
		}
	}
	allMixins = [];
	if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(this, (function (classDef) {
		if ((classDef.flags$() & 128) !== 0) {
			if (allMixins.indexOf(classDef) !== -1) {
				context.errors.push(new CompileError($this.getToken$(), "mixin '" + ClassDefinition$classFullName$LClassDefinition$(classDef) + "' is implemented twice"));
				return false;
			}
			allMixins.push(classDef);
		}
		return true;
	}))) {
		return;
	}
	for (i = 0; i < this._members.length; ++i) {
		ClassDefinition$_assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$(this, context, (_members$0 = this._members)[i], this, (this$1 = _members$0[i], this$1._token));
	}
	for (i = 0; i < this._implementTypes.length; ++i) {
		this$2 = this._implementTypes[i];
		interfaceDef = this$2._classDef;
		for (j = 0; j < interfaceDef._members.length; ++j) {
			ClassDefinition$_assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$(this, context, interfaceDef._members[j], interfaceDef, (this$3 = this._implementTypes[i], this$0$0 = this$3._qualifiedName, this$0$0._token));
		}
	}
	if ((this._flags & 192) === 0) {
		for (i = 0; i < this._members.length; ++i) {
			if (this._members[i] instanceof MemberFunctionDefinition && ((this$9 = this._members[i], this$9._flags) & 32) !== 0) {
				if (ClassDefinition$_assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$(this, context, this._members[i]) == null) {
					context.errors.push(new CompileError((this$4 = this._members[i], this$4._nameToken), "could not find function definition in base classes / mixins to be overridden"));
				}
			}
		}
		for (i = 0; i < this._implementTypes.length; ++i) {
			if (((this$5 = this._implementTypes[i], this$5._classDef).flags$() & 128) === 0) {
				continue;
			}
			this$6 = this._implementTypes[i];
			theMixin = this$6._classDef;
			overrideFunctions = [];
			ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$BNN(theMixin, overrideFunctions, true, 32, 32);
			for (j = 0; j < overrideFunctions.length; ++j) {
				done = false;
				if (this._baseClassDef != null) {
					if (ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$(this._baseClassDef, context, overrideFunctions[j]) != null) {
						done = true;
					}
				}
				for (k = 0; k < i; ++k) {
					if (ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$((this$7 = this._implementTypes[k], this$7._classDef), context, overrideFunctions[j]) != null) {
						done = true;
						break;
					}
				}
				for (k = 0; k < theMixin._implementTypes.length; ++k) {
					if (ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$((this$8 = theMixin._implementTypes[k], this$8._classDef), context, overrideFunctions[j]) != null) {
						done = true;
						break;
					}
				}
				if (! done) {
					context.errors.push(new CompileError(this.getToken$(), "could not find function definition to be overridden by '" + overrideFunctions[j].getNotation$() + "'"));
				}
			}
		}
	}
	if ((this._flags & 194) === 0) {
		abstractMembers = [];
		ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(this, (function (classDef) {
			return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
				var i;
				if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_ABSTRACT) !== 0) {
					for (i = 0; i < abstractMembers.length; ++i) {
						if (ClassDefinition$membersAreEqual$LMemberDefinition$LMemberDefinition$(abstractMembers[i], member)) {
							break;
						}
					}
					if (i === abstractMembers.length) {
						abstractMembers[i] = member;
					}
				}
				return true;
			}));
		}));
		ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(this, (function (classDef) {
			return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
				var i;
				if (abstractMembers.length === 0) {
					return false;
				}
				if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_ABSTRACT) === 0) {
					for (i = 0; i < abstractMembers.length; ++i) {
						if (ClassDefinition$membersAreEqual$LMemberDefinition$LMemberDefinition$(abstractMembers[i], member)) {
							abstractMembers.splice(i, 1);
							break;
						}
					}
				}
				return true;
			}));
		}));
		if (abstractMembers.length !== 0) {
			msg = "class should be declared as 'abstract' since the following members do not have concrete definition: ";
			for ((i = 0, abstractMembers$len$0 = abstractMembers.length); i < abstractMembers$len$0; ++i) {
				if (i !== 0) {
					msg += ", ";
				}
				msg += abstractMembers[i].getNotation$();
			}
			context.errors.push(new CompileError(this.getToken$(), msg));
		}
	}
	usedNames = {};
	ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$(this, [  ], (function (member) {
		var existingDef;
		var this$0$0;
		var this$0$1;
		var this$0$2;
		var this$0$3;
		var this$0;
		var this$1;
		var note$0;
		var this$0$4;
		if (! (member instanceof MemberFunctionDefinition)) {
			return false;
		}
		if ((member._flags & 16392) !== 16384 || (this$0$0 = member._nameToken, this$0$0._value) === "constructor") {
			return false;
		}
		if (! $__jsx_ObjectHasOwnProperty.call(usedNames, (this$0$4 = member._nameToken, this$0$4._value))) {
			usedNames[(this$0$1 = member._nameToken, this$0$1._value)] = member;
			return false;
		}
		existingDef = usedNames[(this$0$2 = member._nameToken, this$0$2._value)];
		if (existingDef.getType$().equals$LType$(member.getType$())) {
			return false;
		}
		context.errors.push((this$1 = new CompileError(member._token, "methods with __export__ attribute cannot be overloaded"), note$0 = new CompileNote((this$0 = usedNames[(this$0$3 = member._nameToken, this$0$3._value)], this$0._token), "previously defined here"), this$1._notes.push(note$0), this$1));
		return false;
	}));
	existingExportedCtor = null;
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(this, (function (funcDef) {
		var this$0;
		var note$0;
		var this$0$0;
		if ((funcDef._flags & 16392) === 16384 && (this$0$0 = funcDef._nameToken, this$0$0._value) === "constructor") {
			if (existingExportedCtor != null) {
				context.errors.push((this$0 = new CompileError(funcDef._token, "only one constructor is exportable per class (or interface or mixin), pleaose mark others using the __noexport__ attribute"), note$0 = new CompileNote(existingExportedCtor._token, "previously defined here"), this$0._notes.push(note$0), this$0));
			} else {
				existingExportedCtor = funcDef;
			}
		}
		return true;
	}));
};


function ClassDefinition$_analyzeClassDef$LClassDefinition$LAnalysisContext$($this, context) {
	var implementClassDefs;
	var i;
	var allMixins;
	var interfaceDef;
	var j;
	var theMixin;
	var overrideFunctions;
	var done;
	var k;
	var abstractMembers;
	var msg;
	var usedNames;
	var existingExportedCtor;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$0$0;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	var this$9;
	var _members$0;
	var abstractMembers$len$0;
	$this._baseClassDef = ($this._extendType != null ? (this$0 = $this._extendType, this$0._classDef) : null);
	implementClassDefs = $this._implementTypes.map((function (type) {
		return type._classDef;
	}));
	if (($this.flags$() & 192) === 0) {
		if ($this._baseClassDef != null) {
			if (($this._baseClassDef.flags$() & 4) !== 0) {
				context.errors.push(new CompileError($this.getToken$(), "cannot extend final class '" + ClassDefinition$classFullName$LClassDefinition$($this._baseClassDef) + "'"));
				return;
			}
			if (($this._baseClassDef.flags$() & 192) !== 0) {
				context.errors.push(new CompileError($this.getToken$(), "interfaces (or mixins) should be implemented, not extended"));
				return;
			}
			if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$($this._baseClassDef, (function (classDef) {
				if ($this == classDef) {
					context.errors.push(new CompileError($this.getToken$(), "class inheritance is in loop"));
					return false;
				}
				return true;
			}))) {
				return;
			}
		}
	} else {
		for (i = 0; i < implementClassDefs.length; ++i) {
			if ((implementClassDefs[i].flags$() & 192) === 0) {
				context.errors.push(new CompileError($this.getToken$(), "class '" + ClassDefinition$classFullName$LClassDefinition$(implementClassDefs[i]) + "' can only be extended, not implemented"));
				return;
			}
			if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(implementClassDefs[i], (function (classDef) {
				if ($this == classDef) {
					context.errors.push(new CompileError($this.getToken$(), "class inheritance is in loop"));
					return false;
				}
				return true;
			}))) {
				return;
			}
		}
	}
	allMixins = [];
	if (! ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$($this, (function (classDef) {
		if ((classDef.flags$() & 128) !== 0) {
			if (allMixins.indexOf(classDef) !== -1) {
				context.errors.push(new CompileError($this.getToken$(), "mixin '" + ClassDefinition$classFullName$LClassDefinition$(classDef) + "' is implemented twice"));
				return false;
			}
			allMixins.push(classDef);
		}
		return true;
	}))) {
		return;
	}
	for (i = 0; i < $this._members.length; ++i) {
		ClassDefinition$_assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$($this, context, (_members$0 = $this._members)[i], $this, (this$1 = _members$0[i], this$1._token));
	}
	for (i = 0; i < $this._implementTypes.length; ++i) {
		this$2 = $this._implementTypes[i];
		interfaceDef = this$2._classDef;
		for (j = 0; j < interfaceDef._members.length; ++j) {
			ClassDefinition$_assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$($this, context, interfaceDef._members[j], interfaceDef, (this$3 = $this._implementTypes[i], this$0$0 = this$3._qualifiedName, this$0$0._token));
		}
	}
	if (($this._flags & 192) === 0) {
		for (i = 0; i < $this._members.length; ++i) {
			if ($this._members[i] instanceof MemberFunctionDefinition && ((this$9 = $this._members[i], this$9._flags) & 32) !== 0) {
				if (ClassDefinition$_assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$($this, context, $this._members[i]) == null) {
					context.errors.push(new CompileError((this$4 = $this._members[i], this$4._nameToken), "could not find function definition in base classes / mixins to be overridden"));
				}
			}
		}
		for (i = 0; i < $this._implementTypes.length; ++i) {
			if (((this$5 = $this._implementTypes[i], this$5._classDef).flags$() & 128) === 0) {
				continue;
			}
			this$6 = $this._implementTypes[i];
			theMixin = this$6._classDef;
			overrideFunctions = [];
			ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$BNN(theMixin, overrideFunctions, true, 32, 32);
			for (j = 0; j < overrideFunctions.length; ++j) {
				done = false;
				if ($this._baseClassDef != null) {
					if (ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$($this._baseClassDef, context, overrideFunctions[j]) != null) {
						done = true;
					}
				}
				for (k = 0; k < i; ++k) {
					if (ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$((this$7 = $this._implementTypes[k], this$7._classDef), context, overrideFunctions[j]) != null) {
						done = true;
						break;
					}
				}
				for (k = 0; k < theMixin._implementTypes.length; ++k) {
					if (ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$((this$8 = theMixin._implementTypes[k], this$8._classDef), context, overrideFunctions[j]) != null) {
						done = true;
						break;
					}
				}
				if (! done) {
					context.errors.push(new CompileError($this.getToken$(), "could not find function definition to be overridden by '" + overrideFunctions[j].getNotation$() + "'"));
				}
			}
		}
	}
	if (($this._flags & 194) === 0) {
		abstractMembers = [];
		ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$($this, (function (classDef) {
			return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
				var i;
				if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_ABSTRACT) !== 0) {
					for (i = 0; i < abstractMembers.length; ++i) {
						if (ClassDefinition$membersAreEqual$LMemberDefinition$LMemberDefinition$(abstractMembers[i], member)) {
							break;
						}
					}
					if (i === abstractMembers.length) {
						abstractMembers[i] = member;
					}
				}
				return true;
			}));
		}));
		ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$($this, (function (classDef) {
			return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
				var i;
				if (abstractMembers.length === 0) {
					return false;
				}
				if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_ABSTRACT) === 0) {
					for (i = 0; i < abstractMembers.length; ++i) {
						if (ClassDefinition$membersAreEqual$LMemberDefinition$LMemberDefinition$(abstractMembers[i], member)) {
							abstractMembers.splice(i, 1);
							break;
						}
					}
				}
				return true;
			}));
		}));
		if (abstractMembers.length !== 0) {
			msg = "class should be declared as 'abstract' since the following members do not have concrete definition: ";
			for ((i = 0, abstractMembers$len$0 = abstractMembers.length); i < abstractMembers$len$0; ++i) {
				if (i !== 0) {
					msg += ", ";
				}
				msg += abstractMembers[i].getNotation$();
			}
			context.errors.push(new CompileError($this.getToken$(), msg));
		}
	}
	usedNames = {};
	ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$($this, [  ], (function (member) {
		var existingDef;
		var this$0$0;
		var this$0$1;
		var this$0$2;
		var this$0$3;
		var this$0;
		var this$1;
		var note$0;
		var this$0$4;
		if (! (member instanceof MemberFunctionDefinition)) {
			return false;
		}
		if ((member._flags & 16392) !== 16384 || (this$0$0 = member._nameToken, this$0$0._value) === "constructor") {
			return false;
		}
		if (! $__jsx_ObjectHasOwnProperty.call(usedNames, (this$0$4 = member._nameToken, this$0$4._value))) {
			usedNames[(this$0$1 = member._nameToken, this$0$1._value)] = member;
			return false;
		}
		existingDef = usedNames[(this$0$2 = member._nameToken, this$0$2._value)];
		if (existingDef.getType$().equals$LType$(member.getType$())) {
			return false;
		}
		context.errors.push((this$1 = new CompileError(member._token, "methods with __export__ attribute cannot be overloaded"), note$0 = new CompileNote((this$0 = usedNames[(this$0$3 = member._nameToken, this$0$3._value)], this$0._token), "previously defined here"), this$1._notes.push(note$0), this$1));
		return false;
	}));
	existingExportedCtor = null;
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$($this, (function (funcDef) {
		var this$0;
		var note$0;
		var this$0$0;
		if ((funcDef._flags & 16392) === 16384 && (this$0$0 = funcDef._nameToken, this$0$0._value) === "constructor") {
			if (existingExportedCtor != null) {
				context.errors.push((this$0 = new CompileError(funcDef._token, "only one constructor is exportable per class (or interface or mixin), pleaose mark others using the __noexport__ attribute"), note$0 = new CompileNote(existingExportedCtor._token, "previously defined here"), this$0._notes.push(note$0), this$0));
			} else {
				existingExportedCtor = funcDef;
			}
		}
		return true;
	}));
};

ClassDefinition._analyzeClassDef$LClassDefinition$LAnalysisContext$ = ClassDefinition$_analyzeClassDef$LClassDefinition$LAnalysisContext$;

ClassDefinition.prototype._analyzeMembers$LAnalysisContext$ = function (context) {
	var i;
	var member;
	for (i = 0; i < this._members.length; ++i) {
		member = this._members[i];
		if (member instanceof MemberFunctionDefinition) {
			if (! (member instanceof TemplateFunctionDefinition)) {
				MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$(member, context);
			}
		} else {
			MemberVariableDefinition$analyze$LMemberVariableDefinition$LAnalysisContext$(member, context);
		}
	}
};


function ClassDefinition$_analyzeMembers$LClassDefinition$LAnalysisContext$($this, context) {
	var i;
	var member;
	for (i = 0; i < $this._members.length; ++i) {
		member = $this._members[i];
		if (member instanceof MemberFunctionDefinition) {
			if (! (member instanceof TemplateFunctionDefinition)) {
				MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$(member, context);
			}
		} else {
			MemberVariableDefinition$analyze$LMemberVariableDefinition$LAnalysisContext$(member, context);
		}
	}
};

ClassDefinition._analyzeMembers$LClassDefinition$LAnalysisContext$ = ClassDefinition$_analyzeMembers$LClassDefinition$LAnalysisContext$;

ClassDefinition.prototype.analyzeUnusedVariables$ = function () {
	var $this = this;
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(this, (function (member) {
		var _nameToken$0;
		switch (member._analyzeState) {
		case 0:
			MemberVariableDefinition$_lazyAnalyze$LMemberVariableDefinition$(member);
			break;
		case 1:
			member._analysisContext.errors.push(new CompileError(_nameToken$0 = member._nameToken, "please declare type of variable '" + (_nameToken$0, _nameToken$0._value) + "' (detected recursion while trying to reduce type)"));
			break;
		default:
			break;
		}
		return true;
	}));
};


function ClassDefinition$analyzeUnusedVariables$LClassDefinition$($this) {
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$($this, (function (member) {
		var _nameToken$0;
		switch (member._analyzeState) {
		case 0:
			MemberVariableDefinition$_lazyAnalyze$LMemberVariableDefinition$(member);
			break;
		case 1:
			member._analysisContext.errors.push(new CompileError(_nameToken$0 = member._nameToken, "please declare type of variable '" + (_nameToken$0, _nameToken$0._value) + "' (detected recursion while trying to reduce type)"));
			break;
		default:
			break;
		}
		return true;
	}));
};

ClassDefinition.analyzeUnusedVariables$LClassDefinition$ = ClassDefinition$analyzeUnusedVariables$LClassDefinition$;

ClassDefinition.prototype.isConvertibleTo$LClassDefinition$ = function (classDef) {
	var i;
	var this$0;
	var this$1;
	if (this == classDef) {
		return true;
	}
	if (classDef.className$() === "Object") {
		return true;
	}
	if (this._extendType != null && ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$((this$0 = this._extendType, this$0._classDef), classDef)) {
		return true;
	}
	for (i = 0; i < this._implementTypes.length; ++i) {
		if (ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$((this$1 = this._implementTypes[i], this$1._classDef), classDef)) {
			return true;
		}
	}
	return false;
};


function ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$($this, classDef) {
	var i;
	var this$0;
	var this$1;
	if ($this == classDef) {
		return true;
	}
	if (classDef.className$() === "Object") {
		return true;
	}
	if ($this._extendType != null && ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$((this$0 = $this._extendType, this$0._classDef), classDef)) {
		return true;
	}
	for (i = 0; i < $this._implementTypes.length; ++i) {
		if (ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$((this$1 = $this._implementTypes[i], this$1._classDef), classDef)) {
			return true;
		}
	}
	return false;
};

ClassDefinition.isConvertibleTo$LClassDefinition$LClassDefinition$ = ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$;

ClassDefinition.prototype._assertMemberIsDefinable$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$ = function (context, member, memberClassDef, token) {
	var numImplementsToCheck;
	var isCheckingSibling;
	var i;
	var isCheckingInterface;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	if ((member._flags & 8) !== 0) {
		return true;
	}
	for (numImplementsToCheck = 0; numImplementsToCheck < this._implementTypes.length; ++numImplementsToCheck) {
		if (memberClassDef == (this$0 = this._implementTypes[numImplementsToCheck], this$0._classDef)) {
			break;
		}
	}
	isCheckingSibling = numImplementsToCheck !== this._implementTypes.length;
	if (member instanceof MemberVariableDefinition) {
		if (this._extendType != null && ! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$((this$1 = this._extendType, this$1._classDef), context, member, memberClassDef, token)) {
			return false;
		}
		for (i = 0; i < numImplementsToCheck; ++i) {
			if (! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$((this$2 = this._implementTypes[i], this$2._classDef), context, member, memberClassDef, token)) {
				return false;
			}
		}
	} else {
		isCheckingInterface = (memberClassDef.flags$() & 64) !== 0;
		if (this._extendType != null && ! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB((this$3 = this._extendType, this$3._classDef), context, member, memberClassDef, token, false, isCheckingInterface)) {
			return false;
		}
		for (i = 0; i < numImplementsToCheck; ++i) {
			if (memberClassDef != (this$4 = this._implementTypes[i], this$4._classDef) && ! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB((this$5 = this._implementTypes[i], this$5._classDef), context, member, memberClassDef, token, isCheckingSibling, isCheckingInterface)) {
				return false;
			}
		}
	}
	return true;
};


function ClassDefinition$_assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$($this, context, member, memberClassDef, token) {
	var numImplementsToCheck;
	var isCheckingSibling;
	var i;
	var isCheckingInterface;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	if ((member._flags & 8) !== 0) {
		return true;
	}
	for (numImplementsToCheck = 0; numImplementsToCheck < $this._implementTypes.length; ++numImplementsToCheck) {
		if (memberClassDef == (this$0 = $this._implementTypes[numImplementsToCheck], this$0._classDef)) {
			break;
		}
	}
	isCheckingSibling = numImplementsToCheck !== $this._implementTypes.length;
	if (member instanceof MemberVariableDefinition) {
		if ($this._extendType != null && ! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$((this$1 = $this._extendType, this$1._classDef), context, member, memberClassDef, token)) {
			return false;
		}
		for (i = 0; i < numImplementsToCheck; ++i) {
			if (! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$((this$2 = $this._implementTypes[i], this$2._classDef), context, member, memberClassDef, token)) {
				return false;
			}
		}
	} else {
		isCheckingInterface = (memberClassDef.flags$() & 64) !== 0;
		if ($this._extendType != null && ! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB((this$3 = $this._extendType, this$3._classDef), context, member, memberClassDef, token, false, isCheckingInterface)) {
			return false;
		}
		for (i = 0; i < numImplementsToCheck; ++i) {
			if (memberClassDef != (this$4 = $this._implementTypes[i], this$4._classDef) && ! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB((this$5 = $this._implementTypes[i], this$5._classDef), context, member, memberClassDef, token, isCheckingSibling, isCheckingInterface)) {
				return false;
			}
		}
	}
	return true;
};

ClassDefinition._assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$ = ClassDefinition$_assertMemberIsDefinable$LClassDefinition$LAnalysisContext$LMemberDefinition$LClassDefinition$LToken$;

ClassDefinition.prototype._assertMemberVariableIsDefinable$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$ = function (context, member, memberClassDef, token) {
	var i;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$0$0;
	var this$0$1;
	for (i = 0; i < this._members.length; ++i) {
		if ((this$3 = this._members[i], this$0$0 = this$3._nameToken, this$0$0._value) === (this$0$1 = member._nameToken, this$0$1._value)) {
			if (((this$2 = this._members[i], this$2._flags) & 2) === 0) {
				context.errors.push(new CompileError(member._nameToken, Util$format$SAS("cannot define property '%1', the name is already used in class '%2'", [ member.getNotation$(), ClassDefinition$classFullName$LClassDefinition$(this) ])));
				return false;
			}
			if (! this._members[i].getType$().equals$LType$(member.getType$())) {
				context.errors.push(new CompileError(member._nameToken, Util$format$SAS("cannot override property '%1' of type '%2' with different type '%3'", [ member.getNotation$(), this._members[i].getType$().toString(), member.getType$().toString() ])));
				return false;
			}
		}
	}
	if (this._extendType != null && ! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$((this$0 = this._extendType, this$0._classDef), context, member, memberClassDef, token)) {
		return false;
	}
	for (i = 0; i < this._implementTypes.length; ++i) {
		if (! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$((this$1 = this._implementTypes[i], this$1._classDef), context, member, memberClassDef, token)) {
			return false;
		}
	}
	return true;
};


function ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$($this, context, member, memberClassDef, token) {
	var i;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$0$0;
	var this$0$1;
	for (i = 0; i < $this._members.length; ++i) {
		if ((this$3 = $this._members[i], this$0$0 = this$3._nameToken, this$0$0._value) === (this$0$1 = member._nameToken, this$0$1._value)) {
			if (((this$2 = $this._members[i], this$2._flags) & 2) === 0) {
				context.errors.push(new CompileError(member._nameToken, Util$format$SAS("cannot define property '%1', the name is already used in class '%2'", [ member.getNotation$(), ClassDefinition$classFullName$LClassDefinition$($this) ])));
				return false;
			}
			if (! $this._members[i].getType$().equals$LType$(member.getType$())) {
				context.errors.push(new CompileError(member._nameToken, Util$format$SAS("cannot override property '%1' of type '%2' with different type '%3'", [ member.getNotation$(), $this._members[i].getType$().toString(), member.getType$().toString() ])));
				return false;
			}
		}
	}
	if ($this._extendType != null && ! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$((this$0 = $this._extendType, this$0._classDef), context, member, memberClassDef, token)) {
		return false;
	}
	for (i = 0; i < $this._implementTypes.length; ++i) {
		if (! ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$((this$1 = $this._implementTypes[i], this$1._classDef), context, member, memberClassDef, token)) {
			return false;
		}
	}
	return true;
};

ClassDefinition._assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$ = ClassDefinition$_assertMemberVariableIsDefinable$LClassDefinition$LAnalysisContext$LMemberVariableDefinition$LClassDefinition$LToken$;

ClassDefinition.prototype._assertMemberFunctionIsDefinable$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB = function (context, member, memberClassDef, token, reportOverridesAsWell, isCheckingInterface) {
	var i;
	var error;
	var this$0$0;
	var this$0;
	var this$0$1;
	var this$0$2;
	var this$1;
	var this$2;
	var note$0;
	var note$1;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	if ((this$0$0 = member._nameToken, this$0$0._value) === "constructor") {
		return true;
	}
	for (i = 0; i < this._members.length; ++i) {
		if ((this$0 = this._members[i], this$0$1 = this$0._nameToken, this$0$1._value) !== (this$0$2 = member._nameToken, this$0$2._value)) {
			continue;
		}
		if (this._members[i] instanceof MemberVariableDefinition) {
			error = new CompileError(member._nameToken, "definition of the function conflicts with property '" + (this$2 = (this$1 = this._members[i], this$1._nameToken), this$2._value) + "'");
			note$0 = new CompileNote((this$5 = this._members[i], this$5._nameToken), "property with the same name has been found here");
			error._notes.push(note$0);
			context.errors.push(error);
			return false;
		}
		if (! Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this._members[i]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member))) {
			continue;
		}
		if (! isCheckingInterface && ((member._flags | (this$8 = this._members[i], this$8._flags)) & 8) === 0 && (member._flags & 32) === 0) {
			error = new CompileError(member._nameToken, "overriding functions must have 'override' attribute set");
			note$1 = new CompileNote((this$6 = this._members[i], this$6._nameToken), Util$format$SAS("defined in base class '%1'", [ ClassDefinition$classFullName$LClassDefinition$(this) ]));
			error._notes.push(note$1);
			context.errors.push(error);
			return false;
		}
		if (reportOverridesAsWell && ((this$7 = this._members[i], this$7._flags) & 32) !== 0) {
			error = new CompileError(member._nameToken, "definition of the function conflicts with sibling mix-in '" + ClassDefinition$classFullName$LClassDefinition$(this) + "'");
			context.errors.push(error);
			return false;
		}
		return true;
	}
	if (this._extendType != null && ! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB((this$3 = this._extendType, this$3._classDef), context, member, memberClassDef, token, false, isCheckingInterface)) {
		return false;
	}
	for (i = 0; i < this._implementTypes.length; ++i) {
		if (! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB((this$4 = this._implementTypes[i], this$4._classDef), context, member, memberClassDef, token, false, isCheckingInterface)) {
			return false;
		}
	}
	return true;
};


function ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB($this, context, member, memberClassDef, token, reportOverridesAsWell, isCheckingInterface) {
	var i;
	var error;
	var this$0$0;
	var this$0;
	var this$0$1;
	var this$0$2;
	var this$1;
	var this$2;
	var note$0;
	var note$1;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	if ((this$0$0 = member._nameToken, this$0$0._value) === "constructor") {
		return true;
	}
	for (i = 0; i < $this._members.length; ++i) {
		if ((this$0 = $this._members[i], this$0$1 = this$0._nameToken, this$0$1._value) !== (this$0$2 = member._nameToken, this$0$2._value)) {
			continue;
		}
		if ($this._members[i] instanceof MemberVariableDefinition) {
			error = new CompileError(member._nameToken, "definition of the function conflicts with property '" + (this$2 = (this$1 = $this._members[i], this$1._nameToken), this$2._value) + "'");
			note$0 = new CompileNote((this$5 = $this._members[i], this$5._nameToken), "property with the same name has been found here");
			error._notes.push(note$0);
			context.errors.push(error);
			return false;
		}
		if (! Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this._members[i]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member))) {
			continue;
		}
		if (! isCheckingInterface && ((member._flags | (this$8 = $this._members[i], this$8._flags)) & 8) === 0 && (member._flags & 32) === 0) {
			error = new CompileError(member._nameToken, "overriding functions must have 'override' attribute set");
			note$1 = new CompileNote((this$6 = $this._members[i], this$6._nameToken), Util$format$SAS("defined in base class '%1'", [ ClassDefinition$classFullName$LClassDefinition$($this) ]));
			error._notes.push(note$1);
			context.errors.push(error);
			return false;
		}
		if (reportOverridesAsWell && ((this$7 = $this._members[i], this$7._flags) & 32) !== 0) {
			error = new CompileError(member._nameToken, "definition of the function conflicts with sibling mix-in '" + ClassDefinition$classFullName$LClassDefinition$($this) + "'");
			context.errors.push(error);
			return false;
		}
		return true;
	}
	if ($this._extendType != null && ! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB((this$3 = $this._extendType, this$3._classDef), context, member, memberClassDef, token, false, isCheckingInterface)) {
		return false;
	}
	for (i = 0; i < $this._implementTypes.length; ++i) {
		if (! ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB((this$4 = $this._implementTypes[i], this$4._classDef), context, member, memberClassDef, token, false, isCheckingInterface)) {
			return false;
		}
	}
	return true;
};

ClassDefinition._assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB = ClassDefinition$_assertMemberFunctionIsDefinable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$LClassDefinition$LToken$BB;

ClassDefinition.prototype._assertFunctionIsOverridable$LAnalysisContext$LMemberFunctionDefinition$ = function (context, overrideDef) {
	var i;
	var overrideReturnType;
	var memberReturnType;
	var this$0;
	var this$1;
	var this$2;
	var this$0$0;
	var this$0$1;
	var this$3;
	for (i = 0; i < this._members.length; ++i) {
		if ((this$2 = this._members[i], this$0$0 = this$2._nameToken, this$0$0._value) === (this$0$1 = overrideDef._nameToken, this$0$1._value) && this._members[i] instanceof MemberFunctionDefinition && ((this$3 = this._members[i], this$3._flags) & 8) === 0 && Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this._members[i]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(overrideDef))) {
			if (((this$1 = this._members[i], this$1._flags) & 4) !== 0) {
				context.errors.push(new CompileError(overrideDef._token, "cannot override final function defined in class '" + ClassDefinition$classFullName$LClassDefinition$(this) + "'"));
				return false;
			}
			overrideReturnType = overrideDef._returnType;
			this$0 = this._members[i];
			memberReturnType = this$0._returnType;
			if (! (overrideReturnType.equals$LType$(memberReturnType) || overrideReturnType.isConvertibleTo$LType$(memberReturnType)) || memberReturnType instanceof NullableType && ! (overrideReturnType instanceof NullableType)) {
				context.errors.push(new CompileError(overrideDef._token, "return type '" + overrideReturnType.toString() + "' is not convertible to '" + memberReturnType.toString() + "'"));
				return false;
			} else {
				return true;
			}
		}
	}
	return ClassDefinition$_assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$(this, context, overrideDef);
};


function ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$($this, context, overrideDef) {
	var i;
	var overrideReturnType;
	var memberReturnType;
	var this$0;
	var this$1;
	var this$2;
	var this$0$0;
	var this$0$1;
	var this$3;
	for (i = 0; i < $this._members.length; ++i) {
		if ((this$2 = $this._members[i], this$0$0 = this$2._nameToken, this$0$0._value) === (this$0$1 = overrideDef._nameToken, this$0$1._value) && $this._members[i] instanceof MemberFunctionDefinition && ((this$3 = $this._members[i], this$3._flags) & 8) === 0 && Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this._members[i]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(overrideDef))) {
			if (((this$1 = $this._members[i], this$1._flags) & 4) !== 0) {
				context.errors.push(new CompileError(overrideDef._token, "cannot override final function defined in class '" + ClassDefinition$classFullName$LClassDefinition$($this) + "'"));
				return false;
			}
			overrideReturnType = overrideDef._returnType;
			this$0 = $this._members[i];
			memberReturnType = this$0._returnType;
			if (! (overrideReturnType.equals$LType$(memberReturnType) || overrideReturnType.isConvertibleTo$LType$(memberReturnType)) || memberReturnType instanceof NullableType && ! (overrideReturnType instanceof NullableType)) {
				context.errors.push(new CompileError(overrideDef._token, "return type '" + overrideReturnType.toString() + "' is not convertible to '" + memberReturnType.toString() + "'"));
				return false;
			} else {
				return true;
			}
		}
	}
	return ClassDefinition$_assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$($this, context, overrideDef);
};

ClassDefinition._assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$ = ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$;

ClassDefinition.prototype._assertFunctionIsOverridableInBaseClasses$LAnalysisContext$LMemberFunctionDefinition$ = function (context, member) {
	var ret;
	var i;
	var this$0;
	var this$1;
	if (this._extendType != null) {
		ret = ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$((this$0 = this._extendType, this$0._classDef), context, member);
		if (ret != null) {
			return ret;
		}
	}
	for (i = 0; i < this._implementTypes.length; ++i) {
		ret = ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$((this$1 = this._implementTypes[i], this$1._classDef), context, member);
		if (ret != null) {
			return ret;
		}
	}
	return null;
};


function ClassDefinition$_assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$($this, context, member) {
	var ret;
	var i;
	var this$0;
	var this$1;
	if ($this._extendType != null) {
		ret = ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$((this$0 = $this._extendType, this$0._classDef), context, member);
		if (ret != null) {
			return ret;
		}
	}
	for (i = 0; i < $this._implementTypes.length; ++i) {
		ret = ClassDefinition$_assertFunctionIsOverridable$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$((this$1 = $this._implementTypes[i], this$1._classDef), context, member);
		if (ret != null) {
			return ret;
		}
	}
	return null;
};

ClassDefinition._assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$ = ClassDefinition$_assertFunctionIsOverridableInBaseClasses$LClassDefinition$LAnalysisContext$LMemberFunctionDefinition$;

ClassDefinition.prototype._getMembers$ALMemberDefinition$F$LMemberDefinition$B$ = function (list, cb) {
	var i;
	var this$0;
	if (this._baseClassDef != null) {
		ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$(this._baseClassDef, list, cb);
	}
	for (i = 0; i < this._implementTypes.length; ++i) {
		ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$((this$0 = this._implementTypes[i], this$0._classDef), list, cb);
	}
	for (i = 0; i < this._members.length; ++i) {
		if (cb(this._members[i])) {
			list.push(this._members[i]);
		}
	}
};


function ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$($this, list, cb) {
	var i;
	var this$0;
	if ($this._baseClassDef != null) {
		ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$($this._baseClassDef, list, cb);
	}
	for (i = 0; i < $this._implementTypes.length; ++i) {
		ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$((this$0 = $this._implementTypes[i], this$0._classDef), list, cb);
	}
	for (i = 0; i < $this._members.length; ++i) {
		if (cb($this._members[i])) {
			list.push($this._members[i]);
		}
	}
};

ClassDefinition._getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$ = ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$;

ClassDefinition.prototype._getMembers$ALMemberDefinition$BNN = function (list, functionOnly, flagsMask, flagsMaskMatch) {
	var $this = this;
	ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$(this, list, (function (member) {
		var j;
		var this$0;
		var this$0$0;
		var this$0$1;
		var list$len$0;
		if (functionOnly && ! (member instanceof MemberFunctionDefinition)) {
			return false;
		}
		if ((member._flags & flagsMask) !== flagsMaskMatch) {
			return false;
		}
		for ((j = 0, list$len$0 = list.length); j < list$len$0; ++j) {
			if ((this$0 = list[j], this$0$0 = this$0._nameToken, this$0$0._value) === (this$0$1 = member._nameToken, this$0$1._value)) {
				if (list[j] instanceof MemberVariableDefinition || Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(list[j]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member))) {
					return false;
				}
			}
		}
		return true;
	}));
};


function ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$BNN($this, list, functionOnly, flagsMask, flagsMaskMatch) {
	ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$F$LMemberDefinition$B$($this, list, (function (member) {
		var j;
		var this$0;
		var this$0$0;
		var this$0$1;
		var list$len$0;
		if (functionOnly && ! (member instanceof MemberFunctionDefinition)) {
			return false;
		}
		if ((member._flags & flagsMask) !== flagsMaskMatch) {
			return false;
		}
		for ((j = 0, list$len$0 = list.length); j < list$len$0; ++j) {
			if ((this$0 = list[j], this$0$0 = this$0._nameToken, this$0$0._value) === (this$0$1 = member._nameToken, this$0$1._value)) {
				if (list[j] instanceof MemberVariableDefinition || Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(list[j]), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member))) {
					return false;
				}
			}
		}
		return true;
	}));
};

ClassDefinition._getMembers$LClassDefinition$ALMemberDefinition$BNN = ClassDefinition$_getMembers$LClassDefinition$ALMemberDefinition$BNN;

ClassDefinition.prototype.hasDefaultConstructor$ = function () {
	var hasCtorWithArgs;
	var i;
	var member;
	var this$0;
	var this$0$0;
	hasCtorWithArgs = false;
	for (i = 0; i < this._members.length; ++i) {
		member = this._members[i];
		if ((this$0$0 = member._nameToken, this$0$0._value) === "constructor" && (member._flags & 8) === 0 && member instanceof MemberFunctionDefinition) {
			if ((this$0 = member, this$0._args).length === 0) {
				return true;
			}
			hasCtorWithArgs = true;
		}
	}
	return ! hasCtorWithArgs;
};


function ClassDefinition$hasDefaultConstructor$LClassDefinition$($this) {
	var hasCtorWithArgs;
	var i;
	var member;
	var this$0;
	var this$0$0;
	hasCtorWithArgs = false;
	for (i = 0; i < $this._members.length; ++i) {
		member = $this._members[i];
		if ((this$0$0 = member._nameToken, this$0$0._value) === "constructor" && (member._flags & 8) === 0 && member instanceof MemberFunctionDefinition) {
			if ((this$0 = member, this$0._args).length === 0) {
				return true;
			}
			hasCtorWithArgs = true;
		}
	}
	return ! hasCtorWithArgs;
};

ClassDefinition.hasDefaultConstructor$LClassDefinition$ = ClassDefinition$hasDefaultConstructor$LClassDefinition$;

function ClassDefinition$membersAreEqual$LMemberDefinition$LMemberDefinition$(x, y) {
	var this$0$0;
	var this$0$1;
	if ((this$0$0 = x._nameToken, this$0$0._value) !== (this$0$1 = y._nameToken, this$0$1._value)) {
		return false;
	}
	if (x instanceof MemberFunctionDefinition) {
		if (! (y instanceof MemberFunctionDefinition)) {
			return false;
		}
		if (! Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(x), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(y))) {
			return false;
		}
	} else if (! (y instanceof MemberVariableDefinition)) {
		return false;
	}
	return true;
};

ClassDefinition.membersAreEqual$LMemberDefinition$LMemberDefinition$ = ClassDefinition$membersAreEqual$LMemberDefinition$LMemberDefinition$;

function MemberDefinition(token, nameToken, flags, closures, docComment) {
	this._stash = {};
	this._token = token;
	this._nameToken = nameToken;
	this._flags = flags;
	this._closures = closures;
	this._docComment = docComment;
	this._classDef = null;
};

$__jsx_extend([MemberDefinition], Object);
$__jsx_merge_interface(MemberDefinition, Stashable);

MemberDefinition.prototype.getToken$ = function () {
	return this._token;
};


function MemberDefinition$getToken$LMemberDefinition$($this) {
	return $this._token;
};

MemberDefinition.getToken$LMemberDefinition$ = MemberDefinition$getToken$LMemberDefinition$;

MemberDefinition.prototype.getNameToken$ = function () {
	return this._nameToken;
};


function MemberDefinition$getNameToken$LMemberDefinition$($this) {
	return $this._nameToken;
};

MemberDefinition.getNameToken$LMemberDefinition$ = MemberDefinition$getNameToken$LMemberDefinition$;

MemberDefinition.prototype.name$ = function () {
	var this$0;
	this$0 = this._nameToken;
	return this$0._value;
};


function MemberDefinition$name$LMemberDefinition$($this) {
	var this$0;
	this$0 = $this._nameToken;
	return this$0._value;
};

MemberDefinition.name$LMemberDefinition$ = MemberDefinition$name$LMemberDefinition$;

MemberDefinition.prototype.flags$ = function () {
	return this._flags;
};


function MemberDefinition$flags$LMemberDefinition$($this) {
	return $this._flags;
};

MemberDefinition.flags$LMemberDefinition$ = MemberDefinition$flags$LMemberDefinition$;

MemberDefinition.prototype.setFlags$N = function (flags) {
	this._flags = flags;
};


function MemberDefinition$setFlags$LMemberDefinition$N($this, flags) {
	$this._flags = flags;
};

MemberDefinition.setFlags$LMemberDefinition$N = MemberDefinition$setFlags$LMemberDefinition$N;

MemberDefinition.prototype.getClosures$ = function () {
	return this._closures;
};


function MemberDefinition$getClosures$LMemberDefinition$($this) {
	return $this._closures;
};

MemberDefinition.getClosures$LMemberDefinition$ = MemberDefinition$getClosures$LMemberDefinition$;

MemberDefinition.prototype.forEachClosure$F$LMemberFunctionDefinition$B$ = function (cb) {
	var i;
	if (this._closures != null) {
		for (i = 0; i < this._closures.length; ++i) {
			if (! cb(this._closures[i])) {
				return false;
			}
		}
	}
	return true;
};


function MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$($this, cb) {
	var i;
	if ($this._closures != null) {
		for (i = 0; i < $this._closures.length; ++i) {
			if (! cb($this._closures[i])) {
				return false;
			}
		}
	}
	return true;
};

MemberDefinition.forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$ = MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$;

MemberDefinition.prototype.getDocComment$ = function () {
	return this._docComment;
};


function MemberDefinition$getDocComment$LMemberDefinition$($this) {
	return $this._docComment;
};

MemberDefinition.getDocComment$LMemberDefinition$ = MemberDefinition$getDocComment$LMemberDefinition$;

MemberDefinition.prototype.setDocComment$LDocComment$ = function (docComment) {
	this._docComment = docComment;
};


function MemberDefinition$setDocComment$LMemberDefinition$LDocComment$($this, docComment) {
	$this._docComment = docComment;
};

MemberDefinition.setDocComment$LMemberDefinition$LDocComment$ = MemberDefinition$setDocComment$LMemberDefinition$LDocComment$;

MemberDefinition.prototype.getClassDef$ = function () {
	return this._classDef;
};


function MemberDefinition$getClassDef$LMemberDefinition$($this) {
	return $this._classDef;
};

MemberDefinition.getClassDef$LMemberDefinition$ = MemberDefinition$getClassDef$LMemberDefinition$;

MemberDefinition.prototype.setClassDef$LClassDefinition$ = function (classDef) {
	this._classDef = classDef;
};


function MemberDefinition$setClassDef$LMemberDefinition$LClassDefinition$($this, classDef) {
	$this._classDef = classDef;
};

MemberDefinition.setClassDef$LMemberDefinition$LClassDefinition$ = MemberDefinition$setClassDef$LMemberDefinition$LClassDefinition$;

MemberDefinition.prototype._instantiateClosures$LInstantiationContext$ = function (instantiationContext) {
	var closures;
	var i;
	closures = [];
	for (i = 0; i < this._closures.length; ++i) {
		closures[i] = this._closures[i].instantiate$LInstantiationContext$(instantiationContext);
	}
	return closures;
};


function MemberDefinition$_instantiateClosures$LMemberDefinition$LInstantiationContext$($this, instantiationContext) {
	var closures;
	var i;
	closures = [];
	for (i = 0; i < $this._closures.length; ++i) {
		closures[i] = $this._closures[i].instantiate$LInstantiationContext$(instantiationContext);
	}
	return closures;
};

MemberDefinition._instantiateClosures$LMemberDefinition$LInstantiationContext$ = MemberDefinition$_instantiateClosures$LMemberDefinition$LInstantiationContext$;

MemberDefinition.prototype._updateLinkFromExpressionToClosuresUponInstantiation$LExpression$ALMemberFunctionDefinition$ = function (instantiatedExpr, instantiatedClosures) {
	var $this = this;
	(function onExpr(expr) {
		var idx;
		var this$0;
		var this$1;
		var funcDef$0;
		if (expr instanceof FunctionExpression) {
			idx = $this._closures.indexOf((this$0 = expr, this$0._funcDef));
			if (idx === -1) {
				throw new Error("logic flaw, cannot find the closure for " + $this.getNotation$());
			}
			this$1 = expr;
			funcDef$0 = instantiatedClosures[idx];
			this$1._funcDef = funcDef$0;
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	})(instantiatedExpr);
};


function MemberDefinition$_updateLinkFromExpressionToClosuresUponInstantiation$LMemberDefinition$LExpression$ALMemberFunctionDefinition$($this, instantiatedExpr, instantiatedClosures) {
	(function onExpr(expr) {
		var idx;
		var this$0;
		var this$1;
		var funcDef$0;
		if (expr instanceof FunctionExpression) {
			idx = $this._closures.indexOf((this$0 = expr, this$0._funcDef));
			if (idx === -1) {
				throw new Error("logic flaw, cannot find the closure for " + $this.getNotation$());
			}
			this$1 = expr;
			funcDef$0 = instantiatedClosures[idx];
			this$1._funcDef = funcDef$0;
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	})(instantiatedExpr);
};

MemberDefinition._updateLinkFromExpressionToClosuresUponInstantiation$LMemberDefinition$LExpression$ALMemberFunctionDefinition$ = MemberDefinition$_updateLinkFromExpressionToClosuresUponInstantiation$LMemberDefinition$LExpression$ALMemberFunctionDefinition$;

function MemberVariableDefinition(token, name, flags, type, initialValue, closures, docComment) {
	MemberDefinition.call(this, token, name, flags, closures, docComment);
	this._type = type;
	this._initialValue = initialValue;
	this._analyzeState = 0;
	this._analysisContext = null;
};

$__jsx_extend([MemberVariableDefinition], MemberDefinition);
MemberVariableDefinition.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var type;
	var initialValue;
	var closures;
	var closures$0;
	var i$0;
	type = (this._type != null ? this._type.instantiate$LInstantiationContext$B(instantiationContext, false) : null);
	initialValue = null;
	if (this._initialValue != null) {
		initialValue = this._initialValue.clone$();
		Expression$instantiate$LExpression$LInstantiationContext$(initialValue, instantiationContext);
		closures$0 = [];
		for (i$0 = 0; i$0 < this._closures.length; ++i$0) {
			closures$0[i$0] = this._closures[i$0].instantiate$LInstantiationContext$(instantiationContext);
		}
		closures = closures$0;
		MemberDefinition$_updateLinkFromExpressionToClosuresUponInstantiation$LMemberDefinition$LExpression$ALMemberFunctionDefinition$(this, initialValue, closures$0);
	} else {
		closures = [  ];
	}
	return new MemberVariableDefinition(this._token, this._nameToken, this._flags, type, initialValue, closures, null);
};


MemberVariableDefinition.prototype.toString = function () {
	var this$0$0;
	return (this$0$0 = this._nameToken, this$0$0._value) + " : " + this._type.toString();
};


MemberVariableDefinition.prototype.serialize$ = function () {
	var v$0;
	var v$1;
	var v$2;
	var v$3;
	return ({ "token": (v$0 = this._token, v$0 == null ? null : [ v$0._value, v$0._isIdentifier, v$0._filename, v$0._lineNumber, v$0._columnNumber ]), "nameToken": (v$1 = this._nameToken, v$1 == null ? null : [ v$1._value, v$1._isIdentifier, v$1._filename, v$1._lineNumber, v$1._columnNumber ]), "flags": this._flags, "type": (v$2 = this._type, v$2 == null ? null : v$2.toString()), "initialValue": (v$3 = this._initialValue, v$3 == null ? null : v$3.serialize$()) });
};


MemberVariableDefinition.prototype.analyze$LAnalysisContext$ = function (context) {
	var rhs;
	var initialValue$0;
	var this$0;
	var this$1;
	if (this._initialValue == null && (this._classDef.flags$() & 16) !== 16) {
		initialValue$0 = Expression$getDefaultValueExpressionOf$LType$(this.getType$());
		this._initialValue = initialValue$0;
	}
	if (this._initialValue != null) {
		rhs = this._initialValue;
		if ((rhs instanceof ArrayLiteralExpression && (this$0 = rhs, this$0._exprs).length === 0 || rhs instanceof MapLiteralExpression && (this$1 = rhs, this$1._elements).length === 0) && rhs.getType$() == null) {
			if (! AssignmentExpression$analyzeEmptyLiteralAssignment$LAnalysisContext$LToken$LType$LExpression$(context, rhs._token, this._type, rhs)) {
				return;
			}
		}
	}
};


function MemberVariableDefinition$analyze$LMemberVariableDefinition$LAnalysisContext$($this, context) {
	var rhs;
	var initialValue$0;
	var this$0;
	var this$1;
	if ($this._initialValue == null && ($this._classDef.flags$() & 16) !== 16) {
		initialValue$0 = Expression$getDefaultValueExpressionOf$LType$($this.getType$());
		$this._initialValue = initialValue$0;
	}
	if ($this._initialValue != null) {
		rhs = $this._initialValue;
		if ((rhs instanceof ArrayLiteralExpression && (this$0 = rhs, this$0._exprs).length === 0 || rhs instanceof MapLiteralExpression && (this$1 = rhs, this$1._elements).length === 0) && rhs.getType$() == null) {
			if (! AssignmentExpression$analyzeEmptyLiteralAssignment$LAnalysisContext$LToken$LType$LExpression$(context, rhs._token, $this._type, rhs)) {
				return;
			}
		}
	}
};

MemberVariableDefinition.analyze$LMemberVariableDefinition$LAnalysisContext$ = MemberVariableDefinition$analyze$LMemberVariableDefinition$LAnalysisContext$;

MemberVariableDefinition.prototype.setAnalysisContext$LAnalysisContext$ = function (context) {
	var this$0$0;
	var funcDef$0$0;
	this$0$0 = ({errors: context.errors, parser: context.parser, postInstantiationCallback: context.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
	funcDef$0$0 = context.funcDef;
	this$0$0.funcDef = funcDef$0$0;
	this._analysisContext = this$0$0;
};


function MemberVariableDefinition$setAnalysisContext$LMemberVariableDefinition$LAnalysisContext$($this, context) {
	var this$0$0;
	var funcDef$0$0;
	this$0$0 = ({errors: context.errors, parser: context.parser, postInstantiationCallback: context.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
	funcDef$0$0 = context.funcDef;
	this$0$0.funcDef = funcDef$0$0;
	$this._analysisContext = this$0$0;
};

MemberVariableDefinition.setAnalysisContext$LMemberVariableDefinition$LAnalysisContext$ = MemberVariableDefinition$setAnalysisContext$LMemberVariableDefinition$LAnalysisContext$;

MemberVariableDefinition.prototype.getType$ = function () {
	var _nameToken$0;
	switch (this._analyzeState) {
	case 0:
		MemberVariableDefinition$_lazyAnalyze$LMemberVariableDefinition$(this);
		break;
	case 1:
		this._analysisContext.errors.push(new CompileError(_nameToken$0 = this._nameToken, "please declare type of variable '" + (_nameToken$0, _nameToken$0._value) + "' (detected recursion while trying to reduce type)"));
		break;
	default:
		break;
	}
	return this._type;
};


MemberVariableDefinition.prototype._lazyAnalyze$ = function () {
	var rhs;
	var ivType;
	try {
		this._analyzeState = 1;
		rhs = this._initialValue;
		if (rhs != null) {
			if (! rhs.analyze$LAnalysisContext$LExpression$(this._analysisContext, null)) {
				return;
			}
			if (rhs.isClassSpecifier$()) {
				this._analysisContext.errors.push(new CompileError(rhs._token, "cannot assign a class"));
				return;
			}
			ivType = rhs.getType$();
			if (this._type == null) {
				if (ivType.equals$LType$(Type.nullType)) {
					this._analysisContext.errors.push(new CompileError(rhs._token, "cannot assign null to an unknown type"));
					return;
				}
				if (ivType.equals$LType$(Type.voidType)) {
					this._analysisContext.errors.push(new CompileError(rhs._token, "cannot assign void"));
					return;
				}
				this._type = ivType.asAssignableType$();
			} else if (! ivType.isConvertibleTo$LType$(this._type)) {
				this._analysisContext.errors.push(new CompileError(this._nameToken, "the variable is declared as '" + this._type.toString() + "' but initial value is '" + ivType.toString() + "'"));
			}
		}
		this._analyzeState = 2;
	} finally {
		if (this._analyzeState !== 2) {
			this._analyzeState = 3;
		}
	}
};


function MemberVariableDefinition$_lazyAnalyze$LMemberVariableDefinition$($this) {
	var rhs;
	var ivType;
	try {
		$this._analyzeState = 1;
		rhs = $this._initialValue;
		if (rhs != null) {
			if (! rhs.analyze$LAnalysisContext$LExpression$($this._analysisContext, null)) {
				return;
			}
			if (rhs.isClassSpecifier$()) {
				$this._analysisContext.errors.push(new CompileError(rhs._token, "cannot assign a class"));
				return;
			}
			ivType = rhs.getType$();
			if ($this._type == null) {
				if (ivType.equals$LType$(Type.nullType)) {
					$this._analysisContext.errors.push(new CompileError(rhs._token, "cannot assign null to an unknown type"));
					return;
				}
				if (ivType.equals$LType$(Type.voidType)) {
					$this._analysisContext.errors.push(new CompileError(rhs._token, "cannot assign void"));
					return;
				}
				$this._type = ivType.asAssignableType$();
			} else if (! ivType.isConvertibleTo$LType$($this._type)) {
				$this._analysisContext.errors.push(new CompileError($this._nameToken, "the variable is declared as '" + $this._type.toString() + "' but initial value is '" + ivType.toString() + "'"));
			}
		}
		$this._analyzeState = 2;
	} finally {
		if ($this._analyzeState !== 2) {
			$this._analyzeState = 3;
		}
	}
};

MemberVariableDefinition._lazyAnalyze$LMemberVariableDefinition$ = MemberVariableDefinition$_lazyAnalyze$LMemberVariableDefinition$;

MemberVariableDefinition.prototype.getInitialValue$ = function () {
	return this._initialValue;
};


function MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$($this) {
	return $this._initialValue;
};

MemberVariableDefinition.getInitialValue$LMemberVariableDefinition$ = MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$;

MemberVariableDefinition.prototype.setInitialValue$LExpression$ = function (initialValue) {
	this._initialValue = initialValue;
};


function MemberVariableDefinition$setInitialValue$LMemberVariableDefinition$LExpression$($this, initialValue) {
	$this._initialValue = initialValue;
};

MemberVariableDefinition.setInitialValue$LMemberVariableDefinition$LExpression$ = MemberVariableDefinition$setInitialValue$LMemberVariableDefinition$LExpression$;

MemberVariableDefinition.prototype.getNotation$ = function () {
	var classDef;
	var s;
	var this$0;
	var this$0$0;
	classDef = this._classDef;
	s = (classDef != null ? ClassDefinition$classFullName$LClassDefinition$(classDef) : "<<unknown:" + ((this$0 = this._token, this$0._filename) || "?") + ">>");
	s += ((this._flags & 8) !== 0 ? "." : "#");
	s += (this$0$0 = this._nameToken, this$0$0._value);
	return s;
};


function MemberFunctionDefinition(token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment) {
	var i;
	var this$0;
	MemberDefinition.call(this, token, name, flags, closures, docComment);
	this._analyzed = false;
	this._returnType = returnType;
	this._args = args;
	this._locals = locals;
	this._statements = statements;
	this._lastTokenOfBody = lastTokenOfBody;
	this._parent = null;
	this._funcLocal = null;
	this._classDef = null;
	for (i = 0; i < this._closures.length; ++i) {
		this$0 = this._closures[i];
		this$0._parent = this;
	}
};

$__jsx_extend([MemberFunctionDefinition], MemberDefinition);
$__jsx_merge_interface(MemberFunctionDefinition, Block);

MemberFunctionDefinition.prototype.isAnonymous$ = function () {
	return this._nameToken == null;
};


function MemberFunctionDefinition$isAnonymous$LMemberFunctionDefinition$($this) {
	return $this._nameToken == null;
};

MemberFunctionDefinition.isAnonymous$LMemberFunctionDefinition$ = MemberFunctionDefinition$isAnonymous$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.isGenerator$ = function () {
	return (this._flags & 8192) !== 0;
};


function MemberFunctionDefinition$isGenerator$LMemberFunctionDefinition$($this) {
	return ($this._flags & 8192) !== 0;
};

MemberFunctionDefinition.isGenerator$LMemberFunctionDefinition$ = MemberFunctionDefinition$isGenerator$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.getNotation$ = function () {
	var $this = this;
	var classDef;
	var s;
	var this$0;
	var this$0$0;
	var this$1;
	var this$2;
	classDef = this._classDef;
	s = (classDef != null ? ClassDefinition$classFullName$LClassDefinition$(classDef) : "<<unknown:" + ((this$0 = this._token, this$0._filename) || "?") + ">>");
	s += ((this._flags & 8) !== 0 ? "." : "#");
	s += (this._nameToken != null ? (this$0$0 = this._nameToken, this$0$0._value) : "$" + ((this$1 = this._token, this$1._lineNumber) + "") + "_" + ((this$2 = this._token, this$2._columnNumber) + ""));
	s += "(";
	s += this._args.map((function (arg) {
		return ":" + (arg._type ? arg._type.toString() : "null");
	})).join(",");
	s += ")";
	return s;
};


MemberFunctionDefinition.prototype.toString = function () {
	var $this = this;
	var argsText;
	var this$0$0;
	argsText = this._args.map((function (arg) {
		var this$0;
		return (this$0 = arg._name, this$0._value) + " : " + arg._type.toString();
	})).join(", ");
	return "function " + (this$0$0 = this._nameToken, this$0$0._value) + "(" + argsText + ") : " + this._returnType.toString();
};


MemberFunctionDefinition.prototype.clone$ = function () {
	var $this = this;
	var stashesUsed;
	var getStash;
	var cloneFuncDef;
	var clonedFuncDef;
	var i;
	var stash;
	var classDef;
	var this$0;
	var parent$0;
	var _members$0;
	var stashesUsed$len$0;
	stashesUsed = [];
	function getStash(stashable) {
		var stash;
		stash = stashable.getStash$S("CLONE-FUNC-DEF");
		if (stash == null) {
			stash = stashable.setStash$SLStash$("CLONE-FUNC-DEF", new MemberFunctionDefinition$x2E_CloneStash());
		}
		stashesUsed.push(stash);
		return stash;
	}
	function cloneFuncDef(funcDef) {
		var statements;
		var closures;
		var funcLocal;
		var newFuncLocal;
		var args;
		var locals;
		var clonedFuncDef;
		var a$0;
		var r$0;
		var i$0;
		var classDef$0;
		a$0 = funcDef._statements;
		r$0 = [  ];
		for (i$0 = 0; i$0 < a$0.length; ++i$0) {
			r$0[i$0] = a$0[i$0].clone$();
		}
		statements = r$0;
		closures = funcDef._closures.map((function (funcDef) {
			var newFuncDef;
			newFuncDef = cloneFuncDef(funcDef);
			getStash(funcDef).newFuncDef = newFuncDef;
			return newFuncDef;
		}));
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var newFuncDef;
			if (statement instanceof FunctionStatement) {
				if ((newFuncDef = getStash(FunctionStatement$getFuncDef$LFunctionStatement$(statement)).newFuncDef) != null) {
					FunctionStatement$setFuncDef$LFunctionStatement$LMemberFunctionDefinition$(statement, newFuncDef);
				}
				return true;
			}
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				var newFuncDef;
				if (expr instanceof FunctionExpression) {
					if ((newFuncDef = getStash(FunctionExpression$getFuncDef$LFunctionExpression$(expr)).newFuncDef) != null) {
						FunctionExpression$setFuncDef$LFunctionExpression$LMemberFunctionDefinition$(expr, newFuncDef);
					}
					return true;
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), statements);
		funcLocal = funcDef._funcLocal;
		if (funcLocal != null) {
			if ((newFuncLocal = getStash(funcLocal).newLocal) != null) {
			} else {
				newFuncLocal = new LocalVariable(funcLocal._name, funcLocal._type, funcLocal._isConstant);
				getStash(funcLocal).newLocal = newFuncLocal;
			}
			funcLocal = newFuncLocal;
		}
		args = funcDef._args.map((function (arg) {
			var newArg;
			newArg = ArgumentDeclaration$clone$LArgumentDeclaration$(arg);
			getStash(arg).newLocal = newArg;
			return newArg;
		}));
		locals = funcDef._locals.map((function (local) {
			var newLocal;
			if ((newLocal = getStash(local).newLocal) != null) {
				return newLocal;
			}
			newLocal = new LocalVariable(LocalVariable$getName$LLocalVariable$(local), LocalVariable$getType$LLocalVariable$(local), LocalVariable$isConstant$LLocalVariable$(local));
			getStash(local).newLocal = newLocal;
			return newLocal;
		}));
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var caughtVar;
			if (statement instanceof CatchStatement) {
				caughtVar = CaughtVariable$clone$LCaughtVariable$(CatchStatement$getLocal$LCatchStatement$(statement));
				getStash(CatchStatement$getLocal$LCatchStatement$(statement)).newLocal = caughtVar;
				CatchStatement$setLocal$LCatchStatement$LCaughtVariable$(statement, caughtVar);
			} else if (statement instanceof FunctionStatement) {
				MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionStatement$getFuncDef$LFunctionStatement$(statement), onStatement);
			}
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				if (expr instanceof FunctionExpression) {
					return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), statements);
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			if (statement instanceof FunctionStatement) {
				MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionStatement$getFuncDef$LFunctionStatement$(statement), onStatement);
			}
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				var newLocal;
				if (expr instanceof LocalExpression) {
					if ((newLocal = getStash(LocalExpression$getLocal$LLocalExpression$(expr)).newLocal) != null) {
						LocalExpression$setLocal$LLocalExpression$LLocalVariable$(expr, newLocal);
					}
				} else if (expr instanceof FunctionExpression) {
					return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), statements);
		clonedFuncDef = new MemberFunctionDefinition(funcDef._token, funcDef._nameToken, funcDef._flags, funcDef._returnType, args, locals, statements, closures, funcDef._lastTokenOfBody, null);
		clonedFuncDef._funcLocal = funcLocal;
		classDef$0 = $this._classDef;
		clonedFuncDef._classDef = classDef$0;
		return clonedFuncDef;
	}
	clonedFuncDef = cloneFuncDef(this);
	for ((i = 0, stashesUsed$len$0 = stashesUsed.length); i < stashesUsed$len$0; ++i) {
		stash = stashesUsed[i];
		stash.newLocal = null;
		stash.newFuncDef = null;
	}
	if (this._parent == null) {
		classDef = this._classDef;
		if (classDef == null) {
		} else {
			(_members$0 = classDef._members).splice(_members$0.indexOf(this) + 1, 0, clonedFuncDef);
		}
	} else {
		(this$0 = this._parent, this$0._closures).push(clonedFuncDef);
		parent$0 = this._parent;
		clonedFuncDef._parent = parent$0;
	}
	return clonedFuncDef;
};


function MemberFunctionDefinition$clone$LMemberFunctionDefinition$($this) {
	var stashesUsed;
	var getStash;
	var cloneFuncDef;
	var clonedFuncDef;
	var i;
	var stash;
	var classDef;
	var this$0;
	var parent$0;
	var _members$0;
	var stashesUsed$len$0;
	stashesUsed = [];
	function getStash(stashable) {
		var stash;
		stash = stashable.getStash$S("CLONE-FUNC-DEF");
		if (stash == null) {
			stash = stashable.setStash$SLStash$("CLONE-FUNC-DEF", new MemberFunctionDefinition$x2E_CloneStash());
		}
		stashesUsed.push(stash);
		return stash;
	}
	function cloneFuncDef(funcDef) {
		var statements;
		var closures;
		var funcLocal;
		var newFuncLocal;
		var args;
		var locals;
		var clonedFuncDef;
		var a$0;
		var r$0;
		var i$0;
		var classDef$0;
		a$0 = funcDef._statements;
		r$0 = [  ];
		for (i$0 = 0; i$0 < a$0.length; ++i$0) {
			r$0[i$0] = a$0[i$0].clone$();
		}
		statements = r$0;
		closures = funcDef._closures.map((function (funcDef) {
			var newFuncDef;
			newFuncDef = cloneFuncDef(funcDef);
			getStash(funcDef).newFuncDef = newFuncDef;
			return newFuncDef;
		}));
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var newFuncDef;
			if (statement instanceof FunctionStatement) {
				if ((newFuncDef = getStash(FunctionStatement$getFuncDef$LFunctionStatement$(statement)).newFuncDef) != null) {
					FunctionStatement$setFuncDef$LFunctionStatement$LMemberFunctionDefinition$(statement, newFuncDef);
				}
				return true;
			}
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				var newFuncDef;
				if (expr instanceof FunctionExpression) {
					if ((newFuncDef = getStash(FunctionExpression$getFuncDef$LFunctionExpression$(expr)).newFuncDef) != null) {
						FunctionExpression$setFuncDef$LFunctionExpression$LMemberFunctionDefinition$(expr, newFuncDef);
					}
					return true;
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), statements);
		funcLocal = funcDef._funcLocal;
		if (funcLocal != null) {
			if ((newFuncLocal = getStash(funcLocal).newLocal) != null) {
			} else {
				newFuncLocal = new LocalVariable(funcLocal._name, funcLocal._type, funcLocal._isConstant);
				getStash(funcLocal).newLocal = newFuncLocal;
			}
			funcLocal = newFuncLocal;
		}
		args = funcDef._args.map((function (arg) {
			var newArg;
			newArg = ArgumentDeclaration$clone$LArgumentDeclaration$(arg);
			getStash(arg).newLocal = newArg;
			return newArg;
		}));
		locals = funcDef._locals.map((function (local) {
			var newLocal;
			if ((newLocal = getStash(local).newLocal) != null) {
				return newLocal;
			}
			newLocal = new LocalVariable(LocalVariable$getName$LLocalVariable$(local), LocalVariable$getType$LLocalVariable$(local), LocalVariable$isConstant$LLocalVariable$(local));
			getStash(local).newLocal = newLocal;
			return newLocal;
		}));
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var caughtVar;
			if (statement instanceof CatchStatement) {
				caughtVar = CaughtVariable$clone$LCaughtVariable$(CatchStatement$getLocal$LCatchStatement$(statement));
				getStash(CatchStatement$getLocal$LCatchStatement$(statement)).newLocal = caughtVar;
				CatchStatement$setLocal$LCatchStatement$LCaughtVariable$(statement, caughtVar);
			} else if (statement instanceof FunctionStatement) {
				MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionStatement$getFuncDef$LFunctionStatement$(statement), onStatement);
			}
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				if (expr instanceof FunctionExpression) {
					return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), statements);
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			if (statement instanceof FunctionStatement) {
				MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionStatement$getFuncDef$LFunctionStatement$(statement), onStatement);
			}
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				var newLocal;
				if (expr instanceof LocalExpression) {
					if ((newLocal = getStash(LocalExpression$getLocal$LLocalExpression$(expr)).newLocal) != null) {
						LocalExpression$setLocal$LLocalExpression$LLocalVariable$(expr, newLocal);
					}
				} else if (expr instanceof FunctionExpression) {
					return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), statements);
		clonedFuncDef = new MemberFunctionDefinition(funcDef._token, funcDef._nameToken, funcDef._flags, funcDef._returnType, args, locals, statements, closures, funcDef._lastTokenOfBody, null);
		clonedFuncDef._funcLocal = funcLocal;
		classDef$0 = $this._classDef;
		clonedFuncDef._classDef = classDef$0;
		return clonedFuncDef;
	}
	clonedFuncDef = cloneFuncDef($this);
	for ((i = 0, stashesUsed$len$0 = stashesUsed.length); i < stashesUsed$len$0; ++i) {
		stash = stashesUsed[i];
		stash.newLocal = null;
		stash.newFuncDef = null;
	}
	if ($this._parent == null) {
		classDef = $this._classDef;
		if (classDef == null) {
		} else {
			(_members$0 = classDef._members).splice(_members$0.indexOf($this) + 1, 0, clonedFuncDef);
		}
	} else {
		(this$0 = $this._parent, this$0._closures).push(clonedFuncDef);
		parent$0 = $this._parent;
		clonedFuncDef._parent = parent$0;
	}
	return clonedFuncDef;
};

MemberFunctionDefinition.clone$LMemberFunctionDefinition$ = MemberFunctionDefinition$clone$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var $this = this;
	return MemberFunctionDefinition$_instantiateCore$LMemberFunctionDefinition$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$(this, instantiationContext, (function (token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment) {
		return new MemberFunctionDefinition(token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment);
	}));
};


MemberFunctionDefinition.prototype._instantiateCore$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$ = function (instantiationContext, constructCallback) {
	var $this = this;
	var args;
	var i;
	var locals;
	var caughtVariables;
	var statements;
	var closures;
	var returnType;
	var this$0;
	var closures$0;
	var i$0;
	var this$1;
	var this$2;
	args = [];
	for (i = 0; i < this._args.length; ++i) {
		args[i] = this._args[i].instantiateAndPush$LInstantiationContext$(instantiationContext);
	}
	if (this._statements != null) {
		locals = [];
		for (i = 0; i < this._locals.length; ++i) {
			locals[i] = this._locals[i].instantiateAndPush$LInstantiationContext$(instantiationContext);
		}
		caughtVariables = [];
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var this$0;
			if (statement instanceof CatchStatement) {
				caughtVariables.push((this$0 = statement, this$0._local).instantiateAndPush$LInstantiationContext$(instantiationContext));
			}
			return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), this._statements);
		statements = [];
		for (i = 0; i < this._statements.length; ++i) {
			if (this._statements[i] instanceof ConstructorInvocationStatement) {
				this$0 = this._statements[i];
				if (this$0._ctorFunctionType != null) {
					throw new Error("instantiation after analysis?");
				}
				statements[i] = new ConstructorInvocationStatement$0(this$0._token, this$0._ctorClassType.instantiate$LInstantiationContext$B(instantiationContext, false), Util$cloneArray$ALExpression$(this$0._args), null);
			} else {
				statements[i] = this._statements[i].clone$();
			}
		}
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var this$0;
			var local$0;
			if (statement instanceof CatchStatement) {
				if (caughtVariables.length === 0) {
					throw new Error("logic flaw");
				}
				this$0 = statement;
				local$0 = caughtVariables.shift();
				this$0._local = local$0;
			}
			Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
				return Expression$instantiate$LExpression$LInstantiationContext$(expr, instantiationContext);
			}));
			return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), statements);
		closures$0 = [];
		for (i$0 = 0; i$0 < this._closures.length; ++i$0) {
			closures$0[i$0] = this._closures[i$0].instantiate$LInstantiationContext$(instantiationContext);
		}
		closures = closures$0;
		for (i = 0; i < this._locals.length; ++i) {
			if (this._locals[i].isInstantiated) {
				throw new Error("logic flaw");
			}
			this$1 = this._locals[i];
			this$1._instantiated.pop();
		}
		if (caughtVariables.length !== 0) {
			throw new Error("logic flaw");
		}
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var this$0;
			var this$1;
			if (statement instanceof CatchStatement) {
				this$1 = statement;
				this$0 = this$1._local;
				this$0._instantiated.pop();
			}
			return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), this._statements);
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var idx;
			var this$0;
			var this$1;
			var funcDef$0;
			if (statement instanceof FunctionStatement) {
				idx = $this._closures.indexOf((this$0 = statement, this$0._funcDef));
				if (i === -1) {
					throw new Error("logic flaw, cannot find the closure for " + $this.getNotation$());
				}
				this$1 = statement;
				funcDef$0 = closures[idx];
				this$1._funcDef = funcDef$0;
				return true;
			}
			Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
				MemberDefinition$_updateLinkFromExpressionToClosuresUponInstantiation$LMemberDefinition$LExpression$ALMemberFunctionDefinition$($this, expr, closures);
				return true;
			}));
			return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), statements);
	} else {
		locals = null;
		statements = null;
		closures = [];
	}
	for (i = 0; i < this._args.length; ++i) {
		this$2 = this._args[i];
		this$2._instantiated.pop();
	}
	if (this._returnType != null) {
		returnType = this._returnType.instantiate$LInstantiationContext$B(instantiationContext, true);
		if (returnType == null) {
			return null;
		}
	} else {
		returnType = null;
	}
	return constructCallback(this._token, this._nameToken, this._flags, returnType, args, locals, statements, closures, this._lastTokenOfBody, this._docComment);
};


function MemberFunctionDefinition$_instantiateCore$LMemberFunctionDefinition$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$($this, instantiationContext, constructCallback) {
	var args;
	var i;
	var locals;
	var caughtVariables;
	var statements;
	var closures;
	var returnType;
	var this$0;
	var closures$0;
	var i$0;
	var this$1;
	var this$2;
	args = [];
	for (i = 0; i < $this._args.length; ++i) {
		args[i] = $this._args[i].instantiateAndPush$LInstantiationContext$(instantiationContext);
	}
	if ($this._statements != null) {
		locals = [];
		for (i = 0; i < $this._locals.length; ++i) {
			locals[i] = $this._locals[i].instantiateAndPush$LInstantiationContext$(instantiationContext);
		}
		caughtVariables = [];
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var this$0;
			if (statement instanceof CatchStatement) {
				caughtVariables.push((this$0 = statement, this$0._local).instantiateAndPush$LInstantiationContext$(instantiationContext));
			}
			return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), $this._statements);
		statements = [];
		for (i = 0; i < $this._statements.length; ++i) {
			if ($this._statements[i] instanceof ConstructorInvocationStatement) {
				this$0 = $this._statements[i];
				if (this$0._ctorFunctionType != null) {
					throw new Error("instantiation after analysis?");
				}
				statements[i] = new ConstructorInvocationStatement$0(this$0._token, this$0._ctorClassType.instantiate$LInstantiationContext$B(instantiationContext, false), Util$cloneArray$ALExpression$(this$0._args), null);
			} else {
				statements[i] = $this._statements[i].clone$();
			}
		}
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var this$0;
			var local$0;
			if (statement instanceof CatchStatement) {
				if (caughtVariables.length === 0) {
					throw new Error("logic flaw");
				}
				this$0 = statement;
				local$0 = caughtVariables.shift();
				this$0._local = local$0;
			}
			Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
				return Expression$instantiate$LExpression$LInstantiationContext$(expr, instantiationContext);
			}));
			return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), statements);
		closures$0 = [];
		for (i$0 = 0; i$0 < $this._closures.length; ++i$0) {
			closures$0[i$0] = $this._closures[i$0].instantiate$LInstantiationContext$(instantiationContext);
		}
		closures = closures$0;
		for (i = 0; i < $this._locals.length; ++i) {
			if ($this._locals[i].isInstantiated) {
				throw new Error("logic flaw");
			}
			this$1 = $this._locals[i];
			this$1._instantiated.pop();
		}
		if (caughtVariables.length !== 0) {
			throw new Error("logic flaw");
		}
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var this$0;
			var this$1;
			if (statement instanceof CatchStatement) {
				this$1 = statement;
				this$0 = this$1._local;
				this$0._instantiated.pop();
			}
			return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), $this._statements);
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			var idx;
			var this$0;
			var this$1;
			var funcDef$0;
			if (statement instanceof FunctionStatement) {
				idx = $this._closures.indexOf((this$0 = statement, this$0._funcDef));
				if (i === -1) {
					throw new Error("logic flaw, cannot find the closure for " + $this.getNotation$());
				}
				this$1 = statement;
				funcDef$0 = closures[idx];
				this$1._funcDef = funcDef$0;
				return true;
			}
			Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
				MemberDefinition$_updateLinkFromExpressionToClosuresUponInstantiation$LMemberDefinition$LExpression$ALMemberFunctionDefinition$($this, expr, closures);
				return true;
			}));
			return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), statements);
	} else {
		locals = null;
		statements = null;
		closures = [];
	}
	for (i = 0; i < $this._args.length; ++i) {
		this$2 = $this._args[i];
		this$2._instantiated.pop();
	}
	if ($this._returnType != null) {
		returnType = $this._returnType.instantiate$LInstantiationContext$B(instantiationContext, true);
		if (returnType == null) {
			return null;
		}
	} else {
		returnType = null;
	}
	return constructCallback($this._token, $this._nameToken, $this._flags, returnType, args, locals, statements, closures, $this._lastTokenOfBody, $this._docComment);
};

MemberFunctionDefinition._instantiateCore$LMemberFunctionDefinition$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$ = MemberFunctionDefinition$_instantiateCore$LMemberFunctionDefinition$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$;

MemberFunctionDefinition.prototype.serialize$ = function () {
	var v$0;
	var v$1;
	var v$2;
	return ({ "token": (v$0 = this._token, v$0 == null ? null : [ v$0._value, v$0._isIdentifier, v$0._filename, v$0._lineNumber, v$0._columnNumber ]), "nameToken": (v$1 = this._nameToken, v$1 == null ? null : [ v$1._value, v$1._isIdentifier, v$1._filename, v$1._lineNumber, v$1._columnNumber ]), "flags": this._flags, "returnType": (v$2 = this._returnType, v$2 == null ? null : v$2.toString()), "args": Util$serializeArray$ALArgumentDeclaration$(this._args), "locals": Util$serializeArray$ALLocalVariable$(this._locals), "statements": Util$serializeArray$ALStatement$(this._statements) });
};


MemberFunctionDefinition.prototype.analyze$LAnalysisContext$ = function (outerContext) {
	var $this = this;
	var docComment;
	var args;
	var context;
	var i;
	var stack$0;
	var stack$1;
	var this$0$0;
	var this$0$1;
	var this$1;
	var this$0$2;
	var this$2;
	var type$0;
	var this$0$3;
	var blockStack$0;
	var blockStack$1;
	if (this._analyzed === true) {
		return;
	}
	this._analyzed = true;
	if ((this._flags & 32768) === 0) {
		docComment = this._docComment;
		if (docComment) {
			args = this._args;
			docComment._params.forEach((function (docParam, i) {
				var this$0;
				var this$1;
				var this$0$0;
				var this$0$2;
				var _token$0;
				var args$len$0;
				for (args$len$0 = args.length; i < args$len$0; ++i) {
					if ((this$1 = (this$0 = args[i], this$0._name), this$1._value) === (this$0$0 = docParam._token, this$0$0._value)) {
						return;
					}
				}
				outerContext.errors.push(new CompileError(_token$0 = docParam._token, 'invalid parameter name "' + (_token$0, _token$0._value) + '" for ' + (this$0$2 = $this._nameToken, this$0$2._value) + "()"));
			}));
		}
	}
	if (this._statements == null) {
		return;
	}
	this$0$3 = ({errors: outerContext.errors, parser: outerContext.parser, postInstantiationCallback: outerContext.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
	this$0$3.funcDef = this;
	context = this$0$3;
	if (this._parent == null) {
		stack$0 = [ ({localVariableStatuses: new LocalVariableStatuses(this, null), block: this}) ];
		context.blockStack = stack$0;
	} else {
		stack$1 = blockStack$1 = outerContext.blockStack;
		blockStack$0 = context.blockStack = stack$1;
		blockStack$0.push(({localVariableStatuses: new LocalVariableStatuses(this, blockStack$1[blockStack$1.length - 1].localVariableStatuses), block: this}));
		if (! (this._nameToken == null)) {
			if (this._returnType != null) {
				context.blockStack[context.blockStack.length - 1].localVariableStatuses._statuses[(this$0$0 = this._nameToken, this$0$0._value)] = 1;
			} else {
				context.blockStack[context.blockStack.length - 1].localVariableStatuses._statuses[(this$0$1 = this._nameToken, this$0$1._value)] = -1;
			}
		}
	}
	try {
		for (i = 0; i < this._statements.length; ++i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$(this._statements[i], context)) {
				break;
			}
		}
		if (this._returnType == null) {
			this._returnType = Type.voidType;
		}
		if ((this._flags & 8192) !== 0) {
		} else if (! this._returnType.equals$LType$(Type.voidType) && (this$1 = context.blockStack[context.blockStack.length - 1].localVariableStatuses, this$1._isReachable)) {
			context.errors.push(new CompileError(this._lastTokenOfBody, "missing return statement"));
		}
		if (this._parent == null && this._nameToken != null && (this$0$2 = this._nameToken, this$0$2._value) === "constructor") {
			MemberFunctionDefinition$_fixupConstructor$LMemberFunctionDefinition$LAnalysisContext$(this, context);
		}
	} finally {
		context.blockStack.pop();
	}
	if (this._funcLocal != null) {
		this$2 = this._funcLocal;
		type$0 = this.getType$();
		this$2._type = type$0;
	}
	this._locals.forEach((function (local) {
		var _name$0;
		if (! local._isUsedAsRHS) {
			context.errors.push(new UnusedWarning(_name$0 = local._name, "unused variable " + (_name$0, _name$0._value)));
		}
	}));
};


function MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$($this, outerContext) {
	var docComment;
	var args;
	var context;
	var i;
	var stack$0;
	var stack$1;
	var this$0$0;
	var this$0$1;
	var this$1;
	var this$0$2;
	var this$2;
	var type$0;
	var this$0$3;
	var blockStack$0;
	var blockStack$1;
	if ($this._analyzed === true) {
		return;
	}
	$this._analyzed = true;
	if (($this._flags & 32768) === 0) {
		docComment = $this._docComment;
		if (docComment) {
			args = $this._args;
			docComment._params.forEach((function (docParam, i) {
				var this$0;
				var this$1;
				var this$0$0;
				var this$0$2;
				var _token$0;
				var args$len$0;
				for (args$len$0 = args.length; i < args$len$0; ++i) {
					if ((this$1 = (this$0 = args[i], this$0._name), this$1._value) === (this$0$0 = docParam._token, this$0$0._value)) {
						return;
					}
				}
				outerContext.errors.push(new CompileError(_token$0 = docParam._token, 'invalid parameter name "' + (_token$0, _token$0._value) + '" for ' + (this$0$2 = $this._nameToken, this$0$2._value) + "()"));
			}));
		}
	}
	if ($this._statements == null) {
		return;
	}
	this$0$3 = ({errors: outerContext.errors, parser: outerContext.parser, postInstantiationCallback: outerContext.postInstantiationCallback, funcDef: null, blockStack: null, statement: null});
	this$0$3.funcDef = $this;
	context = this$0$3;
	if ($this._parent == null) {
		stack$0 = [ ({localVariableStatuses: new LocalVariableStatuses($this, null), block: $this}) ];
		context.blockStack = stack$0;
	} else {
		stack$1 = blockStack$1 = outerContext.blockStack;
		blockStack$0 = context.blockStack = stack$1;
		blockStack$0.push(({localVariableStatuses: new LocalVariableStatuses($this, blockStack$1[blockStack$1.length - 1].localVariableStatuses), block: $this}));
		if (! ($this._nameToken == null)) {
			if ($this._returnType != null) {
				context.blockStack[context.blockStack.length - 1].localVariableStatuses._statuses[(this$0$0 = $this._nameToken, this$0$0._value)] = 1;
			} else {
				context.blockStack[context.blockStack.length - 1].localVariableStatuses._statuses[(this$0$1 = $this._nameToken, this$0$1._value)] = -1;
			}
		}
	}
	try {
		for (i = 0; i < $this._statements.length; ++i) {
			if (! Statement$analyze$LStatement$LAnalysisContext$($this._statements[i], context)) {
				break;
			}
		}
		if ($this._returnType == null) {
			$this._returnType = Type.voidType;
		}
		if (($this._flags & 8192) !== 0) {
		} else if (! $this._returnType.equals$LType$(Type.voidType) && (this$1 = context.blockStack[context.blockStack.length - 1].localVariableStatuses, this$1._isReachable)) {
			context.errors.push(new CompileError($this._lastTokenOfBody, "missing return statement"));
		}
		if ($this._parent == null && $this._nameToken != null && (this$0$2 = $this._nameToken, this$0$2._value) === "constructor") {
			MemberFunctionDefinition$_fixupConstructor$LMemberFunctionDefinition$LAnalysisContext$($this, context);
		}
	} finally {
		context.blockStack.pop();
	}
	if ($this._funcLocal != null) {
		this$2 = $this._funcLocal;
		type$0 = $this.getType$();
		this$2._type = type$0;
	}
	$this._locals.forEach((function (local) {
		var _name$0;
		if (! local._isUsedAsRHS) {
			context.errors.push(new UnusedWarning(_name$0 = local._name, "unused variable " + (_name$0, _name$0._value)));
		}
	}));
};

MemberFunctionDefinition.analyze$LMemberFunctionDefinition$LAnalysisContext$ = MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$;

MemberFunctionDefinition.prototype.generateWrappersForDefaultParameters$ = function () {
	var $this = this;
	var createObjectType;
	var origArgIndex;
	var formalArgs;
	var argExprs;
	var i;
	var defVal;
	var statement;
	var invocant;
	var methodRef;
	var callExpression;
	var wrapper;
	var this$0;
	var this$1;
	var classDef$0;
	var this$0$0;
	var _classDef$0;
	function createObjectType(classDef) {
		var typeArgs;
		var this$0;
		if (classDef instanceof TemplateClassDefinition) {
			typeArgs = (this$0 = classDef, this$0._typeArgs).map((function (token) {
				return new ParsedObjectType(new QualifiedName(token), []);
			}));
			return new ParsedObjectType(new QualifiedName(classDef.getToken$()), typeArgs);
		} else {
			return new ObjectType(classDef);
		}
	}
	for (origArgIndex = 0; origArgIndex !== this._args.length; ++origArgIndex) {
		if ((this$0 = this._args[origArgIndex], this$0._defaultValue) != null) {
			break;
		}
	}
	for (; origArgIndex !== this._args.length; ++origArgIndex) {
		formalArgs = this._args.slice(0, origArgIndex).map((function (arg) {
			return new ArgumentDeclaration(arg._name, arg._type);
		}));
		argExprs = formalArgs.map((function (arg) {
			return new LocalExpression(arg._name, arg);
		}));
		for (i = origArgIndex; i !== this._args.length; ++i) {
			this$1 = this._args[i];
			defVal = this$1._defaultValue;
			argExprs.push(defVal.clone$());
		}
		if ((this$0$0 = this._nameToken, this$0$0._value) === "constructor") {
			statement = new ConstructorInvocationStatement(new Token$2("this", false), createObjectType(this._classDef), argExprs);
		} else {
			invocant = ((this._flags & 8) === 0 ? new ThisExpression(new Token$2("this", false), this._classDef) : new ClassExpression(new Token$2(this._classDef.className$(), true), createObjectType(this._classDef)));
			methodRef = new PropertyExpression(new Token$2(".", false), invocant, this._nameToken, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this));
			callExpression = new CallExpression(new Token$2("(", false), methodRef, argExprs);
			statement = new ReturnStatement(new Token$2("return", false), callExpression);
		}
		if (! (this instanceof TemplateFunctionDefinition)) {
			wrapper = new MemberFunctionDefinition(this._token, this._nameToken, this._flags | 1024 | 32768, this._returnType, formalArgs, [], [ statement ], this._closures.slice(0), this._lastTokenOfBody, this._docComment);
		} else {
			throw new Error("TODO: template function with default parameters in " + this.getNotation$() + " is not yet supported");
		}
		classDef$0 = _classDef$0 = this._classDef;
		wrapper._classDef = classDef$0;
		(_classDef$0, _classDef$0._members).splice((_classDef$0, _classDef$0._members).indexOf(this) + 1, 0, wrapper);
		Util$forEachExpression$F$LExpression$B$ALExpression$((function onExpr(expr) {
			var newFuncDef;
			var this$0;
			var j$0;
			var classDef$0$0;
			var this$1;
			if (expr instanceof FunctionExpression) {
				newFuncDef = MemberFunctionDefinition$clone$LMemberFunctionDefinition$((this$0 = expr, this$0._funcDef));
				if ((j$0 = $this._closures.indexOf(newFuncDef)) !== -1) {
					$this._closures.splice(j$0, 1);
				}
				MemberFunctionDefinition$setParent$LMemberFunctionDefinition$LMemberFunctionDefinition$(newFuncDef, null);
				wrapper._closures.push(newFuncDef);
				newFuncDef._parent = wrapper;
				classDef$0$0 = wrapper._classDef;
				newFuncDef._classDef = classDef$0$0;
				this$1 = expr;
				this$1._funcDef = newFuncDef;
				return true;
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}), argExprs);
	}
};


function MemberFunctionDefinition$generateWrappersForDefaultParameters$LMemberFunctionDefinition$($this) {
	var createObjectType;
	var origArgIndex;
	var formalArgs;
	var argExprs;
	var i;
	var defVal;
	var statement;
	var invocant;
	var methodRef;
	var callExpression;
	var wrapper;
	var this$0;
	var this$1;
	var classDef$0;
	var this$0$0;
	var _classDef$0;
	function createObjectType(classDef) {
		var typeArgs;
		var this$0;
		if (classDef instanceof TemplateClassDefinition) {
			typeArgs = (this$0 = classDef, this$0._typeArgs).map((function (token) {
				return new ParsedObjectType(new QualifiedName(token), []);
			}));
			return new ParsedObjectType(new QualifiedName(classDef.getToken$()), typeArgs);
		} else {
			return new ObjectType(classDef);
		}
	}
	for (origArgIndex = 0; origArgIndex !== $this._args.length; ++origArgIndex) {
		if ((this$0 = $this._args[origArgIndex], this$0._defaultValue) != null) {
			break;
		}
	}
	for (; origArgIndex !== $this._args.length; ++origArgIndex) {
		formalArgs = $this._args.slice(0, origArgIndex).map((function (arg) {
			return new ArgumentDeclaration(arg._name, arg._type);
		}));
		argExprs = formalArgs.map((function (arg) {
			return new LocalExpression(arg._name, arg);
		}));
		for (i = origArgIndex; i !== $this._args.length; ++i) {
			this$1 = $this._args[i];
			defVal = this$1._defaultValue;
			argExprs.push(defVal.clone$());
		}
		if ((this$0$0 = $this._nameToken, this$0$0._value) === "constructor") {
			statement = new ConstructorInvocationStatement(new Token$2("this", false), createObjectType($this._classDef), argExprs);
		} else {
			invocant = (($this._flags & 8) === 0 ? new ThisExpression(new Token$2("this", false), $this._classDef) : new ClassExpression(new Token$2($this._classDef.className$(), true), createObjectType($this._classDef)));
			methodRef = new PropertyExpression(new Token$2(".", false), invocant, $this._nameToken, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this));
			callExpression = new CallExpression(new Token$2("(", false), methodRef, argExprs);
			statement = new ReturnStatement(new Token$2("return", false), callExpression);
		}
		if (! ($this instanceof TemplateFunctionDefinition)) {
			wrapper = new MemberFunctionDefinition($this._token, $this._nameToken, $this._flags | 1024 | 32768, $this._returnType, formalArgs, [], [ statement ], $this._closures.slice(0), $this._lastTokenOfBody, $this._docComment);
		} else {
			throw new Error("TODO: template function with default parameters in " + $this.getNotation$() + " is not yet supported");
		}
		classDef$0 = _classDef$0 = $this._classDef;
		wrapper._classDef = classDef$0;
		(_classDef$0, _classDef$0._members).splice((_classDef$0, _classDef$0._members).indexOf($this) + 1, 0, wrapper);
		Util$forEachExpression$F$LExpression$B$ALExpression$((function onExpr(expr) {
			var newFuncDef;
			var this$0;
			var j$0;
			var classDef$0$0;
			var this$1;
			if (expr instanceof FunctionExpression) {
				newFuncDef = MemberFunctionDefinition$clone$LMemberFunctionDefinition$((this$0 = expr, this$0._funcDef));
				if ((j$0 = $this._closures.indexOf(newFuncDef)) !== -1) {
					$this._closures.splice(j$0, 1);
				}
				MemberFunctionDefinition$setParent$LMemberFunctionDefinition$LMemberFunctionDefinition$(newFuncDef, null);
				wrapper._closures.push(newFuncDef);
				newFuncDef._parent = wrapper;
				classDef$0$0 = wrapper._classDef;
				newFuncDef._classDef = classDef$0$0;
				this$1 = expr;
				this$1._funcDef = newFuncDef;
				return true;
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}), argExprs);
	}
};

MemberFunctionDefinition.generateWrappersForDefaultParameters$LMemberFunctionDefinition$ = MemberFunctionDefinition$generateWrappersForDefaultParameters$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype._fixupConstructor$LAnalysisContext$ = function (context) {
	var $this = this;
	var success;
	var isAlternate;
	var stmtIndex;
	var baseIndex;
	var baseClassType;
	var ctorStmt;
	var normalStatementFromIndex;
	var initProperties;
	var i;
	var onExpr;
	var canContinue;
	var insertStmtAt;
	var this$0;
	var this$1;
	var this$0$0;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	success = true;
	isAlternate = false;
	if ((this._flags & 8192) !== 0) {
		context.errors.push(new CompileError(this._token, "constructor must not be a generator"));
		return;
	}
	stmtIndex = 0;
	if (0 < this._statements.length && this._statements[0] instanceof ConstructorInvocationStatement && (this$5 = this._statements[0], this$5._ctorClassType.getClassDef$()) == this._classDef) {
		isAlternate = true;
		++stmtIndex;
	} else {
		for (baseIndex = 0; baseIndex <= (this$4 = this._classDef, this$4._implementTypes).length; ++baseIndex) {
			baseClassType = (baseIndex === 0 ? (this$0 = this._classDef, this$0._extendType) : (this$1 = this._classDef, this$1._implementTypes)[baseIndex - 1]);
			if (baseClassType != null) {
				if (stmtIndex < this._statements.length && this._statements[stmtIndex] instanceof ConstructorInvocationStatement && baseClassType._classDef == (this$3 = this._statements[stmtIndex], this$3._ctorClassType.getClassDef$())) {
					if ((this$2 = (this$0$0 = baseClassType._qualifiedName, this$0$0._token), this$2._value) === "Object") {
						this._statements.splice(stmtIndex, 1);
					} else {
						++stmtIndex;
					}
				} else if (baseClassType._classDef.className$() === "Object") {
				} else if (ClassDefinition$hasDefaultConstructor$LClassDefinition$(baseClassType._classDef)) {
					ctorStmt = new ConstructorInvocationStatement(this._token, baseClassType, []);
					this._statements.splice(stmtIndex, 0, ctorStmt);
					if (! Statement$analyze$LStatement$LAnalysisContext$(ctorStmt, context)) {
						throw new Error("logic flaw");
					}
					++stmtIndex;
				} else {
					if (stmtIndex < this._statements.length) {
						context.errors.push(new CompileError(this._statements[stmtIndex].getToken$(), "constructor of class '" + baseClassType.toString() + "' should be called prior to the statement"));
					} else {
						context.errors.push(new CompileError(this._token, "super class '" + baseClassType.toString() + "' should be initialized explicitely (no default constructor)"));
					}
					success = false;
				}
			}
		}
	}
	for (; stmtIndex < this._statements.length; ++stmtIndex) {
		if (! (this._statements[stmtIndex] instanceof ConstructorInvocationStatement)) {
			break;
		}
		context.errors.push(new CompileError(this._statements[stmtIndex].getToken$(), "constructors should be invoked in the order they are implemented"));
		success = false;
	}
	if (! success) {
		return;
	}
	if (isAlternate) {
		return;
	}
	normalStatementFromIndex = stmtIndex;
	initProperties = {};
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(this._classDef, (function (member) {
		var this$0$0;
		if ((member._flags & 10) === 0) {
			initProperties[(this$0$0 = member._nameToken, this$0$0._value)] = true;
		}
		return true;
	}));
	for (i = normalStatementFromIndex; i < this._statements.length; ++i) {
		if (! (this._statements[i] instanceof ExpressionStatement)) {
			break;
		}
		function onExpr(expr) {
			var assignExpr;
			var lhsExpr;
			var this$0;
			var this$1;
			var this$2;
			if (expr instanceof AssignmentExpression) {
				assignExpr = expr;
				if (! onExpr(assignExpr._expr2)) {
					return false;
				}
				lhsExpr = assignExpr._expr1;
				if (lhsExpr instanceof PropertyExpression && (this$2 = lhsExpr, this$2._expr) instanceof ThisExpression) {
					initProperties[(this$1 = (this$0 = lhsExpr, this$0._identifierToken), this$1._value)] = false;
					return true;
				}
			} else if (expr instanceof ThisExpression || expr instanceof FunctionExpression) {
				return false;
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}
		canContinue = Statement$forEachExpression$LStatement$F$LExpression$B$(this._statements[i], onExpr);
		if (! canContinue) {
			break;
		}
	}
	insertStmtAt = normalStatementFromIndex;
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(this._classDef, (function (member) {
		var stmt;
		var this$0$0;
		if ((member._flags & 10) === 0) {
			if (initProperties[(this$0$0 = member._nameToken, this$0$0._value)]) {
				stmt = new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new ThisExpression(new Token$2("this", false), $this._classDef), member._nameToken, [], member.getType$()), member._initialValue));
				$this._statements.splice(insertStmtAt++, 0, stmt);
			}
		}
		return true;
	}));
};


function MemberFunctionDefinition$_fixupConstructor$LMemberFunctionDefinition$LAnalysisContext$($this, context) {
	var success;
	var isAlternate;
	var stmtIndex;
	var baseIndex;
	var baseClassType;
	var ctorStmt;
	var normalStatementFromIndex;
	var initProperties;
	var i;
	var onExpr;
	var canContinue;
	var insertStmtAt;
	var this$0;
	var this$1;
	var this$0$0;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	success = true;
	isAlternate = false;
	if (($this._flags & 8192) !== 0) {
		context.errors.push(new CompileError($this._token, "constructor must not be a generator"));
		return;
	}
	stmtIndex = 0;
	if (0 < $this._statements.length && $this._statements[0] instanceof ConstructorInvocationStatement && (this$5 = $this._statements[0], this$5._ctorClassType.getClassDef$()) == $this._classDef) {
		isAlternate = true;
		++stmtIndex;
	} else {
		for (baseIndex = 0; baseIndex <= (this$4 = $this._classDef, this$4._implementTypes).length; ++baseIndex) {
			baseClassType = (baseIndex === 0 ? (this$0 = $this._classDef, this$0._extendType) : (this$1 = $this._classDef, this$1._implementTypes)[baseIndex - 1]);
			if (baseClassType != null) {
				if (stmtIndex < $this._statements.length && $this._statements[stmtIndex] instanceof ConstructorInvocationStatement && baseClassType._classDef == (this$3 = $this._statements[stmtIndex], this$3._ctorClassType.getClassDef$())) {
					if ((this$2 = (this$0$0 = baseClassType._qualifiedName, this$0$0._token), this$2._value) === "Object") {
						$this._statements.splice(stmtIndex, 1);
					} else {
						++stmtIndex;
					}
				} else if (baseClassType._classDef.className$() === "Object") {
				} else if (ClassDefinition$hasDefaultConstructor$LClassDefinition$(baseClassType._classDef)) {
					ctorStmt = new ConstructorInvocationStatement($this._token, baseClassType, []);
					$this._statements.splice(stmtIndex, 0, ctorStmt);
					if (! Statement$analyze$LStatement$LAnalysisContext$(ctorStmt, context)) {
						throw new Error("logic flaw");
					}
					++stmtIndex;
				} else {
					if (stmtIndex < $this._statements.length) {
						context.errors.push(new CompileError($this._statements[stmtIndex].getToken$(), "constructor of class '" + baseClassType.toString() + "' should be called prior to the statement"));
					} else {
						context.errors.push(new CompileError($this._token, "super class '" + baseClassType.toString() + "' should be initialized explicitely (no default constructor)"));
					}
					success = false;
				}
			}
		}
	}
	for (; stmtIndex < $this._statements.length; ++stmtIndex) {
		if (! ($this._statements[stmtIndex] instanceof ConstructorInvocationStatement)) {
			break;
		}
		context.errors.push(new CompileError($this._statements[stmtIndex].getToken$(), "constructors should be invoked in the order they are implemented"));
		success = false;
	}
	if (! success) {
		return;
	}
	if (isAlternate) {
		return;
	}
	normalStatementFromIndex = stmtIndex;
	initProperties = {};
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$($this._classDef, (function (member) {
		var this$0$0;
		if ((member._flags & 10) === 0) {
			initProperties[(this$0$0 = member._nameToken, this$0$0._value)] = true;
		}
		return true;
	}));
	for (i = normalStatementFromIndex; i < $this._statements.length; ++i) {
		if (! ($this._statements[i] instanceof ExpressionStatement)) {
			break;
		}
		function onExpr(expr) {
			var assignExpr;
			var lhsExpr;
			var this$0;
			var this$1;
			var this$2;
			if (expr instanceof AssignmentExpression) {
				assignExpr = expr;
				if (! onExpr(assignExpr._expr2)) {
					return false;
				}
				lhsExpr = assignExpr._expr1;
				if (lhsExpr instanceof PropertyExpression && (this$2 = lhsExpr, this$2._expr) instanceof ThisExpression) {
					initProperties[(this$1 = (this$0 = lhsExpr, this$0._identifierToken), this$1._value)] = false;
					return true;
				}
			} else if (expr instanceof ThisExpression || expr instanceof FunctionExpression) {
				return false;
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}
		canContinue = Statement$forEachExpression$LStatement$F$LExpression$B$($this._statements[i], onExpr);
		if (! canContinue) {
			break;
		}
	}
	insertStmtAt = normalStatementFromIndex;
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$($this._classDef, (function (member) {
		var stmt;
		var this$0$0;
		if ((member._flags & 10) === 0) {
			if (initProperties[(this$0$0 = member._nameToken, this$0$0._value)]) {
				stmt = new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new ThisExpression(new Token$2("this", false), $this._classDef), member._nameToken, [], member.getType$()), member._initialValue));
				$this._statements.splice(insertStmtAt++, 0, stmt);
			}
		}
		return true;
	}));
};

MemberFunctionDefinition._fixupConstructor$LMemberFunctionDefinition$LAnalysisContext$ = MemberFunctionDefinition$_fixupConstructor$LMemberFunctionDefinition$LAnalysisContext$;

MemberFunctionDefinition.prototype.getReturnType$ = function () {
	return this._returnType;
};


function MemberFunctionDefinition$getReturnType$LMemberFunctionDefinition$($this) {
	return $this._returnType;
};

MemberFunctionDefinition.getReturnType$LMemberFunctionDefinition$ = MemberFunctionDefinition$getReturnType$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.setReturnType$LType$ = function (type) {
	this._returnType = type;
};


function MemberFunctionDefinition$setReturnType$LMemberFunctionDefinition$LType$($this, type) {
	$this._returnType = type;
};

MemberFunctionDefinition.setReturnType$LMemberFunctionDefinition$LType$ = MemberFunctionDefinition$setReturnType$LMemberFunctionDefinition$LType$;

MemberFunctionDefinition.prototype.getArguments$ = function () {
	return this._args;
};


function MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$($this) {
	return $this._args;
};

MemberFunctionDefinition.getArguments$LMemberFunctionDefinition$ = MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.getArgumentTypes$ = function () {
	var argTypes;
	var i;
	var this$0;
	argTypes = [];
	for (i = 0; i < this._args.length; ++i) {
		this$0 = this._args[i];
		argTypes[i] = this$0._type;
	}
	return argTypes;
};


function MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$($this) {
	var argTypes;
	var i;
	var this$0;
	argTypes = [];
	for (i = 0; i < $this._args.length; ++i) {
		this$0 = $this._args[i];
		argTypes[i] = this$0._type;
	}
	return argTypes;
};

MemberFunctionDefinition.getArgumentTypes$LMemberFunctionDefinition$ = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.getFuncLocal$ = function () {
	return this._funcLocal;
};


function MemberFunctionDefinition$getFuncLocal$LMemberFunctionDefinition$($this) {
	return $this._funcLocal;
};

MemberFunctionDefinition.getFuncLocal$LMemberFunctionDefinition$ = MemberFunctionDefinition$getFuncLocal$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.setFuncLocal$LLocalVariable$ = function (funcLocal) {
	this._funcLocal = funcLocal;
};


function MemberFunctionDefinition$setFuncLocal$LMemberFunctionDefinition$LLocalVariable$($this, funcLocal) {
	$this._funcLocal = funcLocal;
};

MemberFunctionDefinition.setFuncLocal$LMemberFunctionDefinition$LLocalVariable$ = MemberFunctionDefinition$setFuncLocal$LMemberFunctionDefinition$LLocalVariable$;

MemberFunctionDefinition.prototype.getParent$ = function () {
	return this._parent;
};


function MemberFunctionDefinition$getParent$LMemberFunctionDefinition$($this) {
	return $this._parent;
};

MemberFunctionDefinition.getParent$LMemberFunctionDefinition$ = MemberFunctionDefinition$getParent$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.setParent$LMemberFunctionDefinition$ = function (parent) {
	this._parent = parent;
};


function MemberFunctionDefinition$setParent$LMemberFunctionDefinition$LMemberFunctionDefinition$($this, parent) {
	$this._parent = parent;
};

MemberFunctionDefinition.setParent$LMemberFunctionDefinition$LMemberFunctionDefinition$ = MemberFunctionDefinition$setParent$LMemberFunctionDefinition$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.getLocals$ = function () {
	return this._locals;
};


function MemberFunctionDefinition$getLocals$LMemberFunctionDefinition$($this) {
	return $this._locals;
};

MemberFunctionDefinition.getLocals$LMemberFunctionDefinition$ = MemberFunctionDefinition$getLocals$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.getStatements$ = function () {
	return this._statements;
};


function MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$($this) {
	return $this._statements;
};

MemberFunctionDefinition.getStatements$LMemberFunctionDefinition$ = MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$;

MemberFunctionDefinition.prototype.setStatements$ALStatement$ = function (statements) {
	this._statements = statements;
};


function MemberFunctionDefinition$setStatements$LMemberFunctionDefinition$ALStatement$($this, statements) {
	$this._statements = statements;
};

MemberFunctionDefinition.setStatements$LMemberFunctionDefinition$ALStatement$ = MemberFunctionDefinition$setStatements$LMemberFunctionDefinition$ALStatement$;

MemberFunctionDefinition.prototype.getLocal$LAnalysisContext$S = function (context, name) {
	var i;
	var block;
	var j;
	var local;
	var arg;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	for (i = context.blockStack.length - 1; i >= 0; --i) {
		block = context.blockStack[i].block;
		if (block instanceof MemberFunctionDefinition) {
			for (j = 0; j < block._locals.length; ++j) {
				local = block._locals[j];
				if ((this$0 = local._name, this$0._value) === name) {
					return local;
				}
			}
			for (j = 0; j < block._args.length; ++j) {
				arg = block._args[j];
				if ((this$1 = arg._name, this$1._value) === name) {
					return arg;
				}
			}
		} else if (block instanceof CatchStatement) {
			this$2 = block;
			local = this$2._local;
			if ((this$3 = local._name, this$3._value) === name) {
				return local;
			}
		}
	}
	return null;
};


function MemberFunctionDefinition$getLocal$LMemberFunctionDefinition$LAnalysisContext$S($this, context, name) {
	var i;
	var block;
	var j;
	var local;
	var arg;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	for (i = context.blockStack.length - 1; i >= 0; --i) {
		block = context.blockStack[i].block;
		if (block instanceof MemberFunctionDefinition) {
			for (j = 0; j < block._locals.length; ++j) {
				local = block._locals[j];
				if ((this$0 = local._name, this$0._value) === name) {
					return local;
				}
			}
			for (j = 0; j < block._args.length; ++j) {
				arg = block._args[j];
				if ((this$1 = arg._name, this$1._value) === name) {
					return arg;
				}
			}
		} else if (block instanceof CatchStatement) {
			this$2 = block;
			local = this$2._local;
			if ((this$3 = local._name, this$3._value) === name) {
				return local;
			}
		}
	}
	return null;
};

MemberFunctionDefinition.getLocal$LMemberFunctionDefinition$LAnalysisContext$S = MemberFunctionDefinition$getLocal$LMemberFunctionDefinition$LAnalysisContext$S;

MemberFunctionDefinition.prototype.getType$ = function () {
	return ((this._flags & 8) !== 0 ? new StaticFunctionType(this._token, this._returnType, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this), false) : new MemberFunctionType(this._token, new ObjectType(this._classDef), this._returnType, MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(this), false));
};


MemberFunctionDefinition.prototype.deductTypeIfUnknown$LAnalysisContext$LResolvedFunctionType$ = function (context, type) {
	var i;
	var this$0;
	var this$1;
	var type$0;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var type$1;
	var this$6;
	var type$2;
	var this$7;
	var this$8;
	var _args$0;
	for (i = 0; i < this._args.length; ++i) {
		if ((this$0 = this._args[i], this$0._type) == null) {
			break;
		}
	}
	if (i === this._args.length && this._returnType != null) {
		if (this._funcLocal != null) {
			this$1 = this._funcLocal;
			type$0 = this.getType$();
			this$1._type = type$0;
		}
		return true;
	}
	if (type._argTypes.length !== this._args.length) {
		context.errors.push(new CompileError(this._token, "expected the function to have " + (type._argTypes.length + "") + " arguments, but found " + (this._args.length + "")));
		return false;
	} else if ((_args$0 = this._args).length !== 0 && type._argTypes[_args$0.length - 1] instanceof VariableLengthArgumentType) {
		context.errors.push(new CompileError(this._token, "could not deduct function argument (left hand expression is a function with an variable-length argument)"));
		return false;
	}
	for (i = 0; i < this._args.length; ++i) {
		if (type._argTypes[i] != null) {
			if ((this$8 = this._args[i], this$8._type) != null) {
				if (! (this$7 = this._args[i], this$7._type).equals$LType$(type._argTypes[i])) {
					context.errors.push(new CompileError(this._token, "detected type conflict for argument '" + (this$3 = (this$2 = this._args[i], this$2._name), this$3._value) + "' (expected '" + type._argTypes[i].toString() + "' but found '" + (this$4 = this._args[i], this$4._type).toString() + "'"));
					return false;
				}
			} else {
				this$5 = this._args[i];
				type$1 = type._argTypes[i];
				this$5._type = type$1;
			}
		}
	}
	if (type._returnType != null) {
		if (this._returnType != null) {
			if (! this._returnType.equals$LType$(type._returnType)) {
				context.errors.push(new CompileError(this._token, "detected return type conflict, expected '" + type._returnType.toString() + "' but found '" + this._returnType.toString() + "'"));
				return false;
			}
		} else {
			this._returnType = type._returnType;
		}
	}
	if (this._funcLocal != null) {
		this$6 = this._funcLocal;
		type$2 = this.getType$();
		this$6._type = type$2;
	}
	return true;
};


function MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$($this, context, type) {
	var i;
	var this$0;
	var this$1;
	var type$0;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var type$1;
	var this$6;
	var type$2;
	var this$7;
	var this$8;
	var _args$0;
	for (i = 0; i < $this._args.length; ++i) {
		if ((this$0 = $this._args[i], this$0._type) == null) {
			break;
		}
	}
	if (i === $this._args.length && $this._returnType != null) {
		if ($this._funcLocal != null) {
			this$1 = $this._funcLocal;
			type$0 = $this.getType$();
			this$1._type = type$0;
		}
		return true;
	}
	if (type._argTypes.length !== $this._args.length) {
		context.errors.push(new CompileError($this._token, "expected the function to have " + (type._argTypes.length + "") + " arguments, but found " + ($this._args.length + "")));
		return false;
	} else if ((_args$0 = $this._args).length !== 0 && type._argTypes[_args$0.length - 1] instanceof VariableLengthArgumentType) {
		context.errors.push(new CompileError($this._token, "could not deduct function argument (left hand expression is a function with an variable-length argument)"));
		return false;
	}
	for (i = 0; i < $this._args.length; ++i) {
		if (type._argTypes[i] != null) {
			if ((this$8 = $this._args[i], this$8._type) != null) {
				if (! (this$7 = $this._args[i], this$7._type).equals$LType$(type._argTypes[i])) {
					context.errors.push(new CompileError($this._token, "detected type conflict for argument '" + (this$3 = (this$2 = $this._args[i], this$2._name), this$3._value) + "' (expected '" + type._argTypes[i].toString() + "' but found '" + (this$4 = $this._args[i], this$4._type).toString() + "'"));
					return false;
				}
			} else {
				this$5 = $this._args[i];
				type$1 = type._argTypes[i];
				this$5._type = type$1;
			}
		}
	}
	if (type._returnType != null) {
		if ($this._returnType != null) {
			if (! $this._returnType.equals$LType$(type._returnType)) {
				context.errors.push(new CompileError($this._token, "detected return type conflict, expected '" + type._returnType.toString() + "' but found '" + $this._returnType.toString() + "'"));
				return false;
			}
		} else {
			$this._returnType = type._returnType;
		}
	}
	if ($this._funcLocal != null) {
		this$6 = $this._funcLocal;
		type$2 = $this.getType$();
		this$6._type = type$2;
	}
	return true;
};

MemberFunctionDefinition.deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$ = MemberFunctionDefinition$deductTypeIfUnknown$LMemberFunctionDefinition$LAnalysisContext$LResolvedFunctionType$;

MemberFunctionDefinition.prototype.forEachStatement$F$LStatement$B$ = function (cb) {
	return Util$forEachStatement$F$LStatement$B$ALStatement$(cb, this._statements);
};


function MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$($this, cb) {
	return Util$forEachStatement$F$LStatement$B$ALStatement$(cb, $this._statements);
};

MemberFunctionDefinition.forEachStatement$LMemberFunctionDefinition$F$LStatement$B$ = MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$;

MemberFunctionDefinition.prototype.forEachStatement$F$LStatement$F$LStatement$V$B$ = function (cb) {
	return Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$(cb, this._statements);
};


function MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$F$LStatement$V$B$($this, cb) {
	return Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$(cb, $this._statements);
};

MemberFunctionDefinition.forEachStatement$LMemberFunctionDefinition$F$LStatement$F$LStatement$V$B$ = MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$F$LStatement$V$B$;

function InstantiatedMemberFunctionDefinition(token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment) {
	MemberFunctionDefinition.call(this, token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment);
};

$__jsx_extend([InstantiatedMemberFunctionDefinition], MemberFunctionDefinition);
function TemplateFunctionDefinition(token, name, flags, typeArgs, returnType, args, locals, statements, closures, lastTokenOfBody, docComment) {
	var $this = this;
	MemberFunctionDefinition.call(this, token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment);
	this._resolvedTypemap = null;
	this._instantiatedDefs = null;
	this._typeArgs = typeArgs.concat([]);
	this._instantiatedDefs = ({_list: [], _equalsCallback: (function (x, y) {
		var i;
		var x$len$0;
		for ((i = 0, x$len$0 = x.length); i < x$len$0; ++i) {
			if (! x[i].equals$LType$(y[i])) {
				return false;
			}
		}
		return true;
	})});
	this._resolvedTypemap = {};
};

$__jsx_extend([TemplateFunctionDefinition], MemberFunctionDefinition);
$__jsx_merge_interface(TemplateFunctionDefinition, TemplateDefinition);

TemplateFunctionDefinition.prototype.getType$ = function () {
	return new TemplateFunctionType(this._token, this);
};


TemplateFunctionDefinition.prototype.getResolvedTypemap$ = function () {
	return this._resolvedTypemap;
};


function TemplateFunctionDefinition$getResolvedTypemap$LTemplateFunctionDefinition$($this) {
	return $this._resolvedTypemap;
};

TemplateFunctionDefinition.getResolvedTypemap$LTemplateFunctionDefinition$ = TemplateFunctionDefinition$getResolvedTypemap$LTemplateFunctionDefinition$;

TemplateFunctionDefinition.prototype.getTypeArguments$ = function () {
	return this._typeArgs;
};


function TemplateFunctionDefinition$getTypeArguments$LTemplateFunctionDefinition$($this) {
	return $this._typeArgs;
};

TemplateFunctionDefinition.getTypeArguments$LTemplateFunctionDefinition$ = TemplateFunctionDefinition$getTypeArguments$LTemplateFunctionDefinition$;

TemplateFunctionDefinition.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var instantiated;
	var k;
	instantiated = new TemplateFunctionDefinition(this._token, this._nameToken, this._flags, this._typeArgs.concat([  ]), this._returnType, this._args.concat([  ]), this._locals, this._statements, this._closures, this._lastTokenOfBody, this._docComment);
	for (k in this._resolvedTypemap) {
		instantiated._resolvedTypemap[k] = this._resolvedTypemap[k];
	}
	for (k in instantiationContext.typemap) {
		instantiated._resolvedTypemap[k] = instantiationContext.typemap[k];
	}
	return instantiated;
};


TemplateFunctionDefinition.prototype.instantiateByArgumentTypes$ALCompileError$ALCompileNote$LToken$ALType$B = function (errors, notes, token, actualArgTypes, exact) {
	var $this = this;
	var typemap;
	var i;
	var k;
	var unify;
	var formalArgTypes;
	var typeArgs;
	var remains;
	var this$0;
	var argTypes$0;
	var i$0;
	var this$0$0;
	var this$1;
	var formalArgTypes$len$0;
	typemap = {};
	for (i = 0; i < this._typeArgs.length; ++i) {
		typemap[(this$0 = this._typeArgs[i], this$0._value)] = null;
	}
	for (k in this._resolvedTypemap) {
		typemap[k] = this._resolvedTypemap[k];
	}
	function unify(formal, actual) {
		var expectedType;
		var parser;
		var formalClassDef;
		var actualClassDef;
		var formalTypeArgs;
		var actualTypeArgs;
		var i;
		var formalFuncType;
		var actualFuncType;
		var this$0;
		var this$0$0;
		var this$1;
		var this$2;
		var this$0$1;
		var this$3;
		var this$4;
		var this$5;
		var context$0;
		var this$6;
		var this$7;
		var this$8;
		var this$9;
		var this$10;
		var this$11;
		var this$12;
		var this$13;
		var this$14;
		var this$15;
		var this$16;
		var this$17;
		var this$18;
		var this$0$2;
		var this$19;
		var formalTypeArgs$len$0;
		if (formal instanceof ParsedObjectType && (this$13 = formal, this$13._typeArguments).length === 0 && (this$15 = (this$14 = formal, this$14._qualifiedName), this$15._import) == null && (this$17 = (this$16 = formal, this$16._qualifiedName), this$17._enclosingType) == null && $__jsx_ObjectHasOwnProperty.call(typemap, (this$19 = (this$18 = formal, this$0$2 = this$18._qualifiedName, this$0$2._token), this$19._value))) {
			expectedType = typemap[(this$1 = (this$0 = formal, this$0$0 = this$0._qualifiedName, this$0$0._token), this$1._value)];
			if (expectedType != null) {
				if (exact && ! expectedType.equals$LType$(actual)) {
					return false;
				}
				if (! actual.isConvertibleTo$LType$(expectedType)) {
					notes.push(new CompileNote(token, "expected " + expectedType.toString() + ", but got " + actual.toString()));
					return false;
				}
			} else {
				typemap[(this$3 = (this$2 = formal, this$0$1 = this$2._qualifiedName, this$0$1._token), this$3._value)] = actual;
			}
		} else if (formal instanceof ParsedObjectType) {
			if (! (actual instanceof ObjectType)) {
				notes.push(new CompileNote(token, "expected " + formal.toString() + ", but got " + actual.toString()));
				return false;
			}
			this$4 = $this._classDef;
			parser = this$4._parser;
			if ((this$12 = formal, this$12._typeArguments).length === 0) {
				this$5 = formal;
				context$0 = ({errors: errors, parser: parser, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null});
				if (this$5._classDef == null) {
					this$5._classDef = QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$(this$5._qualifiedName, context$0, this$5._typeArguments);
				}
				if (! actual.isConvertibleTo$LType$(formal)) {
					notes.push(new CompileNote(token, "expected " + formal.toString() + ", but got " + actual.toString()));
					return false;
				}
			} else {
				formalClassDef = QualifiedName$getTemplateClass$LQualifiedName$LParser$((this$6 = formal, this$6._qualifiedName), parser);
				this$7 = actual;
				actualClassDef = this$7._classDef;
				if (formalClassDef == null) {
					notes.push(new CompileNote(token, "not matching class definition " + formal.toString()));
					return false;
				}
				if (! (actualClassDef instanceof InstantiatedClassDefinition && formalClassDef == (this$8 = actualClassDef, this$8._templateClassDef))) {
					notes.push(new CompileNote(token, "expected " + formal.toString() + ", but got " + actual.toString()));
					return false;
				}
				this$9 = formal;
				formalTypeArgs = this$9._typeArguments;
				this$10 = actualClassDef;
				actualTypeArgs = this$10._typeArguments;
				for ((i = 0, formalTypeArgs$len$0 = formalTypeArgs.length); i < formalTypeArgs$len$0; ++i) {
					if (! unify(formalTypeArgs[i], actualTypeArgs[i])) {
						return false;
					}
				}
			}
		} else if (formal instanceof NullableType) {
			if (! unify((this$11 = formal, this$11._baseType), actual)) {
				return false;
			}
		} else if (formal instanceof StaticFunctionType) {
			if (! (actual instanceof StaticFunctionType)) {
				notes.push(new CompileNote(token, "expected " + formal.toString() + ", but got " + actual.toString()));
				return false;
			}
			formalFuncType = formal;
			actualFuncType = actual;
			if (formalFuncType._argTypes.length !== actualFuncType._argTypes.length) {
				notes.push(new CompileNote(token, "expected " + formal.toString() + ", but got " + actual.toString()));
				return false;
			}
			for (i = 0; i < formalFuncType._argTypes.length; ++i) {
				if (! unify(formalFuncType._argTypes[i], actualFuncType._argTypes[i])) {
					return false;
				}
			}
			if (! unify(formalFuncType._returnType, actualFuncType._returnType)) {
				return false;
			}
		} else {
			if (exact && ! formal.equals$LType$(actual)) {
				return false;
			}
			if (! actual.isConvertibleTo$LType$(formal)) {
				notes.push(new CompileNote(token, "expected " + formal.toString() + ", but got " + actual.toString()));
				return false;
			}
		}
		return true;
	}
	argTypes$0 = [];
	for (i$0 = 0; i$0 < this._args.length; ++i$0) {
		this$0$0 = this._args[i$0];
		argTypes$0[i$0] = this$0$0._type;
	}
	formalArgTypes = argTypes$0;
	for ((i = 0, formalArgTypes$len$0 = formalArgTypes.length); i < formalArgTypes$len$0; ++i) {
		if (! unify(formalArgTypes[i], actualArgTypes[i])) {
			break;
		}
	}
	if (i !== formalArgTypes.length) {
		return null;
	}
	typeArgs = [];
	for (i = 0; i < this._typeArgs.length; ++i) {
		if ((typeArgs[i] = typemap[(this$1 = this._typeArgs[i], this$1._value)]) == null) {
			break;
		}
	}
	if (i !== this._typeArgs.length) {
		remains = [];
		this._typeArgs.forEach((function (typeArg) {
			if (typemap[typeArg._value] == null) {
				remains.push(typeArg._value);
			}
		}));
		notes.push(new CompileNote(token, "cannot decide type parameter(s) from given argument expressions: " + remains.join(", ")));
		return null;
	} else {
		return TemplateFunctionDefinition$instantiateTemplateFunction$LTemplateFunctionDefinition$ALCompileError$LToken$ALType$(this, errors, token, typeArgs);
	}
};


function TemplateFunctionDefinition$instantiateByArgumentTypes$LTemplateFunctionDefinition$ALCompileError$ALCompileNote$LToken$ALType$B($this, errors, notes, token, actualArgTypes, exact) {
	var typemap;
	var i;
	var k;
	var unify;
	var formalArgTypes;
	var typeArgs;
	var remains;
	var this$0;
	var argTypes$0;
	var i$0;
	var this$0$0;
	var this$1;
	var formalArgTypes$len$0;
	typemap = {};
	for (i = 0; i < $this._typeArgs.length; ++i) {
		typemap[(this$0 = $this._typeArgs[i], this$0._value)] = null;
	}
	for (k in $this._resolvedTypemap) {
		typemap[k] = $this._resolvedTypemap[k];
	}
	function unify(formal, actual) {
		var expectedType;
		var parser;
		var formalClassDef;
		var actualClassDef;
		var formalTypeArgs;
		var actualTypeArgs;
		var i;
		var formalFuncType;
		var actualFuncType;
		var this$0;
		var this$0$0;
		var this$1;
		var this$2;
		var this$0$1;
		var this$3;
		var this$4;
		var this$5;
		var context$0;
		var this$6;
		var this$7;
		var this$8;
		var this$9;
		var this$10;
		var this$11;
		var this$12;
		var this$13;
		var this$14;
		var this$15;
		var this$16;
		var this$17;
		var this$18;
		var this$0$2;
		var this$19;
		var formalTypeArgs$len$0;
		if (formal instanceof ParsedObjectType && (this$13 = formal, this$13._typeArguments).length === 0 && (this$15 = (this$14 = formal, this$14._qualifiedName), this$15._import) == null && (this$17 = (this$16 = formal, this$16._qualifiedName), this$17._enclosingType) == null && $__jsx_ObjectHasOwnProperty.call(typemap, (this$19 = (this$18 = formal, this$0$2 = this$18._qualifiedName, this$0$2._token), this$19._value))) {
			expectedType = typemap[(this$1 = (this$0 = formal, this$0$0 = this$0._qualifiedName, this$0$0._token), this$1._value)];
			if (expectedType != null) {
				if (exact && ! expectedType.equals$LType$(actual)) {
					return false;
				}
				if (! actual.isConvertibleTo$LType$(expectedType)) {
					notes.push(new CompileNote(token, "expected " + expectedType.toString() + ", but got " + actual.toString()));
					return false;
				}
			} else {
				typemap[(this$3 = (this$2 = formal, this$0$1 = this$2._qualifiedName, this$0$1._token), this$3._value)] = actual;
			}
		} else if (formal instanceof ParsedObjectType) {
			if (! (actual instanceof ObjectType)) {
				notes.push(new CompileNote(token, "expected " + formal.toString() + ", but got " + actual.toString()));
				return false;
			}
			this$4 = $this._classDef;
			parser = this$4._parser;
			if ((this$12 = formal, this$12._typeArguments).length === 0) {
				this$5 = formal;
				context$0 = ({errors: errors, parser: parser, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null});
				if (this$5._classDef == null) {
					this$5._classDef = QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$(this$5._qualifiedName, context$0, this$5._typeArguments);
				}
				if (! actual.isConvertibleTo$LType$(formal)) {
					notes.push(new CompileNote(token, "expected " + formal.toString() + ", but got " + actual.toString()));
					return false;
				}
			} else {
				formalClassDef = QualifiedName$getTemplateClass$LQualifiedName$LParser$((this$6 = formal, this$6._qualifiedName), parser);
				this$7 = actual;
				actualClassDef = this$7._classDef;
				if (formalClassDef == null) {
					notes.push(new CompileNote(token, "not matching class definition " + formal.toString()));
					return false;
				}
				if (! (actualClassDef instanceof InstantiatedClassDefinition && formalClassDef == (this$8 = actualClassDef, this$8._templateClassDef))) {
					notes.push(new CompileNote(token, "expected " + formal.toString() + ", but got " + actual.toString()));
					return false;
				}
				this$9 = formal;
				formalTypeArgs = this$9._typeArguments;
				this$10 = actualClassDef;
				actualTypeArgs = this$10._typeArguments;
				for ((i = 0, formalTypeArgs$len$0 = formalTypeArgs.length); i < formalTypeArgs$len$0; ++i) {
					if (! unify(formalTypeArgs[i], actualTypeArgs[i])) {
						return false;
					}
				}
			}
		} else if (formal instanceof NullableType) {
			if (! unify((this$11 = formal, this$11._baseType), actual)) {
				return false;
			}
		} else if (formal instanceof StaticFunctionType) {
			if (! (actual instanceof StaticFunctionType)) {
				notes.push(new CompileNote(token, "expected " + formal.toString() + ", but got " + actual.toString()));
				return false;
			}
			formalFuncType = formal;
			actualFuncType = actual;
			if (formalFuncType._argTypes.length !== actualFuncType._argTypes.length) {
				notes.push(new CompileNote(token, "expected " + formal.toString() + ", but got " + actual.toString()));
				return false;
			}
			for (i = 0; i < formalFuncType._argTypes.length; ++i) {
				if (! unify(formalFuncType._argTypes[i], actualFuncType._argTypes[i])) {
					return false;
				}
			}
			if (! unify(formalFuncType._returnType, actualFuncType._returnType)) {
				return false;
			}
		} else {
			if (exact && ! formal.equals$LType$(actual)) {
				return false;
			}
			if (! actual.isConvertibleTo$LType$(formal)) {
				notes.push(new CompileNote(token, "expected " + formal.toString() + ", but got " + actual.toString()));
				return false;
			}
		}
		return true;
	}
	argTypes$0 = [];
	for (i$0 = 0; i$0 < $this._args.length; ++i$0) {
		this$0$0 = $this._args[i$0];
		argTypes$0[i$0] = this$0$0._type;
	}
	formalArgTypes = argTypes$0;
	for ((i = 0, formalArgTypes$len$0 = formalArgTypes.length); i < formalArgTypes$len$0; ++i) {
		if (! unify(formalArgTypes[i], actualArgTypes[i])) {
			break;
		}
	}
	if (i !== formalArgTypes.length) {
		return null;
	}
	typeArgs = [];
	for (i = 0; i < $this._typeArgs.length; ++i) {
		if ((typeArgs[i] = typemap[(this$1 = $this._typeArgs[i], this$1._value)]) == null) {
			break;
		}
	}
	if (i !== $this._typeArgs.length) {
		remains = [];
		$this._typeArgs.forEach((function (typeArg) {
			if (typemap[typeArg._value] == null) {
				remains.push(typeArg._value);
			}
		}));
		notes.push(new CompileNote(token, "cannot decide type parameter(s) from given argument expressions: " + remains.join(", ")));
		return null;
	} else {
		return TemplateFunctionDefinition$instantiateTemplateFunction$LTemplateFunctionDefinition$ALCompileError$LToken$ALType$($this, errors, token, typeArgs);
	}
};

TemplateFunctionDefinition.instantiateByArgumentTypes$LTemplateFunctionDefinition$ALCompileError$ALCompileNote$LToken$ALType$B = TemplateFunctionDefinition$instantiateByArgumentTypes$LTemplateFunctionDefinition$ALCompileError$ALCompileNote$LToken$ALType$B;

TemplateFunctionDefinition.prototype.instantiateTemplateFunction$ALCompileError$LToken$ALType$ = function (errors, token, typeArgs) {
	var $this = this;
	var instantiated;
	var instantiationContext;
	var k;
	var analysisContext;
	var i;
	var classDef$0;
	var this$0;
	var this$1;
	var _classDef$0;
	instantiated = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$get$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$(this._instantiatedDefs, typeArgs);
	if (instantiated != null) {
		return instantiated;
	}
	instantiationContext = this.buildInstantiationContext$ALCompileError$LToken$ALToken$ALType$(errors, token, this._typeArgs, typeArgs);
	if (instantiationContext == null) {
		return null;
	}
	for (k in this._resolvedTypemap) {
		instantiationContext.typemap[k] = this._resolvedTypemap[k];
	}
	instantiated = MemberFunctionDefinition$_instantiateCore$LMemberFunctionDefinition$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$(this, instantiationContext, (function (token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment) {
		return new InstantiatedMemberFunctionDefinition(token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment);
	}));
	if (instantiated == null) {
		return null;
	}
	classDef$0 = _classDef$0 = this._classDef;
	instantiated._classDef = classDef$0;
	_classDef$0._members.push(instantiated);
	analysisContext = ({errors: errors, parser: (this$0 = this._classDef, this$0._parser), postInstantiationCallback: (function (parser, classDef) {
		throw new Error("not implemented");
	}), funcDef: null, blockStack: null, statement: null});
	for (i = 0; i < instantiationContext.objectTypesUsed.length; ++i) {
		this$1 = instantiationContext.objectTypesUsed[i];
		if (this$1._classDef == null) {
			this$1._classDef = QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$(this$1._qualifiedName, analysisContext, this$1._typeArguments);
		}
	}
	MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$(instantiated, analysisContext);
	TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$set$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$LMemberFunctionDefinition$(this._instantiatedDefs, typeArgs.concat([]), instantiated);
	return instantiated;
};


function TemplateFunctionDefinition$instantiateTemplateFunction$LTemplateFunctionDefinition$ALCompileError$LToken$ALType$($this, errors, token, typeArgs) {
	var instantiated;
	var instantiationContext;
	var k;
	var analysisContext;
	var i;
	var classDef$0;
	var this$0;
	var this$1;
	var _classDef$0;
	instantiated = TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$get$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$($this._instantiatedDefs, typeArgs);
	if (instantiated != null) {
		return instantiated;
	}
	instantiationContext = $this.buildInstantiationContext$ALCompileError$LToken$ALToken$ALType$(errors, token, $this._typeArgs, typeArgs);
	if (instantiationContext == null) {
		return null;
	}
	for (k in $this._resolvedTypemap) {
		instantiationContext.typemap[k] = $this._resolvedTypemap[k];
	}
	instantiated = MemberFunctionDefinition$_instantiateCore$LMemberFunctionDefinition$LInstantiationContext$F$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$LMemberFunctionDefinition$$($this, instantiationContext, (function (token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment) {
		return new InstantiatedMemberFunctionDefinition(token, name, flags, returnType, args, locals, statements, closures, lastTokenOfBody, docComment);
	}));
	if (instantiated == null) {
		return null;
	}
	classDef$0 = _classDef$0 = $this._classDef;
	instantiated._classDef = classDef$0;
	_classDef$0._members.push(instantiated);
	analysisContext = ({errors: errors, parser: (this$0 = $this._classDef, this$0._parser), postInstantiationCallback: (function (parser, classDef) {
		throw new Error("not implemented");
	}), funcDef: null, blockStack: null, statement: null});
	for (i = 0; i < instantiationContext.objectTypesUsed.length; ++i) {
		this$1 = instantiationContext.objectTypesUsed[i];
		if (this$1._classDef == null) {
			this$1._classDef = QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$(this$1._qualifiedName, analysisContext, this$1._typeArguments);
		}
	}
	MemberFunctionDefinition$analyze$LMemberFunctionDefinition$LAnalysisContext$(instantiated, analysisContext);
	TypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$set$LTypedMap$x2E$x3CArray$x2E$x3CType$x3E$x2CMemberFunctionDefinition$x3E$ALType$LMemberFunctionDefinition$($this._instantiatedDefs, typeArgs.concat([]), instantiated);
	return instantiated;
};

TemplateFunctionDefinition.instantiateTemplateFunction$LTemplateFunctionDefinition$ALCompileError$LToken$ALType$ = TemplateFunctionDefinition$instantiateTemplateFunction$LTemplateFunctionDefinition$ALCompileError$LToken$ALType$;

function TemplateClassDefinition(token, className, flags, typeArgs, extendType, implementTypes, members, inners, templateInners, objectTypesUsed, docComment) {
	ClassDefinition.call(this, token, className, flags, extendType, implementTypes, members, inners, templateInners, objectTypesUsed, docComment);
	this._token = token;
	this._className = className;
	this._flags = flags;
	this._typeArgs = typeArgs.concat([]);
	ClassDefinition$_generateWrapperFunctions$LClassDefinition$(this);
};

$__jsx_extend([TemplateClassDefinition], ClassDefinition);
$__jsx_merge_interface(TemplateClassDefinition, TemplateDefinition);

TemplateClassDefinition.prototype.getToken$ = function () {
	return this._token;
};


TemplateClassDefinition.prototype.className$ = function () {
	return this._className;
};


TemplateClassDefinition.prototype.flags$ = function () {
	return this._flags;
};


TemplateClassDefinition.prototype.getTypeArguments$ = function () {
	return this._typeArgs;
};


function TemplateClassDefinition$getTypeArguments$LTemplateClassDefinition$($this) {
	return $this._typeArgs;
};

TemplateClassDefinition.getTypeArguments$LTemplateClassDefinition$ = TemplateClassDefinition$getTypeArguments$LTemplateClassDefinition$;

TemplateClassDefinition.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	var typemap;
	var key;
	var i;
	var context;
	var succeeded;
	var members;
	var member;
	var inners;
	var inner;
	var templateInners;
	var templateInner;
	var extendType;
	var type;
	var implementTypes;
	var this$0;
	var this$1;
	var this$0$0;
	var this$2;
	var this$0$1;
	typemap = {};
	for (key in instantiationContext.typemap) {
		typemap[key] = instantiationContext.typemap[key];
	}
	for (i = 0; i < this._typeArgs.length; ++i) {
		delete typemap[(this$0 = this._typeArgs[i], this$0._value)];
	}
	context = ({errors: instantiationContext.errors, typemap: typemap, objectTypesUsed: []});
	succeeded = true;
	members = [];
	for (i = 0; i < this._members.length; ++i) {
		member = this._members[i].instantiate$LInstantiationContext$(context);
		if (member == null) {
			succeeded = false;
		}
		members[i] = member;
	}
	inners = [];
	for (i = 0; i < this._inners.length; ++i) {
		inner = this._inners[i].instantiate$LInstantiationContext$(context);
		if (inner == null) {
			succeeded = false;
		}
		inners[i] = inner;
	}
	templateInners = [];
	for (i = 0; i < this._templateInners.length; ++i) {
		templateInner = this._templateInners[i].instantiate$LInstantiationContext$(context);
		if (templateInner == null) {
			succeeded = false;
		}
		templateInners[i] = templateInner;
	}
	if (! succeeded) {
		return null;
	}
	extendType = null;
	if (this._extendType != null) {
		type = this._extendType.instantiate$LInstantiationContext$B(instantiationContext, false);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError((this$1 = this._extendType, this$0$0 = this$1._qualifiedName, this$0$0._token), "non-object type is not extensible"));
			return null;
		}
		extendType = type;
	}
	implementTypes = [];
	for (i = 0; i < this._implementTypes.length; ++i) {
		type = this._implementTypes[i].instantiate$LInstantiationContext$B(instantiationContext, false);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError((this$2 = this._implementTypes[i], this$0$1 = this$2._qualifiedName, this$0$1._token), "non-object type is not extensible"));
			return null;
		}
		implementTypes[i] = type;
	}
	return new TemplateClassDefinition(this._token, this._className, this._flags, this._typeArgs, extendType, implementTypes, members, inners, templateInners, context.objectTypesUsed, this._docComment);
};


TemplateClassDefinition.prototype.instantiateTemplateClass$ALCompileError$LTemplateInstantiationRequest$ = function (errors, request) {
	var instantiationContext;
	var succeeded;
	var members;
	var i;
	var member;
	var inners;
	var inner;
	var templateInners;
	var templateInner;
	var extendType;
	var type;
	var implementTypes;
	var instantiatedDef;
	var this$0;
	var this$0$0;
	var this$1;
	var this$0$1;
	instantiationContext = this.buildInstantiationContext$ALCompileError$LToken$ALToken$ALType$(errors, request._token, this._typeArgs, request._typeArgs);
	if (instantiationContext == null) {
		return null;
	}
	succeeded = true;
	members = [];
	for (i = 0; i < this._members.length; ++i) {
		member = this._members[i].instantiate$LInstantiationContext$(instantiationContext);
		if (member == null) {
			succeeded = false;
		}
		members[i] = member;
	}
	inners = [];
	for (i = 0; i < this._inners.length; ++i) {
		inner = this._inners[i].instantiate$LInstantiationContext$(instantiationContext);
		if (inner == null) {
			succeeded = false;
		}
		inners[i] = inner;
	}
	templateInners = [];
	for (i = 0; i < this._templateInners.length; ++i) {
		templateInner = this._templateInners[i].instantiate$LInstantiationContext$(instantiationContext);
		if (templateInner == null) {
			succeeded = false;
		}
		templateInners[i] = templateInner;
	}
	if (! succeeded) {
		return null;
	}
	extendType = null;
	if (this._extendType != null) {
		type = this._extendType.instantiate$LInstantiationContext$B(instantiationContext, false);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError((this$0 = this._extendType, this$0$0 = this$0._qualifiedName, this$0$0._token), "non-object type is not extensible"));
			return null;
		}
		extendType = type;
	}
	implementTypes = [];
	for (i = 0; i < this._implementTypes.length; ++i) {
		type = this._implementTypes[i].instantiate$LInstantiationContext$B(instantiationContext, false);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError((this$1 = this._implementTypes[i], this$0$1 = this$1._qualifiedName, this$0$1._token), "non-object type is not extensible"));
			return null;
		}
		implementTypes[i] = type;
	}
	instantiatedDef = new InstantiatedClassDefinition(this, request._typeArgs, extendType, implementTypes, members, inners, templateInners, instantiationContext.objectTypesUsed);
	return instantiatedDef;
};


function TemplateClassDefinition$instantiateTemplateClass$LTemplateClassDefinition$ALCompileError$LTemplateInstantiationRequest$($this, errors, request) {
	var instantiationContext;
	var succeeded;
	var members;
	var i;
	var member;
	var inners;
	var inner;
	var templateInners;
	var templateInner;
	var extendType;
	var type;
	var implementTypes;
	var instantiatedDef;
	var this$0;
	var this$0$0;
	var this$1;
	var this$0$1;
	instantiationContext = $this.buildInstantiationContext$ALCompileError$LToken$ALToken$ALType$(errors, request._token, $this._typeArgs, request._typeArgs);
	if (instantiationContext == null) {
		return null;
	}
	succeeded = true;
	members = [];
	for (i = 0; i < $this._members.length; ++i) {
		member = $this._members[i].instantiate$LInstantiationContext$(instantiationContext);
		if (member == null) {
			succeeded = false;
		}
		members[i] = member;
	}
	inners = [];
	for (i = 0; i < $this._inners.length; ++i) {
		inner = $this._inners[i].instantiate$LInstantiationContext$(instantiationContext);
		if (inner == null) {
			succeeded = false;
		}
		inners[i] = inner;
	}
	templateInners = [];
	for (i = 0; i < $this._templateInners.length; ++i) {
		templateInner = $this._templateInners[i].instantiate$LInstantiationContext$(instantiationContext);
		if (templateInner == null) {
			succeeded = false;
		}
		templateInners[i] = templateInner;
	}
	if (! succeeded) {
		return null;
	}
	extendType = null;
	if ($this._extendType != null) {
		type = $this._extendType.instantiate$LInstantiationContext$B(instantiationContext, false);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError((this$0 = $this._extendType, this$0$0 = this$0._qualifiedName, this$0$0._token), "non-object type is not extensible"));
			return null;
		}
		extendType = type;
	}
	implementTypes = [];
	for (i = 0; i < $this._implementTypes.length; ++i) {
		type = $this._implementTypes[i].instantiate$LInstantiationContext$B(instantiationContext, false);
		if (! (type instanceof ParsedObjectType)) {
			instantiationContext.errors.push(new CompileError((this$1 = $this._implementTypes[i], this$0$1 = this$1._qualifiedName, this$0$1._token), "non-object type is not extensible"));
			return null;
		}
		implementTypes[i] = type;
	}
	instantiatedDef = new InstantiatedClassDefinition($this, request._typeArgs, extendType, implementTypes, members, inners, templateInners, instantiationContext.objectTypesUsed);
	return instantiatedDef;
};

TemplateClassDefinition.instantiateTemplateClass$LTemplateClassDefinition$ALCompileError$LTemplateInstantiationRequest$ = TemplateClassDefinition$instantiateTemplateClass$LTemplateClassDefinition$ALCompileError$LTemplateInstantiationRequest$;

function InstantiatedClassDefinition(templateClassDef, typeArguments, extendType, implementTypes, members, inners, templateInners, objectTypesUsed) {
	ClassDefinition.call(this, null, Type$templateTypeToString$SALType$(ClassDefinition$classFullName$LClassDefinition$(templateClassDef), typeArguments), templateClassDef._flags, extendType, implementTypes, members, inners, templateInners, objectTypesUsed, null);
	this._templateClassDef = templateClassDef;
	this._typeArguments = typeArguments;
};

$__jsx_extend([InstantiatedClassDefinition], ClassDefinition);
InstantiatedClassDefinition.prototype.getTemplateClass$ = function () {
	return this._templateClassDef;
};


function InstantiatedClassDefinition$getTemplateClass$LInstantiatedClassDefinition$($this) {
	return $this._templateClassDef;
};

InstantiatedClassDefinition.getTemplateClass$LInstantiatedClassDefinition$ = InstantiatedClassDefinition$getTemplateClass$LInstantiatedClassDefinition$;

InstantiatedClassDefinition.prototype.getTemplateClassName$ = function () {
	var this$0;
	this$0 = this._templateClassDef;
	return this$0._className;
};


function InstantiatedClassDefinition$getTemplateClassName$LInstantiatedClassDefinition$($this) {
	var this$0;
	this$0 = $this._templateClassDef;
	return this$0._className;
};

InstantiatedClassDefinition.getTemplateClassName$LInstantiatedClassDefinition$ = InstantiatedClassDefinition$getTemplateClassName$LInstantiatedClassDefinition$;

InstantiatedClassDefinition.prototype.getTypeArguments$ = function () {
	return this._typeArguments;
};


function InstantiatedClassDefinition$getTypeArguments$LInstantiatedClassDefinition$($this) {
	return $this._typeArguments;
};

InstantiatedClassDefinition.getTypeArguments$LInstantiatedClassDefinition$ = InstantiatedClassDefinition$getTypeArguments$LInstantiatedClassDefinition$;

InstantiatedClassDefinition.prototype.typeArgumentsAreEqual$ALType$ = function (typeArgs) {
	var i;
	var typeArgs$len$0;
	if (! (this._typeArguments.length === typeArgs.length)) {
		return false;
	}
	for ((i = 0, typeArgs$len$0 = typeArgs.length); i < typeArgs$len$0; ++i) {
		if (! this._typeArguments[i].equals$LType$(typeArgs[i])) {
			return false;
		}
	}
	return true;
};


function InstantiatedClassDefinition$typeArgumentsAreEqual$LInstantiatedClassDefinition$ALType$($this, typeArgs) {
	var i;
	var typeArgs$len$0;
	if (! ($this._typeArguments.length === typeArgs.length)) {
		return false;
	}
	for ((i = 0, typeArgs$len$0 = typeArgs.length); i < typeArgs$len$0; ++i) {
		if (! $this._typeArguments[i].equals$LType$(typeArgs[i])) {
			return false;
		}
	}
	return true;
};

InstantiatedClassDefinition.typeArgumentsAreEqual$LInstantiatedClassDefinition$ALType$ = InstantiatedClassDefinition$typeArgumentsAreEqual$LInstantiatedClassDefinition$ALType$;

InstantiatedClassDefinition.prototype.instantiate$LInstantiationContext$ = function (instantiationContext) {
	throw new Error("logic flaw");
};


function Type() {
};

$__jsx_extend([Type], Object);
Type.prototype.serialize$ = function () {
	return this.toString();
};


function Type$serialize$LType$($this) {
	return $this.toString();
};

Type.serialize$LType$ = Type$serialize$LType$;

Type.prototype.equals$LType$ = function (x) {
	return this == x;
};


Type.prototype.resolveIfNullable$ = function () {
	var this$0;
	return (this instanceof NullableType ? (this$0 = this, this$0._baseType) : this);
};


function Type$resolveIfNullable$LType$($this) {
	var this$0;
	return ($this instanceof NullableType ? (this$0 = $this, this$0._baseType) : $this);
};

Type.resolveIfNullable$LType$ = Type$resolveIfNullable$LType$;

Type.prototype.asAssignableType$ = function () {
	return this;
};


Type.prototype.toNullableType$ = function () {
	return (this instanceof PrimitiveType || this.equals$LType$(Type.voidType) ? new NullableType(this) : this);
};


function Type$toNullableType$LType$($this) {
	return ($this instanceof PrimitiveType || $this.equals$LType$(Type.voidType) ? new NullableType($this) : $this);
};

Type.toNullableType$LType$ = Type$toNullableType$LType$;

Type.prototype.toNullableType$B = function (force) {
	return (force || this instanceof PrimitiveType || this.equals$LType$(Type.voidType) ? new NullableType(this) : this);
};


function Type$toNullableType$LType$B($this, force) {
	return (force || $this instanceof PrimitiveType || $this.equals$LType$(Type.voidType) ? new NullableType($this) : $this);
};

Type.toNullableType$LType$B = Type$toNullableType$LType$B;

Type.prototype.forEachType$F$LType$B$ = function (cb) {
	return true;
};


function Type$templateTypeToString$SALType$(parameterizedTypeName, typeArgs) {
	var s;
	var i;
	var typeArgs$len$0;
	s = parameterizedTypeName + ".<";
	for ((i = 0, typeArgs$len$0 = typeArgs.length); i < typeArgs$len$0; ++i) {
		if (i !== 0) {
			s += ",";
		}
		s += typeArgs[i].toString();
	}
	s += ">";
	return s;
};

Type.templateTypeToString$SALType$ = Type$templateTypeToString$SALType$;

function Type$isIntegerOrNumber$LType$(type) {
	return type instanceof IntegerType || type instanceof NumberType;
};

Type.isIntegerOrNumber$LType$ = Type$isIntegerOrNumber$LType$;

function Type$calcLeastCommonAncestor$LType$LType$(type1, type2) {
	return Type$calcLeastCommonAncestor$LType$LType$B(type1, type2, false);
};

Type.calcLeastCommonAncestor$LType$LType$ = Type$calcLeastCommonAncestor$LType$LType$;

function Type$calcLeastCommonAncestor$LType$LType$B(type1, type2, acceptVariant) {
	var obj1;
	var obj2;
	var ifaces1;
	var candidates;
	var i;
	var iface;
	var uniquify;
	var this$0$0;
	var type$0;
	var this$0$1;
	var type$1;
	var this$0$2;
	var this$0$3;
	var this$2;
	var this$3;
	var this$4;
	var this$0$4;
	var this$0$5;
	var this$0$6;
	var this$0$7;
	var this$0$8;
	var this$0$9;
	var this$0$10;
	var this$0$11;
	if (type1.equals$LType$(type2)) {
		return type1;
	}
	if ((type1 instanceof IntegerType || type1 instanceof NumberType) && (type2 instanceof IntegerType || type2 instanceof NumberType)) {
		return Type.numberType;
	}
	if (Type.voidType.equals$LType$(type1) || Type.voidType.equals$LType$(type2)) {
		return null;
	}
	if (Type.variantType.equals$LType$(type1) || Type.variantType.equals$LType$(type2)) {
		return Type.variantType;
	}
	if (Type.nullType.equals$LType$(type1)) {
		return ((Type.nullType, type2 instanceof NullableType || type2 instanceof ObjectType || type2 instanceof VariantType || type2 instanceof StaticFunctionType) ? type2 : new NullableType(type2));
	}
	if (Type.nullType.equals$LType$(type2)) {
		return ((Type.nullType, type1 instanceof NullableType || type1 instanceof ObjectType || type1 instanceof VariantType || type1 instanceof StaticFunctionType) ? type1 : new NullableType(type1));
	}
	if ((type1 instanceof NullableType ? (this$0$8 = type1, this$0$8._baseType) : type1) instanceof PrimitiveType || (type2 instanceof NullableType ? (this$0$9 = type2, this$0$9._baseType) : type2) instanceof PrimitiveType) {
		if ((type1 instanceof NullableType ? (this$0$6 = type1, this$0$6._baseType) : type1).equals$LType$(type2 instanceof NullableType ? (this$0$7 = type2, this$0$7._baseType) : type2)) {
			return new NullableType(type1);
		} else if ((type$0 = (type1 instanceof NullableType ? (this$0$0 = type1, this$0$0._baseType) : type1), type$0 instanceof IntegerType || type$0 instanceof NumberType) && (type$1 = (type2 instanceof NullableType ? (this$0$1 = type2, this$0$1._baseType) : type2), type$1 instanceof IntegerType || type$1 instanceof NumberType)) {
			return new NullableType(Type.numberType);
		} else {
			return (acceptVariant ? Type.variantType : null);
		}
	}
	if ((type1 instanceof NullableType ? (this$0$10 = type1, this$0$10._baseType) : type1) instanceof ObjectType && (type2 instanceof NullableType ? (this$0$11 = type2, this$0$11._baseType) : type2) instanceof ObjectType) {
		obj1 = (type1 instanceof NullableType ? (this$0$2 = type1, this$0$2._baseType) : type1);
		obj2 = (type2 instanceof NullableType ? (this$0$3 = type2, this$0$3._baseType) : type2);
		ifaces1 = [];
		for (; ; ) {
			ifaces1 = ifaces1.concat((this$2 = obj1._classDef, this$2._implementTypes).map((function (t) {
				return t;
			})));
			if (obj2.isConvertibleTo$LType$(obj1)) {
				break;
			}
			this$3 = obj1._classDef;
			obj1 = this$3._extendType;
		}
		if (obj1._classDef.className$() !== "Object") {
			return obj1;
		}
		candidates = [];
		for (i in ifaces1) { i |= 0;
			iface = ifaces1[i];
			do {
				if (obj2.isConvertibleTo$LType$(iface)) {
					candidates.push(iface);
					break;
				}
			} while (iface = (this$4 = iface._classDef, this$4._extendType));
		}
		function uniquify(list) {
			var result;
			var i;
			var j;
			result = [];
			for (i = 0; i < list.length; ++i) {
				result.push(list[i]);
				for (j = i + 1; j < list.length; ++j) {
					if (list[i].equals$LType$(list[j])) {
						result.pop();
						break;
					}
				}
			}
			return result;
		}
		candidates = uniquify(candidates);
		switch (candidates.length) {
		case 0:
			return obj1;
		case 1:
			return candidates[0];
		default:
			return null;
		}
	}
	return ((type1 instanceof NullableType ? (this$0$4 = type1, this$0$4._baseType) : type1) instanceof FunctionType && (type2 instanceof NullableType ? (this$0$5 = type2, this$0$5._baseType) : type2) instanceof FunctionType ? null : acceptVariant ? Type.variantType : null);
};

Type.calcLeastCommonAncestor$LType$LType$B = Type$calcLeastCommonAncestor$LType$LType$B;

function Type$calcLeastCommonAncestor$ALType$(types) {
	return Type$calcLeastCommonAncestor$ALType$B(types, false);
};

Type.calcLeastCommonAncestor$ALType$ = Type$calcLeastCommonAncestor$ALType$;

function Type$calcLeastCommonAncestor$ALType$B(types, acceptVariant) {
	var type;
	var i;
	var types$len$0;
	if (types.length === 0) {
		return null;
	}
	type = types[0];
	for ((i = 1, types$len$0 = types.length); i < types$len$0; ++i) {
		type = Type$calcLeastCommonAncestor$LType$LType$B(type, types[i], acceptVariant);
		if (type == null) {
			return null;
		}
	}
	return type;
};

Type.calcLeastCommonAncestor$ALType$B = Type$calcLeastCommonAncestor$ALType$B;

function VoidType() {
};

$__jsx_extend([VoidType], Type);
VoidType.prototype.instantiate$LInstantiationContext$B = function (instantiationContext, allowVoid) {
	return this;
};


VoidType.prototype.isAssignable$ = function () {
	return false;
};


VoidType.prototype.isConvertibleTo$LType$ = function (type) {
	return type.equals$LType$(Type.voidType);
};


VoidType.prototype.getClassDef$ = function () {
	throw new Error("VoidType#getClassDef() is not supported");
};


VoidType.prototype.toString = function () {
	return "void";
};


function NullType() {
};

$__jsx_extend([NullType], Type);
NullType.prototype.instantiate$LInstantiationContext$B = function (instantiationContext, allowVoid) {
	return this;
};


NullType.prototype.isAssignable$ = function () {
	return false;
};


NullType.prototype.isConvertibleTo$LType$ = function (type) {
	return type instanceof NullableType || type instanceof ObjectType || type instanceof VariantType || type instanceof StaticFunctionType;
};


NullType.prototype.getClassDef$ = function () {
	throw new Error("NullType#getClassDef() is not supported");
};


NullType.prototype.toString = function () {
	return "null";
};


function PrimitiveType() {
};

$__jsx_extend([PrimitiveType], Type);
PrimitiveType.prototype.instantiate$LInstantiationContext$B = function (instantiationContext, allowVoid) {
	return this;
};


PrimitiveType.prototype.isAssignable$ = function () {
	return true;
};


function BooleanType() {
};

$__jsx_extend([BooleanType], PrimitiveType);
BooleanType.prototype.isConvertibleTo$LType$ = function (type) {
	var this$0$0;
	type = (type instanceof NullableType ? (this$0$0 = type, this$0$0._baseType) : type);
	return type instanceof BooleanType || type instanceof VariantType;
};


BooleanType.prototype.getClassDef$ = function () {
	return BooleanType._classDef;
};


BooleanType.prototype.toString = function () {
	return "boolean";
};


function IntegerType() {
};

$__jsx_extend([IntegerType], PrimitiveType);
IntegerType.prototype.isConvertibleTo$LType$ = function (type) {
	var this$0$0;
	type = (type instanceof NullableType ? (this$0$0 = type, this$0$0._baseType) : type);
	return type instanceof IntegerType || type instanceof NumberType || type instanceof VariantType;
};


IntegerType.prototype.getClassDef$ = function () {
	return NumberType._classDef;
};


IntegerType.prototype.toString = function () {
	return "int";
};


function NumberType() {
};

$__jsx_extend([NumberType], PrimitiveType);
NumberType.prototype.isConvertibleTo$LType$ = function (type) {
	var this$0$0;
	type = (type instanceof NullableType ? (this$0$0 = type, this$0$0._baseType) : type);
	return type instanceof IntegerType || type instanceof NumberType || type instanceof VariantType;
};


NumberType.prototype.getClassDef$ = function () {
	return NumberType._classDef;
};


NumberType.prototype.toString = function () {
	return "number";
};


function StringType() {
};

$__jsx_extend([StringType], PrimitiveType);
StringType.prototype.isConvertibleTo$LType$ = function (type) {
	var this$0$0;
	type = (type instanceof NullableType ? (this$0$0 = type, this$0$0._baseType) : type);
	return type instanceof StringType || type instanceof VariantType;
};


StringType.prototype.getClassDef$ = function () {
	return StringType._classDef;
};


StringType.prototype.toString = function () {
	return "string";
};


function VariantType() {
};

$__jsx_extend([VariantType], Type);
VariantType.prototype.instantiate$LInstantiationContext$B = function (instantiationContext, allowVoid) {
	return this;
};


VariantType.prototype.isAssignable$ = function () {
	return true;
};


VariantType.prototype.isConvertibleTo$LType$ = function (type) {
	var this$0$0;
	type = (type instanceof NullableType ? (this$0$0 = type, this$0$0._baseType) : type);
	return type instanceof VariantType;
};


VariantType.prototype.getClassDef$ = function () {
	throw new Error("VariantType#getClassDef() is not supported");
};


VariantType.prototype.toString = function () {
	return "variant";
};


function NullableType(type) {
	this._baseType = null;
	if (type.equals$LType$(Type.variantType)) {
		throw new Error("logic flaw, cannot create Nullable.<variant>");
	}
	this._baseType = (type instanceof NullableType ? type._baseType : type);
};

$__jsx_extend([NullableType], Type);
NullableType.prototype.instantiate$LInstantiationContext$B = function (instantiationContext, allowVoid) {
	var baseType;
	var this$0;
	var this$0$0;
	baseType = (this$0 = this._baseType, this$0 instanceof NullableType ? (this$0$0 = this$0, this$0$0._baseType) : this$0).instantiate$LInstantiationContext$B(instantiationContext, true);
	return (baseType instanceof PrimitiveType || baseType.equals$LType$(Type.voidType) ? new NullableType(baseType) : baseType);
};


NullableType.prototype.equals$LType$ = function (x) {
	return x instanceof NullableType && this._baseType.equals$LType$(x._baseType);
};


NullableType.prototype.isConvertibleTo$LType$ = function (type) {
	return this._baseType.isConvertibleTo$LType$(type instanceof NullableType ? type._baseType : type);
};


NullableType.prototype.isAssignable$ = function () {
	return true;
};


NullableType.prototype.getClassDef$ = function () {
	return this._baseType.getClassDef$();
};


NullableType.prototype.getBaseType$ = function () {
	return this._baseType;
};


function NullableType$getBaseType$LNullableType$($this) {
	return $this._baseType;
};

NullableType.getBaseType$LNullableType$ = NullableType$getBaseType$LNullableType$;

NullableType.prototype.toString = function () {
	return "Nullable.<" + this._baseType.toString() + ">";
};


NullableType.prototype.forEachType$F$LType$B$ = function (cb) {
	return (! cb(this._baseType) ? false : true);
};


function VariableLengthArgumentType(type) {
	this._baseType = null;
	if (type instanceof VariableLengthArgumentType) {
		throw new Error("logic flaw");
	}
	this._baseType = type;
};

$__jsx_extend([VariableLengthArgumentType], Type);
VariableLengthArgumentType.prototype.instantiate$LInstantiationContext$B = function (instantiationContext, allowVoid) {
	var baseType;
	baseType = this._baseType.instantiate$LInstantiationContext$B(instantiationContext, allowVoid);
	return new VariableLengthArgumentType(baseType);
};


VariableLengthArgumentType.prototype.equals$LType$ = function (x) {
	return x instanceof VariableLengthArgumentType && this._baseType.equals$LType$(x._baseType);
};


VariableLengthArgumentType.prototype.isConvertibleTo$LType$ = function (type) {
	throw new Error("logic flaw");
};


VariableLengthArgumentType.prototype.isAssignable$ = function () {
	throw new Error("logic flaw");
};


VariableLengthArgumentType.prototype.getClassDef$ = function () {
	throw new Error("logic flaw");
};


VariableLengthArgumentType.prototype.getBaseType$ = function () {
	return this._baseType;
};


function VariableLengthArgumentType$getBaseType$LVariableLengthArgumentType$($this) {
	return $this._baseType;
};

VariableLengthArgumentType.getBaseType$LVariableLengthArgumentType$ = VariableLengthArgumentType$getBaseType$LVariableLengthArgumentType$;

VariableLengthArgumentType.prototype.toString = function () {
	return "..." + this._baseType.toString();
};


VariableLengthArgumentType.prototype.forEachType$F$LType$B$ = function (cb) {
	return (! cb(this._baseType) ? false : true);
};


function ObjectType(classDef) {
	this._classDef = classDef;
};

$__jsx_extend([ObjectType], Type);
ObjectType.prototype.instantiate$LInstantiationContext$B = function (instantiationContext, allowVoid) {
	throw new Error("logic flaw; ObjectType is created during semantic analysis, after template instantiation");
};


ObjectType.prototype.equals$LType$ = function (x) {
	var that;
	var a;
	var b;
	if (! (x instanceof ObjectType)) {
		return false;
	}
	that = x;
	if (this instanceof ParsedObjectType && x instanceof ParsedObjectType && (this._classDef == null || that._classDef == null)) {
		a = this;
		b = that;
		return QualifiedName$equals$LQualifiedName$LQualifiedName$(a._qualifiedName, b._qualifiedName) && Util$typesAreEqual$ALType$ALType$(a._typeArguments, b._typeArguments);
	}
	return this._classDef == that._classDef;
};


ObjectType.prototype.resolveType$LAnalysisContext$ = function (context) {
	if (this._classDef == null) {
		throw new Error("logic flaw");
	}
};


ObjectType.prototype.isConvertibleTo$LType$ = function (type) {
	var this$0$0;
	type = (type instanceof NullableType ? (this$0$0 = type, this$0$0._baseType) : type);
	return (type instanceof VariantType ? true : ! (type instanceof ObjectType) ? false : this._classDef == null ? false : type._classDef == null ? false : ClassDefinition$isConvertibleTo$LClassDefinition$LClassDefinition$(this._classDef, type._classDef));
};


ObjectType.prototype.isAssignable$ = function () {
	return true;
};


ObjectType.prototype.getClassDef$ = function () {
	return this._classDef;
};


ObjectType.prototype.toString = function () {
	return (this._classDef != null ? this._classDef.className$() : "(null)");
};


ObjectType.prototype.forEachType$F$LType$B$ = function (cb) {
	return true;
};


function ParsedObjectType(qualifiedName, typeArgs) {
	ObjectType.call(this, null);
	this._qualifiedName = qualifiedName;
	this._typeArguments = typeArgs;
};

$__jsx_extend([ParsedObjectType], ObjectType);
ParsedObjectType.prototype.getToken$ = function () {
	var this$0;
	this$0 = this._qualifiedName;
	return this$0._token;
};


function ParsedObjectType$getToken$LParsedObjectType$($this) {
	var this$0;
	this$0 = $this._qualifiedName;
	return this$0._token;
};

ParsedObjectType.getToken$LParsedObjectType$ = ParsedObjectType$getToken$LParsedObjectType$;

ParsedObjectType.prototype.getQualifiedName$ = function () {
	return this._qualifiedName;
};


function ParsedObjectType$getQualifiedName$LParsedObjectType$($this) {
	return $this._qualifiedName;
};

ParsedObjectType.getQualifiedName$LParsedObjectType$ = ParsedObjectType$getQualifiedName$LParsedObjectType$;

ParsedObjectType.prototype.getTypeArguments$ = function () {
	return this._typeArguments;
};


function ParsedObjectType$getTypeArguments$LParsedObjectType$($this) {
	return $this._typeArguments;
};

ParsedObjectType.getTypeArguments$LParsedObjectType$ = ParsedObjectType$getTypeArguments$LParsedObjectType$;

ParsedObjectType.prototype.instantiate$LInstantiationContext$B = function (instantiationContext, allowVoid) {
	var enclosingType;
	var actualType;
	var qualifiedName;
	var actualEnclosingType;
	var typeArgs;
	var i;
	var templateClassName;
	var objectType;
	var this$0;
	var this$1;
	var this$2;
	var this$0$0;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$0$1;
	var this$8;
	this$0 = this._qualifiedName;
	enclosingType = this$0._enclosingType;
	if (enclosingType == null && this._typeArguments.length === 0) {
		actualType = instantiationContext.typemap[(this$2 = (this$1 = this._qualifiedName, this$1._token), this$2._value)];
		if (actualType != null) {
			if (! allowVoid && actualType.equals$LType$(Type.voidType)) {
				instantiationContext.errors.push(new CompileError((this$0$0 = this._qualifiedName, this$0$0._token), "the type cannot be instantiated as void in this context"));
			}
			return actualType;
		}
		if (this._classDef == null) {
			instantiationContext.objectTypesUsed.push(this);
		}
		return this;
	}
	qualifiedName = this._qualifiedName;
	if (enclosingType != null) {
		actualEnclosingType = (this$3 = this._qualifiedName, this$3._enclosingType).instantiate$LInstantiationContext$B(instantiationContext, true);
		if (! (this$8 = this._qualifiedName, this$8._enclosingType).equals$LType$(actualEnclosingType)) {
			qualifiedName = new QualifiedName$1((this$4 = this._qualifiedName, this$4._token), actualEnclosingType);
		}
	}
	typeArgs = [];
	for (i = 0; i < this._typeArguments.length; ++i) {
		if (this._typeArguments[i] instanceof ParsedObjectType && (this$5 = this._typeArguments[i], this$5._typeArguments).length !== 0) {
			actualType = this._typeArguments[i].instantiate$LInstantiationContext$B(instantiationContext, true);
		} else {
			actualType = instantiationContext.typemap[this._typeArguments[i].toString()];
		}
		typeArgs[i] = (actualType != null ? actualType : this._typeArguments[i]);
		this$6 = qualifiedName._token;
		templateClassName = this$6._value;
		if (templateClassName === "Array" || templateClassName === "Map") {
			if (typeArgs[i] instanceof NullableType) {
				this$7 = typeArgs[i];
				typeArgs[i] = this$7._baseType;
			} else if (typeArgs[i].equals$LType$(Type.voidType)) {
				instantiationContext.errors.push(new CompileError((this$0$1 = this._qualifiedName, this$0$1._token), "cannot instantiate " + templateClassName + ".<T> with T=void"));
			}
		}
	}
	objectType = new ParsedObjectType(qualifiedName, typeArgs);
	instantiationContext.objectTypesUsed.push(objectType);
	return objectType;
};


ParsedObjectType.prototype.resolveType$LAnalysisContext$ = function (context) {
	if (this._classDef == null) {
		this._classDef = QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$(this._qualifiedName, context, this._typeArguments);
	}
};


ParsedObjectType.prototype.toString = function () {
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	return (this._typeArguments.length !== 0 ? Type$templateTypeToString$SALType$((this$1 = (this$0 = this._qualifiedName, this$0._token), this$1._value), this._typeArguments) : (this$3 = (this$2 = this._qualifiedName, this$2._token), this$3._value));
};


ParsedObjectType.prototype.forEachType$F$LType$B$ = function (cb) {
	var i;
	var this$0;
	var this$1;
	if ((this$0 = this._qualifiedName, this$0._enclosingType) != null && ! cb((this$1 = this._qualifiedName, this$1._enclosingType))) {
		return false;
	}
	for (i = 0; i < this._typeArguments.length; ++i) {
		if (! cb(this._typeArguments[i])) {
			return false;
		}
	}
	return true;
};


function FunctionType() {
};

$__jsx_extend([FunctionType], Type);
FunctionType.prototype.isConvertibleTo$LType$ = function (type) {
	return false;
};


FunctionType.prototype.getClassDef$ = function () {
	return FunctionType._classDef;
};


FunctionType.prototype.instantiate$LInstantiationContext$B = function (instantiationContext, allowVoid) {
	throw new Error("logic flaw");
};


function FunctionChoiceType(types) {
	this._types = types;
};

$__jsx_extend([FunctionChoiceType], FunctionType);
FunctionChoiceType.prototype.isAssignable$ = function () {
	return false;
};


FunctionChoiceType.prototype.asAssignableType$ = function () {
	throw new Error("logic flaw");
};


FunctionChoiceType.prototype.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B = function (context, operatorToken, argTypes, isStatic) {
	var types;
	var type;
	var i;
	var matched;
	var notes;
	var this$0;
	var this$1;
	var errors$0;
	var types$len$0;
	types = this._types;
	for ((i = 0, types$len$0 = types.length); i < types$len$0; ++i) {
		if ((type = types[i]._deduceByArgumentTypes$LToken$ALType$BBALCompileNote$((this$0 = types[i], this$0._token), argTypes, isStatic, true, [  ])) != null) {
			return type;
		}
	}
	matched = [];
	notes = [];
	for (i = 0; i < types.length; ++i) {
		if ((type = types[i]._deduceByArgumentTypes$LToken$ALType$BBALCompileNote$((this$1 = types[i], this$1._token), argTypes, isStatic, false, notes)) != null) {
			matched.push(type);
		}
	}
	switch (matched.length) {
	case 0:
		context.errors.push(new CompileError(operatorToken, (operatorToken._value === "[" ? "operator [] of type " + argTypes[0].toString() + " is not applicable to " + this.getObjectType$().toString() : "no function with matching arguments")));
		break;
	case 1:
		return matched[0];
	default:
		context.errors.push(new CompileError(operatorToken, "result of function resolution using the arguments is ambiguous"));
		break;
	}
	CompileError$addCompileNotes$LCompileError$ALCompileNote$((errors$0 = context.errors)[errors$0.length - 1], notes);
	return null;
};


FunctionChoiceType.prototype.getExpectedTypes$NB = function (numberOfArgs, isStatic) {
	var expected;
	var i;
	expected = [];
	for (i = 0; i < this._types.length; ++i) {
		this._types[i]._getExpectedTypes$ALUtil$x2EArgumentTypeRequest$NB(expected, numberOfArgs, isStatic);
	}
	return expected;
};


FunctionChoiceType.prototype.toString = function () {
	var $this = this;
	return (this._types.length === 1 ? this._types[0].toString() : "<<multiple choices: " + this._types.map((function (f) {
		return f.toString();
	})).join(" | ") + ">>");
};


FunctionChoiceType.prototype.getObjectType$ = function () {
	throw new Error("logic flaw");
};


FunctionChoiceType.prototype.forEachType$F$LType$B$ = function (cb) {
	throw new Error("logic flaw");
};


function ResolvedFunctionType(token, returnType, argTypes, isAssignable) {
	this._token = token;
	this._returnType = returnType;
	this._argTypes = argTypes;
	this._isAssignable = isAssignable;
};

$__jsx_extend([ResolvedFunctionType], FunctionType);
ResolvedFunctionType.prototype.setIsAssignable$B = function (isAssignable) {
	this._isAssignable = isAssignable;
	return this;
};


function ResolvedFunctionType$setIsAssignable$LResolvedFunctionType$B($this, isAssignable) {
	$this._isAssignable = isAssignable;
	return $this;
};

ResolvedFunctionType.setIsAssignable$LResolvedFunctionType$B = ResolvedFunctionType$setIsAssignable$LResolvedFunctionType$B;

ResolvedFunctionType.prototype.isAssignable$ = function () {
	return this._isAssignable;
};


ResolvedFunctionType.prototype.asAssignableType$ = function () {
	var this$0;
	this$0 = this._clone$();
	this$0._isAssignable = true;
	return this$0;
};


ResolvedFunctionType.prototype.getToken$ = function () {
	return this._token;
};


function ResolvedFunctionType$getToken$LResolvedFunctionType$($this) {
	return $this._token;
};

ResolvedFunctionType.getToken$LResolvedFunctionType$ = ResolvedFunctionType$getToken$LResolvedFunctionType$;

ResolvedFunctionType.prototype.getReturnType$ = function () {
	return this._returnType;
};


function ResolvedFunctionType$getReturnType$LResolvedFunctionType$($this) {
	return $this._returnType;
};

ResolvedFunctionType.getReturnType$LResolvedFunctionType$ = ResolvedFunctionType$getReturnType$LResolvedFunctionType$;

ResolvedFunctionType.prototype.getArgumentTypes$ = function () {
	return this._argTypes;
};


function ResolvedFunctionType$getArgumentTypes$LResolvedFunctionType$($this) {
	return $this._argTypes;
};

ResolvedFunctionType.getArgumentTypes$LResolvedFunctionType$ = ResolvedFunctionType$getArgumentTypes$LResolvedFunctionType$;

ResolvedFunctionType.prototype.deduceByArgumentTypes$LAnalysisContext$LToken$ALType$B = function (context, operatorToken, argTypes, isStatic) {
	var notes;
	var type;
	var error;
	notes = [];
	if ((type = this._deduceByArgumentTypes$LToken$ALType$BBALCompileNote$(this._token != null ? this._token : operatorToken, argTypes, isStatic, false, notes)) == null) {
		error = new CompileError(operatorToken, (operatorToken._value === "[" ? "operator [] of type " + argTypes[0].toString() + " is not applicable to " + this.getObjectType$().toString() : "no function with matching arguments"));
		CompileError$addCompileNotes$LCompileError$ALCompileNote$(error, notes);
		context.errors.push(error);
		return null;
	}
	return type;
};


ResolvedFunctionType.prototype._deduceByArgumentTypes$LToken$ALType$BBALCompileNote$ = function (token, argTypes, isStatic, exact, notes) {
	var $this = this;
	var compareArg;
	var vargType;
	var i;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var _argTypes$0;
	var _argTypes$1;
	compareArg = (function (formal, actual) {
		return (formal.equals$LType$(actual) ? true : ! exact && actual.isConvertibleTo$LType$(formal) ? true : false);
	});
	if (this instanceof StaticFunctionType !== isStatic) {
		if (isStatic) {
			notes.push(new CompileNote(token, 'candidate function not viable: expected a static function, but got a member function'));
		} else {
			notes.push(new CompileNote(token, 'candidate function not viable: expected a member function, but got a static function'));
		}
		return null;
	}
	if ((_argTypes$1 = this._argTypes).length !== 0 && _argTypes$1[_argTypes$1.length - 1] instanceof VariableLengthArgumentType) {
		vargType = (_argTypes$0 = this._argTypes)[_argTypes$0.length - 1];
		if (argTypes.length < _argTypes$0.length - 1) {
			notes.push(new CompileNote(token, 'candidate function not viable: wrong number of arguments'));
			return null;
		}
		for (i = 0; i < this._argTypes.length - 1; ++i) {
			if (! compareArg(this._argTypes[i], argTypes[i])) {
				notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: no known conversion from %1 to %2 for %3 argument.', [ argTypes[i].toString(), this._argTypes[i].toString(), Util$toOrdinal$N(i + 1) ])));
				return null;
			}
		}
		if (argTypes[i] instanceof VariableLengthArgumentType && argTypes.length === this._argTypes.length) {
			if (! compareArg((this$2 = this._argTypes[i], this$2._baseType), (this$3 = argTypes[i], this$3._baseType))) {
				notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: no known conversion from %1 to %2 for %3 argument.', [ (this$0 = argTypes[i], this$0._baseType).toString(), (this$1 = this._argTypes[i], this$1._baseType).toString(), Util$toOrdinal$N(i + 1) ])));
				return null;
			}
		} else {
			for (; i < argTypes.length; ++i) {
				if (! compareArg(vargType._baseType, argTypes[i])) {
					notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: no known conversion from %1 to %2 for %3 argument.', [ argTypes[i].toString(), vargType._baseType.toString(), Util$toOrdinal$N(i + 1) ])));
					return null;
				}
			}
		}
	} else {
		if (argTypes.length !== this._argTypes.length) {
			notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: wrong number of arguments (%1 for %2)', [ argTypes.length + "", this._argTypes.length + "" ])));
			return null;
		}
		for (i = 0; i < argTypes.length; ++i) {
			if (! compareArg(this._argTypes[i], argTypes[i])) {
				notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: no known conversion from %1 to %2 for %3 argument.', [ argTypes[i].toString(), this._argTypes[i].toString(), Util$toOrdinal$N(i + 1) ])));
				return null;
			}
		}
	}
	return this;
};


ResolvedFunctionType.prototype.getExpectedTypes$NB = function (numberOfArgs, isStatic) {
	var expected;
	expected = [];
	this._getExpectedTypes$ALUtil$x2EArgumentTypeRequest$NB(expected, numberOfArgs, isStatic);
	return expected;
};


ResolvedFunctionType.prototype._getExpectedTypes$ALUtil$x2EArgumentTypeRequest$NB = function (expected, numberOfArgs, isStatic) {
	var $this = this;
	var argTypes;
	var i;
	var hasCallback;
	var callbackArgTypes;
	var this$0;
	var _argTypes$0;
	var _argTypes$1;
	if (this instanceof StaticFunctionType !== isStatic) {
		return;
	}
	argTypes = [];
	if ((_argTypes$1 = this._argTypes).length > 0 && numberOfArgs >= _argTypes$1.length && _argTypes$1[_argTypes$1.length - 1] instanceof VariableLengthArgumentType) {
		for (i = 0; i < numberOfArgs; ++i) {
			if (i < this._argTypes.length - 1) {
				argTypes[i] = this._argTypes[i];
			} else {
				this$0 = (_argTypes$0 = this._argTypes)[_argTypes$0.length - 1];
				argTypes[i] = this$0._baseType;
			}
		}
	} else if (this._argTypes.length === numberOfArgs) {
		argTypes = this._argTypes;
	} else {
		return;
	}
	hasCallback = false;
	callbackArgTypes = argTypes.map((function (argType) {
		var typeName;
		var this$0;
		var this$0$0;
		typeName = '';
		if (argType instanceof StaticFunctionType || argType instanceof ObjectType && argType.getClassDef$() instanceof InstantiatedClassDefinition && ((typeName = (this$0 = argType.getClassDef$(), this$0$0 = this$0._templateClassDef, this$0$0._className)) === 'Array' || typeName === 'Map')) {
			hasCallback = true;
			return argType;
		} else {
			return null;
		}
	}));
	if (hasCallback) {
		expected.push(({argTypes: callbackArgTypes, typeArgs: [  ]}));
	}
};


ResolvedFunctionType.prototype.toString = function () {
	var args;
	var i;
	var s;
	var this$0;
	args = [];
	for (i = 0; i < this._argTypes.length; ++i) {
		if (this._argTypes[i] == null) {
		} else if (this._argTypes[i] instanceof VariableLengthArgumentType) {
			args[i] = "... : " + (this$0 = this._argTypes[i], this$0._baseType).toString();
		} else {
			args[i] = ": " + this._argTypes[i].toString();
		}
	}
	s = this._toStringPrefix$() + "function (" + args.join(", ") + ")";
	if (this._returnType != null) {
		s += " : " + this._returnType.toString();
	}
	return s;
};


ResolvedFunctionType.prototype.getObjectType$ = function () {
	throw new Error("logic flaw");
};


ResolvedFunctionType.prototype.forEachType$F$LType$B$ = function (cb) {
	var i;
	for (i = 0; i < this._argTypes.length; ++i) {
		if (! cb(this._argTypes[i])) {
			return false;
		}
	}
	return (! cb(this._returnType) ? false : true);
};


function StaticFunctionType(token, returnType, argTypes, isAssignable) {
	this._token = token;
	this._returnType = returnType;
	this._argTypes = argTypes;
	this._isAssignable = isAssignable;
};

$__jsx_extend([StaticFunctionType], ResolvedFunctionType);
StaticFunctionType.prototype.instantiate$LInstantiationContext$B = function (instantiationContext, allowVoid) {
	var returnType;
	var argTypes;
	var i;
	returnType = this._returnType.instantiate$LInstantiationContext$B(instantiationContext, true);
	if (returnType == null) {
		return null;
	}
	argTypes = [];
	for (i = 0; i < this._argTypes.length; ++i) {
		if ((argTypes[i] = this._argTypes[i].instantiate$LInstantiationContext$B(instantiationContext, true)) == null) {
			return null;
		}
	}
	return new StaticFunctionType(this._token, returnType, argTypes, this._isAssignable);
};


StaticFunctionType.prototype.equals$LType$ = function (x) {
	return x instanceof StaticFunctionType && this._returnType.equals$LType$(x._returnType) && Util$typesAreEqual$ALType$ALType$(this._argTypes, x._argTypes);
};


StaticFunctionType.prototype._clone$ = function () {
	return new StaticFunctionType(this._token, this._returnType, this._argTypes.concat([  ]), this._isAssignable);
};


StaticFunctionType.prototype.isConvertibleTo$LType$ = function (type) {
	var this$0$0;
	var this$0;
	var this$1;
	var this$2;
	type = (type instanceof NullableType ? (this$0$0 = type, this$0$0._baseType) : type);
	return (type instanceof VariantType ? true : ! (type instanceof StaticFunctionType) ? false : ! this._returnType.equals$LType$((this$0 = type, this$0._returnType)) ? false : this._deduceByArgumentTypes$LToken$ALType$BBALCompileNote$((this$1 = type, this$1._token), (this$2 = type, this$2._argTypes), true, true, [  ]) == null ? false : true);
};


StaticFunctionType.prototype._toStringPrefix$ = function () {
	return "";
};


StaticFunctionType.prototype.getObjectType$ = function () {
	throw new Error("logic flaw");
};


function MemberFunctionType(token, objectType, returnType, argTypes, isAssignable) {
	this._token = token;
	this._returnType = returnType;
	this._argTypes = argTypes;
	this._isAssignable = isAssignable;
	this._objectType = objectType;
};

$__jsx_extend([MemberFunctionType], ResolvedFunctionType);
MemberFunctionType.prototype.equals$LType$ = function (x) {
	return x instanceof MemberFunctionType && this._objectType == x._objectType && this._returnType.equals$LType$(x._returnType) && Util$typesAreEqual$ALType$ALType$(this._argTypes, x._argTypes);
};


MemberFunctionType.prototype._clone$ = function () {
	return new MemberFunctionType(this._token, this._objectType, this._returnType, this._argTypes.concat([  ]), this._isAssignable);
};


MemberFunctionType.prototype._toStringPrefix$ = function () {
	return this._objectType.toString() + ".";
};


MemberFunctionType.prototype.getObjectType$ = function () {
	return this._objectType;
};


function TemplateFunctionType(token, funcDef) {
	var returnType$0;
	var argTypes$0;
	returnType$0 = funcDef._returnType;
	argTypes$0 = MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef).concat([  ]);
	this._token = token;
	this._returnType = returnType$0;
	this._argTypes = argTypes$0;
	this._isAssignable = false;
	this._funcDef = funcDef;
};

$__jsx_extend([TemplateFunctionType], ResolvedFunctionType);
TemplateFunctionType.prototype._clone$ = function () {
	return new TemplateFunctionType(this._token, this._funcDef);
};


TemplateFunctionType.prototype._toStringPrefix$ = function () {
	return 'template ';
};


TemplateFunctionType.prototype.asAssignableType$ = function () {
	throw new Error('logic flaw');
};


TemplateFunctionType.prototype._deduceByArgumentTypes$LToken$ALType$BBALCompileNote$ = function (token, argTypes, isStatic, exact, notes) {
	var errors;
	var member;
	var i;
	var this$0;
	var _argTypes$0;
	errors = [];
	if ((((this$0 = this._funcDef, this$0._flags) & 8) === 8) !== isStatic) {
		if (isStatic) {
			notes.push(new CompileNote(token, 'candidate function not viable: expected a static function, but got a member function'));
		} else {
			notes.push(new CompileNote(token, 'candidate function not viable: expected a member function, but got a static function'));
		}
		return null;
	}
	if ((_argTypes$0 = this._argTypes).length !== 0 && _argTypes$0[_argTypes$0.length - 1] instanceof VariableLengthArgumentType) {
		notes.push(new CompileNote(token, "template functions with variable-length arguments cannot be instantiated by the arguments: please specify the type arguments by hand"));
		return null;
	} else {
		if (argTypes.length !== this._argTypes.length) {
			notes.push(new CompileNote(token, Util$format$SAS('candidate function not viable: wrong number of arguments (%1 for %2)', [ argTypes.length + "", this._argTypes.length + "" ])));
			return null;
		}
		member = TemplateFunctionDefinition$instantiateByArgumentTypes$LTemplateFunctionDefinition$ALCompileError$ALCompileNote$LToken$ALType$B(this._funcDef, errors, notes, token, argTypes, exact);
		if (member == null) {
			for (i = 0; i < errors.length; ++i) {
				notes.push(new CompileNote$0(errors[i]._filename, errors[i]._lineNumber, errors[i]._columnNumber, errors[i]._message));
			}
			return null;
		}
		return member.getType$();
	}
};


TemplateFunctionType.prototype._getExpectedTypes$ALUtil$x2EArgumentTypeRequest$NB = function (expected, numberOfArgs, isStatic) {
	var $this = this;
	var argTypes;
	var i;
	var instantiationContext;
	var hasCallback;
	var callbackArgTypes;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var _argTypes$0;
	var _argTypes$1;
	if ((((this$0 = this._funcDef, this$0._flags) & 8) !== 0) !== isStatic) {
		return;
	}
	argTypes = [];
	if ((_argTypes$1 = this._argTypes).length > 0 && numberOfArgs >= _argTypes$1.length && _argTypes$1[_argTypes$1.length - 1] instanceof VariableLengthArgumentType) {
		for (i = 0; i < numberOfArgs; ++i) {
			if (i < this._argTypes.length - 1) {
				argTypes[i] = this._argTypes[i];
			} else {
				this$1 = (_argTypes$0 = this._argTypes)[_argTypes$0.length - 1];
				argTypes[i] = this$1._baseType;
			}
		}
	} else if (this._argTypes.length === numberOfArgs) {
		argTypes = this._argTypes.concat([  ]);
	} else {
		return;
	}
	instantiationContext = ({errors: [  ], typemap: (this$2 = this._funcDef, this$2._resolvedTypemap), objectTypesUsed: []});
	for (i = 0; i < numberOfArgs; ++i) {
		argTypes[i] = argTypes[i].instantiate$LInstantiationContext$B(instantiationContext, true);
	}
	hasCallback = false;
	callbackArgTypes = argTypes.map((function (argType) {
		if (argType instanceof StaticFunctionType) {
			hasCallback = true;
			return argType;
		} else {
			return null;
		}
	}));
	if (hasCallback) {
		expected.push(({argTypes: callbackArgTypes, typeArgs: (this$3 = this._funcDef, this$3._typeArgs)}));
	}
};


TemplateFunctionType.prototype.getObjectType$ = function () {
	throw new Error("logic flaw");
};


function Token(value, isIdentifier, filename, lineNumber, columnNumber) {
	this._value = value;
	this._isIdentifier = isIdentifier;
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = columnNumber;
};

function Token$0(value, isIdentifier, filename, lineNumber) {
	this._value = value;
	this._isIdentifier = isIdentifier;
	this._filename = filename;
	this._lineNumber = lineNumber;
	this._columnNumber = NaN;
};

function Token$1(value, isIdentifier, filename) {
	this._value = value;
	this._isIdentifier = isIdentifier;
	this._filename = filename;
	this._lineNumber = NaN;
	this._columnNumber = NaN;
};

function Token$2(value, isIdentifier) {
	Token.call(this, value, isIdentifier, null, NaN, NaN);
};

function Token$3(value) {
	Token.call(this, value, false, null, NaN, NaN);
};

$__jsx_extend([Token, Token$0, Token$1, Token$2, Token$3], Object);
function Token$getValue$LToken$($this) {
	return $this._value;
};

Token.getValue$LToken$ = Token$getValue$LToken$;

function Token$isIdentifier$LToken$($this) {
	return $this._isIdentifier;
};

Token.isIdentifier$LToken$ = Token$isIdentifier$LToken$;

function Token$getFilename$LToken$($this) {
	return $this._filename;
};

Token.getFilename$LToken$ = Token$getFilename$LToken$;

function Token$getLineNumber$LToken$($this) {
	return $this._lineNumber;
};

Token.getLineNumber$LToken$ = Token$getLineNumber$LToken$;

function Token$getColumnNumber$LToken$($this) {
	return $this._columnNumber;
};

Token.getColumnNumber$LToken$ = Token$getColumnNumber$LToken$;

function Token$serialize$LToken$($this) {
	return [ $this._value, $this._isIdentifier, $this._filename, $this._lineNumber, $this._columnNumber ];
};

Token.serialize$LToken$ = Token$serialize$LToken$;

function Token$getNotation$LToken$($this) {
	return "'" + $this._value + "'" + " at " + ($this._filename || "<<unknown>>") + ":" + ($this._lineNumber + "") + ":" + ($this._columnNumber + "");
};

Token.getNotation$LToken$ = Token$getNotation$LToken$;

function _Lexer() {
};

$__jsx_extend([_Lexer], Object);
function _Lexer$makeAlt$AS(patterns) {
	return "(?: \n" + patterns.join("\n | \n") + "\n)\n";
};

_Lexer.makeAlt$AS = _Lexer$makeAlt$AS;

function _Lexer$quoteMeta$S(pattern) {
	return pattern.replace(/([^0-9A-Za-z_])/g, '\\$1');
};

_Lexer.quoteMeta$S = _Lexer$quoteMeta$S;

function _Lexer$rx$S(pat) {
	return new RegExp(pat.replace(/[ \t\r\n]/g, ""));
};

_Lexer.rx$S = _Lexer$rx$S;

function Import(parser) {
	this._filenameToken = null;
	this._aliasToken = null;
	this._classNames = null;
	this._sourceParsers = [ parser ];
};

function Import$0(filenameToken, aliasToken, classNames) {
	this._filenameToken = filenameToken;
	this._aliasToken = aliasToken;
	this._classNames = classNames;
	this._sourceParsers = [  ];
};

$__jsx_extend([Import, Import$0], Object);
Import.prototype.getFilenameToken$ = function () {
	return this._filenameToken;
};


function Import$getFilenameToken$LImport$($this) {
	return $this._filenameToken;
};

Import.getFilenameToken$LImport$ = Import$getFilenameToken$LImport$;

Import.prototype.getAlias$ = function () {
	var this$0;
	return (this._aliasToken ? (this$0 = this._aliasToken, this$0._value) : null);
};


function Import$getAlias$LImport$($this) {
	var this$0;
	return ($this._aliasToken ? (this$0 = $this._aliasToken, this$0._value) : null);
};

Import.getAlias$LImport$ = Import$getAlias$LImport$;

Import.prototype.getClassNames$ = function () {
	var names;
	var i;
	var this$0;
	if (this._classNames == null) {
		return null;
	}
	names = [];
	for (i = 0; i < this._classNames.length; ++i) {
		this$0 = this._classNames[i];
		names[i] = this$0._value;
	}
	return names;
};


function Import$getClassNames$LImport$($this) {
	var names;
	var i;
	var this$0;
	if ($this._classNames == null) {
		return null;
	}
	names = [];
	for (i = 0; i < $this._classNames.length; ++i) {
		this$0 = $this._classNames[i];
		names[i] = this$0._value;
	}
	return names;
};

Import.getClassNames$LImport$ = Import$getClassNames$LImport$;

Import.prototype.serialize$ = function () {
	var v$0;
	var v$1;
	return [ "Import", (v$0 = this._filenameToken, v$0 == null ? null : [ v$0._value, v$0._isIdentifier, v$0._filename, v$0._lineNumber, v$0._columnNumber ]), (v$1 = this._aliasToken, v$1 == null ? null : [ v$1._value, v$1._isIdentifier, v$1._filename, v$1._lineNumber, v$1._columnNumber ]), Util$serializeArray$ALToken$(this._classNames) ];
};


function Import$serialize$LImport$($this) {
	var v$0;
	var v$1;
	return [ "Import", (v$0 = $this._filenameToken, v$0 == null ? null : [ v$0._value, v$0._isIdentifier, v$0._filename, v$0._lineNumber, v$0._columnNumber ]), (v$1 = $this._aliasToken, v$1 == null ? null : [ v$1._value, v$1._isIdentifier, v$1._filename, v$1._lineNumber, v$1._columnNumber ]), Util$serializeArray$ALToken$($this._classNames) ];
};

Import.serialize$LImport$ = Import$serialize$LImport$;

Import.prototype.checkNameConflict$ALCompileError$LToken$ = function (errors, nameToken) {
	var i;
	var this$0;
	var this$1;
	if (this._aliasToken != null) {
		if ((this$0 = this._aliasToken, this$0._value) === nameToken._value) {
			errors.push(new CompileError(nameToken, "an alias with the same name is already declared"));
			return false;
		}
	} else if (this._classNames != null) {
		for (i = 0; i < this._classNames.length; ++i) {
			if ((this$1 = this._classNames[i], this$1._value) === nameToken._value) {
				errors.push(new CompileError(nameToken, "a class with the same name has already been explicitely imported"));
				return false;
			}
		}
	}
	return true;
};


function Import$checkNameConflict$LImport$ALCompileError$LToken$($this, errors, nameToken) {
	var i;
	var this$0;
	var this$1;
	if ($this._aliasToken != null) {
		if ((this$0 = $this._aliasToken, this$0._value) === nameToken._value) {
			errors.push(new CompileError(nameToken, "an alias with the same name is already declared"));
			return false;
		}
	} else if ($this._classNames != null) {
		for (i = 0; i < $this._classNames.length; ++i) {
			if ((this$1 = $this._classNames[i], this$1._value) === nameToken._value) {
				errors.push(new CompileError(nameToken, "a class with the same name has already been explicitely imported"));
				return false;
			}
		}
	}
	return true;
};

Import.checkNameConflict$LImport$ALCompileError$LToken$ = Import$checkNameConflict$LImport$ALCompileError$LToken$;

Import.prototype.addSource$LParser$ = function (parser) {
	this._sourceParsers.push(parser);
};


function Import$addSource$LImport$LParser$($this, parser) {
	$this._sourceParsers.push(parser);
};

Import.addSource$LImport$LParser$ = Import$addSource$LImport$LParser$;

Import.prototype.getSources$ = function () {
	return this._sourceParsers;
};


function Import$getSources$LImport$($this) {
	return $this._sourceParsers;
};

Import.getSources$LImport$ = Import$getSources$LImport$;

Import.prototype.assertExistenceOfNamedClasses$ALCompileError$ = function (errors) {
	var $this = this;
	var allClassNames;
	var i;
	var countNumberOfClassesByName;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var _classNames$0;
	var _classNames$1;
	if (this._classNames == null) {
		return;
	}
	allClassNames = [];
	for (i = 0; i < this._sourceParsers.length; ++i) {
		allClassNames = allClassNames.concat((this$0 = this._sourceParsers[i], this$0._classDefs).map((function (classDef) {
			return classDef.className$();
		})));
		allClassNames = allClassNames.concat((this$1 = this._sourceParsers[i], this$1._templateClassDefs).map((function (classDef) {
			return classDef._className;
		})));
	}
	function countNumberOfClassesByName(className) {
		var num;
		var i;
		var allClassNames$len$0;
		num = 0;
		for ((i = 0, allClassNames$len$0 = allClassNames.length); i < allClassNames$len$0; ++i) {
			if (allClassNames[i] === className) {
				++num;
			}
		}
		return num;
	}
	for (i = 0; i < this._classNames.length; ++i) {
		switch (countNumberOfClassesByName((this$4 = this._classNames[i], this$4._value))) {
		case 0:
			errors.push(new CompileError((_classNames$0 = this._classNames)[i], "no definition for class '" + (this$2 = _classNames$0[i], this$2._value) + "'"));
			break;
		case 1:
			break;
		default:
			errors.push(new CompileError((_classNames$1 = this._classNames)[i], "multiple candidates for class '" + (this$3 = _classNames$1[i], this$3._value) + "'"));
			break;
		}
	}
};


function Import$assertExistenceOfNamedClasses$LImport$ALCompileError$($this, errors) {
	var allClassNames;
	var i;
	var countNumberOfClassesByName;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var _classNames$0;
	var _classNames$1;
	if ($this._classNames == null) {
		return;
	}
	allClassNames = [];
	for (i = 0; i < $this._sourceParsers.length; ++i) {
		allClassNames = allClassNames.concat((this$0 = $this._sourceParsers[i], this$0._classDefs).map((function (classDef) {
			return classDef.className$();
		})));
		allClassNames = allClassNames.concat((this$1 = $this._sourceParsers[i], this$1._templateClassDefs).map((function (classDef) {
			return classDef._className;
		})));
	}
	function countNumberOfClassesByName(className) {
		var num;
		var i;
		var allClassNames$len$0;
		num = 0;
		for ((i = 0, allClassNames$len$0 = allClassNames.length); i < allClassNames$len$0; ++i) {
			if (allClassNames[i] === className) {
				++num;
			}
		}
		return num;
	}
	for (i = 0; i < $this._classNames.length; ++i) {
		switch (countNumberOfClassesByName((this$4 = $this._classNames[i], this$4._value))) {
		case 0:
			errors.push(new CompileError((_classNames$0 = $this._classNames)[i], "no definition for class '" + (this$2 = _classNames$0[i], this$2._value) + "'"));
			break;
		case 1:
			break;
		default:
			errors.push(new CompileError((_classNames$1 = $this._classNames)[i], "multiple candidates for class '" + (this$3 = _classNames$1[i], this$3._value) + "'"));
			break;
		}
	}
};

Import.assertExistenceOfNamedClasses$LImport$ALCompileError$ = Import$assertExistenceOfNamedClasses$LImport$ALCompileError$;

Import.prototype.getClasses$S = function (name) {
	var found;
	var i;
	var classDefs;
	var j;
	var classDef;
	var this$0;
	if (! Import$_classIsImportable$LImport$S(this, name)) {
		return [  ];
	}
	found = [  ];
	for (i = 0; i < this._sourceParsers.length; ++i) {
		this$0 = this._sourceParsers[i];
		classDefs = this$0._classDefs;
		for (j = 0; j < classDefs.length; ++j) {
			classDef = classDefs[j];
			if (classDef.className$() === name) {
				found.push(classDef);
				break;
			}
		}
	}
	return found;
};


function Import$getClasses$LImport$S($this, name) {
	var found;
	var i;
	var classDefs;
	var j;
	var classDef;
	var this$0;
	if (! Import$_classIsImportable$LImport$S($this, name)) {
		return [  ];
	}
	found = [  ];
	for (i = 0; i < $this._sourceParsers.length; ++i) {
		this$0 = $this._sourceParsers[i];
		classDefs = this$0._classDefs;
		for (j = 0; j < classDefs.length; ++j) {
			classDef = classDefs[j];
			if (classDef.className$() === name) {
				found.push(classDef);
				break;
			}
		}
	}
	return found;
};

Import.getClasses$LImport$S = Import$getClasses$LImport$S;

Import.prototype.createGetTemplateClassCallbacks$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = function (errors, request, postInstantiationCallback) {
	var callbacks;
	var i;
	var callback;
	if (! Import$_classIsImportable$LImport$S(this, request._className)) {
		return [];
	}
	callbacks = [];
	for (i = 0; i < this._sourceParsers.length; ++i) {
		callback = Parser$createGetTemplateClassCallback$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(this._sourceParsers[i], errors, request, postInstantiationCallback);
		if (callback != null) {
			callbacks.push(callback);
		}
	}
	return callbacks;
};


function Import$createGetTemplateClassCallbacks$LImport$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback) {
	var callbacks;
	var i;
	var callback;
	if (! Import$_classIsImportable$LImport$S($this, request._className)) {
		return [];
	}
	callbacks = [];
	for (i = 0; i < $this._sourceParsers.length; ++i) {
		callback = Parser$createGetTemplateClassCallback$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this._sourceParsers[i], errors, request, postInstantiationCallback);
		if (callback != null) {
			callbacks.push(callback);
		}
	}
	return callbacks;
};

Import.createGetTemplateClassCallbacks$LImport$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = Import$createGetTemplateClassCallbacks$LImport$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$;

Import.prototype._classIsImportable$S = function (name) {
	var i;
	var this$0;
	if (this._classNames != null) {
		for (i = 0; i < this._classNames.length; ++i) {
			if ((this$0 = this._classNames[i], this$0._value) === name) {
				break;
			}
		}
		if (i === this._classNames.length) {
			return false;
		}
	} else if (name.charAt(0) === '_') {
		return false;
	}
	return true;
};


function Import$_classIsImportable$LImport$S($this, name) {
	var i;
	var this$0;
	if ($this._classNames != null) {
		for (i = 0; i < $this._classNames.length; ++i) {
			if ((this$0 = $this._classNames[i], this$0._value) === name) {
				break;
			}
		}
		if (i === $this._classNames.length) {
			return false;
		}
	} else if (name.charAt(0) === '_') {
		return false;
	}
	return true;
};

Import._classIsImportable$LImport$S = Import$_classIsImportable$LImport$S;

function Import$create$ALCompileError$LToken$LToken$ALToken$(errors, filenameToken, aliasToken, classNames) {
	var filename;
	var match;
	filename = Util$decodeStringLiteral$S(filenameToken._value);
	if (filename.indexOf("*") !== -1) {
		match = filename.match(/^([^\*]*)\/\*(\.[^\/\*]*)$/);
		if (match == null) {
			errors.push(new CompileError(filenameToken, "invalid use of wildcard"));
			return null;
		}
		return new WildcardImport(filenameToken, aliasToken, classNames, match[1], match[2]);
	}
	return new Import$0(filenameToken, aliasToken, classNames);
};

Import.create$ALCompileError$LToken$LToken$ALToken$ = Import$create$ALCompileError$LToken$LToken$ALToken$;

function WildcardImport(filenameToken, aliasToken, classNames, directory, suffix) {
	this._filenameToken = filenameToken;
	this._aliasToken = aliasToken;
	this._classNames = classNames;
	this._sourceParsers = [  ];
	this._directory = directory;
	this._suffix = suffix;
};

$__jsx_extend([WildcardImport], Import);
WildcardImport.prototype.getDirectory$ = function () {
	return this._directory;
};


function WildcardImport$getDirectory$LWildcardImport$($this) {
	return $this._directory;
};

WildcardImport.getDirectory$LWildcardImport$ = WildcardImport$getDirectory$LWildcardImport$;

WildcardImport.prototype.getSuffix$ = function () {
	return this._suffix;
};


function WildcardImport$getSuffix$LWildcardImport$($this) {
	return $this._suffix;
};

WildcardImport.getSuffix$LWildcardImport$ = WildcardImport$getSuffix$LWildcardImport$;

function QualifiedName(token) {
	this._token = token;
	this._import = null;
	this._enclosingType = null;
};

function QualifiedName$0(token, imprt) {
	this._token = token;
	this._import = imprt;
	this._enclosingType = null;
};

function QualifiedName$1(token, enclosingType) {
	this._token = token;
	this._import = null;
	this._enclosingType = enclosingType;
};

$__jsx_extend([QualifiedName, QualifiedName$0, QualifiedName$1], Object);
QualifiedName.prototype.getToken$ = function () {
	return this._token;
};


function QualifiedName$getToken$LQualifiedName$($this) {
	return $this._token;
};

QualifiedName.getToken$LQualifiedName$ = QualifiedName$getToken$LQualifiedName$;

QualifiedName.prototype.getImport$ = function () {
	return this._import;
};


function QualifiedName$getImport$LQualifiedName$($this) {
	return $this._import;
};

QualifiedName.getImport$LQualifiedName$ = QualifiedName$getImport$LQualifiedName$;

QualifiedName.prototype.getEnclosingType$ = function () {
	return this._enclosingType;
};


function QualifiedName$getEnclosingType$LQualifiedName$($this) {
	return $this._enclosingType;
};

QualifiedName.getEnclosingType$LQualifiedName$ = QualifiedName$getEnclosingType$LQualifiedName$;

QualifiedName.prototype.serialize$ = function () {
	var this$0;
	var v$0;
	var v$1;
	return [ "QualifiedName", (this$0 = this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), (v$0 = this._import, v$0 == null ? null : Import$serialize$LImport$(v$0)), (v$1 = this._enclosingType, v$1 == null ? null : v$1.toString()) ];
};


function QualifiedName$serialize$LQualifiedName$($this) {
	var this$0;
	var v$0;
	var v$1;
	return [ "QualifiedName", (this$0 = $this._token, [ this$0._value, this$0._isIdentifier, this$0._filename, this$0._lineNumber, this$0._columnNumber ]), (v$0 = $this._import, v$0 == null ? null : Import$serialize$LImport$(v$0)), (v$1 = $this._enclosingType, v$1 == null ? null : v$1.toString()) ];
};

QualifiedName.serialize$LQualifiedName$ = QualifiedName$serialize$LQualifiedName$;

QualifiedName.prototype.equals$LQualifiedName$ = function (x) {
	var this$0;
	var this$1;
	if (x == null) {
		return false;
	}
	if ((this$0 = this._token, this$0._value) !== (this$1 = x._token, this$1._value)) {
		return false;
	}
	if (this._import != x._import) {
		return false;
	}
	if (this._enclosingType == null) {
		if (x._enclosingType != null) {
			return false;
		}
	} else if (! this._enclosingType.equals$LType$(x._enclosingType)) {
		return false;
	}
	return true;
};


function QualifiedName$equals$LQualifiedName$LQualifiedName$($this, x) {
	var this$0;
	var this$1;
	if (x == null) {
		return false;
	}
	if ((this$0 = $this._token, this$0._value) !== (this$1 = x._token, this$1._value)) {
		return false;
	}
	if ($this._import != x._import) {
		return false;
	}
	if ($this._enclosingType == null) {
		if (x._enclosingType != null) {
			return false;
		}
	} else if (! $this._enclosingType.equals$LType$(x._enclosingType)) {
		return false;
	}
	return true;
};

QualifiedName.equals$LQualifiedName$LQualifiedName$ = QualifiedName$equals$LQualifiedName$LQualifiedName$;

QualifiedName.prototype.getClass$LAnalysisContext$ALType$ = function (context, typeArguments) {
	var $this = this;
	var classDef;
	var classDefs;
	var callbacks;
	var enclosingClassDef;
	var this$0;
	var this$0$0;
	var this$1$0;
	var this$1;
	var this$2;
	var this$0$1;
	var this$1$1;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$0$2;
	var this$1$2;
	var errors$0;
	var request$0;
	var postInstantiationCallback$0;
	var instantiateCallback$0;
	var this$0$3;
	var this$1$3;
	var this$10;
	var _token$0;
	var _token$1;
	var _token$2;
	var _token$3;
	var _token$4;
	classDef = null;
	if (this._import != null) {
		if (typeArguments.length === 0) {
			classDefs = Import$getClasses$LImport$S(this._import, (this$0 = this._token, this$0._value));
			switch (classDefs.length) {
			case 1:
				classDef = classDefs[0];
				break;
			case 0:
				context.errors.push(new CompileError(this._token, "no definition for class '" + (this._enclosingType != null ? this._enclosingType.toString() + "." + (this$0$0 = this._token, this$0$0._value) : (this$1$0 = this._token, this$1$0._value)) + "' in file '" + (this$2 = (this$1 = this._import, this$1._filenameToken), this$2._value) + "'"));
				return null;
			default:
				context.errors.push(new CompileError(this._token, "multiple candidates"));
				return null;
			}
		} else {
			callbacks = Import$createGetTemplateClassCallbacks$LImport$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(this._import, context.errors, ({_token: _token$0 = this._token, _className: (_token$0, _token$0._value), _typeArgs: typeArguments}), (function (parser, classDef) {
				return null;
			}));
			switch (callbacks.length) {
			case 1:
				return callbacks[0](null, null, null);
			case 0:
				context.errors.push(new CompileError(this._token, "no definition for template class '" + (this._enclosingType != null ? this._enclosingType.toString() + "." + (this$0$1 = this._token, this$0$1._value) : (this$1$1 = this._token, this$1$1._value)) + "' in file '" + (this$5 = (this$4 = this._import, this$4._filenameToken), this$5._value) + "'"));
				return null;
			default:
				context.errors.push(new CompileError(this._token, "multiple canditates"));
				return null;
			}
		}
	} else if (this._enclosingType != null) {
		this$6 = this._enclosingType;
		if (this$6._classDef == null) {
			this$6._classDef = QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$(this$6._qualifiedName, context, this$6._typeArguments);
		}
		if ((enclosingClassDef = (this$7 = this._enclosingType, this$7._classDef)) == null) {
			return null;
		}
		if (typeArguments.length === 0) {
			if ((classDef = ClassDefinition$lookupInnerClass$LClassDefinition$S(enclosingClassDef, (this$10 = this._token, this$10._value))) == null) {
				context.errors.push(new CompileError(this._token, "no class definition or variable for '" + (this._enclosingType != null ? this._enclosingType.toString() + "." + (this$0$2 = this._token, this$0$2._value) : (this$1$2 = this._token, this$1$2._value)) + "'"));
				return null;
			}
		} else if ((classDef = (errors$0 = context.errors, request$0 = ({_token: _token$1 = this._token, _className: (_token$1, _token$1._value), _typeArgs: typeArguments}), postInstantiationCallback$0 = (function (parser, classDef) {
			return null;
		}), instantiateCallback$0 = ClassDefinition$createGetTemplateClassCallback$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(enclosingClassDef, errors$0, request$0, postInstantiationCallback$0), instantiateCallback$0 != null ? instantiateCallback$0(errors$0, request$0, postInstantiationCallback$0) : null)) == null) {
			context.errors.push(new CompileError(this._token, "failed to instantiate class"));
			return null;
		}
	} else if (typeArguments.length === 0) {
		if ((classDef = Parser$lookup$LParser$ALCompileError$LToken$S(context.parser, context.errors, _token$3 = this._token, (_token$3, _token$3._value))) == null) {
			if ((classDef = Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: _token$2 = this._token, _className: (_token$2, _token$2._value), _typeArgs: typeArguments}), (function (parser, classDef) {
				return null;
			}))) == null) {
				context.errors.push(new CompileError(this._token, "no class definition or variable for '" + (this._enclosingType != null ? this._enclosingType.toString() + "." + (this$0$3 = this._token, this$0$3._value) : (this$1$3 = this._token, this$1$3._value)) + "'"));
				return null;
			}
		}
	} else if ((classDef = Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: _token$4 = this._token, _className: (_token$4, _token$4._value), _typeArgs: typeArguments}), (function (parser, classDef) {
		return null;
	}))) == null) {
		context.errors.push(new CompileError(this._token, "failed to instantiate class"));
		return null;
	}
	return classDef;
};


function QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$($this, context, typeArguments) {
	var classDef;
	var classDefs;
	var callbacks;
	var enclosingClassDef;
	var this$0;
	var this$0$0;
	var this$1$0;
	var this$1;
	var this$2;
	var this$0$1;
	var this$1$1;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$0$2;
	var this$1$2;
	var errors$0;
	var request$0;
	var postInstantiationCallback$0;
	var instantiateCallback$0;
	var this$0$3;
	var this$1$3;
	var this$10;
	var _token$0;
	var _token$1;
	var _token$2;
	var _token$3;
	var _token$4;
	classDef = null;
	if ($this._import != null) {
		if (typeArguments.length === 0) {
			classDefs = Import$getClasses$LImport$S($this._import, (this$0 = $this._token, this$0._value));
			switch (classDefs.length) {
			case 1:
				classDef = classDefs[0];
				break;
			case 0:
				context.errors.push(new CompileError($this._token, "no definition for class '" + ($this._enclosingType != null ? $this._enclosingType.toString() + "." + (this$0$0 = $this._token, this$0$0._value) : (this$1$0 = $this._token, this$1$0._value)) + "' in file '" + (this$2 = (this$1 = $this._import, this$1._filenameToken), this$2._value) + "'"));
				return null;
			default:
				context.errors.push(new CompileError($this._token, "multiple candidates"));
				return null;
			}
		} else {
			callbacks = Import$createGetTemplateClassCallbacks$LImport$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this._import, context.errors, ({_token: _token$0 = $this._token, _className: (_token$0, _token$0._value), _typeArgs: typeArguments}), (function (parser, classDef) {
				return null;
			}));
			switch (callbacks.length) {
			case 1:
				return callbacks[0](null, null, null);
			case 0:
				context.errors.push(new CompileError($this._token, "no definition for template class '" + ($this._enclosingType != null ? $this._enclosingType.toString() + "." + (this$0$1 = $this._token, this$0$1._value) : (this$1$1 = $this._token, this$1$1._value)) + "' in file '" + (this$5 = (this$4 = $this._import, this$4._filenameToken), this$5._value) + "'"));
				return null;
			default:
				context.errors.push(new CompileError($this._token, "multiple canditates"));
				return null;
			}
		}
	} else if ($this._enclosingType != null) {
		this$6 = $this._enclosingType;
		if (this$6._classDef == null) {
			this$6._classDef = QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$(this$6._qualifiedName, context, this$6._typeArguments);
		}
		if ((enclosingClassDef = (this$7 = $this._enclosingType, this$7._classDef)) == null) {
			return null;
		}
		if (typeArguments.length === 0) {
			if ((classDef = ClassDefinition$lookupInnerClass$LClassDefinition$S(enclosingClassDef, (this$10 = $this._token, this$10._value))) == null) {
				context.errors.push(new CompileError($this._token, "no class definition or variable for '" + ($this._enclosingType != null ? $this._enclosingType.toString() + "." + (this$0$2 = $this._token, this$0$2._value) : (this$1$2 = $this._token, this$1$2._value)) + "'"));
				return null;
			}
		} else if ((classDef = (errors$0 = context.errors, request$0 = ({_token: _token$1 = $this._token, _className: (_token$1, _token$1._value), _typeArgs: typeArguments}), postInstantiationCallback$0 = (function (parser, classDef) {
			return null;
		}), instantiateCallback$0 = ClassDefinition$createGetTemplateClassCallback$LClassDefinition$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(enclosingClassDef, errors$0, request$0, postInstantiationCallback$0), instantiateCallback$0 != null ? instantiateCallback$0(errors$0, request$0, postInstantiationCallback$0) : null)) == null) {
			context.errors.push(new CompileError($this._token, "failed to instantiate class"));
			return null;
		}
	} else if (typeArguments.length === 0) {
		if ((classDef = Parser$lookup$LParser$ALCompileError$LToken$S(context.parser, context.errors, _token$3 = $this._token, (_token$3, _token$3._value))) == null) {
			if ((classDef = Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: _token$2 = $this._token, _className: (_token$2, _token$2._value), _typeArgs: typeArguments}), (function (parser, classDef) {
				return null;
			}))) == null) {
				context.errors.push(new CompileError($this._token, "no class definition or variable for '" + ($this._enclosingType != null ? $this._enclosingType.toString() + "." + (this$0$3 = $this._token, this$0$3._value) : (this$1$3 = $this._token, this$1$3._value)) + "'"));
				return null;
			}
		}
	} else if ((classDef = Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(context.parser, context.errors, ({_token: _token$4 = $this._token, _className: (_token$4, _token$4._value), _typeArgs: typeArguments}), (function (parser, classDef) {
		return null;
	}))) == null) {
		context.errors.push(new CompileError($this._token, "failed to instantiate class"));
		return null;
	}
	return classDef;
};

QualifiedName.getClass$LQualifiedName$LAnalysisContext$ALType$ = QualifiedName$getClass$LQualifiedName$LAnalysisContext$ALType$;

QualifiedName.prototype.getTemplateClass$LParser$ = function (parser) {
	var $this = this;
	var foundClassDefs;
	var checkClassDef;
	var this$0;
	foundClassDefs = [];
	checkClassDef = (function (classDef) {
		var this$0;
		if (classDef._className === (this$0 = $this._token, this$0._value)) {
			foundClassDefs.push(classDef);
		}
	});
	if (this._import != null) {
		(this$0 = this._import, this$0._sourceParsers).forEach((function (parser) {
			parser._templateClassDefs.forEach(checkClassDef);
		}));
	} else {
		parser._templateClassDefs.forEach(checkClassDef);
		if (foundClassDefs.length === 0) {
			parser._imports.forEach((function (imprt) {
				imprt._sourceParsers.forEach((function (parser) {
					Parser$getTemplateClassDefs$LParser$(parser).forEach(checkClassDef);
				}));
			}));
		}
	}
	return (foundClassDefs.length === 1 ? foundClassDefs[0] : null);
};


function QualifiedName$getTemplateClass$LQualifiedName$LParser$($this, parser) {
	var foundClassDefs;
	var checkClassDef;
	var this$0;
	foundClassDefs = [];
	checkClassDef = (function (classDef) {
		var this$0;
		if (classDef._className === (this$0 = $this._token, this$0._value)) {
			foundClassDefs.push(classDef);
		}
	});
	if ($this._import != null) {
		(this$0 = $this._import, this$0._sourceParsers).forEach((function (parser) {
			parser._templateClassDefs.forEach(checkClassDef);
		}));
	} else {
		parser._templateClassDefs.forEach(checkClassDef);
		if (foundClassDefs.length === 0) {
			parser._imports.forEach((function (imprt) {
				imprt._sourceParsers.forEach((function (parser) {
					Parser$getTemplateClassDefs$LParser$(parser).forEach(checkClassDef);
				}));
			}));
		}
	}
	return (foundClassDefs.length === 1 ? foundClassDefs[0] : null);
};

QualifiedName.getTemplateClass$LQualifiedName$LParser$ = QualifiedName$getTemplateClass$LQualifiedName$LParser$;

QualifiedName.prototype.toString = function () {
	var this$0;
	var this$1;
	return (this._enclosingType != null ? this._enclosingType.toString() + "." + (this$0 = this._token, this$0._value) : (this$1 = this._token, this$1._value));
};


function ParserState(lineNumber, columnNumber, docComment, tokenLength, isGenerator, numErrors, numClosures, numObjectTypesUsed, numTemplateInstantiationRequests) {
	this.lineNumber = lineNumber;
	this.columnOffset = columnNumber;
	this.docComment = docComment;
	this.tokenLength = tokenLength;
	this.isGenerator = isGenerator;
	this.numErrors = numErrors;
	this.numClosures = numClosures;
	this.numObjectTypesUsed = numObjectTypesUsed;
	this.numTemplateInstantiationRequests = numTemplateInstantiationRequests;
};

$__jsx_extend([ParserState], Object);
function ClassState(outer, classType, typeArgs, extendType, implementTypes, objectTypesUsed, classFlags, inners, templateInners) {
	this.outer = outer;
	this.classType = classType;
	this.typeArgs = typeArgs;
	this.extendType = extendType;
	this.implementTypes = implementTypes;
	this.objectTypesUsed = objectTypesUsed;
	this.classFlags = classFlags;
	this.inners = inners;
	this.templateInners = templateInners;
};

$__jsx_extend([ClassState], Object);
function Scope(prev, locals, funcLocal, args, statements, closures, isGenerator) {
	this.prev = prev;
	this.locals = locals;
	this.funcLocal = funcLocal;
	this.arguments = args;
	this.statements = statements;
	this.closures = closures;
	this.isGenerator = isGenerator;
};

$__jsx_extend([Scope], Object);
function Parser(sourceToken, filename, completionRequest) {
	this._content = null;
	this._lines = null;
	this._tokenLength = 0;
	this._lineNumber = 0;
	this._columnOffset = 0;
	this._fileLevelDocComment = null;
	this._docComment = null;
	this._errors = null;
	this._templateClassDefs = null;
	this._classDefs = null;
	this._imports = null;
	this._isGenerator = false;
	this._locals = null;
	this._statements = null;
	this._closures = null;
	this._outerClass = null;
	this._classType = null;
	this._extendType = null;
	this._implementTypes = null;
	this._objectTypesUsed = null;
	this._inners = null;
	this._templateInners = null;
	this._templateInstantiationRequests = null;
	this._prevScope = null;
	this._funcLocal = null;
	this._arguments = null;
	this._classFlags = 0;
	this._typeArgs = null;
	this._sourceToken = sourceToken;
	this._filename = filename;
	this._completionRequest = completionRequest;
};

$__jsx_extend([Parser], Object);
function Parser$parse$LParser$SALCompileError$($this, content, errors) {
	var compLineNumber;
	var line;
	var importToken;
	var value1$0;
	var value2$0;
	var this$0;
	var this$1;
	var this$2;
	var _content$0;
	_content$0 = $this._content = content;
	$this._lines = _content$0.split(_Lexer.rxNewline);
	$this._tokenLength = 0;
	$this._lineNumber = 1;
	$this._columnOffset = 0;
	$this._fileLevelDocComment = null;
	$this._docComment = null;
	if ($this._completionRequest != null) {
		this$2 = $this._completionRequest;
		value1$0 = this$2._lineNumber;
		value2$0 = $this._lines.length + 1;
		compLineNumber = (value1$0 <= value2$0 ? value1$0 : value2$0);
		line = $this._lines[compLineNumber - 1] || '';
		$this._lines[compLineNumber - 1] = line.substring(0, (this$0 = $this._completionRequest, this$0._columnOffest)) + "Q," + line.substring((this$1 = $this._completionRequest, this$1._columnOffest));
	}
	$this._errors = errors;
	$this._templateClassDefs = [];
	$this._classDefs = [];
	$this._imports = [];
	$this._isGenerator = false;
	$this._locals = null;
	$this._statements = null;
	$this._closures = null;
	$this._classType = null;
	$this._extendType = null;
	$this._implementTypes = null;
	$this._objectTypesUsed = [];
	$this._inners = [];
	$this._templateInners = [];
	$this._templateInstantiationRequests = [];
	while (! (Parser$_advanceToken$LParser$($this), $this._lineNumber === $this._lines.length && $this._columnOffset === $this._lines[$this._lines.length - 1].length)) {
		importToken = Parser$_expectOpt$LParser$SLRegExp$($this, "import", null);
		if (importToken == null) {
			break;
		}
		Parser$_importStatement$LParser$LToken$($this, importToken);
	}
	while (! (Parser$_advanceToken$LParser$($this), $this._lineNumber === $this._lines.length && $this._columnOffset === $this._lines[$this._lines.length - 1].length)) {
		if (Parser$_classDefinition$LParser$($this) == null) {
			return false;
		}
	}
	return ($this._errors.length !== 0 ? false : true);
};

Parser.parse$LParser$SALCompileError$ = Parser$parse$LParser$SALCompileError$;

function Parser$getContent$LParser$($this) {
	return $this._content;
};

Parser.getContent$LParser$ = Parser$getContent$LParser$;

function Parser$_getInput$LParser$($this) {
	return $this._lines[$this._lineNumber - 1].substring($this._columnOffset);
};

Parser._getInput$LParser$ = Parser$_getInput$LParser$;

function Parser$_getInputByLength$LParser$N($this, length) {
	var _columnOffset$0;
	return $this._lines[$this._lineNumber - 1].substring(_columnOffset$0 = $this._columnOffset, _columnOffset$0 + length);
};

Parser._getInputByLength$LParser$N = Parser$_getInputByLength$LParser$N;

function Parser$_forwardPos$LParser$N($this, len) {
	$this._columnOffset += len;
};

Parser._forwardPos$LParser$N = Parser$_forwardPos$LParser$N;

function Parser$getSourceToken$LParser$($this) {
	return $this._sourceToken;
};

Parser.getSourceToken$LParser$ = Parser$getSourceToken$LParser$;

function Parser$getPath$LParser$($this) {
	return $this._filename;
};

Parser.getPath$LParser$ = Parser$getPath$LParser$;

function Parser$getDocComment$LParser$($this) {
	return $this._fileLevelDocComment;
};

Parser.getDocComment$LParser$ = Parser$getDocComment$LParser$;

function Parser$getClassDefs$LParser$($this) {
	return $this._classDefs;
};

Parser.getClassDefs$LParser$ = Parser$getClassDefs$LParser$;

function Parser$getTemplateClassDefs$LParser$($this) {
	return $this._templateClassDefs;
};

Parser.getTemplateClassDefs$LParser$ = Parser$getTemplateClassDefs$LParser$;

function Parser$getTemplateInstantiationRequests$LParser$($this) {
	return $this._templateInstantiationRequests;
};

Parser.getTemplateInstantiationRequests$LParser$ = Parser$getTemplateInstantiationRequests$LParser$;

function Parser$getImports$LParser$($this) {
	return $this._imports;
};

Parser.getImports$LParser$ = Parser$getImports$LParser$;

function Parser$registerBuiltinImports$LParser$ALParser$($this, parsers) {
	var i;
	for (i = parsers.length - 1; i >= 0; --i) {
		$this._imports.unshift(new Import(parsers[i]));
	}
};

Parser.registerBuiltinImports$LParser$ALParser$ = Parser$registerBuiltinImports$LParser$ALParser$;

function Parser$lookupImportAlias$LParser$S($this, name) {
	var i;
	var alias;
	var this$0;
	var this$0$0;
	for (i = 0; i < $this._imports.length; ++i) {
		this$0 = $this._imports[i];
		alias = (this$0._aliasToken ? (this$0$0 = this$0._aliasToken, this$0$0._value) : null);
		if (alias != null && alias === name) {
			return $this._imports[i];
		}
	}
	return null;
};

Parser.lookupImportAlias$LParser$S = Parser$lookupImportAlias$LParser$S;

function Parser$lookup$LParser$ALCompileError$LToken$S($this, errors, contextToken, className) {
	var i;
	var classDef;
	var found;
	var this$0;
	var this$0$0;
	for (i = 0; i < $this._classDefs.length; ++i) {
		classDef = $this._classDefs[i];
		if (classDef.className$() === className) {
			return classDef;
		}
	}
	found = [];
	for (i = 0; i < $this._imports.length; ++i) {
		if ((this$0 = $this._imports[i], this$0._aliasToken ? (this$0$0 = this$0._aliasToken, this$0$0._value) : null) == null) {
			found = found.concat(Import$getClasses$LImport$S($this._imports[i], className));
		}
	}
	if (found.length === 1) {
		return found[0];
	}
	if (found.length >= 2) {
		errors.push(new CompileError(contextToken, "multiple candidates exist for class name '" + className + "'"));
	}
	return null;
};

Parser.lookup$LParser$ALCompileError$LToken$S = Parser$lookup$LParser$ALCompileError$LToken$S;

function Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback) {
	var instantiateCallback;
	var candidateCallbacks;
	var i;
	instantiateCallback = Parser$createGetTemplateClassCallback$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback);
	if (instantiateCallback != null) {
		return instantiateCallback(errors, request, postInstantiationCallback);
	}
	candidateCallbacks = [];
	for (i = 0; i < $this._imports.length; ++i) {
		candidateCallbacks = candidateCallbacks.concat(Import$createGetTemplateClassCallbacks$LImport$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this._imports[i], errors, request, postInstantiationCallback));
	}
	if (candidateCallbacks.length === 0) {
		errors.push(new CompileError(request._token, "could not find definition for template class: '" + request._className + "'"));
		return null;
	} else if (candidateCallbacks.length >= 2) {
		errors.push(new CompileError(request._token, "multiple candidates exist for template class name '" + request._className + "'"));
		return null;
	}
	return candidateCallbacks[0](null, null, null);
};

Parser.lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$;

function Parser$createGetTemplateClassCallback$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$($this, errors, request, postInstantiationCallback) {
	var i;
	var classDef;
	var templateDef;
	var this$0;
	var this$0$0;
	var this$1;
	for (i = 0; i < $this._classDefs.length; ++i) {
		classDef = $this._classDefs[i];
		if (classDef instanceof InstantiatedClassDefinition && (this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) === request._className && Util$typesAreEqual$ALType$ALType$((this$1 = classDef, this$1._typeArguments), request._typeArgs)) {
			return (function (_, __, ___) {
				return classDef;
			});
		}
	}
	for (i = 0; i < $this._templateClassDefs.length; ++i) {
		templateDef = $this._templateClassDefs[i];
		if (templateDef._className === request._className) {
			return (function (_, __, ___) {
				var classDef;
				classDef = TemplateClassDefinition$instantiateTemplateClass$LTemplateClassDefinition$ALCompileError$LTemplateInstantiationRequest$(templateDef, errors, request);
				if (classDef == null) {
					return null;
				}
				$this._classDefs.push(classDef);
				classDef._parser = $this;
				ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(classDef, ({errors: errors, parser: $this, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}));
				postInstantiationCallback($this, classDef);
				return classDef;
			});
		}
	}
	return null;
};

Parser.createGetTemplateClassCallback$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$ = Parser$createGetTemplateClassCallback$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$;

function Parser$_pushClassState$LParser$($this) {
	$this._outerClass = ({outer: $this._outerClass, classType: $this._classType, typeArgs: $this._typeArgs, extendType: $this._extendType, implementTypes: $this._implementTypes, objectTypesUsed: $this._objectTypesUsed, classFlags: $this._classFlags, inners: $this._inners, templateInners: $this._templateInners});
};

Parser._pushClassState$LParser$ = Parser$_pushClassState$LParser$;

function Parser$_popClassState$LParser$($this) {
	var _outerClass$0;
	$this._classType = (_outerClass$0 = $this._outerClass).classType;
	$this._typeArgs = _outerClass$0.typeArgs;
	$this._extendType = _outerClass$0.extendType;
	$this._implementTypes = _outerClass$0.implementTypes;
	$this._objectTypesUsed = _outerClass$0.objectTypesUsed;
	$this._classFlags = _outerClass$0.classFlags;
	$this._inners = _outerClass$0.inners;
	$this._templateInners = _outerClass$0.templateInners;
	$this._outerClass = _outerClass$0.outer;
};

Parser._popClassState$LParser$ = Parser$_popClassState$LParser$;

function Parser$_pushScope$LParser$LLocalVariable$ALArgumentDeclaration$($this, funcLocal, args) {
	$this._prevScope = ({prev: $this._prevScope, locals: $this._locals, funcLocal: $this._funcLocal, arguments: $this._arguments, statements: $this._statements, closures: $this._closures, isGenerator: $this._isGenerator});
	$this._locals = [];
	$this._funcLocal = funcLocal;
	$this._arguments = args;
	$this._statements = [];
	$this._closures = [];
	$this._isGenerator = false;
};

Parser._pushScope$LParser$LLocalVariable$ALArgumentDeclaration$ = Parser$_pushScope$LParser$LLocalVariable$ALArgumentDeclaration$;

function Parser$_popScope$LParser$($this) {
	var _prevScope$0;
	$this._locals = (_prevScope$0 = $this._prevScope).locals;
	$this._funcLocal = _prevScope$0.funcLocal;
	$this._arguments = _prevScope$0.arguments;
	$this._statements = _prevScope$0.statements;
	$this._closures = _prevScope$0.closures;
	$this._isGenerator = _prevScope$0.isGenerator;
	$this._prevScope = _prevScope$0.prev;
};

Parser._popScope$LParser$ = Parser$_popScope$LParser$;

function Parser$_registerLocal$LParser$LToken$LType$BB($this, identifierToken, type, isConst, isFunctionStmt) {
	var isEqualTo;
	var i;
	var newLocal;
	var message$0;
	function isEqualTo(local) {
		var message$0;
		var message$1;
		var this$0;
		if ((this$0 = local._name, this$0._value) === identifierToken._value) {
			if (type != null && local._type != null && ! local._type.equals$LType$(type) || isFunctionStmt) {
				message$0 = "conflicting types for variable " + identifierToken._value;
				$this._errors.push(new CompileError(identifierToken, message$0));
			}
			if (local._isConstant !== isConst) {
				message$1 = "const attribute conflict for variable " + identifierToken._value;
				$this._errors.push(new CompileError(identifierToken, message$1));
			}
			return true;
		}
		return false;
	}
	if ($this._arguments == null) {
		message$0 = Util$format$SAS("cannot declare variable %1 outside of a function", [ identifierToken._value ]);
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message$0));
		return null;
	}
	if ($this._funcLocal != null) {
		if (isEqualTo($this._funcLocal)) {
			return $this._funcLocal;
		}
	}
	for (i = 0; i < $this._arguments.length; ++i) {
		if (isEqualTo($this._arguments[i])) {
			return $this._arguments[i];
		}
	}
	for (i = 0; i < $this._locals.length; i++) {
		if (isEqualTo($this._locals[i])) {
			return $this._locals[i];
		}
	}
	newLocal = new LocalVariable(identifierToken, type, isConst);
	$this._locals.push(newLocal);
	return newLocal;
};

Parser._registerLocal$LParser$LToken$LType$BB = Parser$_registerLocal$LParser$LToken$LType$BB;

function Parser$_registerLocal$LParser$LToken$LType$B($this, identifierToken, type, isConst) {
	return Parser$_registerLocal$LParser$LToken$LType$BB($this, identifierToken, type, isConst, false);
};

Parser._registerLocal$LParser$LToken$LType$B = Parser$_registerLocal$LParser$LToken$LType$B;

function Parser$_preserveState$LParser$($this) {
	return ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
};

Parser._preserveState$LParser$ = Parser$_preserveState$LParser$;

function Parser$_restoreState$LParser$LParserState$($this, state) {
	var _closures$0;
	var numClosures$0;
	var _objectTypesUsed$0;
	var numObjectTypesUsed$0;
	var _templateInstantiationRequests$0;
	var numTemplateInstantiationRequests$0;
	$this._lineNumber = state.lineNumber;
	$this._columnOffset = state.columnOffset;
	$this._docComment = state.docComment;
	$this._tokenLength = state.tokenLength;
	$this._isGenerator = state.isGenerator;
	$this._errors.length = state.numErrors;
	if ($this._closures != null) {
		(_closures$0 = $this._closures).splice(numClosures$0 = state.numClosures, _closures$0.length - numClosures$0);
	}
	(_objectTypesUsed$0 = $this._objectTypesUsed).splice(numObjectTypesUsed$0 = state.numObjectTypesUsed, _objectTypesUsed$0.length - numObjectTypesUsed$0);
	(_templateInstantiationRequests$0 = $this._templateInstantiationRequests).splice(numTemplateInstantiationRequests$0 = state.numTemplateInstantiationRequests, _templateInstantiationRequests$0.length - numTemplateInstantiationRequests$0);
};

Parser._restoreState$LParser$LParserState$ = Parser$_restoreState$LParser$LParserState$;

function Parser$_getColumn$LParser$($this) {
	return $this._columnOffset;
};

Parser._getColumn$LParser$ = Parser$_getColumn$LParser$;

function Parser$_newError$LParser$S($this, message) {
	$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message));
};

Parser._newError$LParser$S = Parser$_newError$LParser$S;

function Parser$_newError$LParser$SNN($this, message, lineNumber, columnOffset) {
	$this._errors.push(new CompileError$0($this._filename, lineNumber, columnOffset, message));
};

Parser._newError$LParser$SNN = Parser$_newError$LParser$SNN;

function Parser$_newError$LParser$SLToken$($this, message, token) {
	$this._errors.push(new CompileError(token, message));
};

Parser._newError$LParser$SLToken$ = Parser$_newError$LParser$SLToken$;

function Parser$_newDeprecatedWarning$LParser$S($this, message) {
	$this._errors.push(new DeprecatedWarning$0($this._filename, $this._lineNumber, $this._columnOffset, message));
};

Parser._newDeprecatedWarning$LParser$S = Parser$_newDeprecatedWarning$LParser$S;

function Parser$_newExperimentalWarning$LParser$LToken$($this, feature) {
	$this._errors.push(new ExperimentalWarning(feature, feature._value));
};

Parser._newExperimentalWarning$LParser$LToken$ = Parser$_newExperimentalWarning$LParser$LToken$;

function Parser$_advanceToken$LParser$($this) {
	var matched;
	var fileLevelDocComment;
	var len$0;
	var _columnOffset$0;
	var _columnOffset$1;
	var _columnOffset$2;
	if ($this._tokenLength !== 0) {
		len$0 = $this._tokenLength;
		$this._columnOffset += len$0;
		$this._tokenLength = 0;
		$this._docComment = null;
	}
	while (true) {
		while (true) {
			matched = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(/^[ \t]+/);
			if (matched != null) {
				Parser$_forwardPos$LParser$N($this, matched[0].length);
			}
			if ($this._columnOffset !== $this._lines[$this._lineNumber - 1].length) {
				break;
			}
			if ($this._lineNumber === $this._lines.length) {
				break;
			}
			$this._lineNumber++;
			$this._columnOffset = 0;
		}
		switch ($this._lines[$this._lineNumber - 1].substring(_columnOffset$2 = $this._columnOffset, _columnOffset$2 + 2)) {
		case "/*":
			if ($this._lines[$this._lineNumber - 1].substring(_columnOffset$1 = $this._columnOffset, _columnOffset$1 + 4) === "/***") {
				$this._columnOffset += 3;
				fileLevelDocComment = Parser$_parseDocComment$LParser$($this);
				if (fileLevelDocComment == null) {
					return;
				}
				if ($this._fileLevelDocComment == null) {
					$this._fileLevelDocComment = fileLevelDocComment;
				}
			} else if ($this._lines[$this._lineNumber - 1].substring(_columnOffset$0 = $this._columnOffset, _columnOffset$0 + 3) === "/**") {
				$this._columnOffset += 2;
				if (($this._docComment = Parser$_parseDocComment$LParser$($this)) == null) {
					return;
				}
			} else {
				$this._columnOffset += 2;
				$this._docComment = null;
				if (! Parser$_skipMultilineComment$LParser$($this)) {
					return;
				}
			}
			break;
		case "//":
			$this._docComment = null;
			if ($this._lineNumber === $this._lines.length) {
				$this._columnOffset = $this._lines[$this._lineNumber - 1].length;
			} else {
				$this._lineNumber++;
				$this._columnOffset = 0;
			}
			break;
		default:
			return;
		}
	}
};

Parser._advanceToken$LParser$ = Parser$_advanceToken$LParser$;

function Parser$_skipMultilineComment$LParser$($this) {
	var startLineNumber;
	var startColumnOffset;
	var endAt;
	var len$0;
	startLineNumber = $this._lineNumber;
	startColumnOffset = $this._columnOffset;
	while (true) {
		endAt = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).indexOf("*/");
		if (endAt !== -1) {
			len$0 = endAt + 2;
			$this._columnOffset += len$0;
			return true;
		}
		if ($this._lineNumber === $this._lines.length) {
			$this._columnOffset = $this._lines[$this._lineNumber - 1].length;
			$this._errors.push(new CompileError$0($this._filename, startLineNumber, startColumnOffset, "could not find the end of the comment"));
			return false;
		}
		++$this._lineNumber;
		$this._columnOffset = 0;
	}
	return false;
};

Parser._skipMultilineComment$LParser$ = Parser$_skipMultilineComment$LParser$;

function Parser$_parseDocComment$LParser$($this) {
	var docComment;
	var node;
	var count;
	var tagMatch;
	var tag;
	var nameMatch;
	var token;
	var endAt;
	var len$0;
	var s$0;
	var len$1;
	var s$1;
	var _columnOffset$0;
	var _columnOffset$1;
	var _lineNumber$0;
	var _columnOffset$2;
	docComment = new DocComment();
	node = docComment;
	while (true) {
		count = Parser$_parseDocCommentAdvanceWhiteSpace$LParser$($this);
		if ($this._lines[$this._lineNumber - 1].substring(_columnOffset$1 = $this._columnOffset, _columnOffset$1 + 2) === "*/") {
			$this._columnOffset += 2;
			break;
		} else if ($this._lines[$this._lineNumber - 1].substring(_columnOffset$0 = $this._columnOffset, _columnOffset$0 + 1) === "*") {
			$this._columnOffset += 1;
			Parser$_parseDocCommentAdvanceWhiteSpace$LParser$($this);
		} else {
			len$0 = - count;
			$this._columnOffset += len$0;
		}
		tagMatch = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(/^\@([0-9A-Za-z_]+)[ \t]*/);
		if (tagMatch != null) {
			Parser$_forwardPos$LParser$N($this, tagMatch[0].length);
			tag = tagMatch[1];
			switch (tag) {
			case "param":
				nameMatch = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(/[0-9A-Za-z_]+/);
				if (nameMatch != null) {
					token = ({_value: nameMatch[0], _isIdentifier: false, _filename: $this._filename, _lineNumber: $this._lineNumber, _columnNumber: $this._columnOffset});
					Parser$_forwardPos$LParser$N($this, nameMatch[0].length);
					node = new DocCommentParameter(token);
					docComment._params.push(node);
				} else {
					$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "name of the parameter not found after @param"));
					node = null;
				}
				break;
			default:
				node = new DocCommentTag(tag);
				docComment._tags.push(node);
				break;
			}
		}
		endAt = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).indexOf("*/");
		if (endAt !== -1) {
			if (node != null) {
				s$0 = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).substring(0, endAt) + "\n";
				node._description += s$0;
			}
			len$1 = endAt + 2;
			$this._columnOffset += len$1;
			break;
		}
		if (node != null) {
			s$1 = $this._lines[$this._lineNumber - 1].substring($this._columnOffset) + "\n";
			node._description += s$1;
		}
		if ($this._lineNumber === $this._lines.length) {
			_columnOffset$2 = $this._columnOffset = $this._lines[(_lineNumber$0 = $this._lineNumber) - 1].length;
			$this._errors.push(new CompileError$0($this._filename, _lineNumber$0, _columnOffset$2, "could not find the end of the doccomment"));
			return null;
		}
		++$this._lineNumber;
		$this._columnOffset = 0;
	}
	return docComment;
};

Parser._parseDocComment$LParser$ = Parser$_parseDocComment$LParser$;

function Parser$_parseDocCommentAdvanceWhiteSpace$LParser$($this) {
	var count;
	var ch;
	var _columnOffset$0;
	count = 0;
	while (true) {
		ch = $this._lines[$this._lineNumber - 1].substring(_columnOffset$0 = $this._columnOffset, _columnOffset$0 + 1);
		if (ch === " " || ch === "\t") {
			$this._columnOffset += 1;
			count++;
		} else {
			break;
		}
	}
	return count;
};

Parser._parseDocCommentAdvanceWhiteSpace$LParser$ = Parser$_parseDocCommentAdvanceWhiteSpace$LParser$;

function Parser$_isEOF$LParser$($this) {
	var _lines$0;
	Parser$_advanceToken$LParser$($this);
	return $this._lineNumber === (_lines$0 = $this._lines).length && $this._columnOffset === _lines$0[_lines$0.length - 1].length;
};

Parser._isEOF$LParser$ = Parser$_isEOF$LParser$;

function Parser$_expectIsNotEOF$LParser$($this) {
	var _lines$0;
	Parser$_advanceToken$LParser$($this);
	if ($this._lineNumber === (_lines$0 = $this._lines).length && $this._columnOffset === _lines$0[_lines$0.length - 1].length) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "unexpected EOF"));
		return false;
	}
	return true;
};

Parser._expectIsNotEOF$LParser$ = Parser$_expectIsNotEOF$LParser$;

function Parser$_expectOpt$LParser$SLRegExp$($this, expected, excludePattern) {
	return Parser$_expectOpt$LParser$ASLRegExp$($this, [ expected ], excludePattern);
};

Parser._expectOpt$LParser$SLRegExp$ = Parser$_expectOpt$LParser$SLRegExp$;

function Parser$_expectOpt$LParser$S($this, expected) {
	return Parser$_expectOpt$LParser$SLRegExp$($this, expected, null);
};

Parser._expectOpt$LParser$S = Parser$_expectOpt$LParser$S;

function Parser$_expectOpt$LParser$ASLRegExp$($this, expected, excludePattern) {
	var i;
	var offset;
	var this$0;
	var this$1;
	var prefix$0;
	var _columnOffset$0;
	Parser$_advanceToken$LParser$($this);
	for (i = 0; i < expected.length; ++i) {
		if ($this._completionRequest != null) {
			offset = CompletionRequest$isInRange$LCompletionRequest$NNN($this._completionRequest, $this._lineNumber, $this._columnOffset, expected[i].length);
			if (offset !== -1) {
				this$0 = $this._completionRequest;
				this$1 = new KeywordCompletionCandidate(expected[i]);
				prefix$0 = $this._lines[$this._lineNumber - 1].substring(_columnOffset$0 = $this._columnOffset, _columnOffset$0 + offset);
				this$1._prefix = prefix$0;
				this$0._candidates.push(this$1);
			}
		}
		if (Parser$_getInputByLength$LParser$N($this, expected[i].length) === expected[i]) {
			if (expected[i].match(_Lexer.rxIdent) != null && $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(_Lexer.rxIdent)[0].length !== expected[i].length) {
			} else if (excludePattern != null && $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(excludePattern) != null) {
			} else {
				$this._tokenLength = expected[i].length;
				return ({_value: expected[i], _isIdentifier: false, _filename: $this._filename, _lineNumber: $this._lineNumber, _columnNumber: $this._columnOffset});
			}
		}
	}
	return null;
};

Parser._expectOpt$LParser$ASLRegExp$ = Parser$_expectOpt$LParser$ASLRegExp$;

function Parser$_expectOpt$LParser$AS($this, expected) {
	return Parser$_expectOpt$LParser$ASLRegExp$($this, expected, null);
};

Parser._expectOpt$LParser$AS = Parser$_expectOpt$LParser$AS;

function Parser$_expect$LParser$SLRegExp$($this, expected, excludePattern) {
	return Parser$_expect$LParser$ASLRegExp$($this, [ expected ], excludePattern);
};

Parser._expect$LParser$SLRegExp$ = Parser$_expect$LParser$SLRegExp$;

function Parser$_expect$LParser$S($this, expected) {
	return Parser$_expect$LParser$SLRegExp$($this, expected, null);
};

Parser._expect$LParser$S = Parser$_expect$LParser$S;

function Parser$_expect$LParser$ASLRegExp$($this, expected, excludePattern) {
	var token;
	var lineOffset;
	var columnOffset;
	var message$0;
	var lineNumber$0;
	var columnOffset$0;
	token = Parser$_expectOpt$LParser$ASLRegExp$($this, expected, excludePattern);
	if (token == null) {
		lineOffset = $this._lineNumber - 1;
		columnOffset = $this._columnOffset - 1;
		while (lineOffset >= 0 && columnOffset >= 0) {
			if (! /[ \t\r\n]/.test($this._lines[lineOffset].charAt(columnOffset) || " ")) {
				break;
			}
			if (columnOffset !== 0) {
				columnOffset--;
			} else {
				do {
					columnOffset = $this._lines[--lineOffset].length - 1;
				} while ($this._lines[lineOffset].length === 0 && lineOffset >= 0);
			}
		}
		message$0 = "expected keyword: " + expected.join(" ");
		lineNumber$0 = lineOffset + 1;
		columnOffset$0 = columnOffset + 1;
		$this._errors.push(new CompileError$0($this._filename, lineNumber$0, columnOffset$0, message$0));
		return null;
	}
	return token;
};

Parser._expect$LParser$ASLRegExp$ = Parser$_expect$LParser$ASLRegExp$;

function Parser$_expect$LParser$AS($this, expected) {
	return Parser$_expect$LParser$ASLRegExp$($this, expected, null);
};

Parser._expect$LParser$AS = Parser$_expect$LParser$AS;

function Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, completionCb) {
	var matched;
	var offset;
	var token;
	var this$0;
	var lineNumber$0;
	var columnOffset$0;
	var length$0;
	var this$1;
	var this$2;
	var prefix$0;
	Parser$_advanceToken$LParser$($this);
	matched = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(_Lexer.rxIdent);
	if (completionCb != null && $this._completionRequest != null) {
		this$0 = $this._completionRequest;
		lineNumber$0 = $this._lineNumber;
		columnOffset$0 = $this._columnOffset;
		length$0 = (matched != null ? matched[0].length : 0);
		offset = (lineNumber$0 !== this$0._lineNumber ? -1 : columnOffset$0 <= this$0._columnOffest && this$0._columnOffest <= columnOffset$0 + length$0 ? this$0._columnOffest - columnOffset$0 : -1);
		if (offset !== -1) {
			this$1 = $this._completionRequest;
			this$2 = completionCb($this);
			prefix$0 = matched[0].substring(0, offset);
			this$2._prefix = prefix$0;
			this$1._candidates.push(this$2);
		}
	}
	if (matched == null) {
		return null;
	}
	$this._tokenLength = matched[0].length;
	token = ({_value: matched[0], _isIdentifier: true, _filename: $this._filename, _lineNumber: $this._lineNumber, _columnNumber: $this._columnOffset});
	if ($__jsx_ObjectHasOwnProperty.call(_Lexer.keywords, matched[0])) {
		$this._errors.push(new CompileError(token, "expected an identifier but found a keyword"));
		return null;
	}
	if ($__jsx_ObjectHasOwnProperty.call(_Lexer.reserved, matched[0])) {
		$this._errors.push(new CompileError(token, "expected an identifier but found a reserved word"));
		return null;
	}
	return token;
};

Parser._expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$ = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$;

function Parser$_expectIdentifierOpt$LParser$($this) {
	return Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
};

Parser._expectIdentifierOpt$LParser$ = Parser$_expectIdentifierOpt$LParser$;

function Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, completionCb) {
	var token;
	token = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, completionCb);
	if (token != null) {
		return token;
	}
	$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "expected an identifier"));
	return null;
};

Parser._expectIdentifier$LParser$F$LParser$LCompletionCandidates$$ = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$;

function Parser$_expectIdentifier$LParser$($this) {
	return Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
};

Parser._expectIdentifier$LParser$ = Parser$_expectIdentifier$LParser$;

function Parser$_expectStringLiteralOpt$LParser$($this) {
	var heredocStartMatch;
	var preservedState;
	var value;
	var endRe;
	var input;
	var endMatch;
	var matched;
	Parser$_advanceToken$LParser$($this);
	heredocStartMatch = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(_Lexer.rxHeredocStart);
	if (heredocStartMatch) {
		preservedState = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
		value = heredocStartMatch[0];
		Parser$_forwardPos$LParser$N($this, value.length);
		endRe = (value.charAt(0) === '"' ? _Lexer.rxHeredocEndDoubleQuoted : _Lexer.rxHeredocEndSingleQuoted);
		while (true) {
			input = $this._lines[$this._lineNumber - 1].substring($this._columnOffset);
			endMatch = input.match(endRe);
			if (endMatch) {
				value += endMatch[0];
				Parser$_forwardPos$LParser$N($this, endMatch[0].length);
				break;
			}
			value += input + "\n";
			$this._lineNumber++;
			$this._columnOffset = 0;
			if ($this._lineNumber > $this._lines.length) {
				Parser$_restoreState$LParser$LParserState$($this, preservedState);
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "unterminated multi-line string literal"));
				break;
			}
		}
		return ({_value: value, _isIdentifier: false, _filename: $this._filename, _lineNumber: preservedState.lineNumber, _columnNumber: preservedState.columnOffset});
	}
	matched = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(_Lexer.rxStringLiteral);
	if (matched == null) {
		return null;
	}
	$this._tokenLength = matched[0].length;
	return ({_value: matched[0], _isIdentifier: false, _filename: $this._filename, _lineNumber: $this._lineNumber, _columnNumber: $this._columnOffset});
};

Parser._expectStringLiteralOpt$LParser$ = Parser$_expectStringLiteralOpt$LParser$;

function Parser$_expectStringLiteral$LParser$($this) {
	var token;
	token = Parser$_expectStringLiteralOpt$LParser$($this);
	if (token != null) {
		return token;
	}
	$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "expected a string literal"));
	return null;
};

Parser._expectStringLiteral$LParser$ = Parser$_expectStringLiteral$LParser$;

function Parser$_expectNumberLiteralOpt$LParser$($this) {
	var matched;
	Parser$_advanceToken$LParser$($this);
	matched = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(_Lexer.rxIntegerLiteral);
	if (matched == null) {
		matched = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(_Lexer.rxNumberLiteral);
	}
	if (matched == null) {
		return null;
	}
	$this._tokenLength = matched[0].length;
	return ({_value: matched[0], _isIdentifier: false, _filename: $this._filename, _lineNumber: $this._lineNumber, _columnNumber: $this._columnOffset});
};

Parser._expectNumberLiteralOpt$LParser$ = Parser$_expectNumberLiteralOpt$LParser$;

function Parser$_expectRegExpLiteralOpt$LParser$($this) {
	var matched;
	Parser$_advanceToken$LParser$($this);
	matched = $this._lines[$this._lineNumber - 1].substring($this._columnOffset).match(_Lexer.rxRegExpLiteral);
	if (matched == null) {
		return null;
	}
	$this._tokenLength = matched[0].length;
	return ({_value: matched[0], _isIdentifier: false, _filename: $this._filename, _lineNumber: $this._lineNumber, _columnNumber: $this._columnOffset});
};

Parser._expectRegExpLiteralOpt$LParser$ = Parser$_expectRegExpLiteralOpt$LParser$;

function Parser$_skipStatement$LParser$($this) {
	var advanced;
	var _columnOffset$0;
	advanced = false;
	while (! (Parser$_advanceToken$LParser$($this), $this._lineNumber === $this._lines.length && $this._columnOffset === $this._lines[$this._lines.length - 1].length)) {
		switch ($this._lines[$this._lineNumber - 1].substring(_columnOffset$0 = $this._columnOffset, _columnOffset$0 + 1)) {
		case ";":
			$this._tokenLength = 1;
			Parser$_advanceToken$LParser$($this);
			return;
		case "{":
			if (! advanced) {
				$this._tokenLength = 1;
				Parser$_advanceToken$LParser$($this);
			}
			return;
		case "}":
			return;
		}
		$this._tokenLength = 1;
		Parser$_advanceToken$LParser$($this);
		advanced = true;
	}
};

Parser._skipStatement$LParser$ = Parser$_skipStatement$LParser$;

function Parser$_importStatement$LParser$LToken$($this, importToken) {
	var classes;
	var token;
	var filenameToken;
	var alias;
	var success;
	var i;
	var j;
	var imprt;
	var name$0;
	var this$0;
	var this$0$0;
	var this$1;
	var this$2;
	var classes$len$0;
	classes = null;
	token = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (token != null) {
		classes = [ token ];
		while (true) {
			if ((token = Parser$_expect$LParser$ASLRegExp$($this, [ ",", "from" ], null)) == null) {
				return false;
			}
			if (token._value === "from") {
				break;
			}
			if ((token = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null)) == null) {
				return false;
			}
			classes.push(token);
		}
	}
	filenameToken = Parser$_expectStringLiteral$LParser$($this);
	if (filenameToken == null) {
		return false;
	}
	alias = null;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, "into", null) != null) {
		if ((alias = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null)) == null) {
			return false;
		}
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
		return false;
	}
	if (alias != null && (name$0 = alias._value, $__jsx_ObjectHasOwnProperty.call(Util._builtInClass, name$0))) {
		$this._errors.push(new CompileError(alias, "cannot use name of a built-in class as an alias"));
		return false;
	}
	if (classes != null) {
		success = true;
		for (i = 0; i < $this._imports.length; ++i) {
			for ((j = 0, classes$len$0 = classes.length); j < classes$len$0; ++j) {
				if (! Import$checkNameConflict$LImport$ALCompileError$LToken$($this._imports[i], $this._errors, classes[j])) {
					success = false;
				}
			}
		}
		if (! success) {
			return false;
		}
	} else {
		for (i = 0; i < $this._imports.length; ++i) {
			if (alias == null) {
				if ((this$0 = $this._imports[i], this$0._aliasToken ? (this$0$0 = this$0._aliasToken, this$0$0._value) : null) == null && (this$2 = (this$1 = $this._imports[i], this$1._filenameToken), this$2._value) === filenameToken._value) {
					$this._errors.push(new CompileError(filenameToken, "cannot import the same file more than once (unless using an alias)"));
					return false;
				}
			} else if (! Import$checkNameConflict$LImport$ALCompileError$LToken$($this._imports[i], $this._errors, alias)) {
				return false;
			}
		}
	}
	imprt = Import$create$ALCompileError$LToken$LToken$ALToken$($this._errors, filenameToken, alias, classes);
	if (imprt == null) {
		return false;
	}
	$this._imports.push(imprt);
	return true;
};

Parser._importStatement$LParser$LToken$ = Parser$_importStatement$LParser$LToken$;

function Parser$_expectClassDefOpt$LParser$($this) {
	var state;
	var token;
	var _value$0;
	state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
	try {
		while (true) {
			token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "class", "interface", "mixin", "abstract", "final" ], null);
			if (token == null) {
				return false;
			}
			if ((_value$0 = token._value) === "class" || _value$0 === "interface" || _value$0 === "mixin") {
				return true;
			}
		}
	} finally {
		Parser$_restoreState$LParser$LParserState$($this, state);
	}
	return true;
};

Parser._expectClassDefOpt$LParser$ = Parser$_expectClassDefOpt$LParser$;

function Parser$_classDefinition$LParser$($this) {
	var nativeSource;
	var docComment;
	var token;
	var newFlag;
	var className;
	var implementType;
	var members;
	var success;
	var member;
	var assignToken;
	var i;
	var classDef;
	var templateClassDef;
	var this$0;
	var this$1;
	var name$0;
	var _extendType$0;
	var _classType$0;
	$this._classType = null;
	$this._extendType = null;
	$this._implementTypes = [];
	$this._objectTypesUsed = [];
	$this._inners = [];
	$this._templateInners = [];
	$this._classFlags = 0;
	if ($this._outerClass) {
		$this._classFlags |= $this._outerClass.classFlags & 16;
	}
	nativeSource = null;
	docComment = null;
	while (true) {
		token = Parser$_expect$LParser$ASLRegExp$($this, [ "class", "interface", "mixin", "abstract", "final", "native", "__fake__", "__export__" ], null);
		if (token == null) {
			return null;
		}
		if ($this._classFlags === 0) {
			docComment = $this._docComment;
		}
		if (token._value === "class") {
			break;
		} else if (token._value === "interface") {
			if (($this._classFlags & 20) !== 0) {
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "interface cannot have final or native attribute set"));
				return null;
			}
			$this._classFlags |= 64;
			break;
		} else if (token._value === "mixin") {
			if (($this._classFlags & 16404) !== 0) {
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "mixin cannot have final, native, or __export__ attribute set"));
				return null;
			}
			$this._classFlags |= 128;
			break;
		}
		newFlag = 0;
		switch (token._value) {
		case "abstract":
			newFlag = 2;
			break;
		case "final":
			newFlag = 4;
			break;
		case "native":
			if (Parser$_expectOpt$LParser$SLRegExp$($this, "(", null) != null) {
				$this._errors.push(new DeprecatedWarning$0($this._filename, $this._lineNumber, $this._columnOffset, "use of native(\"...\") is deprecated, use class N { ... } = \"...\"; instead"));
				nativeSource = Parser$_expectStringLiteral$LParser$($this);
				Parser$_expect$LParser$SLRegExp$($this, ")", null);
			}
			newFlag = 16;
			break;
		case "__fake__":
			newFlag = 256;
			break;
		case "__export__":
			newFlag = 16384;
			break;
		default:
			throw new Error("logic flaw");
		}
		if (($this._classFlags & newFlag) !== 0) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "same attribute cannot be specified more than once"));
			return null;
		}
		$this._classFlags |= newFlag;
	}
	className = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (className == null) {
		return null;
	}
	if (($this._typeArgs = Parser$_formalTypeArguments$LParser$($this)) == null) {
		return null;
	}
	_classType$0 = $this._classType = new ParsedObjectType(new QualifiedName$1(className, $this._outerClass != null ? $this._outerClass.classType : null), $this._typeArgs.map((function (token) {
		return new ParsedObjectType(new QualifiedName(token), []);
	})));
	$this._objectTypesUsed.push(_classType$0);
	if (($this._classFlags & 192) === 0) {
		if (Parser$_expectOpt$LParser$SLRegExp$($this, "extends", null) != null) {
			$this._extendType = Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$($this, null, true, (function (classDef) {
				return (classDef.flags$() & 196) === 0;
			}));
		}
		if ($this._extendType == null && className._value !== "Object") {
			_extendType$0 = $this._extendType = new ParsedObjectType(new QualifiedName(new Token$2("Object", true)), []);
			$this._objectTypesUsed.push(_extendType$0);
		}
	} else if (($this._classFlags & 22) !== 0) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "interface or mixin cannot have attributes: 'abstract', 'final', 'native"));
		$this._classFlags &= -23;
	}
	if (Parser$_expectOpt$LParser$SLRegExp$($this, "implements", null) != null) {
		do {
			implementType = Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$($this, null, true, (function (classDef) {
				return (classDef.flags$() & 192) !== 0;
			}));
			if (implementType != null) {
				$this._implementTypes.push(implementType);
			}
		} while (Parser$_expectOpt$LParser$SLRegExp$($this, ",", null) != null);
	}
	if (Parser$_expect$LParser$SLRegExp$($this, "{", null) == null) {
		return null;
	}
	members = [];
	success = true;
	while (Parser$_expectOpt$LParser$SLRegExp$($this, "}", null) == null) {
		if (! Parser$_expectIsNotEOF$LParser$($this)) {
			break;
		}
		if (Parser$_expectClassDefOpt$LParser$($this)) {
			$this._outerClass = ({outer: $this._outerClass, classType: $this._classType, typeArgs: $this._typeArgs, extendType: $this._extendType, implementTypes: $this._implementTypes, objectTypesUsed: $this._objectTypesUsed, classFlags: $this._classFlags, inners: $this._inners, templateInners: $this._templateInners});
			if (Parser$_classDefinition$LParser$($this) == null) {
				Parser$_skipStatement$LParser$($this);
			}
			Parser$_popClassState$LParser$($this);
			continue;
		}
		member = Parser$_memberDefinition$LParser$($this);
		if (member != null) {
			members.push(member);
		} else {
			Parser$_skipStatement$LParser$($this);
		}
	}
	assignToken = Parser$_expectOpt$LParser$SLRegExp$($this, "=", null);
	if (assignToken != null) {
		nativeSource = Parser$_expectStringLiteral$LParser$($this);
		if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
			return null;
		}
		if (($this._classFlags & 16) === 0) {
			$this._errors.push(new CompileError(assignToken, "in-line native definition requires native attribute"));
			return null;
		}
	}
	if (($this._classFlags & 16) === 0 && (name$0 = className._value, $__jsx_ObjectHasOwnProperty.call(Util._builtInClass, name$0))) {
		$this._errors.push(new CompileError(className, "cannot re-define a built-in class"));
		success = false;
	} else if ($this._outerClass != null) {
		for (i = 0; i < $this._outerClass.inners.length; ++i) {
			if ($this._outerClass.inners[i].className$() === className._value) {
				$this._errors.push(new CompileError(className, "a non-template inner class with the same name has been already declared"));
				success = false;
				break;
			}
		}
		for (i = 0; i < $this._outerClass.templateInners.length; ++i) {
			if ((this$0 = $this._outerClass.templateInners[i], this$0._className) === className._value) {
				$this._errors.push(new CompileError(className, "a template inner class with the same name has been already declared"));
				success = false;
				break;
			}
		}
	} else {
		for (i = 0; i < $this._imports.length; ++i) {
			if (! Import$checkNameConflict$LImport$ALCompileError$LToken$($this._imports[i], $this._errors, className)) {
				success = false;
			}
		}
		for (i = 0; i < $this._classDefs.length; ++i) {
			if ($this._classDefs[i].className$() === className._value) {
				$this._errors.push(new CompileError(className, "a non-template class with the same name has been already declared"));
				success = false;
				break;
			}
		}
		for (i = 0; i < $this._templateClassDefs.length; ++i) {
			if ((this$1 = $this._templateClassDefs[i], this$1._className) === className._value) {
				$this._errors.push(new CompileError(className, "a template class with the name same has been already declared"));
				success = false;
				break;
			}
		}
	}
	if (! success) {
		return null;
	}
	if ($this._typeArgs.length !== 0) {
		templateClassDef = new TemplateClassDefinition(className, className._value, $this._classFlags, $this._typeArgs, $this._extendType, $this._implementTypes, members, $this._inners, $this._templateInners, $this._objectTypesUsed, docComment);
		if ($this._outerClass != null) {
			$this._outerClass.templateInners.push(templateClassDef);
		} else {
			$this._templateClassDefs.push(templateClassDef);
		}
		classDef = templateClassDef;
	} else {
		classDef = new ClassDefinition(className, className._value, $this._classFlags, $this._extendType, $this._implementTypes, members, $this._inners, $this._templateInners, $this._objectTypesUsed, docComment);
		if ($this._outerClass != null) {
			$this._outerClass.inners.push(classDef);
		} else {
			$this._classDefs.push(classDef);
		}
	}
	if (nativeSource != null) {
		classDef._nativeSource = nativeSource;
	}
	classDef._parser = $this;
	return classDef;
};

Parser._classDefinition$LParser$ = Parser$_classDefinition$LParser$;

function Parser$_memberDefinition$LParser$($this) {
	var flags;
	var isNoExport;
	var docComment;
	var token;
	var newFlag;
	var shouldExport;
	var name;
	var type;
	var initialValue;
	var closures;
	var _value$0;
	flags = 0;
	isNoExport = false;
	docComment = null;
	while (true) {
		token = Parser$_expect$LParser$ASLRegExp$($this, [ "function", "var", "static", "abstract", "override", "final", "const", "native", "__readonly__", "inline", "__pure__", "delete", "__export__", "__noexport__" ], null);
		if (token == null) {
			return null;
		}
		if (flags === 0) {
			docComment = $this._docComment;
		}
		if (token._value === "const") {
			if ((flags & 8) === 0) {
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "constants must be static"));
				return null;
			}
			flags |= 1;
			break;
		} else if ((_value$0 = token._value) === "function" || _value$0 === "var") {
			break;
		} else if (token._value === "__noexport__") {
			if (isNoExport) {
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "same attribute cannot be specified more than once"));
				return null;
			} else if ((flags & 16384) !== 0) {
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "cannot set the attribute, already declared as __export__"));
				return null;
			}
			isNoExport = true;
		} else {
			newFlag = 0;
			switch (token._value) {
			case "static":
				if (($this._classFlags & 192) !== 0) {
					$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "interfaces and mixins cannot have static members"));
					return null;
				}
				newFlag = 8;
				break;
			case "abstract":
				newFlag = 2;
				break;
			case "override":
				if (($this._classFlags & 64) !== 0) {
					$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "functions of an interface cannot have 'override' attribute set"));
					return null;
				}
				newFlag = 32;
				break;
			case "final":
				if (($this._classFlags & 64) !== 0) {
					$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "functions of an interface cannot have 'final' attribute set"));
					return null;
				}
				newFlag = 4;
				break;
			case "native":
				newFlag = 16;
				break;
			case "__readonly__":
				newFlag = 512;
				break;
			case "inline":
				newFlag = 1024;
				break;
			case "__pure__":
				newFlag = 2048;
				break;
			case "delete":
				newFlag = 4096;
				break;
			case "__export__":
				if (isNoExport) {
					$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "cannot set the attribute, already declared as __noexport__"));
					return null;
				}
				newFlag = 16384;
				break;
			default:
				throw new Error("logic flaw");
			}
			if ((flags & newFlag) !== 0) {
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "same attribute cannot be specified more than once"));
				return null;
			}
			flags |= newFlag;
		}
	}
	function shouldExport(name) {
		return (isNoExport ? false : ($this._classFlags & 16384) === 0 ? false : name.charAt(0) === "_" ? false : true);
	}
	if (($this._classFlags & 64) !== 0) {
		flags |= 2;
	}
	if (token._value === "function") {
		return Parser$_functionDefinition$LParser$LToken$NLDocComment$F$SB$($this, token, flags, docComment, shouldExport);
	}
	if ((flags & -16908) !== 0) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "variables may only have attributes: static, abstract, const"));
		return null;
	}
	if ((flags & 512) !== 0 && ($this._classFlags & 16) === 0) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "only native classes may use the __readonly__ attribute"));
		return null;
	}
	name = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (name == null) {
		return null;
	}
	if (shouldExport(name._value)) {
		flags |= 16384;
	}
	type = null;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ":", null) != null) {
		if ((type = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
			return null;
		}
	}
	initialValue = null;
	closures = [];
	if (Parser$_expectOpt$LParser$SLRegExp$($this, "=", null) != null) {
		if ((flags & 2) !== 0) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "abstract variable cannot have default value"));
			return null;
		}
		$this._closures = closures;
		initialValue = Parser$_assignExpr$LParser$B($this, false);
		$this._closures = null;
		if (initialValue == null) {
			return null;
		}
	}
	if (type == null && initialValue == null) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "variable declaration should either have type declaration or initial value"));
		return null;
	}
	if (! Parser$_expect$LParser$SLRegExp$($this, ";", null)) {
		return null;
	}
	if ($this._typeArgs.length === 0 && initialValue == null && ($this._classFlags & 16) === 0) {
		initialValue = Expression$getDefaultValueExpressionOf$LType$(type);
	}
	return new MemberVariableDefinition(token, name, flags, type, initialValue, closures, docComment);
};

Parser._memberDefinition$LParser$ = Parser$_memberDefinition$LParser$;

function Parser$_functionDefinition$LParser$LToken$NLDocComment$F$SB$($this, token, flags, docComment, shouldExport) {
	var name;
	var typeArgs;
	var numObjectTypesUsed;
	var args;
	var returnType;
	var createDefinition;
	var endDeclToken;
	var lastToken;
	var funcDef;
	var _objectTypesUsed$0;
	var _typeArgs$0;
	name = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (name == null) {
		return null;
	}
	if (shouldExport(name._value)) {
		flags |= 16384;
	}
	if (name._value === "constructor") {
		if (($this._classFlags & 64) !== 0) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "interface cannot have a constructor"));
			return null;
		}
		if ((flags & 6) !== 0) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "constructor cannot be declared as 'abstract' or 'final'"));
			return null;
		}
		flags |= 4;
	}
	flags |= $this._classFlags & 20;
	typeArgs = Parser$_formalTypeArguments$LParser$($this);
	if (typeArgs == null) {
		return null;
	}
	$this._typeArgs = $this._typeArgs.concat(typeArgs);
	numObjectTypesUsed = $this._objectTypesUsed.length;
	Parser$_pushScope$LParser$LLocalVariable$ALArgumentDeclaration$($this, null, null);
	try {
		if (Parser$_expect$LParser$SLRegExp$($this, "(", null) == null) {
			return null;
		}
		args = Parser$_functionArgumentsExpr$LParser$BBB($this, ($this._classFlags & 16) !== 0, true, true);
		if (args == null) {
			return null;
		}
		returnType = null;
		if (name._value === "constructor") {
			returnType = Type.voidType;
		} else {
			if (Parser$_expect$LParser$SLRegExp$($this, ":", null) == null) {
				return null;
			}
			returnType = Parser$_typeDeclaration$LParser$B($this, true);
			if (returnType == null) {
				return null;
			}
		}
		if ((flags & 4096) !== 0) {
			if (name._value !== "constructor" || (flags & 8) !== 0) {
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "only constructors may have the \"delete\" attribute set"));
				return null;
			}
			if (args.length !== 0) {
				$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "cannot \"delete\" a constructor with one or more arguments"));
				return null;
			}
		}
		function createDefinition(locals, statements, closures, lastToken) {
			return (typeArgs.length !== 0 ? new TemplateFunctionDefinition(token, name, flags, typeArgs, returnType, args, locals, statements, closures, lastToken, docComment) : new MemberFunctionDefinition(token, name, flags, returnType, args, locals, statements, closures, lastToken, docComment));
		}
		if (($this._classFlags & 64) !== 0) {
			if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
				return null;
			}
			return createDefinition(null, null, [], null);
		} else if ((flags & 4114) !== 0) {
			endDeclToken = Parser$_expect$LParser$ASLRegExp$($this, [ ";", "{" ], null);
			if (endDeclToken == null) {
				return null;
			}
			if (endDeclToken._value === ";") {
				return createDefinition(null, null, [], null);
			}
		} else if (Parser$_expect$LParser$SLRegExp$($this, "{", null) == null) {
			return null;
		}
		$this._arguments = args;
		if (name._value === "constructor") {
			lastToken = Parser$_initializeBlock$LParser$($this);
		} else {
			lastToken = Parser$_block$LParser$($this);
		}
		funcDef = createDefinition($this._locals, $this._statements, $this._closures, lastToken);
		return funcDef;
	} finally {
		Parser$_popScope$LParser$($this);
		(_typeArgs$0 = $this._typeArgs).splice(_typeArgs$0.length - typeArgs.length, _typeArgs$0.length);
		if (typeArgs.length !== 0) {
			(_objectTypesUsed$0 = $this._objectTypesUsed).splice(numObjectTypesUsed, _objectTypesUsed$0.length - numObjectTypesUsed);
		}
	}
};

Parser._functionDefinition$LParser$LToken$NLDocComment$F$SB$ = Parser$_functionDefinition$LParser$LToken$NLDocComment$F$SB$;

function Parser$_formalTypeArguments$LParser$($this) {
	var typeArgs;
	var typeArg;
	var token;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ".", null) == null) {
		return [];
	}
	if (Parser$_expect$LParser$SLRegExp$($this, "<", null) == null) {
		return null;
	}
	typeArgs = [];
	do {
		typeArg = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
		if (typeArg == null) {
			return null;
		}
		typeArgs.push(typeArg);
		token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ ",", ">" ], null);
		if (token == null) {
			return null;
		}
	} while (token._value === ",");
	return typeArgs;
};

Parser._formalTypeArguments$LParser$ = Parser$_formalTypeArguments$LParser$;

function Parser$_actualTypeArguments$LParser$($this) {
	var types;
	var state;
	var type;
	var token;
	types = [];
	state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ".", null) == null) {
		return types;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, "<", null) == null) {
		Parser$_restoreState$LParser$LParserState$($this, state);
		return types;
	}
	do {
		type = Parser$_typeDeclaration$LParser$B($this, true);
		if (type == null) {
			return null;
		}
		types.push(type);
		token = Parser$_expect$LParser$ASLRegExp$($this, [ ">", "," ], null);
		if (token == null) {
			return null;
		}
	} while (token._value === ",");
	return types;
};

Parser._actualTypeArguments$LParser$ = Parser$_actualTypeArguments$LParser$;

function Parser$_typeDeclaration$LParser$B($this, allowVoid) {
	var token;
	var typeDecl;
	var genType;
	var generatorType$0;
	if ((token = Parser$_expectOpt$LParser$SLRegExp$($this, "void", null)) != null) {
		typeDecl = Type.voidType;
	} else {
		typeDecl = Parser$_typeDeclarationNoVoidNoYield$LParser$($this);
		if (typeDecl == null) {
			return null;
		}
	}
	while (Parser$_expectOpt$LParser$SLRegExp$($this, "yield", null) != null) {
		genType = Parser$_typeDeclaration$LParser$B($this, true);
		if (genType == null) {
			return null;
		}
		generatorType$0 = new ParsedObjectType(new QualifiedName(new Token$2("Generator", true)), [ typeDecl, genType ]);
		$this._objectTypesUsed.push(generatorType$0);
		typeDecl = generatorType$0;
	}
	if (! allowVoid && typeDecl.equals$LType$(Type.voidType)) {
		$this._errors.push(new CompileError(token, "'void' cannot be used here"));
		return null;
	}
	return typeDecl;
};

Parser._typeDeclaration$LParser$B = Parser$_typeDeclaration$LParser$B;

function Parser$_typeDeclarationNoVoidNoYield$LParser$($this) {
	var typeDecl;
	var arrayType$0;
	typeDecl = Parser$_typeDeclarationNoArrayNoVoidNoYield$LParser$($this);
	if (typeDecl == null) {
		return null;
	}
	while (Parser$_expectOpt$LParser$SLRegExp$($this, "[", null) != null) {
		if (Parser$_expect$LParser$SLRegExp$($this, "]", null) == null) {
			return null;
		}
		if (typeDecl instanceof NullableType) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "Nullable.<T> cannot be an array, should be: T[]"));
			return null;
		}
		arrayType$0 = new ParsedObjectType(new QualifiedName(new Token$2("Array", true)), [ typeDecl ]);
		$this._objectTypesUsed.push(arrayType$0);
		typeDecl = arrayType$0;
	}
	return typeDecl;
};

Parser._typeDeclarationNoVoidNoYield$LParser$ = Parser$_typeDeclarationNoVoidNoYield$LParser$;

function Parser$_typeDeclarationNoArrayNoVoidNoYield$LParser$($this) {
	var token;
	token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "MayBeUndefined", "Nullable", "variant" ], null);
	if (token == null) {
		return Parser$_primaryTypeDeclaration$LParser$($this);
	}
	switch (token._value) {
	case "MayBeUndefined":
		$this._errors.push(new DeprecatedWarning$0($this._filename, $this._lineNumber, $this._columnOffset, "use of 'MayBeUndefined' is deprecated, use 'Nullable' instead"));
	case "Nullable":
		return Parser$_nullableTypeDeclaration$LParser$($this);
	case "variant":
		return Type.variantType;
	default:
		throw new Error("logic flaw");
	}
};

Parser._typeDeclarationNoArrayNoVoidNoYield$LParser$ = Parser$_typeDeclarationNoArrayNoVoidNoYield$LParser$;

function Parser$_nullableTypeDeclaration$LParser$($this) {
	var baseType;
	var i;
	if (Parser$_expect$LParser$SLRegExp$($this, ".", null) == null || Parser$_expect$LParser$SLRegExp$($this, "<", null) == null) {
		return null;
	}
	baseType = Parser$_typeDeclaration$LParser$B($this, true);
	if (baseType == null) {
		return null;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ">", null) == null) {
		return null;
	}
	if (baseType.equals$LType$(Type.variantType)) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "variant cannot be declared as nullable (since it is always nullable)"));
		return null;
	}
	if (baseType instanceof NullableType) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "nested Nullable.<T> is forbidden"));
		return null;
	}
	if ($this._typeArgs != null) {
		for (i = 0; i < $this._typeArgs.length; ++i) {
			if (baseType.equals$LType$(new ParsedObjectType(new QualifiedName($this._typeArgs[i]), []))) {
				return new NullableType(baseType);
			}
		}
	}
	return (baseType instanceof PrimitiveType || baseType.equals$LType$(Type.voidType) ? new NullableType(baseType) : baseType);
};

Parser._nullableTypeDeclaration$LParser$ = Parser$_nullableTypeDeclaration$LParser$;

function Parser$_primaryTypeDeclaration$LParser$($this) {
	var token;
	token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "(", "function", "boolean", "int", "number", "string" ], null);
	if (token != null) {
		switch (token._value) {
		case "(":
			return Parser$_lightFunctionTypeDeclaration$LParser$LType$($this, null);
		case "function":
			return Parser$_functionTypeDeclaration$LParser$LType$($this, null);
		case "boolean":
			return Type.booleanType;
		case "int":
			return Type.integerType;
		case "number":
			return Type.numberType;
		case "string":
			return Type.stringType;
		default:
			throw new Error("logic flaw");
		}
	} else {
		return Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$($this, null, true, null);
	}
};

Parser._primaryTypeDeclaration$LParser$ = Parser$_primaryTypeDeclaration$LParser$;

function Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$($this, firstToken, allowInner, autoCompleteMatchCb) {
	var token;
	var imprt;
	var qualifiedName;
	var typeArgs;
	var objectType;
	var enclosingType;
	var _value$0;
	if (firstToken == null) {
		if ($this._classType != null && (token = Parser$_expectOpt$LParser$SLRegExp$($this, "__CLASS__", null)) != null) {
		} else if ((token = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, (function (self) {
			return new CompletionCandidatesOfTopLevel(self, autoCompleteMatchCb);
		}))) == null) {
			return null;
		}
	} else {
		token = firstToken;
	}
	if (token._value === "variant") {
		$this._errors.push(new CompileError(token, "cannot use 'variant' as a class name"));
		return null;
	} else if ((_value$0 = token._value) === "Nullable" || _value$0 === "MayBeUndefined") {
		$this._errors.push(new CompileError(token, "cannot use 'Nullable' (or MayBeUndefined) as a class name"));
		return null;
	} else if (token._value === "__CLASS__") {
		return $this._classType;
	}
	imprt = Parser$lookupImportAlias$LParser$S($this, token._value);
	if (imprt != null) {
		if (Parser$_expect$LParser$SLRegExp$($this, ".", null) == null) {
			return null;
		}
		token = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, (function (self) {
			return new _CompletionCandidatesOfNamespace(imprt, autoCompleteMatchCb);
		}));
		if (token == null) {
			return null;
		}
	}
	if (! allowInner) {
		qualifiedName = new QualifiedName$0(token, imprt);
		typeArgs = Parser$_actualTypeArguments$LParser$($this);
		if (typeArgs == null) {
			return null;
		} else if (typeArgs.length !== 0) {
			return Parser$_templateTypeDeclaration$LParser$LQualifiedName$ALType$($this, qualifiedName, typeArgs);
		} else {
			objectType = new ParsedObjectType(qualifiedName, []);
			$this._objectTypesUsed.push(objectType);
			return objectType;
		}
	} else {
		enclosingType = null;
		while (true) {
			qualifiedName = (enclosingType != null ? new QualifiedName$1(token, enclosingType) : new QualifiedName$0(token, imprt));
			typeArgs = Parser$_actualTypeArguments$LParser$($this);
			if (typeArgs == null) {
				return null;
			} else if (typeArgs.length !== 0) {
				enclosingType = Parser$_templateTypeDeclaration$LParser$LQualifiedName$ALType$($this, qualifiedName, typeArgs);
			} else {
				objectType = new ParsedObjectType(qualifiedName, []);
				$this._objectTypesUsed.push(objectType);
				enclosingType = objectType;
			}
			if (Parser$_expectOpt$LParser$SLRegExp$($this, ".", null) == null) {
				break;
			}
			token = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
			if (token == null) {
				return null;
			}
		}
		return enclosingType;
	}
};

Parser._objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$ = Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$;

function Parser$_templateTypeDeclaration$LParser$LQualifiedName$ALType$($this, qualifiedName, typeArgs) {
	var className;
	var objectType;
	var this$0;
	var message$0;
	var message$1;
	this$0 = qualifiedName._token;
	className = this$0._value;
	if (className === "Array" || className === "Map") {
		if (typeArgs[0] instanceof NullableType) {
			message$0 = "cannot declare " + className + ".<Nullable.<T>>, should be " + className + ".<T>";
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message$0));
			return null;
		}
		if (typeArgs[0].equals$LType$(Type.voidType)) {
			message$1 = "cannot declare " + className + ".<T> with T=void";
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message$1));
			return null;
		}
	}
	objectType = new ParsedObjectType(qualifiedName, typeArgs);
	$this._objectTypesUsed.push(objectType);
	return objectType;
};

Parser._templateTypeDeclaration$LParser$LQualifiedName$ALType$ = Parser$_templateTypeDeclaration$LParser$LQualifiedName$ALType$;

function Parser$_lightFunctionTypeDeclaration$LParser$LType$($this, objectType) {
	var argTypes;
	var isVarArg;
	var argType;
	var token;
	var returnType;
	argTypes = [];
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ")", null) == null) {
		do {
			isVarArg = Parser$_expectOpt$LParser$SLRegExp$($this, "...", null) != null;
			argType = Parser$_typeDeclaration$LParser$B($this, false);
			if (argType == null) {
				return null;
			}
			if (isVarArg) {
				argTypes.push(new VariableLengthArgumentType(argType));
				if (Parser$_expect$LParser$SLRegExp$($this, ")", null) == null) {
					return null;
				}
				break;
			}
			argTypes.push(argType);
			token = Parser$_expect$LParser$ASLRegExp$($this, [ ")", "," ], null);
			if (token == null) {
				return null;
			}
		} while (token._value === ",");
	}
	if (Parser$_expect$LParser$ASLRegExp$($this, [ "->", "=>" ], null) == null) {
		return null;
	}
	returnType = Parser$_typeDeclaration$LParser$B($this, true);
	return (returnType == null ? null : objectType != null ? new MemberFunctionType(null, objectType, returnType, argTypes, true) : new StaticFunctionType(null, returnType, argTypes, true));
};

Parser._lightFunctionTypeDeclaration$LParser$LType$ = Parser$_lightFunctionTypeDeclaration$LParser$LType$;

function Parser$_functionTypeDeclaration$LParser$LType$($this, objectType) {
	var argTypes;
	var isVarArg;
	var argType;
	var token;
	var returnType;
	Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (Parser$_expect$LParser$SLRegExp$($this, "(", null) == null) {
		return null;
	}
	argTypes = [];
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ")", null) == null) {
		do {
			isVarArg = Parser$_expectOpt$LParser$SLRegExp$($this, "...", null) != null;
			Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
			if (Parser$_expect$LParser$SLRegExp$($this, ":", null) == null) {
				return null;
			}
			argType = Parser$_typeDeclaration$LParser$B($this, false);
			if (argType == null) {
				return null;
			}
			if (isVarArg) {
				argTypes.push(new VariableLengthArgumentType(argType));
				if (Parser$_expect$LParser$SLRegExp$($this, ")", null) == null) {
					return null;
				}
				break;
			}
			argTypes.push(argType);
			token = Parser$_expect$LParser$ASLRegExp$($this, [ ")", "," ], null);
			if (token == null) {
				return null;
			}
		} while (token._value === ",");
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ":", null) == null) {
		return null;
	}
	returnType = Parser$_typeDeclaration$LParser$B($this, true);
	return (returnType == null ? null : objectType != null ? new MemberFunctionType(null, objectType, returnType, argTypes, true) : new StaticFunctionType(null, returnType, argTypes, true));
};

Parser._functionTypeDeclaration$LParser$LType$ = Parser$_functionTypeDeclaration$LParser$LType$;

function Parser$_registerArrayTypeOf$LParser$LToken$LType$($this, token, elementType) {
	var arrayType;
	arrayType = new ParsedObjectType(new QualifiedName(new Token$2("Array", true)), [ elementType ]);
	$this._objectTypesUsed.push(arrayType);
	return arrayType;
};

Parser._registerArrayTypeOf$LParser$LToken$LType$ = Parser$_registerArrayTypeOf$LParser$LToken$LType$;

function Parser$_registerGeneratorTypeOf$LParser$LType$LType$($this, seedType, genType) {
	var generatorType;
	generatorType = new ParsedObjectType(new QualifiedName(new Token$2("Generator", true)), [ seedType, genType ]);
	$this._objectTypesUsed.push(generatorType);
	return generatorType;
};

Parser._registerGeneratorTypeOf$LParser$LType$LType$ = Parser$_registerGeneratorTypeOf$LParser$LType$LType$;

function Parser$_initializeBlock$LParser$($this) {
	var token;
	var state;
	while ((token = Parser$_expectOpt$LParser$SLRegExp$($this, "}", null)) == null) {
		state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
		if (! Parser$_constructorInvocationStatement$LParser$($this)) {
			Parser$_restoreState$LParser$LParserState$($this, state);
			return Parser$_block$LParser$($this);
		}
	}
	return token;
};

Parser._initializeBlock$LParser$ = Parser$_initializeBlock$LParser$;

function Parser$_block$LParser$($this) {
	var token;
	while ((token = Parser$_expectOpt$LParser$SLRegExp$($this, "}", null)) == null) {
		if (! Parser$_expectIsNotEOF$LParser$($this)) {
			return null;
		}
		if (! Parser$_statement$LParser$($this)) {
			Parser$_skipStatement$LParser$($this);
		}
	}
	return token;
};

Parser._block$LParser$ = Parser$_block$LParser$;

function Parser$_statement$LParser$($this) {
	var state;
	var label;
	var token;
	var expr;
	state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
	label = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (label != null && Parser$_expectOpt$LParser$SLRegExp$($this, ":", null) != null) {
	} else {
		Parser$_restoreState$LParser$LParserState$($this, state);
		label = null;
	}
	token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "{", "var", ";", "if", "do", "while", "for", "continue", "break", "return", "switch", "throw", "try", "assert", "log", "delete", "debugger", "function", "void", "const" ], null);
	if (label != null) {
		if (! (token != null && token._value.match(/^(?:do|while|for|switch)$/) != null)) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "only blocks, iteration statements, and switch statements are allowed after a label"));
			return false;
		}
	}
	if (token != null) {
		switch (token._value) {
		case "{":
			return Parser$_block$LParser$($this) != null;
		case "var":
			return Parser$_variableStatement$LParser$B($this, false);
		case "const":
			return Parser$_variableStatement$LParser$B($this, true);
		case ";":
			return true;
		case "if":
			return Parser$_ifStatement$LParser$LToken$($this, token);
		case "do":
			return Parser$_doWhileStatement$LParser$LToken$LToken$($this, token, label);
		case "while":
			return Parser$_whileStatement$LParser$LToken$LToken$($this, token, label);
		case "for":
			return Parser$_forStatement$LParser$LToken$LToken$($this, token, label);
		case "continue":
			return Parser$_continueStatement$LParser$LToken$($this, token);
		case "break":
			return Parser$_breakStatement$LParser$LToken$($this, token);
		case "return":
			return Parser$_returnStatement$LParser$LToken$($this, token);
		case "switch":
			return Parser$_switchStatement$LParser$LToken$LToken$($this, token, label);
		case "throw":
			return Parser$_throwStatement$LParser$LToken$($this, token);
		case "try":
			return Parser$_tryStatement$LParser$LToken$($this, token);
		case "assert":
			return Parser$_assertStatement$LParser$LToken$($this, token);
		case "log":
			return Parser$_logStatement$LParser$LToken$($this, token);
		case "delete":
			return Parser$_deleteStatement$LParser$LToken$($this, token);
		case "debugger":
			$this._statements.push(new DebuggerStatement(token));
			return true;
		case "function":
			return Parser$_functionStatement$LParser$LToken$($this, token);
		case "void":
			break;
		default:
			throw new Error("logic flaw, got " + token._value);
		}
	}
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	$this._statements.push(new ExpressionStatement(expr));
	return (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null ? false : true);
};

Parser._statement$LParser$ = Parser$_statement$LParser$;

function Parser$_constructorInvocationStatement$LParser$($this) {
	var token;
	var classType;
	var i;
	var args;
	var this$0$0;
	if ((token = Parser$_expectOpt$LParser$SLRegExp$($this, "super", null)) != null) {
		classType = $this._extendType;
	} else if ((token = Parser$_expectOpt$LParser$SLRegExp$($this, "this", null)) != null) {
		classType = $this._classType;
	} else {
		if ((classType = Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$($this, null, true, null)) == null) {
			return false;
		}
		this$0$0 = classType._qualifiedName;
		token = this$0$0._token;
		if ($this._classType.equals$LType$(classType)) {
		} else if ($this._extendType != null && $this._extendType.equals$LType$(classType)) {
		} else {
			for (i = 0; i < $this._implementTypes.length; ++i) {
				if ($this._implementTypes[i].equals$LType$(classType)) {
					break;
				}
			}
			if (i === $this._implementTypes.length) {
				return false;
			}
		}
	}
	if (Parser$_expect$LParser$SLRegExp$($this, "(", null) == null) {
		return false;
	}
	args = Parser$_argsExpr$LParser$($this);
	if (args == null) {
		return false;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
		return false;
	}
	$this._statements.push(new ConstructorInvocationStatement(token, classType, args));
	return true;
};

Parser._constructorInvocationStatement$LParser$ = Parser$_constructorInvocationStatement$LParser$;

function Parser$_variableStatement$LParser$B($this, isConst) {
	var succeeded;
	var expr;
	succeeded = [ false ];
	expr = Parser$_variableDeclarations$LParser$BBAB($this, false, isConst, succeeded);
	if (! succeeded[0]) {
		return false;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
		return false;
	}
	if (expr != null) {
		$this._statements.push(new ExpressionStatement(expr));
	}
	return true;
};

Parser._variableStatement$LParser$B = Parser$_variableStatement$LParser$B;

function Parser$_functionStatement$LParser$LToken$($this, token) {
	var isGenerator;
	var name;
	var args;
	var returnType;
	var funcLocal;
	var funcDef;
	isGenerator = false;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, "*", null) != null) {
		isGenerator = true;
	}
	name = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (name == null) {
		return false;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, "(", null) == null) {
		return false;
	}
	args = Parser$_functionArgumentsExpr$LParser$BBB($this, false, true, false);
	if (args == null) {
		return false;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ":", null) == null) {
		return false;
	}
	returnType = Parser$_typeDeclaration$LParser$B($this, true);
	if (returnType == null) {
		return false;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, "{", null) == null) {
		return false;
	}
	funcLocal = Parser$_registerLocal$LParser$LToken$LType$BB($this, name, new StaticFunctionType(token, returnType, args.map((function (arg) {
		return arg._type;
	})), false), false, true);
	funcDef = Parser$_functionBody$LParser$LToken$LToken$LLocalVariable$ALArgumentDeclaration$LType$BB($this, token, name, funcLocal, args, returnType, true, isGenerator);
	if (funcDef == null) {
		return false;
	}
	$this._closures.push(funcDef);
	funcDef._funcLocal = funcLocal;
	$this._statements.push(new FunctionStatement(token, funcDef));
	return true;
};

Parser._functionStatement$LParser$LToken$ = Parser$_functionStatement$LParser$LToken$;

function Parser$_ifStatement$LParser$LToken$($this, token) {
	var expr;
	var onTrueStatements;
	var onFalseStatements;
	var statementIndex$0;
	var statementIndex$1;
	var _statements$0;
	var _statements$1;
	if (Parser$_expect$LParser$SLRegExp$($this, "(", null) == null) {
		return false;
	}
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ")", null) == null) {
		return false;
	}
	statementIndex$0 = $this._statements.length;
	if (! Parser$_statement$LParser$($this)) {
		Parser$_skipStatement$LParser$($this);
	}
	onTrueStatements = (_statements$1 = $this._statements).splice(statementIndex$0, _statements$1.length - statementIndex$0);
	onFalseStatements = [];
	if (Parser$_expectOpt$LParser$SLRegExp$($this, "else", null) != null) {
		statementIndex$1 = $this._statements.length;
		if (! Parser$_statement$LParser$($this)) {
			Parser$_skipStatement$LParser$($this);
		}
		onFalseStatements = (_statements$0 = $this._statements).splice(statementIndex$1, _statements$0.length - statementIndex$1);
	}
	$this._statements.push(new IfStatement(token, expr, onTrueStatements, onFalseStatements));
	return true;
};

Parser._ifStatement$LParser$LToken$ = Parser$_ifStatement$LParser$LToken$;

function Parser$_doWhileStatement$LParser$LToken$LToken$($this, token, label) {
	var statements;
	var expr;
	var statementIndex$0;
	var _statements$0;
	statementIndex$0 = $this._statements.length;
	if (! Parser$_statement$LParser$($this)) {
		Parser$_skipStatement$LParser$($this);
	}
	statements = (_statements$0 = $this._statements).splice(statementIndex$0, _statements$0.length - statementIndex$0);
	if (Parser$_expect$LParser$SLRegExp$($this, "while", null) == null) {
		return false;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, "(", null) == null) {
		return false;
	}
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ")", null) == null) {
		return false;
	}
	$this._statements.push(new DoWhileStatement(token, label, expr, statements));
	return true;
};

Parser._doWhileStatement$LParser$LToken$LToken$ = Parser$_doWhileStatement$LParser$LToken$LToken$;

function Parser$_whileStatement$LParser$LToken$LToken$($this, token, label) {
	var expr;
	var statements;
	var statementIndex$0;
	var _statements$0;
	if (Parser$_expect$LParser$SLRegExp$($this, "(", null) == null) {
		return false;
	}
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ")", null) == null) {
		return false;
	}
	statementIndex$0 = $this._statements.length;
	if (! Parser$_statement$LParser$($this)) {
		Parser$_skipStatement$LParser$($this);
	}
	statements = (_statements$0 = $this._statements).splice(statementIndex$0, _statements$0.length - statementIndex$0);
	$this._statements.push(new WhileStatement(token, label, expr, statements));
	return true;
};

Parser._whileStatement$LParser$LToken$LToken$ = Parser$_whileStatement$LParser$LToken$LToken$;

function Parser$_forStatement$LParser$LToken$LToken$($this, token, label) {
	var state;
	var initExpr;
	var succeeded;
	var condExpr;
	var postExpr;
	var statements;
	var statementIndex$0;
	var _statements$0;
	state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
	switch (Parser$_forInStatement$LParser$LToken$LToken$($this, token, label)) {
	case -1:
		break;
	case 0:
		return false;
	case 1:
		return true;
	}
	Parser$_restoreState$LParser$LParserState$($this, state);
	if (Parser$_expect$LParser$SLRegExp$($this, "(", null) == null) {
		return false;
	}
	initExpr = null;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ";", null) != null) {
	} else if (Parser$_expectOpt$LParser$SLRegExp$($this, "var", null) != null) {
		succeeded = [ false ];
		initExpr = Parser$_variableDeclarations$LParser$BBAB($this, true, false, succeeded);
		if (! succeeded[0]) {
			return false;
		}
		if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
			return false;
		}
	} else {
		if ((initExpr = Parser$_expr$LParser$B($this, true)) == null) {
			return false;
		}
		if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
			return false;
		}
	}
	condExpr = null;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ";", null) != null) {
	} else {
		if ((condExpr = Parser$_expr$LParser$B($this, false)) == null) {
			return false;
		}
		if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
			return false;
		}
	}
	postExpr = null;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ")", null) != null) {
	} else {
		if ((postExpr = Parser$_expr$LParser$B($this, false)) == null) {
			return false;
		}
		if (Parser$_expect$LParser$SLRegExp$($this, ")", null) == null) {
			return false;
		}
	}
	statementIndex$0 = $this._statements.length;
	if (! Parser$_statement$LParser$($this)) {
		Parser$_skipStatement$LParser$($this);
	}
	statements = (_statements$0 = $this._statements).splice(statementIndex$0, _statements$0.length - statementIndex$0);
	$this._statements.push(new ForStatement(token, label, initExpr, condExpr, postExpr, statements));
	return true;
};

Parser._forStatement$LParser$LToken$LToken$ = Parser$_forStatement$LParser$LToken$LToken$;

function Parser$_forInStatement$LParser$LToken$LToken$($this, token, label) {
	var lhsExpr;
	var listExpr;
	var statements;
	var statementIndex$0;
	var _statements$0;
	if (Parser$_expect$LParser$SLRegExp$($this, "(", null) == null) {
		return 0;
	}
	if (Parser$_expectOpt$LParser$SLRegExp$($this, "var", null) != null) {
		if ((lhsExpr = Parser$_variableDeclaration$LParser$BB($this, true, false)) == null) {
			return -1;
		}
	} else if ((lhsExpr = Parser$_lhsExpr$LParser$($this)) == null) {
		return -1;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, "in", null) == null) {
		return -1;
	}
	listExpr = Parser$_expr$LParser$B($this, false);
	if (listExpr == null) {
		return 0;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ")", null) == null) {
		return 0;
	}
	statementIndex$0 = $this._statements.length;
	if (! Parser$_statement$LParser$($this)) {
		Parser$_skipStatement$LParser$($this);
	}
	statements = (_statements$0 = $this._statements).splice(statementIndex$0, _statements$0.length - statementIndex$0);
	$this._statements.push(new ForInStatement(token, label, lhsExpr, listExpr, statements));
	return 1;
};

Parser._forInStatement$LParser$LToken$LToken$ = Parser$_forInStatement$LParser$LToken$LToken$;

function Parser$_continueStatement$LParser$LToken$($this, token) {
	var label;
	label = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
		return false;
	}
	$this._statements.push(new ContinueStatement(token, label));
	return true;
};

Parser._continueStatement$LParser$LToken$ = Parser$_continueStatement$LParser$LToken$;

function Parser$_breakStatement$LParser$LToken$($this, token) {
	var label;
	label = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
		return false;
	}
	$this._statements.push(new BreakStatement(token, label));
	return true;
};

Parser._breakStatement$LParser$LToken$ = Parser$_breakStatement$LParser$LToken$;

function Parser$_returnStatement$LParser$LToken$($this, token) {
	var expr;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ";", null) != null) {
		$this._statements.push(new ReturnStatement(token, null));
		return true;
	}
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	$this._statements.push(new ReturnStatement(token, expr));
	return (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null ? false : true);
};

Parser._returnStatement$LParser$LToken$ = Parser$_returnStatement$LParser$LToken$;

function Parser$_switchStatement$LParser$LToken$LToken$($this, token, label) {
	var expr;
	var foundCaseLabel;
	var foundDefaultLabel;
	var startStatementIndex;
	var caseOrDefaultToken;
	var labelExpr;
	var _statements$0;
	if (Parser$_expect$LParser$SLRegExp$($this, "(", null) == null) {
		return false;
	}
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ")", null) == null || Parser$_expect$LParser$SLRegExp$($this, "{", null) == null) {
		return null;
	}
	foundCaseLabel = false;
	foundDefaultLabel = false;
	startStatementIndex = $this._statements.length;
	while (Parser$_expectOpt$LParser$SLRegExp$($this, "}", null) == null) {
		if (! Parser$_expectIsNotEOF$LParser$($this)) {
			return false;
		}
		if (! foundCaseLabel && ! foundDefaultLabel) {
			if ((caseOrDefaultToken = Parser$_expect$LParser$ASLRegExp$($this, [ "case", "default" ], null)) == null) {
				Parser$_skipStatement$LParser$($this);
				continue;
			}
		} else {
			caseOrDefaultToken = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "case", "default" ], null);
		}
		if (caseOrDefaultToken != null) {
			if (caseOrDefaultToken._value === "case") {
				labelExpr = Parser$_expr$LParser$B($this, false);
				if (labelExpr == null) {
					Parser$_skipStatement$LParser$($this);
					continue;
				}
				if (Parser$_expect$LParser$SLRegExp$($this, ":", null) == null) {
					Parser$_skipStatement$LParser$($this);
					continue;
				}
				$this._statements.push(new CaseStatement(caseOrDefaultToken, labelExpr));
				foundCaseLabel = true;
			} else {
				if (Parser$_expect$LParser$SLRegExp$($this, ":", null) == null) {
					Parser$_skipStatement$LParser$($this);
					continue;
				}
				if (foundDefaultLabel) {
					$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "cannot have more than one default statement within one switch block"));
					Parser$_skipStatement$LParser$($this);
					continue;
				}
				$this._statements.push(new DefaultStatement(caseOrDefaultToken));
				foundDefaultLabel = true;
			}
		} else if (! Parser$_statement$LParser$($this)) {
			Parser$_skipStatement$LParser$($this);
		}
	}
	(_statements$0 = $this._statements).push(new SwitchStatement(token, label, expr, _statements$0.splice(startStatementIndex, _statements$0.length - startStatementIndex)));
	return true;
};

Parser._switchStatement$LParser$LToken$LToken$ = Parser$_switchStatement$LParser$LToken$LToken$;

function Parser$_throwStatement$LParser$LToken$($this, token) {
	var expr;
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
		return false;
	}
	$this._statements.push(new ThrowStatement(token, expr));
	return true;
};

Parser._throwStatement$LParser$LToken$ = Parser$_throwStatement$LParser$LToken$;

function Parser$_tryStatement$LParser$LToken$($this, tryToken) {
	var startIndex;
	var tryStatements;
	var catchStatements;
	var catchOrFinallyToken;
	var catchIdentifier;
	var catchType;
	var caughtVariable;
	var finallyStatements;
	var _statements$0;
	var _locals$0;
	var _statements$1;
	var _statements$2;
	if (Parser$_expect$LParser$SLRegExp$($this, "{", null) == null) {
		return false;
	}
	startIndex = $this._statements.length;
	if (Parser$_block$LParser$($this) == null) {
		return false;
	}
	tryStatements = (_statements$0 = $this._statements).splice(startIndex, _statements$0.length - startIndex);
	catchStatements = [];
	catchOrFinallyToken = Parser$_expect$LParser$ASLRegExp$($this, [ "catch", "finally" ], null);
	if (catchOrFinallyToken == null) {
		return false;
	}
	for (; catchOrFinallyToken != null && catchOrFinallyToken._value === "catch"; catchOrFinallyToken = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "catch", "finally" ], null)) {
		if (Parser$_expect$LParser$SLRegExp$($this, "(", null) == null || (catchIdentifier = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null)) == null || Parser$_expect$LParser$SLRegExp$($this, ":", null) == null || (catchType = Parser$_typeDeclaration$LParser$B($this, false)) == null || Parser$_expect$LParser$SLRegExp$($this, ")", null) == null || Parser$_expect$LParser$SLRegExp$($this, "{", null) == null) {
			return false;
		}
		caughtVariable = new CaughtVariable(catchIdentifier, catchType);
		$this._locals.push(caughtVariable);
		try {
			if (Parser$_block$LParser$($this) == null) {
				return false;
			}
		} finally {
			(_locals$0 = $this._locals).splice(_locals$0.indexOf(caughtVariable), 1);
		}
		catchStatements.push(new CatchStatement(catchOrFinallyToken, caughtVariable, (_statements$1 = $this._statements).splice(startIndex, _statements$1.length - startIndex)));
	}
	if (catchOrFinallyToken != null) {
		if (Parser$_expect$LParser$SLRegExp$($this, "{", null) == null) {
			return false;
		}
		if (Parser$_block$LParser$($this) == null) {
			return false;
		}
		finallyStatements = (_statements$2 = $this._statements).splice(startIndex, _statements$2.length - startIndex);
	} else {
		finallyStatements = [];
	}
	$this._statements.push(new TryStatement(tryToken, tryStatements, catchStatements, finallyStatements));
	return true;
};

Parser._tryStatement$LParser$LToken$ = Parser$_tryStatement$LParser$LToken$;

function Parser$_assertStatement$LParser$LToken$($this, token) {
	var expr;
	var msgExpr;
	expr = Parser$_assignExpr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	msgExpr = null;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ",", null) != null) {
		msgExpr = Parser$_assignExpr$LParser$B($this, false);
		if (msgExpr == null) {
			return false;
		}
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
		return false;
	}
	$this._statements.push(new AssertStatement(token, expr, msgExpr));
	return true;
};

Parser._assertStatement$LParser$LToken$ = Parser$_assertStatement$LParser$LToken$;

function Parser$_logStatement$LParser$LToken$($this, token) {
	var exprs;
	var expr;
	exprs = [];
	do {
		expr = Parser$_assignExpr$LParser$B($this, false);
		if (expr == null) {
			return false;
		}
		exprs.push(expr);
	} while (Parser$_expectOpt$LParser$SLRegExp$($this, ",", null) != null);
	if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
		return false;
	}
	if (exprs.length === 0) {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "no arguments"));
		return false;
	}
	$this._statements.push(new LogStatement(token, exprs));
	return true;
};

Parser._logStatement$LParser$LToken$ = Parser$_logStatement$LParser$LToken$;

function Parser$_deleteStatement$LParser$LToken$($this, token) {
	var expr;
	expr = Parser$_expr$LParser$B($this, false);
	if (expr == null) {
		return false;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, ";", null) == null) {
		return false;
	}
	$this._statements.push(new DeleteStatement(token, expr));
	return true;
};

Parser._deleteStatement$LParser$LToken$ = Parser$_deleteStatement$LParser$LToken$;

function Parser$_debuggerStatement$LParser$LToken$($this, token) {
	$this._statements.push(new DebuggerStatement(token));
	return true;
};

Parser._debuggerStatement$LParser$LToken$ = Parser$_debuggerStatement$LParser$LToken$;

function Parser$_subStatements$LParser$($this) {
	var statementIndex;
	var _statements$0;
	statementIndex = $this._statements.length;
	if (! Parser$_statement$LParser$($this)) {
		Parser$_skipStatement$LParser$($this);
	}
	return (_statements$0 = $this._statements).splice(statementIndex, _statements$0.length - statementIndex);
};

Parser._subStatements$LParser$ = Parser$_subStatements$LParser$;

function Parser$_variableDeclarations$LParser$BBAB($this, noIn, isConst, isSuccess) {
	var expr;
	var commaToken;
	var declExpr;
	isSuccess[0] = false;
	expr = null;
	commaToken = null;
	do {
		declExpr = Parser$_variableDeclaration$LParser$BB($this, noIn, isConst);
		if (declExpr == null) {
			return null;
		}
		if (! (declExpr instanceof LocalExpression)) {
			expr = (expr != null ? new CommaExpression(commaToken, expr, declExpr) : declExpr);
		}
	} while ((commaToken = Parser$_expectOpt$LParser$SLRegExp$($this, ",", null)) != null);
	isSuccess[0] = true;
	return expr;
};

Parser._variableDeclarations$LParser$BBAB = Parser$_variableDeclarations$LParser$BBAB;

function Parser$_variableDeclaration$LParser$BB($this, noIn, isConst) {
	var identifier;
	var type;
	var local;
	var initialValue;
	var assignToken;
	var expr;
	identifier = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (identifier == null) {
		return null;
	}
	type = null;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ":", null)) {
		if ((type = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
			return null;
		}
	}
	local = Parser$_registerLocal$LParser$LToken$LType$BB($this, identifier, type, isConst, false);
	initialValue = null;
	if ((assignToken = Parser$_expectOpt$LParser$SLRegExp$($this, "=", null)) == null) {
		if (isConst) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "initializer expression is mandatory for constant declaration"));
			return null;
		}
	} else if ((initialValue = Parser$_assignExpr$LParser$B($this, noIn)) == null) {
		return null;
	}
	expr = new LocalExpression(identifier, local);
	if (initialValue != null) {
		expr = new AssignmentExpression(assignToken, expr, initialValue);
	}
	return expr;
};

Parser._variableDeclaration$LParser$BB = Parser$_variableDeclaration$LParser$BB;

function Parser$_expr$LParser$($this) {
	return Parser$_expr$LParser$B($this, false);
};

Parser._expr$LParser$ = Parser$_expr$LParser$;

function Parser$_expr$LParser$B($this, noIn) {
	var expr;
	var commaToken;
	var assignExpr;
	expr = Parser$_assignExpr$LParser$B($this, noIn);
	if (expr == null) {
		return null;
	}
	while ((commaToken = Parser$_expectOpt$LParser$SLRegExp$($this, ",", null)) != null) {
		assignExpr = Parser$_assignExpr$LParser$B($this, noIn);
		if (assignExpr == null) {
			break;
		}
		expr = new CommaExpression(commaToken, expr, assignExpr);
	}
	return expr;
};

Parser._expr$LParser$B = Parser$_expr$LParser$B;

function Parser$_assignExpr$LParser$($this) {
	return Parser$_assignExpr$LParser$B($this, false);
};

Parser._assignExpr$LParser$ = Parser$_assignExpr$LParser$;

function Parser$_assignExpr$LParser$B($this, noIn) {
	var state;
	var lhsExpr;
	var op;
	var assignExpr;
	state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
	lhsExpr = Parser$_lhsExpr$LParser$($this);
	if (lhsExpr != null) {
		op = Parser$_expect$LParser$ASLRegExp$($this, [ "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", ">>>=", "&=", "^=", "|=" ], /^==/);
		if (op != null) {
			assignExpr = Parser$_assignExpr$LParser$B($this, noIn);
			if (assignExpr == null) {
				return null;
			}
			if (op._value === "=") {
				return new AssignmentExpression(op, lhsExpr, assignExpr);
			} else {
				return new FusedAssignmentExpression(op, lhsExpr, assignExpr);
			}
		}
	}
	Parser$_restoreState$LParser$LParserState$($this, state);
	return Parser$_yieldExpr$LParser$B($this, noIn);
};

Parser._assignExpr$LParser$B = Parser$_assignExpr$LParser$B;

function Parser$_yieldExpr$LParser$B($this, noIn) {
	var operatorToken;
	var condExpr;
	if ((operatorToken = Parser$_expectOpt$LParser$SLRegExp$($this, "yield", null)) != null) {
		$this._errors.push(new ExperimentalWarning(operatorToken, operatorToken._value));
		if (! $this._isGenerator) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "invalid use of 'yield' keyword in non-generator function"));
			return null;
		}
		condExpr = Parser$_condExpr$LParser$B($this, noIn);
		return (condExpr == null ? null : new YieldExpression(operatorToken, condExpr));
	}
	return Parser$_condExpr$LParser$B($this, noIn);
};

Parser._yieldExpr$LParser$B = Parser$_yieldExpr$LParser$B;

function Parser$_condExpr$LParser$B($this, noIn) {
	var lorExpr;
	var operatorToken;
	var ifTrueExpr;
	var ifFalseExpr;
	lorExpr = Parser$_lorExpr$LParser$B($this, noIn);
	if (lorExpr == null) {
		return null;
	}
	if ((operatorToken = Parser$_expectOpt$LParser$SLRegExp$($this, "?", null)) == null) {
		return lorExpr;
	}
	ifTrueExpr = null;
	ifFalseExpr = null;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ":", null) == null) {
		ifTrueExpr = Parser$_assignExpr$LParser$B($this, noIn);
		if (ifTrueExpr == null) {
			return null;
		}
		if (Parser$_expect$LParser$SLRegExp$($this, ":", null) == null) {
			return null;
		}
	}
	ifFalseExpr = Parser$_assignExpr$LParser$B($this, noIn);
	return (ifFalseExpr == null ? null : new ConditionalExpression(operatorToken, lorExpr, ifTrueExpr, ifFalseExpr));
};

Parser._condExpr$LParser$B = Parser$_condExpr$LParser$B;

function Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, ops, excludePattern, parseFunc, noIn, builderFunc) {
	var expr;
	var op;
	var rightExpr;
	expr = parseFunc(noIn);
	if (expr == null) {
		return null;
	}
	while (true) {
		op = Parser$_expectOpt$LParser$ASLRegExp$($this, ops, excludePattern);
		if (op == null) {
			break;
		}
		rightExpr = parseFunc(false);
		if (rightExpr == null) {
			return null;
		}
		expr = builderFunc(op, expr, rightExpr);
	}
	return expr;
};

Parser._binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$ = Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$;

function Parser$_lorExpr$LParser$B($this, noIn) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "||" ], null, (function (noIn) {
		return Parser$_landExpr$LParser$B($this, noIn);
	}), noIn, (function (op, e1, e2) {
		return new LogicalExpression(op, e1, e2);
	}));
};

Parser._lorExpr$LParser$B = Parser$_lorExpr$LParser$B;

function Parser$_landExpr$LParser$B($this, noIn) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "&&" ], null, (function (noIn) {
		return Parser$_borExpr$LParser$B($this, noIn);
	}), noIn, (function (op, e1, e2) {
		return new LogicalExpression(op, e1, e2);
	}));
};

Parser._landExpr$LParser$B = Parser$_landExpr$LParser$B;

function Parser$_borExpr$LParser$B($this, noIn) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "|" ], /^\|\|/, (function (noIn) {
		return Parser$_bxorExpr$LParser$B($this, noIn);
	}), noIn, (function (op, e1, e2) {
		return new BinaryNumberExpression(op, e1, e2);
	}));
};

Parser._borExpr$LParser$B = Parser$_borExpr$LParser$B;

function Parser$_bxorExpr$LParser$B($this, noIn) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "^" ], null, (function (noIn) {
		return Parser$_bandExpr$LParser$B($this, noIn);
	}), noIn, (function (op, e1, e2) {
		return new BinaryNumberExpression(op, e1, e2);
	}));
};

Parser._bxorExpr$LParser$B = Parser$_bxorExpr$LParser$B;

function Parser$_bandExpr$LParser$B($this, noIn) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "&" ], /^&&/, (function (noIn) {
		return Parser$_eqExpr$LParser$B($this, noIn);
	}), noIn, (function (op, e1, e2) {
		return new BinaryNumberExpression(op, e1, e2);
	}));
};

Parser._bandExpr$LParser$B = Parser$_bandExpr$LParser$B;

function Parser$_eqExpr$LParser$B($this, noIn) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "==", "!=" ], null, (function (noIn) {
		return Parser$_relExpr$LParser$B($this, noIn);
	}), noIn, (function (op, e1, e2) {
		return new EqualityExpression(op, e1, e2);
	}));
};

Parser._eqExpr$LParser$B = Parser$_eqExpr$LParser$B;

function Parser$_relExpr$LParser$B($this, noIn) {
	var ops;
	ops = [ "<=", ">=", "<", ">" ];
	if (! noIn) {
		ops.push("in");
	}
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, ops, null, (function (noIn) {
		return Parser$_shiftExpr$LParser$($this);
	}), noIn, (function (op, e1, e2) {
		return (op._value === "in" ? new InExpression(op, e1, e2) : new BinaryNumberExpression(op, e1, e2));
	}));
};

Parser._relExpr$LParser$B = Parser$_relExpr$LParser$B;

function Parser$_shiftExpr$LParser$($this) {
	var expr;
	expr = Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ ">>>", "<<", ">>" ], null, (function (noIn) {
		return Parser$_addExpr$LParser$($this);
	}), false, (function (op, e1, e2) {
		return new ShiftExpression(op, e1, e2);
	}));
	return expr;
};

Parser._shiftExpr$LParser$ = Parser$_shiftExpr$LParser$;

function Parser$_addExpr$LParser$($this) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "+", "-" ], /^[+-]{2}/, (function (noIn) {
		return Parser$_mulExpr$LParser$($this);
	}), false, (function (op, e1, e2) {
		return (op._value === "+" ? new AdditiveExpression(op, e1, e2) : new BinaryNumberExpression(op, e1, e2));
	}));
};

Parser._addExpr$LParser$ = Parser$_addExpr$LParser$;

function Parser$_mulExpr$LParser$($this) {
	return Parser$_binaryOpExpr$LParser$ASLRegExp$F$BLExpression$$BF$LToken$LExpression$LExpression$LExpression$$($this, [ "*", "/", "%" ], null, (function (noIn) {
		return Parser$_unaryExpr$LParser$($this);
	}), false, (function (op, e1, e2) {
		return new BinaryNumberExpression(op, e1, e2);
	}));
};

Parser._mulExpr$LParser$ = Parser$_mulExpr$LParser$;

function Parser$_unaryExpr$LParser$($this) {
	var op;
	var expr;
	op = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "++", "--", "+", "-", "~", "!", "typeof" ], null);
	if (op == null) {
		return Parser$_asExpr$LParser$($this);
	}
	expr = Parser$_unaryExpr$LParser$($this);
	if (expr == null) {
		return null;
	}
	switch (op._value) {
	case "++":
	case "--":
		return new PreIncrementExpression(op, expr);
	case "+":
	case "-":
		return new SignExpression(op, expr);
	case "~":
		return new BitwiseNotExpression(op, expr);
	case "!":
		return new LogicalNotExpression(op, expr);
	case "typeof":
		return new TypeofExpression(op, expr);
	default:
		throw new Error("logic flaw");
	}
};

Parser._unaryExpr$LParser$ = Parser$_unaryExpr$LParser$;

function Parser$_asExpr$LParser$($this) {
	var expr;
	var token;
	var noConvert;
	var type;
	expr = Parser$_postfixExpr$LParser$($this);
	if (expr == null) {
		return null;
	}
	while ((token = Parser$_expectOpt$LParser$SLRegExp$($this, "as", null)) != null) {
		noConvert = Parser$_expectOpt$LParser$SLRegExp$($this, "__noconvert__", null);
		type = Parser$_typeDeclaration$LParser$B($this, false);
		if (type == null) {
			return null;
		}
		expr = (noConvert ? new AsNoConvertExpression(token, expr, type) : new AsExpression(token, expr, type));
	}
	return expr;
};

Parser._asExpr$LParser$ = Parser$_asExpr$LParser$;

function Parser$_postfixExpr$LParser$($this) {
	var expr;
	var op;
	var type;
	expr = Parser$_lhsExpr$LParser$($this);
	op = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "++", "--", "instanceof" ], null);
	if (op == null) {
		return expr;
	}
	switch (op._value) {
	case "instanceof":
		type = Parser$_typeDeclaration$LParser$B($this, false);
		if (type == null) {
			return null;
		}
		return new InstanceofExpression(op, expr, type);
	default:
		return new PostIncrementExpression(op, expr);
	}
};

Parser._postfixExpr$LParser$ = Parser$_postfixExpr$LParser$;

function Parser$_lhsExpr$LParser$($this) {
	var expr;
	var token;
	var args;
	var index;
	var identifier;
	var typeArgs;
	token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "new", "super", "function" ], null);
	if (token != null) {
		switch (token._value) {
		case "super":
			return Parser$_superExpr$LParser$($this);
		case "function":
			expr = Parser$_functionExpr$LParser$LToken$($this, token);
			break;
		case "new":
			expr = Parser$_newExpr$LParser$LToken$($this, token);
			break;
		default:
			throw new Error("logic flaw");
		}
	} else {
		expr = Parser$_arrowFunctionOpt$LParser$($this);
		if (expr == null) {
			expr = Parser$_primaryExpr$LParser$($this);
		}
	}
	if (expr == null) {
		return null;
	}
	while ((token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "(", "[", "." ], null)) != null) {
		switch (token._value) {
		case "(":
			if ((args = Parser$_argsExpr$LParser$($this)) == null) {
				return null;
			}
			expr = new CallExpression(token, expr, args);
			break;
		case "[":
			index = Parser$_expr$LParser$B($this, false);
			if (index == null) {
				return null;
			}
			if (Parser$_expect$LParser$SLRegExp$($this, "]", null) == null) {
				return null;
			}
			expr = new ArrayExpression(token, expr, index);
			break;
		case ".":
			identifier = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, (function (self) {
				return new _CompletionCandidatesOfProperty(expr);
			}));
			if (identifier == null) {
				return null;
			}
			typeArgs = Parser$_actualTypeArguments$LParser$($this);
			if (typeArgs == null) {
				return null;
			}
			expr = new PropertyExpression(token, expr, identifier, typeArgs);
			break;
		}
	}
	return expr;
};

Parser._lhsExpr$LParser$ = Parser$_lhsExpr$LParser$;

function Parser$_newExpr$LParser$LToken$($this, newToken) {
	var type;
	var lengthExpr;
	var args;
	var arrayType$0;
	var message$0;
	type = Parser$_typeDeclarationNoArrayNoVoidNoYield$LParser$($this);
	if (type == null) {
		return null;
	}
	while (Parser$_expectOpt$LParser$SLRegExp$($this, "[", null) != null) {
		if (type instanceof NullableType) {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "cannot instantiate an array of an Nullable type"));
			return null;
		}
		arrayType$0 = new ParsedObjectType(new QualifiedName(new Token$2("Array", true)), [ type ]);
		$this._objectTypesUsed.push(arrayType$0);
		type = arrayType$0;
		if (Parser$_expectOpt$LParser$SLRegExp$($this, "]", null) == null) {
			lengthExpr = Parser$_assignExpr$LParser$B($this, false);
			if (lengthExpr == null) {
				return null;
			}
			if (Parser$_expect$LParser$SLRegExp$($this, "]", null) == null) {
				return null;
			}
			return new NewExpression(newToken, type, [ lengthExpr ]);
		}
	}
	if (! (type instanceof ParsedObjectType)) {
		message$0 = "cannot instantiate a primitive type '" + type.toString() + "' using 'new'";
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message$0));
		return null;
	}
	if (Parser$_expectOpt$LParser$SLRegExp$($this, "(", null) != null) {
		args = Parser$_argsExpr$LParser$($this);
		if (args == null) {
			return null;
		}
	} else {
		args = [];
	}
	return new NewExpression(newToken, type, args);
};

Parser._newExpr$LParser$LToken$ = Parser$_newExpr$LParser$LToken$;

function Parser$_superExpr$LParser$($this) {
	var identifier;
	var token;
	var args;
	if (Parser$_expect$LParser$SLRegExp$($this, ".", null) == null) {
		return null;
	}
	identifier = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (identifier == null) {
		return null;
	}
	token = Parser$_expect$LParser$SLRegExp$($this, "(", null);
	if (token == null) {
		return null;
	}
	args = Parser$_argsExpr$LParser$($this);
	return (args == null ? null : new SuperExpression(token, identifier, args));
};

Parser._superExpr$LParser$ = Parser$_superExpr$LParser$;

function Parser$_arrowFunctionOpt$LParser$($this) {
	var state;
	var expr;
	state = ({lineNumber: $this._lineNumber, columnOffset: $this._columnOffset, docComment: $this._docComment, tokenLength: $this._tokenLength, isGenerator: $this._isGenerator, numErrors: $this._errors.length, numClosures: ($this._closures != null ? $this._closures.length : 0), numObjectTypesUsed: $this._objectTypesUsed.length, numTemplateInstantiationRequests: $this._templateInstantiationRequests.length});
	if ((expr = Parser$_arrowFunction$LParser$($this)) == null) {
		Parser$_restoreState$LParser$LParserState$($this, state);
		return null;
	}
	return expr;
};

Parser._arrowFunctionOpt$LParser$ = Parser$_arrowFunctionOpt$LParser$;

function Parser$_arrowFunction$LParser$($this) {
	var args;
	var argName;
	var argType;
	var returnType;
	var token;
	var funcDef;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, "(", null) != null) {
		args = Parser$_functionArgumentsExpr$LParser$BBB($this, false, false, false);
		if (args == null) {
			return null;
		}
	} else {
		argName = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
		if (argName == null) {
			return null;
		}
		argType = null;
		if (Parser$_expectOpt$LParser$SLRegExp$($this, ":", null) != null) {
			if ((argType = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
				return null;
			}
		}
		args = [ new ArgumentDeclaration$0(argName, argType, null) ];
	}
	returnType = null;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ":", null) != null) {
		if ((returnType = Parser$_typeDeclaration$LParser$B($this, true)) == null) {
			return null;
		}
	}
	token = Parser$_expect$LParser$ASLRegExp$($this, [ "->", "=>" ], null);
	if (token == null) {
		return null;
	}
	funcDef = Parser$_functionBody$LParser$LToken$LToken$LLocalVariable$ALArgumentDeclaration$LType$BB($this, token, null, null, args, returnType, Parser$_expectOpt$LParser$SLRegExp$($this, "{", null) != null, false);
	if (funcDef == null) {
		return null;
	}
	$this._closures.push(funcDef);
	return new FunctionExpression(token, funcDef);
};

Parser._arrowFunction$LParser$ = Parser$_arrowFunction$LParser$;

function Parser$_functionBody$LParser$LToken$LToken$LLocalVariable$ALArgumentDeclaration$LType$BB($this, token, name, funcLocal, args, returnType, withBlock, isGenerator) {
	var flags;
	var lastToken;
	var expr;
	var funcDef;
	Parser$_pushScope$LParser$LLocalVariable$ALArgumentDeclaration$($this, funcLocal, args);
	try {
		flags = 8;
		if (isGenerator) {
			$this._isGenerator = isGenerator;
			flags |= 8192;
		}
		if (! withBlock) {
			lastToken = null;
			expr = Parser$_assignExpr$LParser$B($this, false);
			$this._statements.push(new ReturnStatement(token, expr));
		} else {
			lastToken = Parser$_block$LParser$($this);
			if (lastToken == null) {
				return null;
			}
		}
		funcDef = new MemberFunctionDefinition(token, name, flags, returnType, args, $this._locals, $this._statements, $this._closures, lastToken, null);
		if (funcLocal != null) {
			funcDef._funcLocal = funcLocal;
		}
		return funcDef;
	} finally {
		Parser$_popScope$LParser$($this);
	}
};

Parser._functionBody$LParser$LToken$LToken$LLocalVariable$ALArgumentDeclaration$LType$BB = Parser$_functionBody$LParser$LToken$LToken$LLocalVariable$ALArgumentDeclaration$LType$BB;

function Parser$_functionExpr$LParser$LToken$($this, token) {
	var isGenerator;
	var name;
	var args;
	var returnType;
	var type;
	var argTypes;
	var funcLocal;
	var funcDef;
	isGenerator = false;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, "*", null) != null) {
		isGenerator = true;
	}
	name = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null);
	if (Parser$_expect$LParser$SLRegExp$($this, "(", null) == null) {
		return null;
	}
	args = Parser$_functionArgumentsExpr$LParser$BBB($this, false, false, false);
	if (args == null) {
		return null;
	}
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ":", null) != null) {
		returnType = Parser$_typeDeclaration$LParser$B($this, true);
		if (returnType == null) {
			return null;
		}
	} else {
		returnType = null;
	}
	if (Parser$_expect$LParser$SLRegExp$($this, "{", null) == null) {
		return null;
	}
	type = null;
	if (returnType != null) {
		argTypes = args.map((function (arg) {
			return arg._type;
		}));
		type = new StaticFunctionType(token, returnType, argTypes, false);
	}
	funcLocal = null;
	if (name != null) {
		funcLocal = new LocalVariable(name, type, true);
	}
	funcDef = Parser$_functionBody$LParser$LToken$LToken$LLocalVariable$ALArgumentDeclaration$LType$BB($this, token, name, funcLocal, args, returnType, true, isGenerator);
	if (funcDef == null) {
		return null;
	}
	$this._closures.push(funcDef);
	return new FunctionExpression(token, funcDef);
};

Parser._functionExpr$LParser$LToken$ = Parser$_functionExpr$LParser$LToken$;

function Parser$_forEachScope$LParser$F$LLocalVariable$ALLocalVariable$ALArgumentDeclaration$B$($this, cb) {
	var scope;
	if ($this._locals != null) {
		if (! cb($this._funcLocal, $this._locals, $this._arguments)) {
			return false;
		}
		for (scope = $this._prevScope; scope != null; scope = scope.prev) {
			if (scope.locals && ! cb(scope.funcLocal, scope.locals, scope.arguments)) {
				return false;
			}
		}
	}
	return true;
};

Parser._forEachScope$LParser$F$LLocalVariable$ALLocalVariable$ALArgumentDeclaration$B$ = Parser$_forEachScope$LParser$F$LLocalVariable$ALLocalVariable$ALArgumentDeclaration$B$;

function Parser$_findLocal$LParser$S($this, name) {
	var found;
	found = null;
	Parser$_forEachScope$LParser$F$LLocalVariable$ALLocalVariable$ALArgumentDeclaration$B$($this, (function (funcLocal, locals, args) {
		var i;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var this$4;
		var locals$len$0;
		var args$len$0;
		if (funcLocal != null && (this$0 = funcLocal._name, this$0._value) === name) {
			found = funcLocal;
			return false;
		}
		for ((i = 0, locals$len$0 = locals.length); i < locals$len$0; ++i) {
			if ((this$2 = (this$1 = locals[i], this$1._name), this$2._value) === name) {
				found = locals[i];
				return false;
			}
		}
		if (args != null) {
			for ((i = 0, args$len$0 = args.length); i < args$len$0; ++i) {
				if ((this$4 = (this$3 = args[i], this$3._name), this$4._value) === name) {
					found = args[i];
					return false;
				}
			}
		}
		return true;
	}));
	return found;
};

Parser._findLocal$LParser$S = Parser$_findLocal$LParser$S;

function Parser$_primaryExpr$LParser$($this) {
	var token;
	var expr;
	var local;
	var parsedType;
	var this$0$0;
	if ((token = Parser$_expectOpt$LParser$ASLRegExp$($this, [ "this", "undefined", "null", "false", "true", "[", "{", "(", "__FILE__", "__LINE__", "__CLASS__" ], null)) != null) {
		switch (token._value) {
		case "this":
			return new ThisExpression(token, null);
		case "undefined":
			$this._errors.push(new DeprecatedWarning$0($this._filename, $this._lineNumber, $this._columnOffset, "use of 'undefined' is deprerated, use 'null' instead"));
		case "null":
			return Parser$_nullLiteral$LParser$LToken$($this, token);
		case "false":
			return new BooleanLiteralExpression(token);
		case "true":
			return new BooleanLiteralExpression(token);
		case "[":
			return Parser$_arrayLiteral$LParser$LToken$($this, token);
		case "{":
			return Parser$_mapLiteral$LParser$LToken$($this, token);
		case "(":
			expr = Parser$_expr$LParser$B($this, false);
			if (Parser$_expect$LParser$SLRegExp$($this, ")", null) == null) {
				return null;
			}
			return expr;
		case "__FILE__":
			return new FileMacroExpression(token);
		case "__LINE__":
			return new LineMacroExpression(token);
		case "__CLASS__":
			return new ClassExpression(token, $this._classType);
		default:
			throw new Error("logic flaw");
		}
	} else if ((token = Parser$_expectNumberLiteralOpt$LParser$($this)) != null) {
		return new NumberLiteralExpression(token);
	} else if ((token = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, (function (self) {
		return new _CompletionCandidatesWithLocal(self);
	}))) != null) {
		local = Parser$_findLocal$LParser$S($this, token._value);
		if (local != null) {
			return new LocalExpression(token, local);
		} else {
			parsedType = Parser$_objectTypeDeclaration$LParser$LToken$BF$LClassDefinition$B$($this, token, false, null);
			if (parsedType == null) {
				return null;
			}
			return new ClassExpression((this$0$0 = parsedType._qualifiedName, this$0$0._token), parsedType);
		}
	} else if ((token = Parser$_expectStringLiteralOpt$LParser$($this)) != null) {
		return new StringLiteralExpression(token);
	} else if ((token = Parser$_expectRegExpLiteralOpt$LParser$($this)) != null) {
		return new RegExpLiteralExpression(token);
	} else {
		$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "expected primary expression"));
		return null;
	}
};

Parser._primaryExpr$LParser$ = Parser$_primaryExpr$LParser$;

function Parser$_nullLiteral$LParser$LToken$($this, token) {
	var type;
	var message$0;
	type = Type.nullType;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ":", null) != null) {
		if ((type = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
			return null;
		}
		if (type instanceof PrimitiveType) {
			message$0 = "type '" + type.toString() + "' is not nullable";
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, message$0));
			return null;
		}
	}
	return new NullExpression(token, type);
};

Parser._nullLiteral$LParser$LToken$ = Parser$_nullLiteral$LParser$LToken$;

function Parser$_arrayLiteral$LParser$LToken$($this, token) {
	var exprs;
	var expr;
	var separator;
	var type;
	exprs = [];
	while (Parser$_expectOpt$LParser$SLRegExp$($this, "]", null) == null) {
		expr = Parser$_assignExpr$LParser$B($this, false);
		if (expr == null) {
			return null;
		}
		exprs.push(expr);
		separator = Parser$_expect$LParser$ASLRegExp$($this, [ ",", "]" ], null);
		if (separator == null) {
			return null;
		} else if (separator._value === "]") {
			break;
		}
	}
	type = null;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ":", null) != null) {
		if ((type = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
			return null;
		}
	}
	return new ArrayLiteralExpression(token, exprs, type);
};

Parser._arrayLiteral$LParser$LToken$ = Parser$_arrayLiteral$LParser$LToken$;

function Parser$_mapLiteral$LParser$LToken$($this, token) {
	var elements;
	var keyToken;
	var expr;
	var separator;
	var type;
	elements = [];
	while (Parser$_expectOpt$LParser$SLRegExp$($this, "}", null) == null) {
		if ((keyToken = Parser$_expectIdentifierOpt$LParser$F$LParser$LCompletionCandidates$$($this, null)) != null || (keyToken = Parser$_expectNumberLiteralOpt$LParser$($this)) != null || (keyToken = Parser$_expectStringLiteralOpt$LParser$($this)) != null) {
		} else {
			$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "expected identifier, number or string"));
			return null;
		}
		if (Parser$_expect$LParser$SLRegExp$($this, ":", null) == null) {
			return null;
		}
		expr = Parser$_assignExpr$LParser$B($this, false);
		if (expr == null) {
			return null;
		}
		elements.push(({_key: keyToken, _expr: expr}));
		separator = Parser$_expect$LParser$ASLRegExp$($this, [ ",", "}" ], null);
		if (separator == null) {
			return null;
		} else if (separator._value === "}") {
			break;
		}
	}
	type = null;
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ":", null) != null) {
		if ((type = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
			return null;
		}
	}
	return new MapLiteralExpression(token, elements, type);
};

Parser._mapLiteral$LParser$LToken$ = Parser$_mapLiteral$LParser$LToken$;

function Parser$_functionArgumentsExpr$LParser$BBB($this, allowVarArgs, requireTypeDeclaration, allowDefaultValues) {
	var args;
	var token;
	var isVarArg;
	var argName;
	var argType;
	var i;
	var defaultValue;
	var assignToken;
	var this$0;
	var this$1;
	var this$2;
	var state$numClosures$0;
	var _closures$0;
	args = [];
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ")", null) == null) {
		token = null;
		do {
			isVarArg = allowVarArgs && Parser$_expectOpt$LParser$SLRegExp$($this, "...", null) != null;
			argName = Parser$_expectIdentifier$LParser$F$LParser$LCompletionCandidates$$($this, null);
			if (argName == null) {
				return null;
			}
			argType = null;
			if (requireTypeDeclaration) {
				if (Parser$_expect$LParser$SLRegExp$($this, ":", null) == null) {
					$this._errors.push(new CompileError$0($this._filename, $this._lineNumber, $this._columnOffset, "type declarations are mandatory for non-expression function definition"));
					return null;
				}
				if ((argType = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
					return null;
				}
			} else if (Parser$_expectOpt$LParser$SLRegExp$($this, ":", null) != null) {
				if ((argType = Parser$_typeDeclaration$LParser$B($this, false)) == null) {
					return null;
				}
			}
			for (i = 0; i < args.length; ++i) {
				if ((this$1 = (this$0 = args[i], this$0._name), this$1._value) === argName._value) {
					$this._errors.push(new CompileError(argName, "cannot declare an argument with the same name twice"));
					return null;
				}
			}
			if (isVarArg) {
				if (argType == null && isVarArg) {
					throw new Error("not yet implemented!");
				}
				args.push(new ArgumentDeclaration(argName, new VariableLengthArgumentType(argType)));
				if (Parser$_expect$LParser$SLRegExp$($this, ")", null) == null) {
					return null;
				}
				break;
			}
			defaultValue = null;
			assignToken = Parser$_expectOpt$LParser$SLRegExp$($this, "=", null);
			if (assignToken != null) {
				state$numClosures$0 = ($this._closures != null ? $this._closures.length : 0);
				Parser$_pushScope$LParser$LLocalVariable$ALArgumentDeclaration$($this, null, args);
				try {
					if ((defaultValue = Parser$_assignExpr$LParser$B($this, true)) == null) {
						return null;
					}
				} finally {
					if ($this._closures != null) {
						(_closures$0 = $this._closures).splice(state$numClosures$0, _closures$0.length - state$numClosures$0);
					}
					Parser$_popScope$LParser$($this);
				}
				if (! allowDefaultValues) {
					$this._errors.push(new CompileError(assignToken, "default parameters are only allowed for member functions"));
					return null;
				}
			} else if (args.length !== 0 && (this$2 = args[args.length - 1], this$2._defaultValue) != null) {
				$this._errors.push(new CompileError(argName, "required argument cannot be declared after an optional argument"));
				return null;
			}
			args.push(new ArgumentDeclaration$0(argName, argType, defaultValue));
			token = Parser$_expect$LParser$ASLRegExp$($this, [ ")", "," ], null);
			if (token == null) {
				return null;
			}
		} while (token._value === ",");
	}
	return args;
};

Parser._functionArgumentsExpr$LParser$BBB = Parser$_functionArgumentsExpr$LParser$BBB;

function Parser$_argsExpr$LParser$($this) {
	var args;
	var token;
	var arg;
	args = [];
	if (Parser$_expectOpt$LParser$SLRegExp$($this, ")", null) == null) {
		token = null;
		do {
			arg = Parser$_assignExpr$LParser$B($this, false);
			if (arg == null) {
				return null;
			}
			args.push(arg);
			token = Parser$_expect$LParser$ASLRegExp$($this, [ ")", "," ], null);
			if (token == null) {
				return null;
			}
		} while (token._value === ",");
	}
	return args;
};

Parser._argsExpr$LParser$ = Parser$_argsExpr$LParser$;

function Parser$_getCompletionCandidatesOfTopLevel$LParser$F$LClassDefinition$B$($this, autoCompleteMatchCb) {
	return new CompletionCandidatesOfTopLevel($this, autoCompleteMatchCb);
};

Parser._getCompletionCandidatesOfTopLevel$LParser$F$LClassDefinition$B$ = Parser$_getCompletionCandidatesOfTopLevel$LParser$F$LClassDefinition$B$;

function Parser$_getCompletionCandidatesWithLocal$LParser$($this) {
	return new _CompletionCandidatesWithLocal($this);
};

Parser._getCompletionCandidatesWithLocal$LParser$ = Parser$_getCompletionCandidatesWithLocal$LParser$;

function Parser$_getCompletionCandidatesOfNamespace$LParser$LImport$F$LClassDefinition$B$($this, imprt, autoCompleteMatchCb) {
	return new _CompletionCandidatesOfNamespace(imprt, autoCompleteMatchCb);
};

Parser._getCompletionCandidatesOfNamespace$LParser$LImport$F$LClassDefinition$B$ = Parser$_getCompletionCandidatesOfNamespace$LParser$LImport$F$LClassDefinition$B$;

function Parser$_getCompletionCandidatesOfProperty$LParser$LExpression$($this, expr) {
	return new _CompletionCandidatesOfProperty(expr);
};

Parser._getCompletionCandidatesOfProperty$LParser$LExpression$ = Parser$_getCompletionCandidatesOfProperty$LParser$LExpression$;

var SourceMapGenerator$0 = require('source-map').SourceMapGenerator;
var SourceMapConsumer$0 = require('source-map').SourceMapConsumer;
function SourceMapper(rootDir, outputFile, runenv) {
	var path$0;
	var parts$0;
	var _header$0;
	this._impl = null;
	this._header = "";
	this._sourceFiles = {};
	this._outputLength = 0;
	this._outputLineNumber = 1;
	this._rootDir = rootDir;
	this._outputFile = (outputFile != null ? Util$_resolvedPathParts$S(outputFile).join("/") : null);
	this._impl = new SourceMapGenerator$0(({ file: outputFile != null ? (path$0 = this._outputFile, parts$0 = Util$_resolvedPathParts$S(path$0), parts$0.pop()) : null }));
	switch (runenv) {
	case "node":
		this._header = "require('source-map-support').install();\n\n";
		break;
	case "web":
		this._header = "";
		break;
	default:
		this._header = "";
	}
	this._outputLength += (_header$0 = this._header).length;
	this._outputLineNumber += _header$0.split('\n').length - 1;
};

$__jsx_extend([SourceMapper], Object);
SourceMapper.prototype.getSourceMapHeader$ = function () {
	return this._header;
};


function SourceMapper$getSourceMapHeader$LSourceMapper$($this) {
	return $this._header;
};

SourceMapper.getSourceMapHeader$LSourceMapper$ = SourceMapper$getSourceMapHeader$LSourceMapper$;

SourceMapper.prototype.makeGeneratedPos$S = function (output) {
	var pos;
	var line;
	var lastNewLinePos;
	var column;
	pos = this._outputLength;
	line = this._outputLineNumber;
	while ((pos = output.indexOf("\n", pos)) !== -1) {
		++pos;
		++line;
	}
	this._outputLength = output.length;
	this._outputLineNumber = line;
	lastNewLinePos = output.lastIndexOf("\n") + 1;
	column = output.length - lastNewLinePos;
	return ({ line: line, column: column });
};


function SourceMapper$makeGeneratedPos$LSourceMapper$S($this, output) {
	var pos;
	var line;
	var lastNewLinePos;
	var column;
	pos = $this._outputLength;
	line = $this._outputLineNumber;
	while ((pos = output.indexOf("\n", pos)) !== -1) {
		++pos;
		++line;
	}
	$this._outputLength = output.length;
	$this._outputLineNumber = line;
	lastNewLinePos = output.lastIndexOf("\n") + 1;
	column = output.length - lastNewLinePos;
	return ({ line: line, column: column });
};

SourceMapper.makeGeneratedPos$LSourceMapper$S = SourceMapper$makeGeneratedPos$LSourceMapper$S;

SourceMapper.prototype.add$SNNUSUS = function (output, tokenLineNumber, tokenColumnNumber, tokenValue, tokenFilename) {
	var genPos;
	var origPos;
	var sourceFile;
	genPos = SourceMapper$makeGeneratedPos$LSourceMapper$S(this, output);
	if (tokenLineNumber !== tokenLineNumber || tokenFilename == null) {
		origPos = null;
		sourceFile = null;
		tokenValue = null;
	} else {
		origPos = ({ line: tokenLineNumber, column: tokenColumnNumber });
		sourceFile = tokenFilename;
		this._sourceFiles[tokenFilename] = true;
		if (tokenFilename.indexOf(this._rootDir + "/") === 0) {
			sourceFile = sourceFile.substring(this._rootDir.length + 1);
		}
	}
	this._impl.addMapping(({ generated: genPos, original: origPos, source: sourceFile, name: tokenValue }));
};


function SourceMapper$add$LSourceMapper$SNNUSUS($this, output, tokenLineNumber, tokenColumnNumber, tokenValue, tokenFilename) {
	var genPos;
	var origPos;
	var sourceFile;
	genPos = SourceMapper$makeGeneratedPos$LSourceMapper$S($this, output);
	if (tokenLineNumber !== tokenLineNumber || tokenFilename == null) {
		origPos = null;
		sourceFile = null;
		tokenValue = null;
	} else {
		origPos = ({ line: tokenLineNumber, column: tokenColumnNumber });
		sourceFile = tokenFilename;
		$this._sourceFiles[tokenFilename] = true;
		if (tokenFilename.indexOf($this._rootDir + "/") === 0) {
			sourceFile = sourceFile.substring($this._rootDir.length + 1);
		}
	}
	$this._impl.addMapping(({ generated: genPos, original: origPos, source: sourceFile, name: tokenValue }));
};

SourceMapper.add$LSourceMapper$SNNUSUS = SourceMapper$add$LSourceMapper$SNNUSUS;

SourceMapper.prototype.setSourceContent$SS = function (sourceFile, sourceContent) {
	this._impl.setSourceContent(sourceFile, sourceContent);
};


function SourceMapper$setSourceContent$LSourceMapper$SS($this, sourceFile, sourceContent) {
	$this._impl.setSourceContent(sourceFile, sourceContent);
};

SourceMapper.setSourceContent$LSourceMapper$SS = SourceMapper$setSourceContent$LSourceMapper$SS;

SourceMapper.prototype.getSourceMappingFile$ = function () {
	return this._outputFile + ".mapping";
};


function SourceMapper$getSourceMappingFile$LSourceMapper$($this) {
	return $this._outputFile + ".mapping";
};

SourceMapper.getSourceMappingFile$LSourceMapper$ = SourceMapper$getSourceMappingFile$LSourceMapper$;

SourceMapper.prototype.getSourceFiles$ = function () {
	return Object.keys(this._sourceFiles);
};


function SourceMapper$getSourceFiles$LSourceMapper$($this) {
	return Object.keys($this._sourceFiles);
};

SourceMapper.getSourceFiles$LSourceMapper$ = SourceMapper$getSourceFiles$LSourceMapper$;

SourceMapper.prototype.generate$ = function () {
	return this._impl.toString();
};


function SourceMapper$generate$LSourceMapper$($this) {
	return $this._impl.toString();
};

SourceMapper.generate$LSourceMapper$ = SourceMapper$generate$LSourceMapper$;

SourceMapper.prototype.getSourceMapFooter$ = function () {
	var sourceMappingURL;
	var path$0;
	var parts$0;
	if (this._outputFile != null) {
		path$0 = this._outputFile + ".mapping";
		parts$0 = Util$_resolvedPathParts$S(path$0);
		sourceMappingURL = parts$0.pop();
	} else {
		sourceMappingURL = "data:application/json;base64," + new Buffer(this._impl.toString(), "utf8").toString("base64");
	}
	return "\n//# sourceMappingURL=" + sourceMappingURL + "\n";
};


function SourceMapper$getSourceMapFooter$LSourceMapper$($this) {
	var sourceMappingURL;
	var path$0;
	var parts$0;
	if ($this._outputFile != null) {
		path$0 = $this._outputFile + ".mapping";
		parts$0 = Util$_resolvedPathParts$S(path$0);
		sourceMappingURL = parts$0.pop();
	} else {
		sourceMappingURL = "data:application/json;base64," + new Buffer($this._impl.toString(), "utf8").toString("base64");
	}
	return "\n//# sourceMappingURL=" + sourceMappingURL + "\n";
};

SourceMapper.getSourceMapFooter$LSourceMapper$ = SourceMapper$getSourceMapFooter$LSourceMapper$;

function _Util$0() {
};

$__jsx_extend([_Util$0], Object);
function _Util$0$handleSubStatements$F$ALStatement$B$LStatement$(cb, statement) {
	var ret;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	ret = false;
	if (statement instanceof ContinuableStatement) {
		if (cb(statement.getStatements$())) {
			ret = true;
		}
	} else if (statement instanceof IfStatement) {
		if (cb((this$0 = statement, this$0._onTrueStatements))) {
			ret = true;
		}
		if (cb((this$1 = statement, this$1._onFalseStatements))) {
			ret = true;
		}
	} else if (statement instanceof SwitchStatement) {
		if (cb((this$2 = statement, this$2._statements))) {
			ret = true;
		}
	} else if (statement instanceof TryStatement) {
		if (cb((this$3 = statement, this$3._tryStatements))) {
			ret = true;
		}
		if (cb((this$4 = statement, this$4._catchStatements).map((function (s) {
			return s;
		})))) {
			ret = true;
		}
		if (cb((this$5 = statement, this$5._finallyStatements))) {
			ret = true;
		}
	} else if (statement instanceof CatchStatement) {
		if (cb((this$6 = statement, this$6._statements))) {
			ret = true;
		}
	}
	return ret;
};

_Util$0.handleSubStatements$F$ALStatement$B$LStatement$ = _Util$0$handleSubStatements$F$ALStatement$B$LStatement$;

function _Util$0$exprIsAssignment$LExpression$(expr) {
	return expr instanceof AssignmentExpression || expr instanceof FusedAssignmentExpression || expr instanceof PreIncrementExpression || expr instanceof PostIncrementExpression;
};

_Util$0.exprIsAssignment$LExpression$ = _Util$0$exprIsAssignment$LExpression$;

function _Util$0$exprHasSideEffects$LExpression$(expr) {
	var preCheckCb$0;
	var r$0;
	preCheckCb$0 = (function precheck(expr) {
		var callingFuncDef;
		var stash$0;
		if (expr instanceof CallExpression) {
			stash$0 = expr.getStash$S("determine-callee");
			if (stash$0 == null) {
				throw new Error("callee not searched");
			}
			callingFuncDef = stash$0.callingFuncDef;
			if (callingFuncDef != null && (callingFuncDef._flags & 2048) !== 0) {
				return ! Expression$forEachExpression$LExpression$F$LExpression$B$(expr, (function (expr) {
					return ! Expression$hasSideEffects$LExpression$F$LExpression$UB$(expr, precheck);
				}));
			}
		}
		return null;
	});
	r$0 = preCheckCb$0(expr);
	return (r$0 != null ? r$0 : expr._doHasSideEffects$F$LExpression$UB$(preCheckCb$0));
};

_Util$0.exprHasSideEffects$LExpression$ = _Util$0$exprHasSideEffects$LExpression$;

function _Util$0$conditionIsConstant$LExpression$(expr) {
	var leafIsConstant;
	var asExpr;
	function leafIsConstant(expr) {
		var this$0;
		var this$0$0;
		var this$1;
		var this$0$1;
		if (expr instanceof NullExpression) {
			return false;
		} else if (expr instanceof BooleanLiteralExpression) {
			this$0 = expr;
			return (this$0$0 = this$0._token, this$0$0._value) !== "false";
		} else if (expr instanceof StringLiteralExpression) {
			return !! expr.getDecoded$();
		} else if (expr instanceof NumberLiteralExpression) {
			return !! expr.getDecoded$();
		} else if (expr instanceof IntegerLiteralExpression) {
			return !! (this$1 = expr, (this$0$1 = this$1._token, this$0$1._value) | 0);
		} else if (expr instanceof MapLiteralExpression || expr instanceof ArrayLiteralExpression) {
			return true;
		}
		return null;
	}
	if (expr instanceof LeafExpression) {
		return leafIsConstant(expr);
	} else if (expr instanceof AsExpression) {
		asExpr = expr;
		return (asExpr._type.equals$LType$(Type.booleanType) ? leafIsConstant(asExpr._expr) : null);
	} else {
		return null;
	}
};

_Util$0.conditionIsConstant$LExpression$ = _Util$0$conditionIsConstant$LExpression$;

function _Util$0$decodeNumericLiteral$LExpression$(expr) {
	var this$0;
	var this$0$0;
	return (expr instanceof NumberLiteralExpression ? expr.getDecoded$() : (this$0 = expr, (this$0$0 = this$0._token, this$0$0._value) | 0));
};

_Util$0.decodeNumericLiteral$LExpression$ = _Util$0$decodeNumericLiteral$LExpression$;

function _Util$0$optimizeBasicBlock$LMemberFunctionDefinition$F$ALExpression$V$(funcDef, optimizeExpressions) {
	var optimizeStatements;
	var statements;
	function optimizeStatements(statements) {
		var statementIndex;
		var exprsToOptimize;
		var setOptimizedExprs;
		var statement;
		var expr;
		var i;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var this$4;
		statementIndex = 0;
		while (statementIndex < statements.length) {
			exprsToOptimize = [];
			setOptimizedExprs = [];
			while (statementIndex < statements.length) {
				statement = statements[statementIndex++];
				if (statement instanceof ExpressionStatement) {
					exprsToOptimize.push((this$0 = statement, this$0._expr));
					setOptimizedExprs.push((function (statement) {
						return (function (expr) {
							UnaryExpressionStatement$setExpr$LUnaryExpressionStatement$LExpression$(statement, expr);
						});
					})(statement));
				} else if (statement instanceof ReturnStatement) {
					this$1 = statement;
					expr = this$1._expr;
					if (expr != null) {
						exprsToOptimize.push((this$2 = statement, this$2._expr));
						setOptimizedExprs.push((function (statement) {
							return (function (expr) {
								ReturnStatement$setExpr$LReturnStatement$LExpression$(statement, expr);
							});
						})(statement));
					}
					break;
				} else {
					statement.handleStatements$F$ALStatement$B$((function (statements) {
						optimizeStatements(statements);
						return true;
					}));
					if (statement instanceof IfStatement) {
						exprsToOptimize.push((this$3 = statement, this$3._expr));
						setOptimizedExprs.push((function (statement) {
							return (function (expr) {
								IfStatement$setExpr$LIfStatement$LExpression$(statement, expr);
							});
						})(statement));
					} else if (statement instanceof SwitchStatement) {
						exprsToOptimize.push((this$4 = statement, this$4._expr));
						setOptimizedExprs.push((function (statement) {
							return (function (expr) {
								SwitchStatement$setExpr$LSwitchStatement$LExpression$(statement, expr);
							});
						})(statement));
					}
					break;
				}
			}
			if (exprsToOptimize.length !== 0) {
				optimizeExpressions(exprsToOptimize);
				for (i = 0; i < exprsToOptimize.length; ++i) {
					setOptimizedExprs[i](exprsToOptimize[i]);
				}
			}
		}
	}
	statements = funcDef._statements;
	if (statements != null) {
		optimizeStatements(statements);
	}
};

_Util$0.optimizeBasicBlock$LMemberFunctionDefinition$F$ALExpression$V$ = _Util$0$optimizeBasicBlock$LMemberFunctionDefinition$F$ALExpression$V$;

function Optimizer() {
	this._compiler = null;
	this._commands = [];
	this._log = "";
	this._dumpLogs = false;
	this._enableRunTimeTypeCheck = true;
};

$__jsx_extend([Optimizer], Object);
function Optimizer$getReleaseOptimizationCommands$() {
	return [ "lto", "no-assert", "no-log", "no-debug", "fold-const", "tail-rec", "return-if", "inline", "dce", "unbox", "fold-const", "lcse", "dce", "fold-const", "array-length", "unclassify", "staticize" ];
};

Optimizer.getReleaseOptimizationCommands$ = Optimizer$getReleaseOptimizationCommands$;

function Optimizer$setup$LOptimizer$AS($this, cmds) {
	var calleesAreDetermined;
	var determineCallee;
	var i;
	var cmd;
	var _commands$0;
	calleesAreDetermined = false;
	function determineCallee() {
		if (! calleesAreDetermined) {
			$this._commands.push(new _DetermineCalleeCommand());
			calleesAreDetermined = true;
		}
	}
	for (i = 0; i < cmds.length; ++i) {
		cmd = cmds[i];
		if (cmd === "lto") {
			$this._commands.push(new _LinkTimeOptimizationCommand());
		} else if (cmd === "no-assert") {
			$this._commands.push(new _NoAssertCommand());
		} else if (cmd === "no-log") {
			$this._commands.push(new _NoLogCommand());
		} else if (cmd === "no-debug") {
			$this._commands.push(new _NoDebugCommand());
		} else if (cmd === "strip") {
			$this._commands.push(new _StripOptimizeCommand());
		} else if (cmd === "staticize") {
			$this._commands.push(new _StaticizeOptimizeCommand());
			calleesAreDetermined = false;
		} else if (cmd === "unclassify") {
			$this._commands.push(new _UnclassifyOptimizationCommand());
			calleesAreDetermined = false;
		} else if (cmd === "fold-const") {
			$this._commands.push(new _FoldConstantCommand());
		} else if (cmd === "dce") {
			determineCallee();
			$this._commands.push(new _DeadCodeEliminationOptimizeCommand());
		} else if (cmd === "inline") {
			determineCallee();
			$this._commands.push(new _InlineOptimizeCommand());
		} else if (cmd === "return-if") {
			$this._commands.push(new _ReturnIfOptimizeCommand());
		} else if (cmd === "lcse") {
			determineCallee();
			$this._commands.push(new _LCSEOptimizeCommand());
		} else if (cmd === "unbox") {
			determineCallee();
			$this._commands.push(new _UnboxOptimizeCommand());
		} else if (cmd === "array-length") {
			$this._commands.push(new _ArrayLengthOptimizeCommand());
		} else if (cmd === "tail-rec") {
			determineCallee();
			$this._commands.push(new _TailRecursionOptimizeCommand());
		} else if (cmd === "dump-logs") {
			$this._dumpLogs = true;
		} else {
			return "unknown optimization command: " + cmd;
		}
	}
	for (i = 0; i < $this._commands.length; ++i) {
		if ($this._commands[i] instanceof _LinkTimeOptimizationCommand) {
			break;
		}
	}
	if (i !== $this._commands.length) {
		(_commands$0 = $this._commands).unshift(_commands$0.splice(i, 1)[0]);
	}
	return null;
};

Optimizer.setup$LOptimizer$AS = Optimizer$setup$LOptimizer$AS;

function Optimizer$enableRuntimeTypeCheck$LOptimizer$($this) {
	return $this._enableRunTimeTypeCheck;
};

Optimizer.enableRuntimeTypeCheck$LOptimizer$ = Optimizer$enableRuntimeTypeCheck$LOptimizer$;

function Optimizer$setEnableRunTimeTypeCheck$LOptimizer$B($this, mode) {
	$this._enableRunTimeTypeCheck = mode;
};

Optimizer.setEnableRunTimeTypeCheck$LOptimizer$B = Optimizer$setEnableRunTimeTypeCheck$LOptimizer$B;

function Optimizer$setCompiler$LOptimizer$LCompiler$($this, compiler) {
	$this._compiler = compiler;
	return $this;
};

Optimizer.setCompiler$LOptimizer$LCompiler$ = Optimizer$setCompiler$LOptimizer$LCompiler$;

function Optimizer$getCompiler$LOptimizer$($this) {
	return $this._compiler;
};

Optimizer.getCompiler$LOptimizer$ = Optimizer$getCompiler$LOptimizer$;

function Optimizer$performOptimization$LOptimizer$($this) {
	var i;
	var platform;
	var message$0;
	var this$0;
	var message$1;
	var this$1;
	var this$2;
	var _commands$0;
	for (i = 0; i < $this._commands.length; ++i) {
		try {
			message$0 = "starting optimizer: " + (_commands$0 = $this._commands)[i]._identifier;
			$this._log += message$0 + "\n";
			(this$0 = _commands$0[i], this$0._optimizer = $this, this$0).performOptimization$();
			message$1 = "finished optimizer: " + $this._commands[i]._identifier;
			$this._log += message$1 + "\n";
		} catch ($__jsx_catch_0) {
			if ($__jsx_catch_0 instanceof Error) {
				this$1 = $this._compiler;
				platform = this$1._platform;
				platform.error$S("fatal error: optimizer '" + $this._commands[i]._identifier + "' died unexpectedly, dumping the logs" + $this._log);
				throw $__jsx_catch_0;
			} else {
				throw $__jsx_catch_0;
			}
		}
	}
	if ($this._dumpLogs) {
		this$2 = $this._compiler;
		platform = this$2._platform;
		platform.warn$S($this._log);
	}
};

Optimizer.performOptimization$LOptimizer$ = Optimizer$performOptimization$LOptimizer$;

function Optimizer$log$LOptimizer$S($this, message) {
	$this._log += message + "\n";
};

Optimizer.log$LOptimizer$S = Optimizer$log$LOptimizer$S;

function Optimizer$dumpLogs$LOptimizer$($this) {
	return $this._log;
};

Optimizer.dumpLogs$LOptimizer$ = Optimizer$dumpLogs$LOptimizer$;

function _OptimizeCommand(identifier) {
	this._identifier = identifier;
	this._optimizer = null;
};

$__jsx_extend([_OptimizeCommand], Object);
_OptimizeCommand.prototype.setup$LOptimizer$ = function (optimizer) {
	this._optimizer = optimizer;
	return this;
};


function _OptimizeCommand$setup$L_OptimizeCommand$LOptimizer$($this, optimizer) {
	$this._optimizer = optimizer;
	return $this;
};

_OptimizeCommand.setup$L_OptimizeCommand$LOptimizer$ = _OptimizeCommand$setup$L_OptimizeCommand$LOptimizer$;

_OptimizeCommand.prototype.getCompiler$ = function () {
	var this$0;
	this$0 = this._optimizer;
	return this$0._compiler;
};


function _OptimizeCommand$getCompiler$L_OptimizeCommand$($this) {
	var this$0;
	this$0 = $this._optimizer;
	return this$0._compiler;
};

_OptimizeCommand.getCompiler$L_OptimizeCommand$ = _OptimizeCommand$getCompiler$L_OptimizeCommand$;

_OptimizeCommand.prototype.createVar$LMemberFunctionDefinition$LType$S = function (funcDef, type, baseName) {
	var $this = this;
	var locals;
	var nameExists;
	var i;
	var newLocal;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	locals = funcDef._locals;
	function nameExists(n) {
		var i;
		var this$0;
		var this$1;
		var locals$len$0;
		for ((i = 0, locals$len$0 = locals.length); i < locals$len$0; ++i) {
			if ((this$1 = (this$0 = locals[i], this$0._name), this$1._value) === n) {
				return true;
			}
		}
		return false;
	}
	for (i = 0; nameExists(baseName + "$" + (i + "")); ++i) {
	}
	newLocal = new LocalVariable(new Token$2(baseName + "$" + (i + ""), false), type, false);
	locals.push(newLocal);
	message$0 = "rewriting " + baseName + " to " + (this$0 = newLocal._name, this$0._value);
	this$0$0 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	return newLocal;
};


function _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, type, baseName) {
	var locals;
	var nameExists;
	var i;
	var newLocal;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	locals = funcDef._locals;
	function nameExists(n) {
		var i;
		var this$0;
		var this$1;
		var locals$len$0;
		for ((i = 0, locals$len$0 = locals.length); i < locals$len$0; ++i) {
			if ((this$1 = (this$0 = locals[i], this$0._name), this$1._value) === n) {
				return true;
			}
		}
		return false;
	}
	for (i = 0; nameExists(baseName + "$" + (i + "")); ++i) {
	}
	newLocal = new LocalVariable(new Token$2(baseName + "$" + (i + ""), false), type, false);
	locals.push(newLocal);
	message$0 = "rewriting " + baseName + " to " + (this$0 = newLocal._name, this$0._value);
	this$0$0 = $this._optimizer;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	return newLocal;
};

_OptimizeCommand.createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S;

_OptimizeCommand.prototype.log$S = function (message) {
	var this$0;
	var message$0;
	this$0 = this._optimizer;
	message$0 = "[" + this._identifier + "] " + message;
	this$0._log += message$0 + "\n";
};


function _OptimizeCommand$log$L_OptimizeCommand$S($this, message) {
	var this$0;
	var message$0;
	this$0 = $this._optimizer;
	message$0 = "[" + $this._identifier + "] " + message;
	this$0._log += message$0 + "\n";
};

_OptimizeCommand.log$L_OptimizeCommand$S = _OptimizeCommand$log$L_OptimizeCommand$S;

_OptimizeCommand.prototype.setupCommand$L_OptimizeCommand$ = function (command) {
	var optimizer$0;
	optimizer$0 = this._optimizer;
	command._optimizer = optimizer$0;
	return command;
};


function _OptimizeCommand$setupCommand$L_OptimizeCommand$L_OptimizeCommand$($this, command) {
	var optimizer$0;
	optimizer$0 = $this._optimizer;
	command._optimizer = optimizer$0;
	return command;
};

_OptimizeCommand.setupCommand$L_OptimizeCommand$L_OptimizeCommand$ = _OptimizeCommand$setupCommand$L_OptimizeCommand$L_OptimizeCommand$;

function _FunctionOptimizeCommand(identifier) {
	this._identifier = identifier;
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_FunctionOptimizeCommand], _OptimizeCommand);
_FunctionOptimizeCommand.prototype.performOptimization$ = function () {
	var $this = this;
	var doit;
	var this$0$0;
	function doit(funcDef) {
		var message$0;
		var this$0$0;
		var message$0$0;
		var message$1;
		var this$0$1;
		var message$0$1;
		message$0 = "starting optimization of " + funcDef.getNotation$();
		this$0$0 = $this._optimizer;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
		$this.optimizeFunction$LMemberFunctionDefinition$(funcDef);
		message$1 = "finished optimization of " + funcDef.getNotation$();
		this$0$1 = $this._optimizer;
		message$0$1 = "[" + $this._identifier + "] " + message$1;
		this$0$1._log += message$0$1 + "\n";
	}
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$0 = this._optimizer, this$0$0._compiler), (function (parser, classDef) {
		ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
			var funcDef;
			if (member instanceof TemplateFunctionDefinition) {
				return true;
			}
			if (member instanceof MemberFunctionDefinition) {
				funcDef = member;
				if (MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef) != null) {
					doit(funcDef);
				}
			}
			MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(member, (function (funcDef) {
				doit(funcDef);
				return true;
			}));
			return true;
		}));
		return true;
	}));
};


function _NoAssertCommand() {
	this._identifier = "no-assert";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_NoAssertCommand], _FunctionOptimizeCommand);
_NoAssertCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	_NoAssertCommand$_optimizeStatements$L_NoAssertCommand$ALStatement$(this, funcDef._statements);
	return true;
};


_NoAssertCommand.prototype._optimizeStatements$ALStatement$ = function (statements) {
	var $this = this;
	var optimize;
	function optimize(statements) {
		var i;
		for (i = 0; i < statements.length; ) {
			if (statements[i] instanceof AssertStatement) {
				statements.splice(i, 1);
			} else {
				_Util$0$handleSubStatements$F$ALStatement$B$LStatement$(optimize, statements[i]);
				++i;
			}
		}
		return false;
	}
	optimize(statements);
};


function _NoAssertCommand$_optimizeStatements$L_NoAssertCommand$ALStatement$($this, statements) {
	var optimize;
	function optimize(statements) {
		var i;
		for (i = 0; i < statements.length; ) {
			if (statements[i] instanceof AssertStatement) {
				statements.splice(i, 1);
			} else {
				_Util$0$handleSubStatements$F$ALStatement$B$LStatement$(optimize, statements[i]);
				++i;
			}
		}
		return false;
	}
	optimize(statements);
};

_NoAssertCommand._optimizeStatements$L_NoAssertCommand$ALStatement$ = _NoAssertCommand$_optimizeStatements$L_NoAssertCommand$ALStatement$;

function _NoLogCommand() {
	this._identifier = "no-log";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_NoLogCommand], _FunctionOptimizeCommand);
_NoLogCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	_NoLogCommand$_optimizeStatements$L_NoLogCommand$ALStatement$(this, funcDef._statements);
	return true;
};


_NoLogCommand.prototype._optimizeStatements$ALStatement$ = function (statements) {
	var $this = this;
	var optimize;
	function optimize(statements) {
		var i;
		for (i = 0; i < statements.length; ) {
			if (statements[i] instanceof LogStatement) {
				statements.splice(i, 1);
			} else {
				_Util$0$handleSubStatements$F$ALStatement$B$LStatement$(optimize, statements[i]);
				++i;
			}
		}
		return false;
	}
	optimize(statements);
};


function _NoLogCommand$_optimizeStatements$L_NoLogCommand$ALStatement$($this, statements) {
	var optimize;
	function optimize(statements) {
		var i;
		for (i = 0; i < statements.length; ) {
			if (statements[i] instanceof LogStatement) {
				statements.splice(i, 1);
			} else {
				_Util$0$handleSubStatements$F$ALStatement$B$LStatement$(optimize, statements[i]);
				++i;
			}
		}
		return false;
	}
	optimize(statements);
};

_NoLogCommand._optimizeStatements$L_NoLogCommand$ALStatement$ = _NoLogCommand$_optimizeStatements$L_NoLogCommand$ALStatement$;

function _DeadCodeEliminationOptimizeCommand() {
	this._identifier = "dce";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_DeadCodeEliminationOptimizeCommand], _FunctionOptimizeCommand);
_DeadCodeEliminationOptimizeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	if (funcDef._statements == null) {
		return true;
	}
	while (_DeadCodeEliminationOptimizeCommand$_optimizeFunction$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$(this, funcDef) || _DeadCodeEliminationOptimizeCommand$_removeExpressionStatementsWithoutSideEffects$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$(this, funcDef)) {
	}
	return true;
};


_DeadCodeEliminationOptimizeCommand.prototype._removeExpressionStatementsWithoutSideEffects$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var shouldRetry;
	shouldRetry = false;
	(function onStatements(statements) {
		var i;
		var this$0;
		var this$1;
		for (i = 0; i < statements.length; ) {
			if (statements[i] instanceof ExpressionStatement && ! _Util$0$exprHasSideEffects$LExpression$((this$1 = statements[i], this$1._expr))) {
				shouldRetry = true;
				statements.splice(i, 1);
			} else {
				if (statements[i] instanceof ExpressionStatement) {
					_DeadCodeEliminationOptimizeCommand$_optimizeExprInVoid$L_DeadCodeEliminationOptimizeCommand$LExpression$F$LExpression$V$($this, (this$0 = statements[i], this$0._expr), (function (expr) {
						statements[i] = new ExpressionStatement(expr);
					}));
				}
				statements[i++].handleStatements$F$ALStatement$B$(onStatements);
			}
		}
		return true;
	})(funcDef._statements);
	return shouldRetry;
};


function _DeadCodeEliminationOptimizeCommand$_removeExpressionStatementsWithoutSideEffects$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var shouldRetry;
	shouldRetry = false;
	(function onStatements(statements) {
		var i;
		var this$0;
		var this$1;
		for (i = 0; i < statements.length; ) {
			if (statements[i] instanceof ExpressionStatement && ! _Util$0$exprHasSideEffects$LExpression$((this$1 = statements[i], this$1._expr))) {
				shouldRetry = true;
				statements.splice(i, 1);
			} else {
				if (statements[i] instanceof ExpressionStatement) {
					_DeadCodeEliminationOptimizeCommand$_optimizeExprInVoid$L_DeadCodeEliminationOptimizeCommand$LExpression$F$LExpression$V$($this, (this$0 = statements[i], this$0._expr), (function (expr) {
						statements[i] = new ExpressionStatement(expr);
					}));
				}
				statements[i++].handleStatements$F$ALStatement$B$(onStatements);
			}
		}
		return true;
	})(funcDef._statements);
	return shouldRetry;
};

_DeadCodeEliminationOptimizeCommand._removeExpressionStatementsWithoutSideEffects$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ = _DeadCodeEliminationOptimizeCommand$_removeExpressionStatementsWithoutSideEffects$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$;

_DeadCodeEliminationOptimizeCommand.prototype._optimizeExprInVoid$LExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var condExpr;
	var ifTrueHasSideEffect;
	var ifFalseHasSideEffect;
	var condAndIfTrue;
	var condOrIfFalse;
	var this$0;
	if (expr instanceof ConditionalExpression) {
		condExpr = expr;
		ifTrueHasSideEffect = _Util$0$exprHasSideEffects$LExpression$(condExpr._ifTrueExpr);
		ifFalseHasSideEffect = _Util$0$exprHasSideEffects$LExpression$(condExpr._ifFalseExpr);
		if (ifTrueHasSideEffect && ifFalseHasSideEffect) {
		} else if (ifTrueHasSideEffect && ! ifFalseHasSideEffect) {
			condAndIfTrue = new LogicalExpression(new Token$3("&&"), condExpr._condExpr, condExpr._ifTrueExpr);
			replaceCb(condAndIfTrue);
		} else if (! ifTrueHasSideEffect && ifFalseHasSideEffect) {
			condOrIfFalse = new LogicalExpression(new Token$3("||"), condExpr._condExpr, condExpr._ifFalseExpr);
			replaceCb(condOrIfFalse);
		} else {
			replaceCb(condExpr._condExpr);
		}
	} else if (expr instanceof LogicalNotExpression) {
		replaceCb((this$0 = expr, this$0._expr));
	}
};


function _DeadCodeEliminationOptimizeCommand$_optimizeExprInVoid$L_DeadCodeEliminationOptimizeCommand$LExpression$F$LExpression$V$($this, expr, replaceCb) {
	var condExpr;
	var ifTrueHasSideEffect;
	var ifFalseHasSideEffect;
	var condAndIfTrue;
	var condOrIfFalse;
	var this$0;
	if (expr instanceof ConditionalExpression) {
		condExpr = expr;
		ifTrueHasSideEffect = _Util$0$exprHasSideEffects$LExpression$(condExpr._ifTrueExpr);
		ifFalseHasSideEffect = _Util$0$exprHasSideEffects$LExpression$(condExpr._ifFalseExpr);
		if (ifTrueHasSideEffect && ifFalseHasSideEffect) {
		} else if (ifTrueHasSideEffect && ! ifFalseHasSideEffect) {
			condAndIfTrue = new LogicalExpression(new Token$3("&&"), condExpr._condExpr, condExpr._ifTrueExpr);
			replaceCb(condAndIfTrue);
		} else if (! ifTrueHasSideEffect && ifFalseHasSideEffect) {
			condOrIfFalse = new LogicalExpression(new Token$3("||"), condExpr._condExpr, condExpr._ifFalseExpr);
			replaceCb(condOrIfFalse);
		} else {
			replaceCb(condExpr._condExpr);
		}
	} else if (expr instanceof LogicalNotExpression) {
		replaceCb((this$0 = expr, this$0._expr));
	}
};

_DeadCodeEliminationOptimizeCommand._optimizeExprInVoid$L_DeadCodeEliminationOptimizeCommand$LExpression$F$LExpression$V$ = _DeadCodeEliminationOptimizeCommand$_optimizeExprInVoid$L_DeadCodeEliminationOptimizeCommand$LExpression$F$LExpression$V$;

_DeadCodeEliminationOptimizeCommand.prototype._optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	_Util$0$optimizeBasicBlock$LMemberFunctionDefinition$F$ALExpression$V$(funcDef, (function (exprs) {
		_DeadCodeEliminationOptimizeCommand$_eliminateDeadStoresToProperties$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
		_DeadCodeEliminationOptimizeCommand$_delayAssignmentsBetweenLocals$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
		_DeadCodeEliminationOptimizeCommand$_eliminateDeadStores$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
		_DeadCodeEliminationOptimizeCommand$_eliminateDeadConditions$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
	}));
	return _DeadCodeEliminationOptimizeCommand$_eliminateUnusedVariables$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$(this, funcDef);
};


function _DeadCodeEliminationOptimizeCommand$_optimizeFunction$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	_Util$0$optimizeBasicBlock$LMemberFunctionDefinition$F$ALExpression$V$(funcDef, (function (exprs) {
		_DeadCodeEliminationOptimizeCommand$_eliminateDeadStoresToProperties$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
		_DeadCodeEliminationOptimizeCommand$_delayAssignmentsBetweenLocals$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
		_DeadCodeEliminationOptimizeCommand$_eliminateDeadStores$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
		_DeadCodeEliminationOptimizeCommand$_eliminateDeadConditions$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
	}));
	return _DeadCodeEliminationOptimizeCommand$_eliminateUnusedVariables$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$($this, funcDef);
};

_DeadCodeEliminationOptimizeCommand._optimizeFunction$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ = _DeadCodeEliminationOptimizeCommand$_optimizeFunction$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$;

_DeadCodeEliminationOptimizeCommand.prototype._eliminateUnusedVariables$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var shouldRetry;
	var locals;
	var localsUsed;
	var localIndex;
	shouldRetry = false;
	locals = funcDef._locals;
	localsUsed = new Array(locals.length);
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var this$0;
		var this$1;
		if (statement instanceof FunctionStatement) {
			this$1 = statement;
			this$0 = this$1._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
		}
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			var i;
			if (expr instanceof AssignmentExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr) instanceof LocalExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr).getType$().equals$LType$(BinaryExpression$getSecondExpr$LBinaryExpression$(expr).getType$())) {
				return onExpr(BinaryExpression$getSecondExpr$LBinaryExpression$(expr));
			} else if (expr instanceof LocalExpression) {
				for (i = 0; i < locals.length; ++i) {
					if (locals[i] == LocalExpression$getLocal$LLocalExpression$(expr)) {
						break;
					}
				}
				if (i !== locals.length) {
					localsUsed[i] = true;
				}
			} else if (expr instanceof FunctionExpression) {
				MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}));
		return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), funcDef._statements);
	for (localIndex = localsUsed.length - 1; localIndex >= 0; --localIndex) {
		if (localsUsed[localIndex]) {
			continue;
		}
		(function onStatements(statements) {
			var i;
			var statement;
			var localFuncDef;
			var this$0;
			var message$0;
			var this$0$0;
			var message$0$0;
			var this$1;
			var this$2;
			var _closures$0;
			for (i = 0; i < statements.length; ) {
				statement = statements[i];
				if (statement instanceof FunctionStatement) {
					this$0 = statement;
					localFuncDef = this$0._funcDef;
					onStatements(localFuncDef._statements);
					if (localFuncDef._funcLocal == locals[localIndex]) {
						message$0 = "removing definition of " + (this$2 = (this$1 = locals[localIndex], this$1._name), "'" + this$2._value + "'" + " at " + (this$2._filename || "<<unknown>>") + ":" + (this$2._lineNumber + "") + ":" + (this$2._columnNumber + ""));
						this$0$0 = $this._optimizer;
						message$0$0 = "[" + $this._identifier + "] " + message$0;
						this$0$0._log += message$0$0 + "\n";
						(_closures$0 = funcDef._closures).splice(_closures$0.indexOf(localFuncDef), 1);
						statements.splice(i, 1);
					} else {
						i++;
					}
				} else {
					i++;
				}
				statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
					var rhsExpr;
					if (expr instanceof AssignmentExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr) instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(BinaryExpression$getFirstExpr$LBinaryExpression$(expr)) == locals[localIndex]) {
						_OptimizeCommand$log$L_OptimizeCommand$S($this, "removing assignment to " + Token$getNotation$LToken$(LocalVariable$getName$LLocalVariable$(locals[localIndex])));
						rhsExpr = BinaryExpression$getSecondExpr$LBinaryExpression$(expr);
						replaceCb(rhsExpr);
						shouldRetry = true;
						return rhsExpr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
					} else if (expr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(expr) == locals[localIndex]) {
						throw new Error("logic flaw, found a variable going to be removed being used");
					} else if (expr instanceof FunctionExpression) {
						onStatements(MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(FunctionExpression$getFuncDef$LFunctionExpression$(expr)));
					}
					return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
				}));
				_Util$0$handleSubStatements$F$ALStatement$B$LStatement$(onStatements, statement);
			}
			return true;
		})(funcDef._statements);
		locals.splice(localIndex, 1);
	}
	return shouldRetry;
};


function _DeadCodeEliminationOptimizeCommand$_eliminateUnusedVariables$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var shouldRetry;
	var locals;
	var localsUsed;
	var localIndex;
	shouldRetry = false;
	locals = funcDef._locals;
	localsUsed = new Array(locals.length);
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var this$0;
		var this$1;
		if (statement instanceof FunctionStatement) {
			this$1 = statement;
			this$0 = this$1._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
		}
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			var i;
			if (expr instanceof AssignmentExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr) instanceof LocalExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr).getType$().equals$LType$(BinaryExpression$getSecondExpr$LBinaryExpression$(expr).getType$())) {
				return onExpr(BinaryExpression$getSecondExpr$LBinaryExpression$(expr));
			} else if (expr instanceof LocalExpression) {
				for (i = 0; i < locals.length; ++i) {
					if (locals[i] == LocalExpression$getLocal$LLocalExpression$(expr)) {
						break;
					}
				}
				if (i !== locals.length) {
					localsUsed[i] = true;
				}
			} else if (expr instanceof FunctionExpression) {
				MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}));
		return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), funcDef._statements);
	for (localIndex = localsUsed.length - 1; localIndex >= 0; --localIndex) {
		if (localsUsed[localIndex]) {
			continue;
		}
		(function onStatements(statements) {
			var i;
			var statement;
			var localFuncDef;
			var this$0;
			var message$0;
			var this$0$0;
			var message$0$0;
			var this$1;
			var this$2;
			var _closures$0;
			for (i = 0; i < statements.length; ) {
				statement = statements[i];
				if (statement instanceof FunctionStatement) {
					this$0 = statement;
					localFuncDef = this$0._funcDef;
					onStatements(localFuncDef._statements);
					if (localFuncDef._funcLocal == locals[localIndex]) {
						message$0 = "removing definition of " + (this$2 = (this$1 = locals[localIndex], this$1._name), "'" + this$2._value + "'" + " at " + (this$2._filename || "<<unknown>>") + ":" + (this$2._lineNumber + "") + ":" + (this$2._columnNumber + ""));
						this$0$0 = $this._optimizer;
						message$0$0 = "[" + $this._identifier + "] " + message$0;
						this$0$0._log += message$0$0 + "\n";
						(_closures$0 = funcDef._closures).splice(_closures$0.indexOf(localFuncDef), 1);
						statements.splice(i, 1);
					} else {
						i++;
					}
				} else {
					i++;
				}
				statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
					var rhsExpr;
					if (expr instanceof AssignmentExpression && BinaryExpression$getFirstExpr$LBinaryExpression$(expr) instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(BinaryExpression$getFirstExpr$LBinaryExpression$(expr)) == locals[localIndex]) {
						_OptimizeCommand$log$L_OptimizeCommand$S($this, "removing assignment to " + Token$getNotation$LToken$(LocalVariable$getName$LLocalVariable$(locals[localIndex])));
						rhsExpr = BinaryExpression$getSecondExpr$LBinaryExpression$(expr);
						replaceCb(rhsExpr);
						shouldRetry = true;
						return rhsExpr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
					} else if (expr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(expr) == locals[localIndex]) {
						throw new Error("logic flaw, found a variable going to be removed being used");
					} else if (expr instanceof FunctionExpression) {
						onStatements(MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(FunctionExpression$getFuncDef$LFunctionExpression$(expr)));
					}
					return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
				}));
				_Util$0$handleSubStatements$F$ALStatement$B$LStatement$(onStatements, statement);
			}
			return true;
		})(funcDef._statements);
		locals.splice(localIndex, 1);
	}
	return shouldRetry;
};

_DeadCodeEliminationOptimizeCommand._eliminateUnusedVariables$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ = _DeadCodeEliminationOptimizeCommand$_eliminateUnusedVariables$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$;

_DeadCodeEliminationOptimizeCommand.prototype._delayAssignmentsBetweenLocals$LMemberFunctionDefinition$ALExpression$ = function (funcDef, exprs) {
	var $this = this;
	var localsUntouchable;
	var locals;
	localsUntouchable = new TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E();
	locals = new TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E();
	Util$forEachExpression$F$LExpression$B$ALExpression$((function onExpr(expr) {
		var local;
		var this$0;
		var message$0;
		var this$0$0;
		var message$0$0;
		var this$1;
		var message$1;
		var this$0$1;
		var message$0$1;
		var this$2;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$7;
		if (expr instanceof FusedAssignmentExpression && (this$7 = expr, this$7._expr1) instanceof LocalExpression) {
			this$0 = (this$2 = expr, this$2._expr1);
			local = this$0._local;
			message$0 = "local variable " + (this$3 = local._name, this$3._value) + " cannot be rewritten (has fused assignment)";
			this$0$0 = $this._optimizer;
			message$0$0 = "[" + $this._identifier + "] " + message$0;
			this$0$0._log += message$0$0 + "\n";
			TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B(localsUntouchable, local, true);
		} else if (expr instanceof IncrementExpression && (this$6 = expr, this$6._expr) instanceof LocalExpression) {
			this$1 = (this$4 = expr, this$4._expr);
			local = this$1._local;
			message$1 = "local variable " + (this$5 = local._name, this$5._value) + " cannot be rewritten (has increment)";
			this$0$1 = $this._optimizer;
			message$0$1 = "[" + $this._identifier + "] " + message$1;
			this$0$1._log += message$0$1 + "\n";
			TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B(localsUntouchable, local, true);
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}), exprs);
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$((function onExpr(expr, replaceCb) {
		var assignmentExpr;
		var lhsLocal;
		var rhsExpr;
		var rhsLocal;
		var cachedExpr;
		var callingFuncDef;
		var this$0;
		var message$0;
		var this$0$0;
		var message$0$0;
		var this$1;
		var message$1;
		var this$0$1;
		var message$0$1;
		var message$2;
		var this$0$2;
		var message$0$2;
		var this$2;
		var stashable$0;
		var stash$0;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$7;
		var this$8;
		var this$9;
		var this$0$3;
		var _list$0;
		var _list$1;
		if (expr instanceof AssignmentExpression) {
			assignmentExpr = expr;
			if (assignmentExpr._expr1 instanceof LocalExpression) {
				onExpr(assignmentExpr._expr2, (function (expr) {
					BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
				}));
				if (! TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$(localsUntouchable, (this$8 = assignmentExpr._expr1, this$8._local)) && (this$9 = assignmentExpr._expr1, this$0$3 = this$9._local, this$0$3._type).equals$LType$(assignmentExpr._expr2.getType$())) {
					this$0 = assignmentExpr._expr1;
					lhsLocal = this$0._local;
					message$0 = "resetting cache for: " + (this$4 = lhsLocal._name, "'" + this$4._value + "'" + " at " + (this$4._filename || "<<unknown>>") + ":" + (this$4._lineNumber + "") + ":" + (this$4._columnNumber + ""));
					this$0$0 = $this._optimizer;
					message$0$0 = "[" + $this._identifier + "] " + message$0;
					this$0$0._log += message$0$0 + "\n";
					TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$(locals, (function (local, expr) {
						if (local == lhsLocal) {
							_OptimizeCommand$log$L_OptimizeCommand$S($this, "  clearing itself");
							TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$(locals, local);
						} else if (expr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(expr) == lhsLocal) {
							_OptimizeCommand$log$L_OptimizeCommand$S($this, "  clearing " + Token$getNotation$LToken$(LocalVariable$getName$LLocalVariable$(local)));
							TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$(locals, local);
						}
						return true;
					}));
					if ((this$7 = assignmentExpr._token, this$7._value) === "=") {
						rhsExpr = assignmentExpr._expr2;
						if (rhsExpr instanceof LocalExpression) {
							this$1 = rhsExpr;
							rhsLocal = this$1._local;
							if (lhsLocal != rhsLocal && ! TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$(localsUntouchable, rhsLocal)) {
								message$1 = "  set to: " + (this$5 = rhsLocal._name, "'" + this$5._value + "'" + " at " + (this$5._filename || "<<unknown>>") + ":" + (this$5._lineNumber + "") + ":" + (this$5._columnNumber + ""));
								this$0$1 = $this._optimizer;
								message$0$1 = "[" + $this._identifier + "] " + message$1;
								this$0$1._log += message$0$1 + "\n";
								TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$(locals, lhsLocal, rhsExpr);
							}
						} else if (rhsExpr instanceof LeafExpression) {
							message$2 = "  set to: " + (this$6 = rhsExpr._token, "'" + this$6._value + "'" + " at " + (this$6._filename || "<<unknown>>") + ":" + (this$6._lineNumber + "") + ":" + (this$6._columnNumber + ""));
							this$0$2 = $this._optimizer;
							message$0$2 = "[" + $this._identifier + "] " + message$2;
							this$0$2._log += message$0$2 + "\n";
							TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$(locals, lhsLocal, rhsExpr);
						}
					}
				}
				return true;
			}
		} else if (expr instanceof LocalExpression) {
			cachedExpr = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$(locals, (this$2 = expr, this$2._local));
			if (cachedExpr) {
				replaceCb(cachedExpr.clone$());
				return true;
			}
		} else if (expr instanceof CallExpression) {
			stashable$0 = expr;
			stash$0 = stashable$0.getStash$S("determine-callee");
			if (stash$0 == null) {
				throw new Error("callee not searched");
			}
			callingFuncDef = stash$0.callingFuncDef;
			if (callingFuncDef != null && (callingFuncDef._flags & 2048) !== 0) {
			} else {
				expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
				if (funcDef._parent != null || funcDef._closures.length !== 0) {
					(_list$0 = locals._list).splice(0, _list$0.length);
				}
				return true;
			}
		} else if (expr instanceof NewExpression) {
			this$3 = expr;
			Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, this$3._args);
			(_list$1 = locals._list).splice(0, _list$1.length);
			return true;
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	}), exprs);
};


function _DeadCodeEliminationOptimizeCommand$_delayAssignmentsBetweenLocals$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs) {
	var localsUntouchable;
	var locals;
	localsUntouchable = new TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E();
	locals = new TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E();
	Util$forEachExpression$F$LExpression$B$ALExpression$((function onExpr(expr) {
		var local;
		var this$0;
		var message$0;
		var this$0$0;
		var message$0$0;
		var this$1;
		var message$1;
		var this$0$1;
		var message$0$1;
		var this$2;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$7;
		if (expr instanceof FusedAssignmentExpression && (this$7 = expr, this$7._expr1) instanceof LocalExpression) {
			this$0 = (this$2 = expr, this$2._expr1);
			local = this$0._local;
			message$0 = "local variable " + (this$3 = local._name, this$3._value) + " cannot be rewritten (has fused assignment)";
			this$0$0 = $this._optimizer;
			message$0$0 = "[" + $this._identifier + "] " + message$0;
			this$0$0._log += message$0$0 + "\n";
			TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B(localsUntouchable, local, true);
		} else if (expr instanceof IncrementExpression && (this$6 = expr, this$6._expr) instanceof LocalExpression) {
			this$1 = (this$4 = expr, this$4._expr);
			local = this$1._local;
			message$1 = "local variable " + (this$5 = local._name, this$5._value) + " cannot be rewritten (has increment)";
			this$0$1 = $this._optimizer;
			message$0$1 = "[" + $this._identifier + "] " + message$1;
			this$0$1._log += message$0$1 + "\n";
			TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B(localsUntouchable, local, true);
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}), exprs);
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$((function onExpr(expr, replaceCb) {
		var assignmentExpr;
		var lhsLocal;
		var rhsExpr;
		var rhsLocal;
		var cachedExpr;
		var callingFuncDef;
		var this$0;
		var message$0;
		var this$0$0;
		var message$0$0;
		var this$1;
		var message$1;
		var this$0$1;
		var message$0$1;
		var message$2;
		var this$0$2;
		var message$0$2;
		var this$2;
		var stashable$0;
		var stash$0;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$7;
		var this$8;
		var this$9;
		var this$0$3;
		var _list$0;
		var _list$1;
		if (expr instanceof AssignmentExpression) {
			assignmentExpr = expr;
			if (assignmentExpr._expr1 instanceof LocalExpression) {
				onExpr(assignmentExpr._expr2, (function (expr) {
					BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
				}));
				if (! TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$(localsUntouchable, (this$8 = assignmentExpr._expr1, this$8._local)) && (this$9 = assignmentExpr._expr1, this$0$3 = this$9._local, this$0$3._type).equals$LType$(assignmentExpr._expr2.getType$())) {
					this$0 = assignmentExpr._expr1;
					lhsLocal = this$0._local;
					message$0 = "resetting cache for: " + (this$4 = lhsLocal._name, "'" + this$4._value + "'" + " at " + (this$4._filename || "<<unknown>>") + ":" + (this$4._lineNumber + "") + ":" + (this$4._columnNumber + ""));
					this$0$0 = $this._optimizer;
					message$0$0 = "[" + $this._identifier + "] " + message$0;
					this$0$0._log += message$0$0 + "\n";
					TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$reversedForEach$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$F$LLocalVariable$LExpression$B$(locals, (function (local, expr) {
						if (local == lhsLocal) {
							_OptimizeCommand$log$L_OptimizeCommand$S($this, "  clearing itself");
							TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$(locals, local);
						} else if (expr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(expr) == lhsLocal) {
							_OptimizeCommand$log$L_OptimizeCommand$S($this, "  clearing " + Token$getNotation$LToken$(LocalVariable$getName$LLocalVariable$(local)));
							TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$(locals, local);
						}
						return true;
					}));
					if ((this$7 = assignmentExpr._token, this$7._value) === "=") {
						rhsExpr = assignmentExpr._expr2;
						if (rhsExpr instanceof LocalExpression) {
							this$1 = rhsExpr;
							rhsLocal = this$1._local;
							if (lhsLocal != rhsLocal && ! TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$(localsUntouchable, rhsLocal)) {
								message$1 = "  set to: " + (this$5 = rhsLocal._name, "'" + this$5._value + "'" + " at " + (this$5._filename || "<<unknown>>") + ":" + (this$5._lineNumber + "") + ":" + (this$5._columnNumber + ""));
								this$0$1 = $this._optimizer;
								message$0$1 = "[" + $this._identifier + "] " + message$1;
								this$0$1._log += message$0$1 + "\n";
								TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$(locals, lhsLocal, rhsExpr);
							}
						} else if (rhsExpr instanceof LeafExpression) {
							message$2 = "  set to: " + (this$6 = rhsExpr._token, "'" + this$6._value + "'" + " at " + (this$6._filename || "<<unknown>>") + ":" + (this$6._lineNumber + "") + ":" + (this$6._columnNumber + ""));
							this$0$2 = $this._optimizer;
							message$0$2 = "[" + $this._identifier + "] " + message$2;
							this$0$2._log += message$0$2 + "\n";
							TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$LExpression$(locals, lhsLocal, rhsExpr);
						}
					}
				}
				return true;
			}
		} else if (expr instanceof LocalExpression) {
			cachedExpr = TypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CExpression$x3E$LLocalVariable$(locals, (this$2 = expr, this$2._local));
			if (cachedExpr) {
				replaceCb(cachedExpr.clone$());
				return true;
			}
		} else if (expr instanceof CallExpression) {
			stashable$0 = expr;
			stash$0 = stashable$0.getStash$S("determine-callee");
			if (stash$0 == null) {
				throw new Error("callee not searched");
			}
			callingFuncDef = stash$0.callingFuncDef;
			if (callingFuncDef != null && (callingFuncDef._flags & 2048) !== 0) {
			} else {
				expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
				if (funcDef._parent != null || funcDef._closures.length !== 0) {
					(_list$0 = locals._list).splice(0, _list$0.length);
				}
				return true;
			}
		} else if (expr instanceof NewExpression) {
			this$3 = expr;
			Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, this$3._args);
			(_list$1 = locals._list).splice(0, _list$1.length);
			return true;
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	}), exprs);
};

_DeadCodeEliminationOptimizeCommand._delayAssignmentsBetweenLocals$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$ = _DeadCodeEliminationOptimizeCommand$_delayAssignmentsBetweenLocals$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$;

_DeadCodeEliminationOptimizeCommand.prototype._eliminateDeadStores$LMemberFunctionDefinition$ALExpression$ = function (funcDef, exprs) {
	var $this = this;
	var lastAssignExpr;
	var onExpr;
	lastAssignExpr = new TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E();
	function onExpr(expr, rewriteCb) {
		var assignExpr;
		var lhsLocal;
		var lastAssign;
		var this$0;
		var message$0;
		var this$0$0;
		var message$0$0;
		var this$1;
		var this$2;
		var this$3;
		var _list$0;
		if (expr instanceof AssignmentExpression) {
			assignExpr = expr;
			if (assignExpr._expr1 instanceof LocalExpression) {
				onExpr(assignExpr._expr2, (function (assignExpr) {
					return (function (expr) {
						BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignExpr, expr);
					});
				})(assignExpr));
				this$0 = assignExpr._expr1;
				lhsLocal = this$0._local;
				lastAssign = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$(lastAssignExpr, lhsLocal);
				if (lastAssign) {
					message$0 = "eliminating dead store to: " + (this$3 = lhsLocal._name, this$3._value);
					this$0$0 = $this._optimizer;
					message$0$0 = "[" + $this._identifier + "] " + message$0;
					this$0$0._log += message$0$0 + "\n";
					lastAssign.second((this$1 = lastAssign.first, this$1._expr2));
				}
				TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$(lastAssignExpr, lhsLocal, ({first: assignExpr, second: rewriteCb}));
				return true;
			}
		} else if (expr instanceof LocalExpression) {
			TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$(lastAssignExpr, (this$2 = expr, this$2._local));
		} else if (expr instanceof LogicalExpression || expr instanceof ConditionalExpression) {
			expr.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, rewriteCb) {
				var result;
				result = onExpr(expr, rewriteCb);
				TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$(lastAssignExpr);
				return result;
			}));
			return true;
		} else if (_Util$0$exprHasSideEffects$LExpression$(expr)) {
			expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			(_list$0 = lastAssignExpr._list).splice(0, _list$0.length);
			return true;
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	}
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, exprs);
};


function _DeadCodeEliminationOptimizeCommand$_eliminateDeadStores$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs) {
	var lastAssignExpr;
	var onExpr;
	lastAssignExpr = new TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E();
	function onExpr(expr, rewriteCb) {
		var assignExpr;
		var lhsLocal;
		var lastAssign;
		var this$0;
		var message$0;
		var this$0$0;
		var message$0$0;
		var this$1;
		var this$2;
		var this$3;
		var _list$0;
		if (expr instanceof AssignmentExpression) {
			assignExpr = expr;
			if (assignExpr._expr1 instanceof LocalExpression) {
				onExpr(assignExpr._expr2, (function (assignExpr) {
					return (function (expr) {
						BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignExpr, expr);
					});
				})(assignExpr));
				this$0 = assignExpr._expr1;
				lhsLocal = this$0._local;
				lastAssign = TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$get$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$(lastAssignExpr, lhsLocal);
				if (lastAssign) {
					message$0 = "eliminating dead store to: " + (this$3 = lhsLocal._name, this$3._value);
					this$0$0 = $this._optimizer;
					message$0$0 = "[" + $this._identifier + "] " + message$0;
					this$0$0._log += message$0$0 + "\n";
					lastAssign.second((this$1 = lastAssign.first, this$1._expr2));
				}
				TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$LPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$(lastAssignExpr, lhsLocal, ({first: assignExpr, second: rewriteCb}));
				return true;
			}
		} else if (expr instanceof LocalExpression) {
			TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$delete$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$LLocalVariable$(lastAssignExpr, (this$2 = expr, this$2._local));
		} else if (expr instanceof LogicalExpression || expr instanceof ConditionalExpression) {
			expr.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, rewriteCb) {
				var result;
				result = onExpr(expr, rewriteCb);
				TypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$clear$LTypedMap$x2E$x3CLocalVariable$x2CPair$x2E$x3CAssignmentExpression$x2Cfunction$x20$x28$x3A$x20Expression$x29$x20$x3A$x20void$x3E$x3E$(lastAssignExpr);
				return result;
			}));
			return true;
		} else if (_Util$0$exprHasSideEffects$LExpression$(expr)) {
			expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			(_list$0 = lastAssignExpr._list).splice(0, _list$0.length);
			return true;
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	}
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, exprs);
};

_DeadCodeEliminationOptimizeCommand._eliminateDeadStores$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$ = _DeadCodeEliminationOptimizeCommand$_eliminateDeadStores$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$;

_DeadCodeEliminationOptimizeCommand.prototype._eliminateDeadStoresToProperties$LMemberFunctionDefinition$ALExpression$ = function (funcDef, exprs) {
	var $this = this;
	var isFirstLevelPropertyAccess;
	var baseExprsAreEqual;
	var lastAssignExpr;
	var onExpr;
	function isFirstLevelPropertyAccess(expr) {
		var baseExpr;
		var this$0;
		if (! (expr instanceof PropertyExpression)) {
			return false;
		}
		this$0 = expr;
		baseExpr = this$0._expr;
		return (baseExpr instanceof LocalExpression || baseExpr instanceof ThisExpression || baseExpr.isClassSpecifier$() ? true : false);
	}
	function baseExprsAreEqual(x, y) {
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		if (x instanceof LocalExpression && y instanceof LocalExpression) {
			return (this$0 = x, this$0._local) == (this$1 = y, this$1._local);
		} else if (x instanceof ThisExpression && y instanceof ThisExpression) {
			return true;
		} else if (x.isClassSpecifier$() && y.isClassSpecifier$()) {
			return (this$2 = x, this$2._parsedType).equals$LType$((this$3 = y, this$3._parsedType));
		}
		return false;
	}
	lastAssignExpr = {};
	onExpr = (function (expr, rewriteCb) {
		var assignmentExpr;
		var firstExpr;
		var propertyName;
		var k;
		var baseExpr;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$7;
		var this$8;
		var this$9;
		var this$10;
		var this$11;
		var this$12;
		var this$13;
		var this$14;
		var this$15;
		var this$16;
		if (expr instanceof AssignmentExpression) {
			assignmentExpr = expr;
			firstExpr = assignmentExpr._expr1;
			if (isFirstLevelPropertyAccess(firstExpr) && ! Util$rootIsNativeClass$LType$((this$16 = firstExpr, this$16._expr).getType$())) {
				this$10 = firstExpr;
				this$0 = this$10._identifierToken;
				propertyName = this$0._value;
				onExpr(assignmentExpr._expr2, null);
				if (lastAssignExpr[propertyName] && lastAssignExpr[propertyName].second != null && baseExprsAreEqual((this$11 = firstExpr, this$11._expr), (this$13 = (this$12 = lastAssignExpr[propertyName].first, this$12._expr1), this$13._expr))) {
					lastAssignExpr[propertyName].second((this$1 = lastAssignExpr[propertyName].first, this$1._expr2));
				}
				lastAssignExpr[propertyName] = ({first: assignmentExpr, second: rewriteCb});
				return true;
			} else if (assignmentExpr._expr1 instanceof LocalExpression) {
				onExpr(assignmentExpr._expr2, null);
				for (k in lastAssignExpr) {
					this$2 = (this$14 = lastAssignExpr[k].first, this$14._expr1);
					baseExpr = this$2._expr;
					if (baseExpr instanceof LocalExpression && (this$3 = baseExpr, this$3._local) == (this$5 = (this$4 = expr, this$4._expr1), this$5._local)) {
						delete lastAssignExpr[k];
					}
				}
				return true;
			}
		} else if (isFirstLevelPropertyAccess(expr)) {
			this$15 = expr;
			this$6 = this$15._identifierToken;
			propertyName = this$6._value;
			delete lastAssignExpr[propertyName];
		} else if (expr instanceof CallExpression) {
			onExpr((this$7 = expr, this$7._expr), null);
			Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, (this$8 = expr, this$8._args));
			lastAssignExpr = {};
			return true;
		} else if (expr instanceof NewExpression) {
			Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, (this$9 = expr, this$9._args));
			lastAssignExpr = {};
			return true;
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	});
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, exprs);
};


function _DeadCodeEliminationOptimizeCommand$_eliminateDeadStoresToProperties$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs) {
	var isFirstLevelPropertyAccess;
	var baseExprsAreEqual;
	var lastAssignExpr;
	var onExpr;
	function isFirstLevelPropertyAccess(expr) {
		var baseExpr;
		var this$0;
		if (! (expr instanceof PropertyExpression)) {
			return false;
		}
		this$0 = expr;
		baseExpr = this$0._expr;
		return (baseExpr instanceof LocalExpression || baseExpr instanceof ThisExpression || baseExpr.isClassSpecifier$() ? true : false);
	}
	function baseExprsAreEqual(x, y) {
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		if (x instanceof LocalExpression && y instanceof LocalExpression) {
			return (this$0 = x, this$0._local) == (this$1 = y, this$1._local);
		} else if (x instanceof ThisExpression && y instanceof ThisExpression) {
			return true;
		} else if (x.isClassSpecifier$() && y.isClassSpecifier$()) {
			return (this$2 = x, this$2._parsedType).equals$LType$((this$3 = y, this$3._parsedType));
		}
		return false;
	}
	lastAssignExpr = {};
	onExpr = (function (expr, rewriteCb) {
		var assignmentExpr;
		var firstExpr;
		var propertyName;
		var k;
		var baseExpr;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$7;
		var this$8;
		var this$9;
		var this$10;
		var this$11;
		var this$12;
		var this$13;
		var this$14;
		var this$15;
		var this$16;
		if (expr instanceof AssignmentExpression) {
			assignmentExpr = expr;
			firstExpr = assignmentExpr._expr1;
			if (isFirstLevelPropertyAccess(firstExpr) && ! Util$rootIsNativeClass$LType$((this$16 = firstExpr, this$16._expr).getType$())) {
				this$10 = firstExpr;
				this$0 = this$10._identifierToken;
				propertyName = this$0._value;
				onExpr(assignmentExpr._expr2, null);
				if (lastAssignExpr[propertyName] && lastAssignExpr[propertyName].second != null && baseExprsAreEqual((this$11 = firstExpr, this$11._expr), (this$13 = (this$12 = lastAssignExpr[propertyName].first, this$12._expr1), this$13._expr))) {
					lastAssignExpr[propertyName].second((this$1 = lastAssignExpr[propertyName].first, this$1._expr2));
				}
				lastAssignExpr[propertyName] = ({first: assignmentExpr, second: rewriteCb});
				return true;
			} else if (assignmentExpr._expr1 instanceof LocalExpression) {
				onExpr(assignmentExpr._expr2, null);
				for (k in lastAssignExpr) {
					this$2 = (this$14 = lastAssignExpr[k].first, this$14._expr1);
					baseExpr = this$2._expr;
					if (baseExpr instanceof LocalExpression && (this$3 = baseExpr, this$3._local) == (this$5 = (this$4 = expr, this$4._expr1), this$5._local)) {
						delete lastAssignExpr[k];
					}
				}
				return true;
			}
		} else if (isFirstLevelPropertyAccess(expr)) {
			this$15 = expr;
			this$6 = this$15._identifierToken;
			propertyName = this$6._value;
			delete lastAssignExpr[propertyName];
		} else if (expr instanceof CallExpression) {
			onExpr((this$7 = expr, this$7._expr), null);
			Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, (this$8 = expr, this$8._args));
			lastAssignExpr = {};
			return true;
		} else if (expr instanceof NewExpression) {
			Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, (this$9 = expr, this$9._args));
			lastAssignExpr = {};
			return true;
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	});
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, exprs);
};

_DeadCodeEliminationOptimizeCommand._eliminateDeadStoresToProperties$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$ = _DeadCodeEliminationOptimizeCommand$_eliminateDeadStoresToProperties$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$;

_DeadCodeEliminationOptimizeCommand.prototype._eliminateDeadConditions$LMemberFunctionDefinition$ALExpression$ = function (funcDef, exprs) {
	var $this = this;
	var spliceStatements;
	function spliceStatements(dest, index, src) {
		var i;
		dest.splice(index, 1);
		for (i = 0; i < src.length; ++i) {
			dest.splice(index + i, 0, src[i]);
		}
	}
	(function onStatements(statements) {
		var i;
		var statement;
		var ifStatement;
		var cond;
		for (i = statements.length - 1; i >= 0; --i) {
			statement = statements[i];
			if (statement instanceof IfStatement) {
				ifStatement = statement;
				cond = _Util$0$conditionIsConstant$LExpression$(ifStatement._expr);
				if (cond == null) {
				} else if (cond === false && ifStatement._onFalseStatements.length === 0) {
					statements.splice(i, 1);
				} else if (cond === false) {
					spliceStatements(statements, i, ifStatement._onFalseStatements);
				} else if (cond === true) {
					spliceStatements(statements, i, ifStatement._onTrueStatements);
				}
			}
			statement.handleStatements$F$ALStatement$B$(onStatements);
		}
		return true;
	})(funcDef._statements);
};


function _DeadCodeEliminationOptimizeCommand$_eliminateDeadConditions$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs) {
	var spliceStatements;
	function spliceStatements(dest, index, src) {
		var i;
		dest.splice(index, 1);
		for (i = 0; i < src.length; ++i) {
			dest.splice(index + i, 0, src[i]);
		}
	}
	(function onStatements(statements) {
		var i;
		var statement;
		var ifStatement;
		var cond;
		for (i = statements.length - 1; i >= 0; --i) {
			statement = statements[i];
			if (statement instanceof IfStatement) {
				ifStatement = statement;
				cond = _Util$0$conditionIsConstant$LExpression$(ifStatement._expr);
				if (cond == null) {
				} else if (cond === false && ifStatement._onFalseStatements.length === 0) {
					statements.splice(i, 1);
				} else if (cond === false) {
					spliceStatements(statements, i, ifStatement._onFalseStatements);
				} else if (cond === true) {
					spliceStatements(statements, i, ifStatement._onTrueStatements);
				}
			}
			statement.handleStatements$F$ALStatement$B$(onStatements);
		}
		return true;
	})(funcDef._statements);
};

_DeadCodeEliminationOptimizeCommand._eliminateDeadConditions$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$ = _DeadCodeEliminationOptimizeCommand$_eliminateDeadConditions$L_DeadCodeEliminationOptimizeCommand$LMemberFunctionDefinition$ALExpression$;

function _ReturnIfOptimizeCommand() {
	this._identifier = "return-if";
	this._optimizer = null;
	this._excludeNative = false;
	this._altered = false;
};

$__jsx_extend([_ReturnIfOptimizeCommand], _FunctionOptimizeCommand);
_ReturnIfOptimizeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var message$0;
	var this$0$0;
	var message$0$0;
	if (funcDef._returnType == null || funcDef._returnType.equals$LType$(Type.voidType)) {
		return false;
	}
	this._altered = false;
	_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$(this, funcDef._statements);
	message$0 = funcDef.getNotation$() + " " + (this._altered ? "Y" : "N");
	this$0$0 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	return this._altered;
};


_ReturnIfOptimizeCommand.prototype._statementsCanBeReturnExpr$ALStatement$ = function (statements) {
	if (statements.length === 1 && statements[0] instanceof ReturnStatement) {
		return true;
	}
	_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$(this, statements);
	return (statements.length === 1 && statements[0] instanceof ReturnStatement ? true : false);
};


function _ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$($this, statements) {
	if (statements.length === 1 && statements[0] instanceof ReturnStatement) {
		return true;
	}
	_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$($this, statements);
	return (statements.length === 1 && statements[0] instanceof ReturnStatement ? true : false);
};

_ReturnIfOptimizeCommand._statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$ = _ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$;

_ReturnIfOptimizeCommand.prototype._optimizeStatements$ALStatement$ = function (statements) {
	var ifStatement;
	var onFalseStatements;
	var token$0;
	var condExpr$0;
	var trueExpr$0;
	var falseExpr$0;
	var this$0;
	var this$1;
	var token$1;
	var condExpr$1;
	var trueExpr$1;
	var falseExpr$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	if (statements.length >= 1 && statements[statements.length - 1] instanceof IfStatement) {
		ifStatement = statements[statements.length - 1];
		if (_ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$(this, ifStatement._onTrueStatements) && _ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$(this, ifStatement._onFalseStatements)) {
			token$0 = ifStatement._token;
			condExpr$0 = ifStatement._expr;
			this$3 = ifStatement._onTrueStatements[0];
			trueExpr$0 = this$3._expr;
			this$4 = ifStatement._onFalseStatements[0];
			falseExpr$0 = this$4._expr;
			statements[statements.length - 1] = new ReturnStatement(token$0, new ConditionalExpression$0(new Token$2("?", false), condExpr$0, trueExpr$0, falseExpr$0, falseExpr$0.getType$()));
			this._altered = true;
			_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$(this, statements);
		}
	} else if (statements.length >= 2 && statements[statements.length - 1] instanceof ReturnStatement && statements[statements.length - 2] instanceof IfStatement) {
		ifStatement = statements[statements.length - 2];
		if (_ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$(this, ifStatement._onTrueStatements)) {
			onFalseStatements = ifStatement._onFalseStatements;
			if (onFalseStatements.length === 0) {
				statements.splice(statements.length - 2, 2, (token$1 = ifStatement._token, condExpr$1 = ifStatement._expr, trueExpr$1 = (this$0 = ifStatement._onTrueStatements[0], this$0._expr), falseExpr$1 = (this$1 = statements[statements.length - 1], this$1._expr), new ReturnStatement(token$1, new ConditionalExpression$0(new Token$2("?", false), condExpr$1, trueExpr$1, falseExpr$1, falseExpr$1.getType$()))));
				this._altered = true;
				_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$(this, statements);
			} else if (onFalseStatements.length === 1 && onFalseStatements[0] instanceof IfStatement && (this$5 = onFalseStatements[0], this$5._onFalseStatements).length === 0) {
				(this$2 = onFalseStatements[0], this$2._onFalseStatements).push(statements[statements.length - 1]);
				statements.pop();
				this._altered = true;
				_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$(this, statements);
			}
		}
	}
};


function _ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$($this, statements) {
	var ifStatement;
	var onFalseStatements;
	var token$0;
	var condExpr$0;
	var trueExpr$0;
	var falseExpr$0;
	var this$0;
	var this$1;
	var token$1;
	var condExpr$1;
	var trueExpr$1;
	var falseExpr$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	if (statements.length >= 1 && statements[statements.length - 1] instanceof IfStatement) {
		ifStatement = statements[statements.length - 1];
		if (_ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$($this, ifStatement._onTrueStatements) && _ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$($this, ifStatement._onFalseStatements)) {
			token$0 = ifStatement._token;
			condExpr$0 = ifStatement._expr;
			this$3 = ifStatement._onTrueStatements[0];
			trueExpr$0 = this$3._expr;
			this$4 = ifStatement._onFalseStatements[0];
			falseExpr$0 = this$4._expr;
			statements[statements.length - 1] = new ReturnStatement(token$0, new ConditionalExpression$0(new Token$2("?", false), condExpr$0, trueExpr$0, falseExpr$0, falseExpr$0.getType$()));
			$this._altered = true;
			_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$($this, statements);
		}
	} else if (statements.length >= 2 && statements[statements.length - 1] instanceof ReturnStatement && statements[statements.length - 2] instanceof IfStatement) {
		ifStatement = statements[statements.length - 2];
		if (_ReturnIfOptimizeCommand$_statementsCanBeReturnExpr$L_ReturnIfOptimizeCommand$ALStatement$($this, ifStatement._onTrueStatements)) {
			onFalseStatements = ifStatement._onFalseStatements;
			if (onFalseStatements.length === 0) {
				statements.splice(statements.length - 2, 2, (token$1 = ifStatement._token, condExpr$1 = ifStatement._expr, trueExpr$1 = (this$0 = ifStatement._onTrueStatements[0], this$0._expr), falseExpr$1 = (this$1 = statements[statements.length - 1], this$1._expr), new ReturnStatement(token$1, new ConditionalExpression$0(new Token$2("?", false), condExpr$1, trueExpr$1, falseExpr$1, falseExpr$1.getType$()))));
				$this._altered = true;
				_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$($this, statements);
			} else if (onFalseStatements.length === 1 && onFalseStatements[0] instanceof IfStatement && (this$5 = onFalseStatements[0], this$5._onFalseStatements).length === 0) {
				(this$2 = onFalseStatements[0], this$2._onFalseStatements).push(statements[statements.length - 1]);
				statements.pop();
				$this._altered = true;
				_ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$($this, statements);
			}
		}
	}
};

_ReturnIfOptimizeCommand._optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$ = _ReturnIfOptimizeCommand$_optimizeStatements$L_ReturnIfOptimizeCommand$ALStatement$;

_ReturnIfOptimizeCommand.prototype._createReturnStatement$LToken$LExpression$LExpression$LExpression$ = function (token, condExpr, trueExpr, falseExpr) {
	return new ReturnStatement(token, new ConditionalExpression$0(new Token$2("?", false), condExpr, trueExpr, falseExpr, falseExpr.getType$()));
};


function _ReturnIfOptimizeCommand$_createReturnStatement$L_ReturnIfOptimizeCommand$LToken$LExpression$LExpression$LExpression$($this, token, condExpr, trueExpr, falseExpr) {
	return new ReturnStatement(token, new ConditionalExpression$0(new Token$2("?", false), condExpr, trueExpr, falseExpr, falseExpr.getType$()));
};

_ReturnIfOptimizeCommand._createReturnStatement$L_ReturnIfOptimizeCommand$LToken$LExpression$LExpression$LExpression$ = _ReturnIfOptimizeCommand$_createReturnStatement$L_ReturnIfOptimizeCommand$LToken$LExpression$LExpression$LExpression$;

function _LCSECachedExpression(origExpr, replaceCb) {
	this._origExpr = origExpr;
	this._replaceCb = replaceCb;
	this._localExpr = null;
};

$__jsx_extend([_LCSECachedExpression], Object);
function _LCSECachedExpression$getOrigExpr$L_LCSECachedExpression$($this) {
	return $this._origExpr;
};

_LCSECachedExpression.getOrigExpr$L_LCSECachedExpression$ = _LCSECachedExpression$getOrigExpr$L_LCSECachedExpression$;

function _LCSECachedExpression$getLocalExpr$L_LCSECachedExpression$F$LType$SLLocalExpression$$($this, createVarCb) {
	var this$0;
	var this$1;
	if ($this._localExpr == null) {
		$this._localExpr = createVarCb($this._origExpr.getType$(), (this$1 = (this$0 = $this._origExpr, this$0._identifierToken), this$1._value));
		$this._replaceCb(new AssignmentExpression(new Token$2("=", false), $this._localExpr, $this._origExpr));
	}
	return $this._localExpr;
};

_LCSECachedExpression.getLocalExpr$L_LCSECachedExpression$F$LType$SLLocalExpression$$ = _LCSECachedExpression$getLocalExpr$L_LCSECachedExpression$F$LType$SLLocalExpression$$;

function _LCSEOptimizeCommand() {
	this._identifier = "lcse";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_LCSEOptimizeCommand], _FunctionOptimizeCommand);
_LCSEOptimizeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	_Util$0$optimizeBasicBlock$LMemberFunctionDefinition$F$ALExpression$V$(funcDef, (function (exprs) {
		_LCSEOptimizeCommand$_optimizeExpressions$L_LCSEOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs);
	}));
	return true;
};


_LCSEOptimizeCommand.prototype._optimizeExpressions$LMemberFunctionDefinition$ALExpression$ = function (funcDef, exprs) {
	var $this = this;
	var cachedExprs;
	var getCacheKey;
	var registerCacheable;
	var clearCacheByLocalName;
	var clearCache;
	var this$0$0;
	var message$0$0;
	this$0$0 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + "optimizing expressions starting";
	this$0$0._log += message$0$0 + "\n";
	cachedExprs = {};
	getCacheKey = (function (expr) {
		var propertyExpr;
		var receiverType;
		var base;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		if (expr instanceof PropertyExpression) {
			propertyExpr = expr;
			receiverType = propertyExpr._expr.getType$();
			if (Util$rootIsNativeClass$LType$(receiverType)) {
				return null;
			}
			base = getCacheKey(propertyExpr._expr);
			return (base == null ? null : base + "." + (this$0 = propertyExpr._identifierToken, this$0._value));
		} else if (expr instanceof LocalExpression) {
			this$3 = expr;
			this$2 = this$3._local;
			this$1 = this$2._name;
			return this$1._value;
		} else if (expr instanceof ThisExpression) {
			return "this";
		}
		return null;
	});
	registerCacheable = (function (key, expr, replaceCb) {
		var message$0;
		var this$0$0;
		var message$0$0;
		message$0 = "registering lcse entry for: " + key;
		this$0$0 = $this._optimizer;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
		cachedExprs[key] = ({_origExpr: expr, _replaceCb: replaceCb, _localExpr: null});
	});
	clearCacheByLocalName = (function (name) {
		var k;
		var message$0;
		var this$0$0;
		var message$0$0;
		var message$1;
		var this$0$1;
		var message$0$1;
		message$0 = "clearing lcse entry for local name: " + name;
		this$0$0 = $this._optimizer;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
		for (k in cachedExprs) {
			if (k.substring(0, name.length + 1) === name + ".") {
				message$1 = "  removing: " + k;
				this$0$1 = $this._optimizer;
				message$0$1 = "[" + $this._identifier + "] " + message$1;
				this$0$1._log += message$0$1 + "\n";
				delete cachedExprs[k];
			}
		}
	});
	clearCache = (function () {
		var this$0$0;
		var message$0$0;
		this$0$0 = $this._optimizer;
		message$0$0 = "[" + $this._identifier + "] " + "clearing lcse cache";
		this$0$0._log += message$0$0 + "\n";
		cachedExprs = {};
	});
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$((function onExpr(expr, replaceCb) {
		var assignmentExpr;
		var lhsExpr;
		var lhsPropertyExpr;
		var cacheKey;
		var incrementExpr;
		var propertyExpr;
		var conditionalExpr;
		var funcExpr;
		var args;
		var i;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$0$0;
		var message$0$0;
		var this$7;
		var message$0;
		var this$0$1;
		var message$0$1;
		var this$8;
		var that$0;
		var this$9;
		var this$10;
		if (expr instanceof AssignmentExpression || expr instanceof FusedAssignmentExpression) {
			assignmentExpr = expr;
			lhsExpr = assignmentExpr._expr1;
			if (lhsExpr instanceof LocalExpression) {
				onExpr(assignmentExpr._expr2, (function (expr) {
					BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
				}));
				clearCacheByLocalName((this$2 = (this$1 = (this$0 = lhsExpr, this$0._local), this$1._name), this$2._value));
			} else if (lhsExpr instanceof PropertyExpression) {
				lhsPropertyExpr = lhsExpr;
				onExpr((this$3 = lhsExpr, this$3._expr), (function (expr) {
					UnaryExpression$setExpr$LUnaryExpression$LExpression$(lhsPropertyExpr, expr);
				}));
				onExpr(assignmentExpr._expr2, (function (expr) {
					BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
				}));
				if ((this$4 = lhsPropertyExpr._identifierToken, this$4._value) === "length") {
				} else {
					cacheKey = getCacheKey(lhsExpr);
					if (cacheKey) {
						registerCacheable(cacheKey, lhsExpr, (function (expr) {
							BinaryExpression$setFirstExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
						}));
					}
				}
			} else {
				clearCache();
			}
			return true;
		} else if (expr instanceof IncrementExpression) {
			incrementExpr = expr;
			if (incrementExpr._expr instanceof PropertyExpression) {
				propertyExpr = incrementExpr._expr;
				onExpr(propertyExpr._expr, (function (expr) {
					UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
				}));
			}
			clearCache();
			return true;
		} else if (expr instanceof ConditionalExpression) {
			conditionalExpr = expr;
			onExpr(conditionalExpr._condExpr, (function (expr) {
				ConditionalExpression$setCondExpr$LConditionalExpression$LExpression$(conditionalExpr, expr);
			}));
			clearCache();
			return true;
		} else if (expr instanceof LogicalExpression) {
			if (! Expression$forEachExpression$LExpression$F$LExpression$B$(expr, (function (expr) {
				return ! _Util$0$exprHasSideEffects$LExpression$(expr);
			}))) {
				clearCache();
				return true;
			}
		} else if (expr instanceof FunctionExpression) {
			clearCache();
			return true;
		} else if (expr instanceof CallExpression) {
			this$5 = expr;
			funcExpr = this$5._expr;
			if (funcExpr instanceof LocalExpression) {
			} else if (funcExpr instanceof PropertyExpression) {
				propertyExpr = funcExpr;
				onExpr(propertyExpr._expr, (function (expr) {
					UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
				}));
			} else {
				clearCache();
			}
			this$6 = expr;
			args = this$6._args;
			for (i = 0; i < args.length; ++i) {
				onExpr(args[i], (function (args, index) {
					return (function (expr) {
						args[index] = expr;
					});
				})(args, i));
			}
			clearCache();
			return true;
		} else if (expr instanceof NewExpression) {
			this$0$0 = $this._optimizer;
			message$0$0 = "[" + $this._identifier + "] " + "new expression";
			this$0$0._log += message$0$0 + "\n";
			this$7 = expr;
			args = this$7._args;
			for (i = 0; i < args.length; ++i) {
				onExpr(args[i], (function (args, index) {
					return (function (expr) {
						args[index] = expr;
					});
				})(args, i));
			}
			clearCache();
			return true;
		}
		if (expr instanceof PropertyExpression) {
			if ((this$10 = (this$9 = expr, this$9._identifierToken), this$10._value) === "length") {
			} else {
				cacheKey = getCacheKey(expr);
				if (cacheKey) {
					message$0 = "rewriting cse for: " + cacheKey;
					this$0$1 = $this._optimizer;
					message$0$1 = "[" + $this._identifier + "] " + message$0;
					this$0$1._log += message$0$1 + "\n";
					if (cachedExprs[cacheKey]) {
						replaceCb((this$8 = _LCSECachedExpression$getLocalExpr$L_LCSECachedExpression$F$LType$SLLocalExpression$$(cachedExprs[cacheKey], (function (type, baseName) {
							var localVar;
							localVar = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, type, baseName);
							return new LocalExpression(LocalVariable$getName$LLocalVariable$(localVar), localVar);
						})), that$0 = new LocalExpression(this$8._token, this$8._local), that$0._cloned = true, that$0));
					} else {
						registerCacheable(cacheKey, expr, replaceCb);
					}
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	}), exprs);
};


function _LCSEOptimizeCommand$_optimizeExpressions$L_LCSEOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, funcDef, exprs) {
	var cachedExprs;
	var getCacheKey;
	var registerCacheable;
	var clearCacheByLocalName;
	var clearCache;
	var this$0$0;
	var message$0$0;
	this$0$0 = $this._optimizer;
	message$0$0 = "[" + $this._identifier + "] " + "optimizing expressions starting";
	this$0$0._log += message$0$0 + "\n";
	cachedExprs = {};
	getCacheKey = (function (expr) {
		var propertyExpr;
		var receiverType;
		var base;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		if (expr instanceof PropertyExpression) {
			propertyExpr = expr;
			receiverType = propertyExpr._expr.getType$();
			if (Util$rootIsNativeClass$LType$(receiverType)) {
				return null;
			}
			base = getCacheKey(propertyExpr._expr);
			return (base == null ? null : base + "." + (this$0 = propertyExpr._identifierToken, this$0._value));
		} else if (expr instanceof LocalExpression) {
			this$3 = expr;
			this$2 = this$3._local;
			this$1 = this$2._name;
			return this$1._value;
		} else if (expr instanceof ThisExpression) {
			return "this";
		}
		return null;
	});
	registerCacheable = (function (key, expr, replaceCb) {
		var message$0;
		var this$0$0;
		var message$0$0;
		message$0 = "registering lcse entry for: " + key;
		this$0$0 = $this._optimizer;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
		cachedExprs[key] = ({_origExpr: expr, _replaceCb: replaceCb, _localExpr: null});
	});
	clearCacheByLocalName = (function (name) {
		var k;
		var message$0;
		var this$0$0;
		var message$0$0;
		var message$1;
		var this$0$1;
		var message$0$1;
		message$0 = "clearing lcse entry for local name: " + name;
		this$0$0 = $this._optimizer;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
		for (k in cachedExprs) {
			if (k.substring(0, name.length + 1) === name + ".") {
				message$1 = "  removing: " + k;
				this$0$1 = $this._optimizer;
				message$0$1 = "[" + $this._identifier + "] " + message$1;
				this$0$1._log += message$0$1 + "\n";
				delete cachedExprs[k];
			}
		}
	});
	clearCache = (function () {
		var this$0$0;
		var message$0$0;
		this$0$0 = $this._optimizer;
		message$0$0 = "[" + $this._identifier + "] " + "clearing lcse cache";
		this$0$0._log += message$0$0 + "\n";
		cachedExprs = {};
	});
	Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$((function onExpr(expr, replaceCb) {
		var assignmentExpr;
		var lhsExpr;
		var lhsPropertyExpr;
		var cacheKey;
		var incrementExpr;
		var propertyExpr;
		var conditionalExpr;
		var funcExpr;
		var args;
		var i;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$0$0;
		var message$0$0;
		var this$7;
		var message$0;
		var this$0$1;
		var message$0$1;
		var this$8;
		var that$0;
		var this$9;
		var this$10;
		if (expr instanceof AssignmentExpression || expr instanceof FusedAssignmentExpression) {
			assignmentExpr = expr;
			lhsExpr = assignmentExpr._expr1;
			if (lhsExpr instanceof LocalExpression) {
				onExpr(assignmentExpr._expr2, (function (expr) {
					BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
				}));
				clearCacheByLocalName((this$2 = (this$1 = (this$0 = lhsExpr, this$0._local), this$1._name), this$2._value));
			} else if (lhsExpr instanceof PropertyExpression) {
				lhsPropertyExpr = lhsExpr;
				onExpr((this$3 = lhsExpr, this$3._expr), (function (expr) {
					UnaryExpression$setExpr$LUnaryExpression$LExpression$(lhsPropertyExpr, expr);
				}));
				onExpr(assignmentExpr._expr2, (function (expr) {
					BinaryExpression$setSecondExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
				}));
				if ((this$4 = lhsPropertyExpr._identifierToken, this$4._value) === "length") {
				} else {
					cacheKey = getCacheKey(lhsExpr);
					if (cacheKey) {
						registerCacheable(cacheKey, lhsExpr, (function (expr) {
							BinaryExpression$setFirstExpr$LBinaryExpression$LExpression$(assignmentExpr, expr);
						}));
					}
				}
			} else {
				clearCache();
			}
			return true;
		} else if (expr instanceof IncrementExpression) {
			incrementExpr = expr;
			if (incrementExpr._expr instanceof PropertyExpression) {
				propertyExpr = incrementExpr._expr;
				onExpr(propertyExpr._expr, (function (expr) {
					UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
				}));
			}
			clearCache();
			return true;
		} else if (expr instanceof ConditionalExpression) {
			conditionalExpr = expr;
			onExpr(conditionalExpr._condExpr, (function (expr) {
				ConditionalExpression$setCondExpr$LConditionalExpression$LExpression$(conditionalExpr, expr);
			}));
			clearCache();
			return true;
		} else if (expr instanceof LogicalExpression) {
			if (! Expression$forEachExpression$LExpression$F$LExpression$B$(expr, (function (expr) {
				return ! _Util$0$exprHasSideEffects$LExpression$(expr);
			}))) {
				clearCache();
				return true;
			}
		} else if (expr instanceof FunctionExpression) {
			clearCache();
			return true;
		} else if (expr instanceof CallExpression) {
			this$5 = expr;
			funcExpr = this$5._expr;
			if (funcExpr instanceof LocalExpression) {
			} else if (funcExpr instanceof PropertyExpression) {
				propertyExpr = funcExpr;
				onExpr(propertyExpr._expr, (function (expr) {
					UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
				}));
			} else {
				clearCache();
			}
			this$6 = expr;
			args = this$6._args;
			for (i = 0; i < args.length; ++i) {
				onExpr(args[i], (function (args, index) {
					return (function (expr) {
						args[index] = expr;
					});
				})(args, i));
			}
			clearCache();
			return true;
		} else if (expr instanceof NewExpression) {
			this$0$0 = $this._optimizer;
			message$0$0 = "[" + $this._identifier + "] " + "new expression";
			this$0$0._log += message$0$0 + "\n";
			this$7 = expr;
			args = this$7._args;
			for (i = 0; i < args.length; ++i) {
				onExpr(args[i], (function (args, index) {
					return (function (expr) {
						args[index] = expr;
					});
				})(args, i));
			}
			clearCache();
			return true;
		}
		if (expr instanceof PropertyExpression) {
			if ((this$10 = (this$9 = expr, this$9._identifierToken), this$10._value) === "length") {
			} else {
				cacheKey = getCacheKey(expr);
				if (cacheKey) {
					message$0 = "rewriting cse for: " + cacheKey;
					this$0$1 = $this._optimizer;
					message$0$1 = "[" + $this._identifier + "] " + message$0;
					this$0$1._log += message$0$1 + "\n";
					if (cachedExprs[cacheKey]) {
						replaceCb((this$8 = _LCSECachedExpression$getLocalExpr$L_LCSECachedExpression$F$LType$SLLocalExpression$$(cachedExprs[cacheKey], (function (type, baseName) {
							var localVar;
							localVar = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, type, baseName);
							return new LocalExpression(LocalVariable$getName$LLocalVariable$(localVar), localVar);
						})), that$0 = new LocalExpression(this$8._token, this$8._local), that$0._cloned = true, that$0));
					} else {
						registerCacheable(cacheKey, expr, replaceCb);
					}
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	}), exprs);
};

_LCSEOptimizeCommand._optimizeExpressions$L_LCSEOptimizeCommand$LMemberFunctionDefinition$ALExpression$ = _LCSEOptimizeCommand$_optimizeExpressions$L_LCSEOptimizeCommand$LMemberFunctionDefinition$ALExpression$;

function _ArrayLengthOptimizeCommand() {
	this._identifier = "array-length";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_ArrayLengthOptimizeCommand], _FunctionOptimizeCommand);
_ArrayLengthOptimizeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var condExpr;
		var arrayLocal;
		var this$0;
		Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		if (statement instanceof ForStatement) {
			this$0 = statement;
			condExpr = this$0._condExpr;
			arrayLocal = (condExpr != null ? _ArrayLengthOptimizeCommand$_hasLengthExprOfLocalArray$L_ArrayLengthOptimizeCommand$LExpression$($this, condExpr) : null);
			if (arrayLocal != null) {
				_ArrayLengthOptimizeCommand$_optimizeArrayLength$L_ArrayLengthOptimizeCommand$LMemberFunctionDefinition$LForStatement$LLocalVariable$($this, funcDef, statement, arrayLocal);
			}
		}
		return true;
	}), funcDef._statements);
	return true;
};


_ArrayLengthOptimizeCommand.prototype._optimizeArrayLength$LMemberFunctionDefinition$LForStatement$LLocalVariable$ = function (funcDef, statement, arrayLocal) {
	var $this = this;
	var lengthLocal;
	var assignToLocal;
	var onExpr;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	var this$1;
	var this$2;
	var expr$0;
	var this$3;
	if (_ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$(this, statement._condExpr) && _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$(this, statement._postExpr) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, (function (statement) {
		return _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$($this, statement);
	}))) {
		message$0 = funcDef.getNotation$() + " optimizing " + (this$3 = statement._token, "'" + this$3._value + "'" + " at " + (this$3._filename || "<<unknown>>") + ":" + (this$3._lineNumber + "") + ":" + (this$3._columnNumber + ""));
		this$0$0 = this._optimizer;
		message$0$0 = "[" + this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
		lengthLocal = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S(this, funcDef, Type.integerType, (this$0 = arrayLocal._name, this$0._value) + "$len");
		assignToLocal = new AssignmentExpression(new Token$3("="), new LocalExpression(new Token$2((this$1 = lengthLocal._name, this$1._value), true), lengthLocal), new PropertyExpression$0(new Token$3("."), new LocalExpression(new Token$2((this$2 = arrayLocal._name, this$2._value), true), arrayLocal), new Token$3("length"), [], lengthLocal._type));
		if (statement._initExpr != null) {
			expr$0 = new CommaExpression(new Token$3(","), statement._initExpr, assignToLocal);
			statement._initExpr = expr$0;
		} else {
			statement._initExpr = assignToLocal;
		}
		onExpr = (function (expr, replaceCb) {
			var this$0;
			var this$1;
			var this$2;
			var this$3;
			var this$4;
			var this$5;
			if (expr instanceof PropertyExpression && (this$2 = (this$1 = expr, this$1._identifierToken), this$2._value) === "length" && (this$3 = expr, this$3._expr) instanceof LocalExpression && (this$5 = (this$4 = expr, this$4._expr), this$5._local) == arrayLocal) {
				replaceCb(new LocalExpression(new Token$2((this$0 = lengthLocal._name, this$0._value), true), lengthLocal));
			} else {
				expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			}
			return true;
		});
		if (statement._condExpr != null) {
			statement._condExpr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		}
		if (statement._postExpr != null) {
			statement._postExpr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		}
		Statement$forEachStatement$LStatement$F$LStatement$B$(statement, (function onStatement2(statement) {
			Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement2);
			statement.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			return true;
		}));
	}
};


function _ArrayLengthOptimizeCommand$_optimizeArrayLength$L_ArrayLengthOptimizeCommand$LMemberFunctionDefinition$LForStatement$LLocalVariable$($this, funcDef, statement, arrayLocal) {
	var lengthLocal;
	var assignToLocal;
	var onExpr;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	var this$1;
	var this$2;
	var expr$0;
	var this$3;
	if (_ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$($this, statement._condExpr) && _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$($this, statement._postExpr) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, (function (statement) {
		return _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$($this, statement);
	}))) {
		message$0 = funcDef.getNotation$() + " optimizing " + (this$3 = statement._token, "'" + this$3._value + "'" + " at " + (this$3._filename || "<<unknown>>") + ":" + (this$3._lineNumber + "") + ":" + (this$3._columnNumber + ""));
		this$0$0 = $this._optimizer;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
		lengthLocal = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, Type.integerType, (this$0 = arrayLocal._name, this$0._value) + "$len");
		assignToLocal = new AssignmentExpression(new Token$3("="), new LocalExpression(new Token$2((this$1 = lengthLocal._name, this$1._value), true), lengthLocal), new PropertyExpression$0(new Token$3("."), new LocalExpression(new Token$2((this$2 = arrayLocal._name, this$2._value), true), arrayLocal), new Token$3("length"), [], lengthLocal._type));
		if (statement._initExpr != null) {
			expr$0 = new CommaExpression(new Token$3(","), statement._initExpr, assignToLocal);
			statement._initExpr = expr$0;
		} else {
			statement._initExpr = assignToLocal;
		}
		onExpr = (function (expr, replaceCb) {
			var this$0;
			var this$1;
			var this$2;
			var this$3;
			var this$4;
			var this$5;
			if (expr instanceof PropertyExpression && (this$2 = (this$1 = expr, this$1._identifierToken), this$2._value) === "length" && (this$3 = expr, this$3._expr) instanceof LocalExpression && (this$5 = (this$4 = expr, this$4._expr), this$5._local) == arrayLocal) {
				replaceCb(new LocalExpression(new Token$2((this$0 = lengthLocal._name, this$0._value), true), lengthLocal));
			} else {
				expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			}
			return true;
		});
		if (statement._condExpr != null) {
			statement._condExpr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		}
		if (statement._postExpr != null) {
			statement._postExpr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		}
		Statement$forEachStatement$LStatement$F$LStatement$B$(statement, (function onStatement2(statement) {
			Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement2);
			statement.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			return true;
		}));
	}
};

_ArrayLengthOptimizeCommand._optimizeArrayLength$L_ArrayLengthOptimizeCommand$LMemberFunctionDefinition$LForStatement$LLocalVariable$ = _ArrayLengthOptimizeCommand$_optimizeArrayLength$L_ArrayLengthOptimizeCommand$LMemberFunctionDefinition$LForStatement$LLocalVariable$;

_ArrayLengthOptimizeCommand.prototype._hasLengthExprOfLocalArray$LExpression$ = function (expr) {
	var $this = this;
	var local;
	local = null;
	Expression$forEachExpression$LExpression$F$LExpression$B$(expr, (function onExpr(expr) {
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$0$0;
		if (expr instanceof PropertyExpression && (this$3 = (this$2 = expr, this$2._identifierToken), this$3._value) === "length" && (this$4 = expr, this$4._expr) instanceof LocalExpression && _ArrayLengthOptimizeCommand$_typeIsArray$L_ArrayLengthOptimizeCommand$LType$($this, (this$6 = (this$5 = expr, this$5._expr).getType$(), this$6 instanceof NullableType ? (this$0$0 = this$6, this$0$0._baseType) : this$6))) {
			this$0 = (this$1 = expr, this$1._expr);
			local = this$0._local;
			return false;
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}));
	return local;
};


function _ArrayLengthOptimizeCommand$_hasLengthExprOfLocalArray$L_ArrayLengthOptimizeCommand$LExpression$($this, expr) {
	var local;
	local = null;
	Expression$forEachExpression$LExpression$F$LExpression$B$(expr, (function onExpr(expr) {
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$0$0;
		if (expr instanceof PropertyExpression && (this$3 = (this$2 = expr, this$2._identifierToken), this$3._value) === "length" && (this$4 = expr, this$4._expr) instanceof LocalExpression && _ArrayLengthOptimizeCommand$_typeIsArray$L_ArrayLengthOptimizeCommand$LType$($this, (this$6 = (this$5 = expr, this$5._expr).getType$(), this$6 instanceof NullableType ? (this$0$0 = this$6, this$0$0._baseType) : this$6))) {
			this$0 = (this$1 = expr, this$1._expr);
			local = this$0._local;
			return false;
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}));
	return local;
};

_ArrayLengthOptimizeCommand._hasLengthExprOfLocalArray$L_ArrayLengthOptimizeCommand$LExpression$ = _ArrayLengthOptimizeCommand$_hasLengthExprOfLocalArray$L_ArrayLengthOptimizeCommand$LExpression$;

_ArrayLengthOptimizeCommand.prototype._lengthIsUnmodifiedInStatement$LStatement$ = function (statement) {
	var $this = this;
	return (! Statement$forEachStatement$LStatement$F$LStatement$B$(statement, (function (statement) {
		return _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$($this, statement);
	})) ? false : Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
		return _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$($this, expr);
	})));
};


function _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$($this, statement) {
	return (! Statement$forEachStatement$LStatement$F$LStatement$B$(statement, (function (statement) {
		return _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$($this, statement);
	})) ? false : Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
		return _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$($this, expr);
	})));
};

_ArrayLengthOptimizeCommand._lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$ = _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInStatement$L_ArrayLengthOptimizeCommand$LStatement$;

_ArrayLengthOptimizeCommand.prototype._lengthIsUnmodifiedInExpr$LExpression$ = function (expr) {
	var this$0;
	var this$1;
	if (expr instanceof AssignmentExpression) {
		if (_ArrayLengthOptimizeCommand$_lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$(this, (this$0 = expr, this$0._expr1))) {
			return false;
		}
	} else if (expr instanceof CallExpression || expr instanceof SuperExpression) {
		return false;
	} else if (expr instanceof IncrementExpression) {
		if (_ArrayLengthOptimizeCommand$_lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$(this, (this$1 = expr, this$1._expr))) {
			return false;
		}
	}
	return true;
};


function _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$($this, expr) {
	var this$0;
	var this$1;
	if (expr instanceof AssignmentExpression) {
		if (_ArrayLengthOptimizeCommand$_lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$($this, (this$0 = expr, this$0._expr1))) {
			return false;
		}
	} else if (expr instanceof CallExpression || expr instanceof SuperExpression) {
		return false;
	} else if (expr instanceof IncrementExpression) {
		if (_ArrayLengthOptimizeCommand$_lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$($this, (this$1 = expr, this$1._expr))) {
			return false;
		}
	}
	return true;
};

_ArrayLengthOptimizeCommand._lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$ = _ArrayLengthOptimizeCommand$_lengthIsUnmodifiedInExpr$L_ArrayLengthOptimizeCommand$LExpression$;

_ArrayLengthOptimizeCommand.prototype._lhsMayModifyLength$LExpression$ = function (expr) {
	var exprType;
	var this$0;
	var this$1;
	var this$2;
	var this$0$0;
	if (expr instanceof PropertyExpression && (this$1 = (this$0 = expr, this$0._identifierToken), this$1._value) === "length") {
		return true;
	}
	if (expr instanceof ArrayExpression) {
		return true;
	}
	this$2 = expr.getType$();
	exprType = (this$2 instanceof NullableType ? (this$0$0 = this$2, this$0$0._baseType) : this$2);
	return (exprType.equals$LType$(Type.variantType) ? true : _ArrayLengthOptimizeCommand$_typeIsArray$L_ArrayLengthOptimizeCommand$LType$(this, exprType) ? true : false);
};


function _ArrayLengthOptimizeCommand$_lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$($this, expr) {
	var exprType;
	var this$0;
	var this$1;
	var this$2;
	var this$0$0;
	if (expr instanceof PropertyExpression && (this$1 = (this$0 = expr, this$0._identifierToken), this$1._value) === "length") {
		return true;
	}
	if (expr instanceof ArrayExpression) {
		return true;
	}
	this$2 = expr.getType$();
	exprType = (this$2 instanceof NullableType ? (this$0$0 = this$2, this$0$0._baseType) : this$2);
	return (exprType.equals$LType$(Type.variantType) ? true : _ArrayLengthOptimizeCommand$_typeIsArray$L_ArrayLengthOptimizeCommand$LType$($this, exprType) ? true : false);
};

_ArrayLengthOptimizeCommand._lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$ = _ArrayLengthOptimizeCommand$_lhsMayModifyLength$L_ArrayLengthOptimizeCommand$LExpression$;

_ArrayLengthOptimizeCommand.prototype._typeIsArray$LType$ = function (type) {
	var classDef;
	var this$0;
	var this$0$0;
	if (! (type instanceof ObjectType)) {
		return false;
	}
	classDef = type.getClassDef$();
	return (! (classDef instanceof InstantiatedClassDefinition) ? false : (this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) === "Array");
};


function _ArrayLengthOptimizeCommand$_typeIsArray$L_ArrayLengthOptimizeCommand$LType$($this, type) {
	var classDef;
	var this$0;
	var this$0$0;
	if (! (type instanceof ObjectType)) {
		return false;
	}
	classDef = type.getClassDef$();
	return (! (classDef instanceof InstantiatedClassDefinition) ? false : (this$0 = classDef, this$0$0 = this$0._templateClassDef, this$0$0._className) === "Array");
};

_ArrayLengthOptimizeCommand._typeIsArray$L_ArrayLengthOptimizeCommand$LType$ = _ArrayLengthOptimizeCommand$_typeIsArray$L_ArrayLengthOptimizeCommand$LType$;

function _TailRecursionOptimizeCommand() {
	this._identifier = "tail-rec";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_TailRecursionOptimizeCommand], _FunctionOptimizeCommand);
_TailRecursionOptimizeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var altered;
	var statements;
	var body;
	var message$0;
	var this$0$0;
	var message$0$0;
	var statements$0;
	var _flags$0;
	if (((_flags$0 = funcDef._flags) & 50) !== 0 || (_flags$0 & 12) === 0) {
		return false;
	}
	altered = false;
	statements = funcDef._statements;
	(function onStatements(statements) {
		var i;
		for (i = 0; i < statements.length; ++i) {
			if (_TailRecursionOptimizeCommand$_isTailCall$L_TailRecursionOptimizeCommand$LMemberFunctionDefinition$LStatement$($this, funcDef, statements[i])) {
				_TailRecursionOptimizeCommand$_replaceTailCallStatement$L_TailRecursionOptimizeCommand$LMemberFunctionDefinition$ALStatement$N($this, funcDef, statements, i);
				altered = true;
			}
			statements[i].handleStatements$F$ALStatement$B$(onStatements);
		}
		return true;
	})(statements);
	if (altered) {
		message$0 = "transform " + funcDef.getNotation$();
		this$0$0 = this._optimizer;
		message$0$0 = "[" + this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
		body = new WhileStatement(new Token$3("while"), new Token$3("$TAIL_REC"), new BooleanLiteralExpression(new Token$3("true")), statements);
		statements$0 = [ body ];
		funcDef._statements = statements$0;
	}
	return true;
};


_TailRecursionOptimizeCommand.prototype._isTailCall$LMemberFunctionDefinition$LStatement$ = function (funcDef, statement) {
	var returnStatement;
	var _expr$0;
	if (statement instanceof ReturnStatement) {
		returnStatement = statement;
		if ((_expr$0 = returnStatement._expr) != null && _expr$0 instanceof CallExpression) {
			return funcDef == _DetermineCalleeCommand$getCallingFuncDef$LStashable$(returnStatement._expr);
		}
	}
	return false;
};


function _TailRecursionOptimizeCommand$_isTailCall$L_TailRecursionOptimizeCommand$LMemberFunctionDefinition$LStatement$($this, funcDef, statement) {
	var returnStatement;
	var _expr$0;
	if (statement instanceof ReturnStatement) {
		returnStatement = statement;
		if ((_expr$0 = returnStatement._expr) != null && _expr$0 instanceof CallExpression) {
			return funcDef == _DetermineCalleeCommand$getCallingFuncDef$LStashable$(returnStatement._expr);
		}
	}
	return false;
};

_TailRecursionOptimizeCommand._isTailCall$L_TailRecursionOptimizeCommand$LMemberFunctionDefinition$LStatement$ = _TailRecursionOptimizeCommand$_isTailCall$L_TailRecursionOptimizeCommand$LMemberFunctionDefinition$LStatement$;

_TailRecursionOptimizeCommand.prototype._replaceTailCallStatement$LMemberFunctionDefinition$ALStatement$N = function (funcDef, statements, idx) {
	var $this = this;
	var callExpression;
	var locals;
	var setupArgs;
	var retry;
	var localsToArgs;
	var this$0;
	callExpression = (this$0 = statements[idx], this$0._expr);
	locals = funcDef._args.map((function (argDecl) {
		var this$0;
		return _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, argDecl._type, (this$0 = argDecl._name, this$0._value));
	}));
	setupArgs = callExpression._args.reduce((function (prevExpr, arg, i) {
		var assignToArg;
		var this$0;
		assignToArg = new AssignmentExpression(new Token$3("="), new LocalExpression((this$0 = locals[i], this$0._name), locals[i]), arg);
		return (prevExpr == null ? assignToArg : new CommaExpression(new Token$3(","), prevExpr, assignToArg));
	}), null);
	retry = new ContinueStatement(new Token$3("continue"), new Token$3("$TAIL_REC"));
	if (setupArgs == null) {
		statements.splice(idx, 1, retry);
	} else {
		localsToArgs = locals.reduce((function (prevExpr, local, i) {
			var assignToArg;
			var this$0;
			var _args$0;
			assignToArg = new AssignmentExpression(new Token$3("="), new LocalExpression((this$0 = (_args$0 = funcDef._args)[i], this$0._name), _args$0[i]), new LocalExpression(local._name, local));
			return (prevExpr == null ? assignToArg : new CommaExpression(new Token$3(","), prevExpr, assignToArg));
		}), null);
		statements.splice(idx, 1, new ExpressionStatement(setupArgs), new ExpressionStatement(localsToArgs), retry);
	}
};


function _TailRecursionOptimizeCommand$_replaceTailCallStatement$L_TailRecursionOptimizeCommand$LMemberFunctionDefinition$ALStatement$N($this, funcDef, statements, idx) {
	var callExpression;
	var locals;
	var setupArgs;
	var retry;
	var localsToArgs;
	var this$0;
	callExpression = (this$0 = statements[idx], this$0._expr);
	locals = funcDef._args.map((function (argDecl) {
		var this$0;
		return _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, argDecl._type, (this$0 = argDecl._name, this$0._value));
	}));
	setupArgs = callExpression._args.reduce((function (prevExpr, arg, i) {
		var assignToArg;
		var this$0;
		assignToArg = new AssignmentExpression(new Token$3("="), new LocalExpression((this$0 = locals[i], this$0._name), locals[i]), arg);
		return (prevExpr == null ? assignToArg : new CommaExpression(new Token$3(","), prevExpr, assignToArg));
	}), null);
	retry = new ContinueStatement(new Token$3("continue"), new Token$3("$TAIL_REC"));
	if (setupArgs == null) {
		statements.splice(idx, 1, retry);
	} else {
		localsToArgs = locals.reduce((function (prevExpr, local, i) {
			var assignToArg;
			var this$0;
			var _args$0;
			assignToArg = new AssignmentExpression(new Token$3("="), new LocalExpression((this$0 = (_args$0 = funcDef._args)[i], this$0._name), _args$0[i]), new LocalExpression(local._name, local));
			return (prevExpr == null ? assignToArg : new CommaExpression(new Token$3(","), prevExpr, assignToArg));
		}), null);
		statements.splice(idx, 1, new ExpressionStatement(setupArgs), new ExpressionStatement(localsToArgs), retry);
	}
};

_TailRecursionOptimizeCommand._replaceTailCallStatement$L_TailRecursionOptimizeCommand$LMemberFunctionDefinition$ALStatement$N = _TailRecursionOptimizeCommand$_replaceTailCallStatement$L_TailRecursionOptimizeCommand$LMemberFunctionDefinition$ALStatement$N;

function _StructuredStashAccessor$x2E$x3CStash$x3E() {
};

$__jsx_extend([_StructuredStashAccessor$x2E$x3CStash$x3E], Object);
_StructuredStashAccessor$x2E$x3CStash$x3E.prototype.$__jsx_implements__StructuredStashAccessor$x2E$x3CStash$x3E = true;

_StructuredStashAccessor$x2E$x3CStash$x3E.prototype.getStash$LStashable$ = function (stashable) {
	var identifier;
	var stash;
	identifier = this._identifier;
	stash = stashable.getStash$S(identifier);
	if (stash == null) {
		stash = new _LinkTimeOptimizationCommand$x2EStash();
		stashable.setStash$SLStash$(identifier, stash);
	}
	return stash;
};


_StructuredStashAccessor$x2E$x3CStash$x3E.prototype.resetStash$LStashable$ = function (stashable) {
	var identifier;
	identifier = this._identifier;
	stashable.setStash$SLStash$(identifier, null);
};


function _LinkTimeOptimizationCommand() {
	this._identifier = "lto";
	this._optimizer = null;
};

$__jsx_extend([_LinkTimeOptimizationCommand], _OptimizeCommand);
$__jsx_merge_interface(_LinkTimeOptimizationCommand, _StructuredStashAccessor$x2E$x3CStash$x3E);

_LinkTimeOptimizationCommand.prototype.performOptimization$ = function () {
	var $this = this;
	var this$0$0;
	var this$0$1;
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$0 = this._optimizer, this$0$0._compiler), (function (parser, classDef) {
		var i;
		var this$0;
		var this$1;
		if (classDef._extendType != null) {
			$this.getStash$LStashable$((this$0 = classDef._extendType, this$0._classDef)).extendedBy.push(classDef);
		}
		for (i = 0; i < classDef._implementTypes.length; ++i) {
			$this.getStash$LStashable$((this$1 = classDef._implementTypes[i], this$1._classDef)).extendedBy.push(classDef);
		}
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$1 = this._optimizer, this$0$1._compiler), (function (parser, classDef) {
		var message$0;
		var this$0$0;
		var message$0$0;
		if ((classDef.flags$() & 16596) === 0 && $this.getStash$LStashable$(classDef).extendedBy.length === 0) {
			message$0 = "marking class as final: " + classDef.className$();
			this$0$0 = $this._optimizer;
			message$0$0 = "[" + $this._identifier + "] " + message$0;
			this$0$0._log += message$0$0 + "\n";
			ClassDefinition$setFlags$LClassDefinition$N(classDef, classDef.flags$() | 4);
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_FINAL)) === 0) {
					MemberDefinition$setFlags$LMemberDefinition$N(funcDef, MemberDefinition$flags$LMemberDefinition$(funcDef) | ClassDefinition.IS_FINAL);
				}
				return true;
			}));
		} else if ((classDef.flags$() & 20) === 0) {
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
				var overrides;
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_NATIVE | ClassDefinition.IS_FINAL)) !== 0) {
				} else if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_ABSTRACT) === 0) {
					if (MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef) == null) {
						throw new Error("a non-native, non-abstract function with out function body?");
					}
					overrides = _LinkTimeOptimizationCommand$_getOverrides$L_LinkTimeOptimizationCommand$LClassDefinition$ALClassDefinition$SALType$($this, classDef, $this.getStash$LStashable$(classDef).extendedBy, MemberDefinition$name$LMemberDefinition$(funcDef), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef));
					if (overrides.length === 0) {
						_OptimizeCommand$log$L_OptimizeCommand$S($this, "marking function as final: " + funcDef.getNotation$());
						MemberDefinition$setFlags$LMemberDefinition$N(funcDef, MemberDefinition$flags$LMemberDefinition$(funcDef) | ClassDefinition.IS_FINAL);
					} else {
						_OptimizeCommand$log$L_OptimizeCommand$S($this, "function has overrides, not marking as final: " + funcDef.getNotation$());
					}
				} else if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_ABSTRACT) !== 0) {
				}
				return true;
			}));
		}
		return true;
	}));
};


_LinkTimeOptimizationCommand.prototype._getOverrides$LClassDefinition$ALClassDefinition$SALType$ = function (srcClassDef, classDefs, name, argTypes) {
	var overrides;
	var i;
	overrides = [];
	for (i = 0; i < classDefs.length; ++i) {
		overrides = overrides.concat(_LinkTimeOptimizationCommand$_getOverridesByClass$L_LinkTimeOptimizationCommand$LClassDefinition$LClassDefinition$SALType$(this, srcClassDef, classDefs[i], name, argTypes));
	}
	return overrides;
};


function _LinkTimeOptimizationCommand$_getOverrides$L_LinkTimeOptimizationCommand$LClassDefinition$ALClassDefinition$SALType$($this, srcClassDef, classDefs, name, argTypes) {
	var overrides;
	var i;
	overrides = [];
	for (i = 0; i < classDefs.length; ++i) {
		overrides = overrides.concat(_LinkTimeOptimizationCommand$_getOverridesByClass$L_LinkTimeOptimizationCommand$LClassDefinition$LClassDefinition$SALType$($this, srcClassDef, classDefs[i], name, argTypes));
	}
	return overrides;
};

_LinkTimeOptimizationCommand._getOverrides$L_LinkTimeOptimizationCommand$LClassDefinition$ALClassDefinition$SALType$ = _LinkTimeOptimizationCommand$_getOverrides$L_LinkTimeOptimizationCommand$LClassDefinition$ALClassDefinition$SALType$;

_LinkTimeOptimizationCommand.prototype._getOverridesByClass$LClassDefinition$LClassDefinition$SALType$ = function (srcClassDef, classDef, name, argTypes) {
	var $this = this;
	var overrides;
	var addOverride;
	var implementClassDefs;
	var i;
	var classDefs$0;
	var overrides$0;
	var i$0;
	classDefs$0 = this.getStash$LStashable$(classDef).extendedBy;
	overrides$0 = [];
	for (i$0 = 0; i$0 < classDefs$0.length; ++i$0) {
		overrides$0 = overrides$0.concat(_LinkTimeOptimizationCommand$_getOverridesByClass$L_LinkTimeOptimizationCommand$LClassDefinition$LClassDefinition$SALType$(this, srcClassDef, classDefs$0[i$0], name, argTypes));
	}
	overrides = overrides$0;
	function addOverride(funcDef) {
		var this$0$0;
		if ((this$0$0 = funcDef._nameToken, this$0$0._value) === name && (funcDef._flags & 2) === 0 && Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), argTypes)) {
			overrides.push(funcDef);
			return false;
		}
		return true;
	}
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, addOverride);
	implementClassDefs = classDef._implementTypes.map((function (type) {
		return type._classDef;
	}));
	for (i = 0; i < implementClassDefs.length; ++i) {
		if (srcClassDef != implementClassDefs[i]) {
			ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(implementClassDefs[i], (function (classDef) {
				return ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, addOverride);
			}));
		}
	}
	return overrides;
};


function _LinkTimeOptimizationCommand$_getOverridesByClass$L_LinkTimeOptimizationCommand$LClassDefinition$LClassDefinition$SALType$($this, srcClassDef, classDef, name, argTypes) {
	var overrides;
	var addOverride;
	var implementClassDefs;
	var i;
	var classDefs$0;
	var overrides$0;
	var i$0;
	classDefs$0 = $this.getStash$LStashable$(classDef).extendedBy;
	overrides$0 = [];
	for (i$0 = 0; i$0 < classDefs$0.length; ++i$0) {
		overrides$0 = overrides$0.concat(_LinkTimeOptimizationCommand$_getOverridesByClass$L_LinkTimeOptimizationCommand$LClassDefinition$LClassDefinition$SALType$($this, srcClassDef, classDefs$0[i$0], name, argTypes));
	}
	overrides = overrides$0;
	function addOverride(funcDef) {
		var this$0$0;
		if ((this$0$0 = funcDef._nameToken, this$0$0._value) === name && (funcDef._flags & 2) === 0 && Util$typesAreEqual$ALType$ALType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef), argTypes)) {
			overrides.push(funcDef);
			return false;
		}
		return true;
	}
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, addOverride);
	implementClassDefs = classDef._implementTypes.map((function (type) {
		return type._classDef;
	}));
	for (i = 0; i < implementClassDefs.length; ++i) {
		if (srcClassDef != implementClassDefs[i]) {
			ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(implementClassDefs[i], (function (classDef) {
				return ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, addOverride);
			}));
		}
	}
	return overrides;
};

_LinkTimeOptimizationCommand._getOverridesByClass$L_LinkTimeOptimizationCommand$LClassDefinition$LClassDefinition$SALType$ = _LinkTimeOptimizationCommand$_getOverridesByClass$L_LinkTimeOptimizationCommand$LClassDefinition$LClassDefinition$SALType$;

function _StructuredStashAccessor$x2E$x3C_Stash$x3E() {
};

$__jsx_extend([_StructuredStashAccessor$x2E$x3C_Stash$x3E], Object);
_StructuredStashAccessor$x2E$x3C_Stash$x3E.prototype.$__jsx_implements__StructuredStashAccessor$x2E$x3C_Stash$x3E = true;

_StructuredStashAccessor$x2E$x3C_Stash$x3E.prototype.getStash$LStashable$ = function (stashable) {
	var identifier;
	var stash;
	identifier = this._identifier;
	stash = stashable.getStash$S(identifier);
	if (stash == null) {
		stash = new _StripOptimizeCommand$x2E_Stash();
		stashable.setStash$SLStash$(identifier, stash);
	}
	return stash;
};


_StructuredStashAccessor$x2E$x3C_Stash$x3E.prototype.resetStash$LStashable$ = function (stashable) {
	var identifier;
	identifier = this._identifier;
	stashable.setStash$SLStash$(identifier, null);
};


function _StripOptimizeCommand() {
	this._identifier = "strip";
	this._optimizer = null;
	this._classesInstantiated = [];
	this._methodsAlive = {};
	this._membersToWalk = [];
};

$__jsx_extend([_StripOptimizeCommand], _OptimizeCommand);
$__jsx_merge_interface(_StripOptimizeCommand, _StructuredStashAccessor$x2E$x3C_Stash$x3E);

_StripOptimizeCommand.prototype._touchStatic$LMemberDefinition$ = function (member) {
	var stash;
	var identifier$0;
	var stash$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	identifier$0 = this._identifier;
	stash$0 = member.getStash$S(identifier$0);
	if (stash$0 == null) {
		stash$0 = new _StripOptimizeCommand$x2E_Stash();
		member.setStash$SLStash$(identifier$0, stash$0);
	}
	stash = stash$0;
	if (stash$0.touched) {
		return;
	}
	message$0 = "touched " + member.getNotation$();
	this$0$0 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	stash.touched = true;
	this._membersToWalk.push(member);
};


function _StripOptimizeCommand$_touchStatic$L_StripOptimizeCommand$LMemberDefinition$($this, member) {
	var stash;
	var identifier$0;
	var stash$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	identifier$0 = $this._identifier;
	stash$0 = member.getStash$S(identifier$0);
	if (stash$0 == null) {
		stash$0 = new _StripOptimizeCommand$x2E_Stash();
		member.setStash$SLStash$(identifier$0, stash$0);
	}
	stash = stash$0;
	if (stash$0.touched) {
		return;
	}
	message$0 = "touched " + member.getNotation$();
	this$0$0 = $this._optimizer;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	stash.touched = true;
	$this._membersToWalk.push(member);
};

_StripOptimizeCommand._touchStatic$L_StripOptimizeCommand$LMemberDefinition$ = _StripOptimizeCommand$_touchStatic$L_StripOptimizeCommand$LMemberDefinition$;

_StripOptimizeCommand.prototype._touchInstance$LClassDefinition$ = function (classDef) {
	var $this = this;
	var stash;
	var name;
	var listOfArgTypes;
	var i;
	var funcDef;
	var identifier$0;
	var stash$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	identifier$0 = this._identifier;
	stash$0 = classDef.getStash$S(identifier$0);
	if (stash$0 == null) {
		stash$0 = new _StripOptimizeCommand$x2E_Stash();
		classDef.setStash$SLStash$(identifier$0, stash$0);
	}
	stash = stash$0;
	if (stash$0.touched) {
		return;
	}
	message$0 = "touched " + classDef.className$();
	this$0$0 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	stash.touched = true;
	this._classesInstantiated.push(classDef);
	for (name in this._methodsAlive) {
		listOfArgTypes = this._methodsAlive[name];
		for (i = 0; i !== listOfArgTypes.length; ++i) {
			funcDef = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, listOfArgTypes[i], false);
			if (funcDef != null) {
				this._membersToWalk.push(funcDef);
			}
		}
	}
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
		if ((varDef._flags & 8) === 0) {
			$this._membersToWalk.push(varDef);
		}
		return true;
	}));
	if (classDef._extendType != null) {
		_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$(this, (this$0 = classDef._extendType, this$0._classDef));
	}
	classDef._implementTypes.forEach((function (implementType) {
		_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, implementType._classDef);
	}));
	if (classDef._outerClassDef != null) {
		_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$(this, classDef._outerClassDef);
	}
};


function _StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, classDef) {
	var stash;
	var name;
	var listOfArgTypes;
	var i;
	var funcDef;
	var identifier$0;
	var stash$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	identifier$0 = $this._identifier;
	stash$0 = classDef.getStash$S(identifier$0);
	if (stash$0 == null) {
		stash$0 = new _StripOptimizeCommand$x2E_Stash();
		classDef.setStash$SLStash$(identifier$0, stash$0);
	}
	stash = stash$0;
	if (stash$0.touched) {
		return;
	}
	message$0 = "touched " + classDef.className$();
	this$0$0 = $this._optimizer;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	stash.touched = true;
	$this._classesInstantiated.push(classDef);
	for (name in $this._methodsAlive) {
		listOfArgTypes = $this._methodsAlive[name];
		for (i = 0; i !== listOfArgTypes.length; ++i) {
			funcDef = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, listOfArgTypes[i], false);
			if (funcDef != null) {
				$this._membersToWalk.push(funcDef);
			}
		}
	}
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
		if ((varDef._flags & 8) === 0) {
			$this._membersToWalk.push(varDef);
		}
		return true;
	}));
	if (classDef._extendType != null) {
		_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, (this$0 = classDef._extendType, this$0._classDef));
	}
	classDef._implementTypes.forEach((function (implementType) {
		_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, implementType._classDef);
	}));
	if (classDef._outerClassDef != null) {
		_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, classDef._outerClassDef);
	}
};

_StripOptimizeCommand._touchInstance$L_StripOptimizeCommand$LClassDefinition$ = _StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$;

_StripOptimizeCommand.prototype._touchConstructor$LMemberFunctionDefinition$ = function (funcDef) {
	var stash;
	var identifier$0;
	var stash$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	identifier$0 = this._identifier;
	stash$0 = funcDef.getStash$S(identifier$0);
	if (stash$0 == null) {
		stash$0 = new _StripOptimizeCommand$x2E_Stash();
		funcDef.setStash$SLStash$(identifier$0, stash$0);
	}
	stash = stash$0;
	if (stash$0.touched) {
		return;
	}
	message$0 = "touched " + funcDef.getNotation$();
	this$0$0 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	stash.touched = true;
	this._membersToWalk.push(funcDef);
	_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$(this, funcDef._classDef);
};


function _StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var stash;
	var identifier$0;
	var stash$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	identifier$0 = $this._identifier;
	stash$0 = funcDef.getStash$S(identifier$0);
	if (stash$0 == null) {
		stash$0 = new _StripOptimizeCommand$x2E_Stash();
		funcDef.setStash$SLStash$(identifier$0, stash$0);
	}
	stash = stash$0;
	if (stash$0.touched) {
		return;
	}
	message$0 = "touched " + funcDef.getNotation$();
	this$0$0 = $this._optimizer;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	stash.touched = true;
	$this._membersToWalk.push(funcDef);
	_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, funcDef._classDef);
};

_StripOptimizeCommand._touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$ = _StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$;

_StripOptimizeCommand.prototype._touchMethod$SALType$ = function (name, argTypes) {
	var listOfArgTypes;
	var i;
	var funcDef;
	var message$0;
	var this$0$0;
	var message$0$0;
	if ($__jsx_ObjectHasOwnProperty.call(this._methodsAlive, name)) {
		listOfArgTypes = this._methodsAlive[name];
	} else {
		listOfArgTypes = this._methodsAlive[name] = [];
	}
	for (i = 0; i < listOfArgTypes.length; ++i) {
		if (Util$typesAreEqual$ALType$ALType$(listOfArgTypes[i], argTypes)) {
			return;
		}
	}
	message$0 = "touched #" + name;
	this$0$0 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	listOfArgTypes.push(argTypes.concat());
	for (i = 0; i < this._classesInstantiated.length; ++i) {
		funcDef = Util$findFunctionInClass$LClassDefinition$SALType$B(this._classesInstantiated[i], name, argTypes, false);
		if (funcDef != null) {
			this._membersToWalk.push(funcDef);
		}
	}
};


function _StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, name, argTypes) {
	var listOfArgTypes;
	var i;
	var funcDef;
	var message$0;
	var this$0$0;
	var message$0$0;
	if ($__jsx_ObjectHasOwnProperty.call($this._methodsAlive, name)) {
		listOfArgTypes = $this._methodsAlive[name];
	} else {
		listOfArgTypes = $this._methodsAlive[name] = [];
	}
	for (i = 0; i < listOfArgTypes.length; ++i) {
		if (Util$typesAreEqual$ALType$ALType$(listOfArgTypes[i], argTypes)) {
			return;
		}
	}
	message$0 = "touched #" + name;
	this$0$0 = $this._optimizer;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	listOfArgTypes.push(argTypes.concat());
	for (i = 0; i < $this._classesInstantiated.length; ++i) {
		funcDef = Util$findFunctionInClass$LClassDefinition$SALType$B($this._classesInstantiated[i], name, argTypes, false);
		if (funcDef != null) {
			$this._membersToWalk.push(funcDef);
		}
	}
};

_StripOptimizeCommand._touchMethod$L_StripOptimizeCommand$SALType$ = _StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$;

_StripOptimizeCommand.prototype.performOptimization$ = function () {
	var $this = this;
	var isEmittedClass;
	var member;
	var memberShouldPreserve;
	var this$0$0;
	var this$0$1;
	var this$0$2;
	var message$0;
	var this$0$3;
	var message$0$0;
	var this$0$4;
	var this$0$5;
	var this$0;
	function isEmittedClass(classDef) {
		return (classDef instanceof TemplateClassDefinition ? false : (classDef.flags$() & 16) !== 0 ? false : true);
	}
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$0 = this._optimizer, this$0$0._compiler), (function (parser, classDef) {
		var identifier$0;
		identifier$0 = $this._identifier;
		classDef.setStash$SLStash$(identifier$0, null);
		return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
			$this.resetStash$LStashable$(member);
			return true;
		}));
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$1 = this._optimizer, this$0$1._compiler), (function (parser, classDef) {
		if (! (classDef instanceof TemplateClassDefinition) && (classDef.flags$() & 16) !== 0) {
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
				if (MemberDefinition$name$LMemberDefinition$(funcDef) === "constructor") {
				} else if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_FINAL) !== 0) {
				} else {
					_StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, MemberDefinition$name$LMemberDefinition$(funcDef), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef));
				}
				return true;
			}));
		}
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$2 = this._optimizer, this$0$2._compiler), (function (parser, classDef) {
		if (isEmittedClass(classDef)) {
			if ((classDef.flags$() & 16384) !== 0) {
				_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, classDef);
			}
			ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
				var funcDef;
				if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_EXPORT) !== 0) {
					if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_STATIC) !== 0) {
						_StripOptimizeCommand$_touchStatic$L_StripOptimizeCommand$LMemberDefinition$($this, member);
					} else if (member instanceof MemberFunctionDefinition) {
						funcDef = member;
						if (MemberDefinition$name$LMemberDefinition$(funcDef) === "constructor") {
							_StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef);
						} else {
							_StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, MemberDefinition$name$LMemberDefinition$(funcDef), MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef));
						}
					}
				}
				return true;
			}));
		}
		return true;
	}));
	while (this._membersToWalk.length !== 0) {
		member = this._membersToWalk.shift();
		message$0 = "walking " + member.getNotation$();
		this$0$3 = this._optimizer;
		message$0$0 = "[" + this._identifier + "] " + message$0;
		this$0$3._log += message$0$0 + "\n";
		if (member instanceof MemberFunctionDefinition) {
			_StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$(this, member);
		} else {
			_StripOptimizeCommand$_walkVariableDefinition$L_StripOptimizeCommand$LMemberVariableDefinition$(this, member);
		}
	}
	function memberShouldPreserve(member) {
		var isTouched;
		var listOfArgTypes;
		var i;
		var this$0$0;
		var this$0$1;
		var this$0$2;
		if ((member._flags & 16384) !== 0) {
			return true;
		}
		isTouched = $this.getStash$LStashable$(member).touched;
		if ((member._flags & 8) !== 0) {
			return isTouched;
		} else if (member instanceof MemberFunctionDefinition) {
			if ((this$0$2 = member._nameToken, this$0$2._value) === "constructor") {
				return isTouched;
			} else {
				if ($this.getStash$LStashable$(member._classDef).touched && $__jsx_ObjectHasOwnProperty.call($this._methodsAlive, (this$0$1 = member._nameToken, this$0$1._value))) {
					listOfArgTypes = $this._methodsAlive[(this$0$0 = member._nameToken, this$0$0._value)];
					for (i = 0; i !== listOfArgTypes.length; ++i) {
						if (Util$typesAreEqual$ALType$ALType$(listOfArgTypes[i], MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(member))) {
							return true;
						}
					}
				}
				return false;
			}
		} else {
			return true;
		}
	}
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$4 = this._optimizer, this$0$4._compiler), (function (parser, classDef) {
		var numConstructors;
		var members;
		var memberIndex;
		var member;
		var ctor;
		var this$0$0;
		var message$0;
		var this$0$1;
		var message$0$0;
		var message$1;
		var this$0$2;
		var message$0$1;
		var message$2;
		var this$0$3;
		var message$0$2;
		if (isEmittedClass(classDef)) {
			numConstructors = 0;
			members = classDef._members;
			for (memberIndex = 0; memberIndex !== members.length; ) {
				member = members[memberIndex];
				if (memberShouldPreserve(member)) {
					if (member instanceof MemberFunctionDefinition && (member._flags & 8) === 0 && (this$0$0 = member._nameToken, this$0$0._value) === "constructor") {
						++numConstructors;
					}
					++memberIndex;
					message$0 = "preserving used: " + member.getNotation$();
					this$0$1 = $this._optimizer;
					message$0$0 = "[" + $this._identifier + "] " + message$0;
					this$0$1._log += message$0$0 + "\n";
				} else {
					message$1 = "removing unused: " + member.getNotation$();
					this$0$2 = $this._optimizer;
					message$0$1 = "[" + $this._identifier + "] " + message$1;
					this$0$2._log += message$0$1 + "\n";
					members.splice(memberIndex, 1);
				}
			}
			if (numConstructors === 0) {
				message$2 = "substituting fake constructor for class: " + classDef.className$();
				this$0$3 = $this._optimizer;
				message$0$2 = "[" + $this._identifier + "] " + message$2;
				this$0$3._log += message$0$2 + "\n";
				ctor = new MemberFunctionDefinition(null, new Token$2("constructor", true), 4 | classDef.flags$() & 16384, Type.voidType, [], [], [], [], classDef.getToken$(), null);
				ctor._classDef = classDef;
				members.push(ctor);
			}
		}
		return true;
	}));
	(this$0 = (this$0$5 = this._optimizer, this$0$5._compiler), this$0._parsers).forEach((function (parser) {
		var classDefs;
		var i;
		var preserve;
		var this$0;
		var message$0;
		var this$0$0;
		var message$0$0;
		classDefs = parser._classDefs;
		for (i = 0; i !== classDefs.length; ) {
			preserve = true;
			if ((classDefs[i].flags$() & 16) !== 0 && (this$0 = classDefs[i], this$0._nativeSource) != null && ! $this.getStash$LStashable$(classDefs[i]).touched && ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDefs[i], (function (member) {
				if ((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_STATIC) === 0) {
					return true;
				}
				return ! $this.getStash$LStashable$(member).touched;
			}))) {
				preserve = false;
			}
			if (preserve) {
				++i;
			} else {
				message$0 = "removing unused native class: " + classDefs[i].className$();
				this$0$0 = $this._optimizer;
				message$0$0 = "[" + $this._identifier + "] " + message$0;
				this$0$0._log += message$0$0 + "\n";
				classDefs.splice(i, 1);
			}
		}
	}));
};


_StripOptimizeCommand.prototype._walkExpression$LExpression$ = function (expr) {
	var $this = this;
	var onExpr;
	function onExpr(expr) {
		var callee;
		var propertyExpr;
		var holderClassDef;
		var name;
		var member;
		var superExpr;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var exprType$0;
		var this$4;
		var exprType$1;
		var this$5;
		var this$6;
		var this$7;
		if (expr instanceof NewExpression) {
			callee = Util$findFunctionInClass$LClassDefinition$SALType$B(expr.getType$().getClassDef$(), "constructor", (this$1 = (this$0 = expr, this$0._constructor), this$1._argTypes), false);
			_StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, callee);
		} else if (expr instanceof InstanceofExpression) {
			_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, (this$2 = expr, this$2._expectedType).getClassDef$());
		} else if (expr instanceof AsExpression) {
			if (expr.getType$() instanceof ObjectType) {
				_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, expr.getType$().getClassDef$());
			}
		} else if (expr instanceof AsNoConvertExpression) {
			if (expr.getType$() instanceof ObjectType) {
				_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, expr.getType$().getClassDef$());
			}
		} else if (expr instanceof PropertyExpression) {
			propertyExpr = expr;
			holderClassDef = propertyExpr.getHolderType$().getClassDef$();
			if (propertyExpr._isInner) {
				if ((holderClassDef.flags$() & 16) !== 0) {
					_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, holderClassDef);
				}
			} else {
				this$3 = propertyExpr._identifierToken;
				name = this$3._value;
				if (propertyExpr._expr.isClassSpecifier$()) {
					exprType$0 = propertyExpr._type;
					if (! (exprType$0 instanceof FunctionType) ? false : exprType$0.isAssignable$() ? false : true) {
						member = Util$findFunctionInClass$LClassDefinition$SALType$B(holderClassDef, name, (this$4 = expr.getType$(), this$4._argTypes), true);
					} else {
						member = Util$findVariableInClass$LClassDefinition$SB(holderClassDef, name, true);
					}
					_StripOptimizeCommand$_touchStatic$L_StripOptimizeCommand$LMemberDefinition$($this, member);
				} else {
					exprType$1 = propertyExpr._type;
					if (! (exprType$1 instanceof FunctionType) ? false : exprType$1.isAssignable$() ? false : true) {
						_StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, name, (this$5 = expr.getType$(), this$5._argTypes));
					}
				}
			}
		} else if (expr instanceof SuperExpression) {
			superExpr = expr;
			_StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, (this$6 = superExpr._name, this$6._value), (this$7 = superExpr._funcType, this$7._argTypes));
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}
	return onExpr(expr);
};


function _StripOptimizeCommand$_walkExpression$L_StripOptimizeCommand$LExpression$($this, expr) {
	var onExpr;
	function onExpr(expr) {
		var callee;
		var propertyExpr;
		var holderClassDef;
		var name;
		var member;
		var superExpr;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var exprType$0;
		var this$4;
		var exprType$1;
		var this$5;
		var this$6;
		var this$7;
		if (expr instanceof NewExpression) {
			callee = Util$findFunctionInClass$LClassDefinition$SALType$B(expr.getType$().getClassDef$(), "constructor", (this$1 = (this$0 = expr, this$0._constructor), this$1._argTypes), false);
			_StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, callee);
		} else if (expr instanceof InstanceofExpression) {
			_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, (this$2 = expr, this$2._expectedType).getClassDef$());
		} else if (expr instanceof AsExpression) {
			if (expr.getType$() instanceof ObjectType) {
				_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, expr.getType$().getClassDef$());
			}
		} else if (expr instanceof AsNoConvertExpression) {
			if (expr.getType$() instanceof ObjectType) {
				_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, expr.getType$().getClassDef$());
			}
		} else if (expr instanceof PropertyExpression) {
			propertyExpr = expr;
			holderClassDef = propertyExpr.getHolderType$().getClassDef$();
			if (propertyExpr._isInner) {
				if ((holderClassDef.flags$() & 16) !== 0) {
					_StripOptimizeCommand$_touchInstance$L_StripOptimizeCommand$LClassDefinition$($this, holderClassDef);
				}
			} else {
				this$3 = propertyExpr._identifierToken;
				name = this$3._value;
				if (propertyExpr._expr.isClassSpecifier$()) {
					exprType$0 = propertyExpr._type;
					if (! (exprType$0 instanceof FunctionType) ? false : exprType$0.isAssignable$() ? false : true) {
						member = Util$findFunctionInClass$LClassDefinition$SALType$B(holderClassDef, name, (this$4 = expr.getType$(), this$4._argTypes), true);
					} else {
						member = Util$findVariableInClass$LClassDefinition$SB(holderClassDef, name, true);
					}
					_StripOptimizeCommand$_touchStatic$L_StripOptimizeCommand$LMemberDefinition$($this, member);
				} else {
					exprType$1 = propertyExpr._type;
					if (! (exprType$1 instanceof FunctionType) ? false : exprType$1.isAssignable$() ? false : true) {
						_StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, name, (this$5 = expr.getType$(), this$5._argTypes));
					}
				}
			}
		} else if (expr instanceof SuperExpression) {
			superExpr = expr;
			_StripOptimizeCommand$_touchMethod$L_StripOptimizeCommand$SALType$($this, (this$6 = superExpr._name, this$6._value), (this$7 = superExpr._funcType, this$7._argTypes));
		}
		return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
	}
	return onExpr(expr);
};

_StripOptimizeCommand._walkExpression$L_StripOptimizeCommand$LExpression$ = _StripOptimizeCommand$_walkExpression$L_StripOptimizeCommand$LExpression$;

_StripOptimizeCommand.prototype._walkStatement$LStatement$ = function (statement) {
	var $this = this;
	var onStatement;
	function onStatement(statement) {
		var ctorStatement;
		var callee;
		var this$0;
		if (statement instanceof ConstructorInvocationStatement) {
			ctorStatement = statement;
			callee = Util$findFunctionInClass$LClassDefinition$SALType$B(ctorStatement._ctorClassType.getClassDef$(), "constructor", (this$0 = ctorStatement._ctorFunctionType, this$0._argTypes), false);
			_StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, callee);
		}
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
			return _StripOptimizeCommand$_walkExpression$L_StripOptimizeCommand$LExpression$($this, expr);
		}));
		return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}
	return onStatement(statement);
};


function _StripOptimizeCommand$_walkStatement$L_StripOptimizeCommand$LStatement$($this, statement) {
	var onStatement;
	function onStatement(statement) {
		var ctorStatement;
		var callee;
		var this$0;
		if (statement instanceof ConstructorInvocationStatement) {
			ctorStatement = statement;
			callee = Util$findFunctionInClass$LClassDefinition$SALType$B(ctorStatement._ctorClassType.getClassDef$(), "constructor", (this$0 = ctorStatement._ctorFunctionType, this$0._argTypes), false);
			_StripOptimizeCommand$_touchConstructor$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, callee);
		}
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function (expr) {
			return _StripOptimizeCommand$_walkExpression$L_StripOptimizeCommand$LExpression$($this, expr);
		}));
		return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}
	return onStatement(statement);
};

_StripOptimizeCommand._walkStatement$L_StripOptimizeCommand$LStatement$ = _StripOptimizeCommand$_walkStatement$L_StripOptimizeCommand$LStatement$;

_StripOptimizeCommand.prototype._walkFunctionDefinition$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	if (funcDef._statements != null) {
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			return _StripOptimizeCommand$_walkStatement$L_StripOptimizeCommand$LStatement$($this, statement);
		}), funcDef._statements);
	}
	return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, (function (funcDef) {
		return _StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef);
	}));
};


function _StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	if (funcDef._statements != null) {
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			return _StripOptimizeCommand$_walkStatement$L_StripOptimizeCommand$LStatement$($this, statement);
		}), funcDef._statements);
	}
	return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, (function (funcDef) {
		return _StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef);
	}));
};

_StripOptimizeCommand._walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$ = _StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$;

_StripOptimizeCommand.prototype._walkVariableDefinition$LMemberVariableDefinition$ = function (varDef) {
	var $this = this;
	var initialValue;
	initialValue = varDef._initialValue;
	if (initialValue != null) {
		_StripOptimizeCommand$_walkExpression$L_StripOptimizeCommand$LExpression$(this, initialValue);
	}
	return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(varDef, (function (funcDef) {
		return _StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef);
	}));
};


function _StripOptimizeCommand$_walkVariableDefinition$L_StripOptimizeCommand$LMemberVariableDefinition$($this, varDef) {
	var initialValue;
	initialValue = varDef._initialValue;
	if (initialValue != null) {
		_StripOptimizeCommand$_walkExpression$L_StripOptimizeCommand$LExpression$($this, initialValue);
	}
	return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(varDef, (function (funcDef) {
		return _StripOptimizeCommand$_walkFunctionDefinition$L_StripOptimizeCommand$LMemberFunctionDefinition$($this, funcDef);
	}));
};

_StripOptimizeCommand._walkVariableDefinition$L_StripOptimizeCommand$LMemberVariableDefinition$ = _StripOptimizeCommand$_walkVariableDefinition$L_StripOptimizeCommand$LMemberVariableDefinition$;

function _StructuredStashAccessor$x2E$x3CStash$x3E$0() {
};

$__jsx_extend([_StructuredStashAccessor$x2E$x3CStash$x3E$0], Object);
_StructuredStashAccessor$x2E$x3CStash$x3E$0.prototype.$__jsx_implements__StructuredStashAccessor$x2E$x3CStash$x3E$0 = true;

_StructuredStashAccessor$x2E$x3CStash$x3E$0.prototype.getStash$LStashable$ = function (stashable) {
	var identifier;
	var stash;
	identifier = this._identifier;
	stash = stashable.getStash$S(identifier);
	if (stash == null) {
		stash = new _DetermineCalleeCommand$x2EStash();
		stashable.setStash$SLStash$(identifier, stash);
	}
	return stash;
};


_StructuredStashAccessor$x2E$x3CStash$x3E$0.prototype.resetStash$LStashable$ = function (stashable) {
	var identifier;
	identifier = this._identifier;
	stashable.setStash$SLStash$(identifier, null);
};


function _DetermineCalleeCommand() {
	this._identifier = "determine-callee";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_DetermineCalleeCommand], _FunctionOptimizeCommand);
$__jsx_merge_interface(_DetermineCalleeCommand, _StructuredStashAccessor$x2E$x3CStash$x3E$0);

_DetermineCalleeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var callingFuncDef;
		var classDef$0;
		var argTypes$0;
		var found$0;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var this$4;
		if (statement instanceof ConstructorInvocationStatement) {
			this$1 = statement;
			classDef$0 = this$1._ctorClassType.getClassDef$();
			this$2 = (this$4 = statement, this$4._ctorFunctionType);
			argTypes$0 = this$2._argTypes;
			found$0 = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef$0, "constructor", argTypes$0, false);
			if (found$0 != null) {
				if ((found$0._flags & 12) === 0) {
					found$0 = null;
				}
			}
			callingFuncDef = found$0;
			if (found$0 == null) {
				throw new Error("could not determine the associated parent ctor");
			}
			$this.getStash$LStashable$(statement).callingFuncDef = callingFuncDef;
		} else if (statement instanceof FunctionStatement) {
			this$3 = statement;
			this$0 = this$3._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
		}
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			var calleeExpr;
			var propertyExpr;
			var holderType;
			var callingFuncDef;
			var newExpr;
			if (expr instanceof CallExpression) {
				calleeExpr = CallExpression$getExpr$LCallExpression$(expr);
				if (calleeExpr instanceof PropertyExpression && ! calleeExpr.getType$().isAssignable$()) {
					propertyExpr = calleeExpr;
					holderType = propertyExpr.getHolderType$();
					callingFuncDef = _DetermineCalleeCommand$findCallingFunction$LClassDefinition$SALType$B(holderType.getClassDef$(), Token$getValue$LToken$(PropertyExpression$getIdentifierToken$LPropertyExpression$(propertyExpr)), ResolvedFunctionType$getArgumentTypes$LResolvedFunctionType$(propertyExpr.getType$()), UnaryExpression$getExpr$LUnaryExpression$(propertyExpr).isClassSpecifier$());
					_DetermineCalleeCommand$_setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$($this, expr, callingFuncDef);
				} else if (calleeExpr instanceof FunctionExpression) {
					_DetermineCalleeCommand$_setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$($this, expr, FunctionExpression$getFuncDef$LFunctionExpression$(calleeExpr));
				} else {
					_DetermineCalleeCommand$_setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$($this, expr, null);
				}
			} else if (expr instanceof NewExpression) {
				newExpr = expr;
				if (! (newExpr.getType$().getClassDef$() != null)) {
					debugger;
					throw new Error("[src/optimizer.jsx:1039:59] assertion failure\n                    assert newExpr.getType().getClassDef() != null;\n                                                           ^^\n");
				}
				if (! (NewExpression$getConstructor$LNewExpression$(newExpr) != null)) {
					debugger;
					throw new Error("[src/optimizer.jsx:1040:52] assertion failure\n                    assert newExpr.getConstructor() != null;\n                                                    ^^\n");
				}
				callingFuncDef = _DetermineCalleeCommand$findCallingFunctionInClass$LClassDefinition$SALType$B(newExpr.getType$().getClassDef$(), "constructor", ResolvedFunctionType$getArgumentTypes$LResolvedFunctionType$(NewExpression$getConstructor$LNewExpression$(newExpr)), false);
				if (callingFuncDef == null) {
					throw new Error("could not find matching constructor for " + NewExpression$getConstructor$LNewExpression$(newExpr).toString());
				}
				_DetermineCalleeCommand$_setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$($this, newExpr, callingFuncDef);
			}
			if (expr instanceof FunctionExpression) {
				return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
			} else {
				return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
			}
		}));
		return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), funcDef._statements);
	return true;
};


_DetermineCalleeCommand.prototype._setCallingFuncDef$LStashable$LMemberFunctionDefinition$ = function (stashable, funcDef) {
	this.getStash$LStashable$(stashable).callingFuncDef = funcDef;
};


function _DetermineCalleeCommand$_setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$($this, stashable, funcDef) {
	$this.getStash$LStashable$(stashable).callingFuncDef = funcDef;
};

_DetermineCalleeCommand._setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$ = _DetermineCalleeCommand$_setCallingFuncDef$L_DetermineCalleeCommand$LStashable$LMemberFunctionDefinition$;

function _DetermineCalleeCommand$findCallingFunctionInClass$LClassDefinition$SALType$B(classDef, funcName, argTypes, isStatic) {
	var found;
	found = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, funcName, argTypes, isStatic);
	if (found != null) {
		if ((found._flags & 12) === 0) {
			found = null;
		}
	}
	return found;
};

_DetermineCalleeCommand.findCallingFunctionInClass$LClassDefinition$SALType$B = _DetermineCalleeCommand$findCallingFunctionInClass$LClassDefinition$SALType$B;

function _DetermineCalleeCommand$findCallingFunction$LClassDefinition$SALType$B(classDef, funcName, argTypes, isStatic) {
	var found;
	found = null;
	ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(classDef, (function (classDef) {
		return ((found = _DetermineCalleeCommand$findCallingFunctionInClass$LClassDefinition$SALType$B(classDef, funcName, argTypes, isStatic)) != null ? false : true);
	}));
	return found;
};

_DetermineCalleeCommand.findCallingFunction$LClassDefinition$SALType$B = _DetermineCalleeCommand$findCallingFunction$LClassDefinition$SALType$B;

function _DetermineCalleeCommand$getCallingFuncDef$LStashable$(stashable) {
	var stash;
	stash = stashable.getStash$S("determine-callee");
	if (stash == null) {
		throw new Error("callee not searched");
	}
	return stash.callingFuncDef;
};

_DetermineCalleeCommand.getCallingFuncDef$LStashable$ = _DetermineCalleeCommand$getCallingFuncDef$LStashable$;

function _StructuredStashAccessor$x2E$x3CStash$x3E$1() {
};

$__jsx_extend([_StructuredStashAccessor$x2E$x3CStash$x3E$1], Object);
_StructuredStashAccessor$x2E$x3CStash$x3E$1.prototype.$__jsx_implements__StructuredStashAccessor$x2E$x3CStash$x3E$1 = true;

_StructuredStashAccessor$x2E$x3CStash$x3E$1.prototype.getStash$LStashable$ = function (stashable) {
	var identifier;
	var stash;
	identifier = this._identifier;
	stash = stashable.getStash$S(identifier);
	if (stash == null) {
		stash = new _StaticizeOptimizeCommand$x2EStash();
		stashable.setStash$SLStash$(identifier, stash);
	}
	return stash;
};


_StructuredStashAccessor$x2E$x3CStash$x3E$1.prototype.resetStash$LStashable$ = function (stashable) {
	var identifier;
	identifier = this._identifier;
	stashable.setStash$SLStash$(identifier, null);
};


function _StaticizeOptimizeCommand() {
	this._identifier = "staticize";
	this._optimizer = null;
};

$__jsx_extend([_StaticizeOptimizeCommand], _OptimizeCommand);
$__jsx_merge_interface(_StaticizeOptimizeCommand, _StructuredStashAccessor$x2E$x3CStash$x3E$1);

_StaticizeOptimizeCommand.prototype.performOptimization$ = function () {
	var $this = this;
	var memberCanBeStaticized;
	var this$0$0;
	var this$0$1;
	function memberCanBeStaticized(funcDef) {
		var onStatement;
		var this$0$0;
		if ((funcDef._flags & 62) !== 4) {
			return false;
		}
		if ((this$0$0 = funcDef._nameToken, this$0$0._value) === "constructor") {
			return false;
		}
		function onStatement(statement) {
			if (statement instanceof FunctionStatement) {
				return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionStatement$getFuncDef$LFunctionStatement$(statement), onStatement);
			}
			return Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpression(expr) {
				if (expr instanceof FunctionExpression) {
					return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
				} else if (expr instanceof SuperExpression) {
					return false;
				}
				return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpression);
			})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}
		return (! Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, funcDef._statements) ? false : true);
	}
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$0 = this._optimizer, this$0$0._compiler), (function (parser, classDef) {
		if ((classDef.flags$() & 192) !== 0) {
			return true;
		}
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function onFunction(funcDef) {
			if (memberCanBeStaticized(funcDef)) {
				_OptimizeCommand$log$L_OptimizeCommand$S($this, "staticizing method: " + MemberDefinition$name$LMemberDefinition$(funcDef));
				_StaticizeOptimizeCommand$_staticizeMethod$L_StaticizeOptimizeCommand$LMemberFunctionDefinition$($this, funcDef);
			}
			return true;
		}));
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$1 = this._optimizer, this$0$1._compiler), (function (parser, classDef) {
		var onFunction;
		var message$0;
		var this$0$0;
		var message$0$0;
		message$0 = "rewriting member method calls in class: " + classDef.className$();
		this$0$0 = $this._optimizer;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
			if (MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef) == null) {
				return true;
			}
			_StaticizeOptimizeCommand$_rewriteMethodCallsToStatic$L_StaticizeOptimizeCommand$LExpression$F$LExpression$V$LMemberFunctionDefinition$($this, MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef), (function (expr) {
				MemberVariableDefinition$setInitialValue$LMemberVariableDefinition$LExpression$(varDef, expr);
			}), null);
			return true;
		}));
		function onFunction(funcDef) {
			var onStatement;
			function onStatement(statement) {
				statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
					_StaticizeOptimizeCommand$_rewriteMethodCallsToStatic$L_StaticizeOptimizeCommand$LExpression$F$LExpression$V$LMemberFunctionDefinition$($this, expr, replaceCb, funcDef);
					return true;
				}));
				return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
			}
			MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(funcDef, onStatement);
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, onFunction);
		}
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, onFunction);
		return true;
	}));
};


_StaticizeOptimizeCommand.prototype._staticizeMethod$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var staticFuncDef;
	var classDef;
	var newName;
	var thisArg;
	var baseName$0;
	var argTypes$0;
	var index$0;
	var newName$0;
	var this$0$0;
	var this$0;
	staticFuncDef = MemberFunctionDefinition$clone$LMemberFunctionDefinition$(funcDef);
	classDef = staticFuncDef._classDef;
	this$0$0 = funcDef._nameToken;
	baseName$0 = this$0$0._value;
	argTypes$0 = [ new ObjectType(classDef) ].concat((this$0 = funcDef.getType$(), this$0._argTypes));
	index$0 = 0;
	newName$0 = baseName$0;
	while (Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, newName$0, argTypes$0, true) != null) {
		newName$0 = Util$format$SAS("%1_%2", [ baseName$0, index$0 + "" ]);
		++index$0;
	}
	newName = newName$0;
	this.getStash$LStashable$(funcDef).altName = newName;
	staticFuncDef._nameToken = new Token$2(newName, true);
	MemberDefinition$setFlags$LMemberDefinition$N(staticFuncDef, funcDef._flags & -16385 | 8);
	thisArg = new ArgumentDeclaration(new Token$2("$this", false), new ObjectType(classDef));
	staticFuncDef._args.unshift(thisArg);
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var this$0;
		var this$1;
		if (statement instanceof FunctionStatement) {
			this$1 = statement;
			this$0 = this$1._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
		}
		return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
			if (expr instanceof ThisExpression) {
				replaceCb(new LocalExpression(LocalVariable$getName$LLocalVariable$(thisArg), thisArg));
			} else if (expr instanceof FunctionExpression) {
				return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
			}
			return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), staticFuncDef._statements);
};


function _StaticizeOptimizeCommand$_staticizeMethod$L_StaticizeOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var staticFuncDef;
	var classDef;
	var newName;
	var thisArg;
	var baseName$0;
	var argTypes$0;
	var index$0;
	var newName$0;
	var this$0$0;
	var this$0;
	staticFuncDef = MemberFunctionDefinition$clone$LMemberFunctionDefinition$(funcDef);
	classDef = staticFuncDef._classDef;
	this$0$0 = funcDef._nameToken;
	baseName$0 = this$0$0._value;
	argTypes$0 = [ new ObjectType(classDef) ].concat((this$0 = funcDef.getType$(), this$0._argTypes));
	index$0 = 0;
	newName$0 = baseName$0;
	while (Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, newName$0, argTypes$0, true) != null) {
		newName$0 = Util$format$SAS("%1_%2", [ baseName$0, index$0 + "" ]);
		++index$0;
	}
	newName = newName$0;
	$this.getStash$LStashable$(funcDef).altName = newName;
	staticFuncDef._nameToken = new Token$2(newName, true);
	MemberDefinition$setFlags$LMemberDefinition$N(staticFuncDef, funcDef._flags & -16385 | 8);
	thisArg = new ArgumentDeclaration(new Token$2("$this", false), new ObjectType(classDef));
	staticFuncDef._args.unshift(thisArg);
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var this$0;
		var this$1;
		if (statement instanceof FunctionStatement) {
			this$1 = statement;
			this$0 = this$1._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
		}
		return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
			if (expr instanceof ThisExpression) {
				replaceCb(new LocalExpression(LocalVariable$getName$LLocalVariable$(thisArg), thisArg));
			} else if (expr instanceof FunctionExpression) {
				return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
			}
			return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), staticFuncDef._statements);
};

_StaticizeOptimizeCommand._staticizeMethod$L_StaticizeOptimizeCommand$LMemberFunctionDefinition$ = _StaticizeOptimizeCommand$_staticizeMethod$L_StaticizeOptimizeCommand$LMemberFunctionDefinition$;

_StaticizeOptimizeCommand.prototype._newStaticFunctionName$LClassDefinition$SALType$B = function (classDef, baseName, argTypes, isStatic) {
	var index;
	var newName;
	index = 0;
	newName = baseName;
	while (Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, newName, argTypes, isStatic) != null) {
		newName = Util$format$SAS("%1_%2", [ baseName, index + "" ]);
		++index;
	}
	return newName;
};


function _StaticizeOptimizeCommand$_newStaticFunctionName$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B($this, classDef, baseName, argTypes, isStatic) {
	var index;
	var newName;
	index = 0;
	newName = baseName;
	while (Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, newName, argTypes, isStatic) != null) {
		newName = Util$format$SAS("%1_%2", [ baseName, index + "" ]);
		++index;
	}
	return newName;
};

_StaticizeOptimizeCommand._newStaticFunctionName$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B = _StaticizeOptimizeCommand$_newStaticFunctionName$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B;

_StaticizeOptimizeCommand.prototype._rewriteMethodCallsToStatic$LExpression$F$LExpression$V$LMemberFunctionDefinition$ = function (expr, replaceCb, rewritingFuncDef) {
	var $this = this;
	var onExpr;
	function onExpr(expr, replaceCb) {
		var calleeExpr;
		var propertyExpr;
		var receiverType;
		var funcDef;
		var newName;
		var superExpr;
		var classDef;
		var thisVar;
		var thisArg;
		var this$0;
		var this$1;
		var this$0$0;
		var this$2;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$7;
		var this$8;
		var this$9;
		var this$10;
		var this$11;
		var this$12;
		var this$13;
		var this$14;
		if (expr instanceof CallExpression) {
			this$0 = expr;
			calleeExpr = this$0._expr;
			if (calleeExpr instanceof PropertyExpression && ! (this$13 = calleeExpr, this$13._expr).isClassSpecifier$() && ! (this$14 = calleeExpr, this$14._type).isAssignable$()) {
				propertyExpr = calleeExpr;
				this$1 = propertyExpr._expr.getType$();
				receiverType = (this$1 instanceof NullableType ? (this$0$0 = this$1, this$0$0._baseType) : this$1);
				if ((receiverType.getClassDef$().flags$() & 192) === 0) {
					funcDef = _StaticizeOptimizeCommand$_findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B($this, receiverType.getClassDef$(), (this$2 = propertyExpr._identifierToken, this$2._value), (this$3 = propertyExpr._type, this$3._argTypes), false);
					if (funcDef != null && (newName = $this.getStash$LStashable$(funcDef).altName) != null) {
						onExpr(propertyExpr._expr, (function (expr) {
							UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
						}));
						Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, (this$4 = expr, this$4._args));
						replaceCb(new CallExpression(expr._token, new PropertyExpression$0(propertyExpr._token, new ClassExpression(new Token$2(funcDef._classDef.className$(), true), new ObjectType(funcDef._classDef)), new Token$2(newName, true), propertyExpr._typeArgs, new StaticFunctionType(null, (this$5 = funcDef.getType$(), this$5._returnType), [ new ObjectType(funcDef._classDef) ].concat((this$6 = funcDef.getType$(), this$6._argTypes)), false)), [ propertyExpr._expr ].concat((this$7 = expr, this$7._args))));
						return true;
					}
				}
			}
		} else if (expr instanceof SuperExpression) {
			superExpr = expr;
			classDef = (this$8 = superExpr._funcType, this$8._objectType).getClassDef$();
			funcDef = _StaticizeOptimizeCommand$_findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B($this, classDef, (this$9 = superExpr._name, this$9._value), (this$10 = superExpr._funcType, this$10._argTypes), false);
			if (funcDef != null && (newName = $this.getStash$LStashable$(funcDef).altName) != null) {
				Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, superExpr._args);
				if ((rewritingFuncDef._flags & 8) !== 0) {
					thisArg = rewritingFuncDef._args[0];
					thisVar = new LocalExpression(thisArg._name, thisArg);
				} else {
					thisVar = new ThisExpression(new Token$2("this", false), funcDef._classDef);
				}
				replaceCb(new CallExpression(expr._token, new PropertyExpression$0(superExpr._token, new ClassExpression(new Token$2(funcDef._classDef.className$(), true), new ObjectType(funcDef._classDef)), new Token$2(newName, true), [  ], new StaticFunctionType(null, (this$11 = funcDef.getType$(), this$11._returnType), [ new ObjectType(funcDef._classDef) ].concat((this$12 = funcDef.getType$(), this$12._argTypes)), false)), [ thisVar ].concat(superExpr._args)));
				return true;
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	}
	onExpr(expr, replaceCb);
};


function _StaticizeOptimizeCommand$_rewriteMethodCallsToStatic$L_StaticizeOptimizeCommand$LExpression$F$LExpression$V$LMemberFunctionDefinition$($this, expr, replaceCb, rewritingFuncDef) {
	var onExpr;
	function onExpr(expr, replaceCb) {
		var calleeExpr;
		var propertyExpr;
		var receiverType;
		var funcDef;
		var newName;
		var superExpr;
		var classDef;
		var thisVar;
		var thisArg;
		var this$0;
		var this$1;
		var this$0$0;
		var this$2;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$7;
		var this$8;
		var this$9;
		var this$10;
		var this$11;
		var this$12;
		var this$13;
		var this$14;
		if (expr instanceof CallExpression) {
			this$0 = expr;
			calleeExpr = this$0._expr;
			if (calleeExpr instanceof PropertyExpression && ! (this$13 = calleeExpr, this$13._expr).isClassSpecifier$() && ! (this$14 = calleeExpr, this$14._type).isAssignable$()) {
				propertyExpr = calleeExpr;
				this$1 = propertyExpr._expr.getType$();
				receiverType = (this$1 instanceof NullableType ? (this$0$0 = this$1, this$0$0._baseType) : this$1);
				if ((receiverType.getClassDef$().flags$() & 192) === 0) {
					funcDef = _StaticizeOptimizeCommand$_findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B($this, receiverType.getClassDef$(), (this$2 = propertyExpr._identifierToken, this$2._value), (this$3 = propertyExpr._type, this$3._argTypes), false);
					if (funcDef != null && (newName = $this.getStash$LStashable$(funcDef).altName) != null) {
						onExpr(propertyExpr._expr, (function (expr) {
							UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
						}));
						Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, (this$4 = expr, this$4._args));
						replaceCb(new CallExpression(expr._token, new PropertyExpression$0(propertyExpr._token, new ClassExpression(new Token$2(funcDef._classDef.className$(), true), new ObjectType(funcDef._classDef)), new Token$2(newName, true), propertyExpr._typeArgs, new StaticFunctionType(null, (this$5 = funcDef.getType$(), this$5._returnType), [ new ObjectType(funcDef._classDef) ].concat((this$6 = funcDef.getType$(), this$6._argTypes)), false)), [ propertyExpr._expr ].concat((this$7 = expr, this$7._args))));
						return true;
					}
				}
			}
		} else if (expr instanceof SuperExpression) {
			superExpr = expr;
			classDef = (this$8 = superExpr._funcType, this$8._objectType).getClassDef$();
			funcDef = _StaticizeOptimizeCommand$_findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B($this, classDef, (this$9 = superExpr._name, this$9._value), (this$10 = superExpr._funcType, this$10._argTypes), false);
			if (funcDef != null && (newName = $this.getStash$LStashable$(funcDef).altName) != null) {
				Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, superExpr._args);
				if ((rewritingFuncDef._flags & 8) !== 0) {
					thisArg = rewritingFuncDef._args[0];
					thisVar = new LocalExpression(thisArg._name, thisArg);
				} else {
					thisVar = new ThisExpression(new Token$2("this", false), funcDef._classDef);
				}
				replaceCb(new CallExpression(expr._token, new PropertyExpression$0(superExpr._token, new ClassExpression(new Token$2(funcDef._classDef.className$(), true), new ObjectType(funcDef._classDef)), new Token$2(newName, true), [  ], new StaticFunctionType(null, (this$11 = funcDef.getType$(), this$11._returnType), [ new ObjectType(funcDef._classDef) ].concat((this$12 = funcDef.getType$(), this$12._argTypes)), false)), [ thisVar ].concat(superExpr._args)));
				return true;
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	}
	onExpr(expr, replaceCb);
};

_StaticizeOptimizeCommand._rewriteMethodCallsToStatic$L_StaticizeOptimizeCommand$LExpression$F$LExpression$V$LMemberFunctionDefinition$ = _StaticizeOptimizeCommand$_rewriteMethodCallsToStatic$L_StaticizeOptimizeCommand$LExpression$F$LExpression$V$LMemberFunctionDefinition$;

_StaticizeOptimizeCommand.prototype._findFunctionInClassTree$LClassDefinition$SALType$B = function (classDef, name, argTypes, isStatic) {
	var funcDef;
	var this$0;
	while (classDef.className$() !== "Object") {
		if ((funcDef = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic)) != null) {
			return funcDef;
		}
		this$0 = classDef._extendType;
		classDef = this$0._classDef;
	}
	return Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic);
};


function _StaticizeOptimizeCommand$_findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B($this, classDef, name, argTypes, isStatic) {
	var funcDef;
	var this$0;
	while (classDef.className$() !== "Object") {
		if ((funcDef = Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic)) != null) {
			return funcDef;
		}
		this$0 = classDef._extendType;
		classDef = this$0._classDef;
	}
	return Util$findFunctionInClass$LClassDefinition$SALType$B(classDef, name, argTypes, isStatic);
};

_StaticizeOptimizeCommand._findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B = _StaticizeOptimizeCommand$_findFunctionInClassTree$L_StaticizeOptimizeCommand$LClassDefinition$SALType$B;

function _StructuredStashAccessor$x2E$x3CStash$x3E$2() {
};

$__jsx_extend([_StructuredStashAccessor$x2E$x3CStash$x3E$2], Object);
_StructuredStashAccessor$x2E$x3CStash$x3E$2.prototype.$__jsx_implements__StructuredStashAccessor$x2E$x3CStash$x3E$2 = true;

_StructuredStashAccessor$x2E$x3CStash$x3E$2.prototype.getStash$LStashable$ = function (stashable) {
	var identifier;
	var stash;
	identifier = this._identifier;
	stash = stashable.getStash$S(identifier);
	if (stash == null) {
		stash = new _UnclassifyOptimizationCommand$x2EStash();
		stashable.setStash$SLStash$(identifier, stash);
	}
	return stash;
};


_StructuredStashAccessor$x2E$x3CStash$x3E$2.prototype.resetStash$LStashable$ = function (stashable) {
	var identifier;
	identifier = this._identifier;
	stashable.setStash$SLStash$(identifier, null);
};


function _UnclassifyOptimizationCommand() {
	this._identifier = "unclassify";
	this._optimizer = null;
};

$__jsx_extend([_UnclassifyOptimizationCommand], _OptimizeCommand);
$__jsx_merge_interface(_UnclassifyOptimizationCommand, _StructuredStashAccessor$x2E$x3CStash$x3E$2);

_UnclassifyOptimizationCommand.prototype.performOptimization$ = function () {
	var $this = this;
	var classDefs;
	var this$0$0;
	classDefs = _UnclassifyOptimizationCommand$_getClassesToUnclassify$L_UnclassifyOptimizationCommand$(this);
	classDefs.forEach((function (classDef) {
		var message$0;
		var this$0$0;
		var message$0$0;
		message$0 = "unclassifying class: " + classDef.className$();
		this$0$0 = $this._optimizer;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function onFunction(funcDef) {
			if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_STATIC) === 0 && MemberDefinition$name$LMemberDefinition$(funcDef) !== "constructor") {
				_OptimizeCommand$log$L_OptimizeCommand$S($this, "rewriting method to static function: " + MemberDefinition$name$LMemberDefinition$(funcDef));
				_UnclassifyOptimizationCommand$_rewriteFunctionAsStatic$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$($this, funcDef);
			}
			return true;
		}));
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$0 = this._optimizer, this$0$0._compiler), (function (parser, classDef) {
		var onFunction;
		var message$0;
		var this$0$0;
		var message$0$0;
		message$0 = "rewriting member method calls in class: " + classDef.className$();
		this$0$0 = $this._optimizer;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
		function onFunction(funcDef) {
			var onStatement;
			function onStatement(statement) {
				statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
					_UnclassifyOptimizationCommand$_rewriteMethodCallsToStatic$L_UnclassifyOptimizationCommand$LExpression$F$LExpression$V$ALClassDefinition$($this, expr, replaceCb, classDefs);
					return true;
				}));
				return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
			}
			MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(funcDef, onStatement);
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, onFunction);
		}
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, onFunction);
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
			if ((MemberDefinition$flags$LMemberDefinition$(varDef) & ClassDefinition.IS_STATIC) !== 0) {
				if (MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef) != null) {
					_UnclassifyOptimizationCommand$_rewriteMethodCallsToStatic$L_UnclassifyOptimizationCommand$LExpression$F$LExpression$V$ALClassDefinition$($this, MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef), (function (expr) {
						MemberVariableDefinition$setInitialValue$LMemberVariableDefinition$LExpression$(varDef, expr);
					}), classDefs);
				}
			}
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(varDef, onFunction);
		}));
		return true;
	}));
};


_UnclassifyOptimizationCommand.prototype._getClassesToUnclassify$ = function () {
	var $this = this;
	var candidates;
	var candidateIndex;
	var hasInlineableCtor;
	var this$0$0;
	var this$0$1;
	candidates = [];
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$0 = this._optimizer, this$0$0._compiler), (function (parser, classDef) {
		var this$0;
		if ((classDef.flags$() & 16404) === 4 && (this$0 = classDef._extendType, this$0._classDef).className$() === "Object" && classDef._implementTypes.length === 0 && ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
			return (MemberDefinition$flags$LMemberDefinition$(funcDef) & (ClassDefinition.IS_OVERRIDE | ClassDefinition.IS_EXPORT)) === 0;
		}))) {
			candidates.push(classDef);
		}
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$1 = this._optimizer, this$0$1._compiler), (function (parser, classDef) {
		var onExpr;
		var onFunction;
		if (candidates.length === 0) {
			return false;
		}
		function onExpr(expr) {
			var foundClassDefIndex;
			if (! (expr != null)) {
				debugger;
				throw new Error("[src/optimizer.jsx:1420:28] assertion failure\n                assert expr != null;\n                            ^^\n");
			}
			if (expr instanceof InstanceofExpression) {
				foundClassDefIndex = candidates.indexOf(InstanceofExpression$getExpectedType$LInstanceofExpression$(expr).getClassDef$());
				if (foundClassDefIndex !== - 1) {
					candidates.splice(foundClassDefIndex, 1);
					if (candidates.length === 0) {
						return false;
					}
				}
			} else if (expr instanceof AsExpression && expr.getType$() instanceof ObjectType) {
				foundClassDefIndex = candidates.indexOf(expr.getType$().getClassDef$());
				if (foundClassDefIndex !== - 1) {
					candidates.splice(foundClassDefIndex, 1);
					if (candidates.length === 0) {
						return false;
					}
				}
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}
		function onFunction(funcDef) {
			MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(funcDef, (function onStatement(statement) {
				Statement$forEachExpression$LStatement$F$LExpression$B$(statement, onExpr);
				return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
			}));
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, onFunction);
		}
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, onFunction);
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
			if ((MemberDefinition$flags$LMemberDefinition$(varDef) & ClassDefinition.IS_STATIC) !== 0) {
				if (MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef) != null) {
					onExpr(MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef));
				}
			}
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(varDef, onFunction);
		}));
		return true;
	}));
	for (candidateIndex = candidates.length - 1; candidateIndex >= 0; --candidateIndex) {
		hasInlineableCtor = false;
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(candidates[candidateIndex], (function (funcDef) {
			var inliner;
			var message$0;
			var this$0$0;
			var message$0$0;
			var this$0$1;
			if ((funcDef._flags & 8) === 0 && (this$0$1 = funcDef._nameToken, this$0$1._value) === "constructor") {
				inliner = _UnclassifyOptimizationCommand$_createInliner$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$($this, funcDef);
				message$0 = funcDef.getNotation$() + " is" + (inliner ? "" : " not") + " inlineable";
				this$0$0 = $this._optimizer;
				message$0$0 = "[" + $this._identifier + "] " + message$0;
				this$0$0._log += message$0$0 + "\n";
				if (inliner) {
					$this.getStash$LStashable$(funcDef).inliner = inliner;
					hasInlineableCtor = true;
				}
			}
			return true;
		}));
		if (! hasInlineableCtor) {
			candidates.splice(candidateIndex, 1);
		}
	}
	return (candidates.length === 0 ? candidates : candidates);
};


function _UnclassifyOptimizationCommand$_getClassesToUnclassify$L_UnclassifyOptimizationCommand$($this) {
	var candidates;
	var candidateIndex;
	var hasInlineableCtor;
	var this$0$0;
	var this$0$1;
	candidates = [];
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$0 = $this._optimizer, this$0$0._compiler), (function (parser, classDef) {
		var this$0;
		if ((classDef.flags$() & 16404) === 4 && (this$0 = classDef._extendType, this$0._classDef).className$() === "Object" && classDef._implementTypes.length === 0 && ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
			return (MemberDefinition$flags$LMemberDefinition$(funcDef) & (ClassDefinition.IS_OVERRIDE | ClassDefinition.IS_EXPORT)) === 0;
		}))) {
			candidates.push(classDef);
		}
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$1 = $this._optimizer, this$0$1._compiler), (function (parser, classDef) {
		var onExpr;
		var onFunction;
		if (candidates.length === 0) {
			return false;
		}
		function onExpr(expr) {
			var foundClassDefIndex;
			if (! (expr != null)) {
				debugger;
				throw new Error("[src/optimizer.jsx:1420:28] assertion failure\n                assert expr != null;\n                            ^^\n");
			}
			if (expr instanceof InstanceofExpression) {
				foundClassDefIndex = candidates.indexOf(InstanceofExpression$getExpectedType$LInstanceofExpression$(expr).getClassDef$());
				if (foundClassDefIndex !== - 1) {
					candidates.splice(foundClassDefIndex, 1);
					if (candidates.length === 0) {
						return false;
					}
				}
			} else if (expr instanceof AsExpression && expr.getType$() instanceof ObjectType) {
				foundClassDefIndex = candidates.indexOf(expr.getType$().getClassDef$());
				if (foundClassDefIndex !== - 1) {
					candidates.splice(foundClassDefIndex, 1);
					if (candidates.length === 0) {
						return false;
					}
				}
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}
		function onFunction(funcDef) {
			MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(funcDef, (function onStatement(statement) {
				Statement$forEachExpression$LStatement$F$LExpression$B$(statement, onExpr);
				return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
			}));
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(funcDef, onFunction);
		}
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, onFunction);
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
			if ((MemberDefinition$flags$LMemberDefinition$(varDef) & ClassDefinition.IS_STATIC) !== 0) {
				if (MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef) != null) {
					onExpr(MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef));
				}
			}
			return MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(varDef, onFunction);
		}));
		return true;
	}));
	for (candidateIndex = candidates.length - 1; candidateIndex >= 0; --candidateIndex) {
		hasInlineableCtor = false;
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(candidates[candidateIndex], (function (funcDef) {
			var inliner;
			var message$0;
			var this$0$0;
			var message$0$0;
			var this$0$1;
			if ((funcDef._flags & 8) === 0 && (this$0$1 = funcDef._nameToken, this$0$1._value) === "constructor") {
				inliner = _UnclassifyOptimizationCommand$_createInliner$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$($this, funcDef);
				message$0 = funcDef.getNotation$() + " is" + (inliner ? "" : " not") + " inlineable";
				this$0$0 = $this._optimizer;
				message$0$0 = "[" + $this._identifier + "] " + message$0;
				this$0$0._log += message$0$0 + "\n";
				if (inliner) {
					$this.getStash$LStashable$(funcDef).inliner = inliner;
					hasInlineableCtor = true;
				}
			}
			return true;
		}));
		if (! hasInlineableCtor) {
			candidates.splice(candidateIndex, 1);
		}
	}
	return (candidates.length === 0 ? candidates : candidates);
};

_UnclassifyOptimizationCommand._getClassesToUnclassify$L_UnclassifyOptimizationCommand$ = _UnclassifyOptimizationCommand$_getClassesToUnclassify$L_UnclassifyOptimizationCommand$;

_UnclassifyOptimizationCommand.prototype._createInliner$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var propertyNames;
	var propertyExprs;
	var expectedArgIndex;
	var statements;
	var statementIndex;
	var statementExpr;
	var lhsExpr;
	var onRHSExpr;
	var propertyIndex;
	var i;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	var propertyNames$len$0;
	if (funcDef._locals.length !== 0) {
		return null;
	}
	propertyNames = [];
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(funcDef._classDef, (function (member) {
		var this$0$0;
		if ((member._flags & 8) === 0) {
			propertyNames.push((this$0$0 = member._nameToken, this$0$0._value));
		}
		return true;
	}));
	propertyExprs = [];
	expectedArgIndex = 0;
	statements = funcDef._statements;
	if (statements.length !== propertyNames.length) {
		return null;
	}
	for (statementIndex = 0; statementIndex < statements.length; ++statementIndex) {
		if (! (statements[statementIndex] instanceof ExpressionStatement)) {
			return null;
		}
		this$0 = statements[statementIndex];
		statementExpr = this$0._expr;
		if (! (statementExpr instanceof AssignmentExpression)) {
			return null;
		}
		this$1 = statementExpr;
		lhsExpr = this$1._expr1;
		if (! (lhsExpr instanceof PropertyExpression && (this$2 = lhsExpr, this$2._expr) instanceof ThisExpression)) {
			return null;
		}
		function onRHSExpr(expr) {
			var argIndex;
			var this$0;
			var this$1;
			var this$2;
			var this$3;
			if (expr instanceof AssignmentExpression || expr instanceof FusedAssignmentExpression || expr instanceof PreIncrementExpression || expr instanceof PostIncrementExpression) {
				return false;
			} else if (expr instanceof FunctionExpression) {
				return false;
			} else if (expr instanceof ThisExpression) {
				return false;
			} else if (expr instanceof LocalExpression) {
				argIndex = funcDef._args.map((function (i) {
					return i;
				})).indexOf((this$0 = expr, this$0._local));
				if (argIndex === -1) {
					throw new Error("logic flaw; could not find argument: " + (this$3 = (this$2 = (this$1 = expr, this$1._local), this$2._name), this$3._value));
				}
				if (expectedArgIndex !== argIndex) {
					return false;
				}
				++expectedArgIndex;
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onRHSExpr);
		}
		if (! onRHSExpr((this$3 = statementExpr, this$3._expr2))) {
			return null;
		}
		propertyIndex = propertyNames.indexOf((this$5 = (this$4 = lhsExpr, this$4._identifierToken), this$5._value));
		if (propertyIndex === -1) {
			throw new Error("logic flaw; could not find property: " + (this$7 = (this$6 = lhsExpr, this$6._identifierToken), this$7._value));
		}
		if (propertyExprs[propertyIndex]) {
			return null;
		}
		for ((i = propertyIndex + 1, propertyNames$len$0 = propertyNames.length); i < propertyNames$len$0; ++i) {
			if (propertyExprs[i] != null && _Util$0$exprHasSideEffects$LExpression$(propertyExprs[i])) {
				return null;
			}
		}
		propertyExprs[propertyIndex] = (this$8 = statementExpr, this$8._expr2).clone$();
	}
	return (function (newExpr) {
		return propertyExprs.map((function (expr) {
			var onExpr;
			function onExpr(expr, replaceCb) {
				var args;
				var argIndex;
				var i;
				if (expr instanceof LocalExpression) {
					(args = MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef), argIndex = - 1);
					for (i in args) { i |= 0;
						if (args[i] == LocalExpression$getLocal$LLocalExpression$(expr)) {
							argIndex = i;
							break;
						}
					}
					if (argIndex === - 1) {
						throw new Error("logic flaw");
					}
					replaceCb(NewExpression$getArguments$LNewExpression$(newExpr)[argIndex]);
					return true;
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			}
			expr = expr.clone$();
			onExpr(expr, (function (newExpr) {
				expr = newExpr;
			}));
			return expr;
		}));
	});
};


function _UnclassifyOptimizationCommand$_createInliner$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$($this, funcDef) {
	var propertyNames;
	var propertyExprs;
	var expectedArgIndex;
	var statements;
	var statementIndex;
	var statementExpr;
	var lhsExpr;
	var onRHSExpr;
	var propertyIndex;
	var i;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	var propertyNames$len$0;
	if (funcDef._locals.length !== 0) {
		return null;
	}
	propertyNames = [];
	ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(funcDef._classDef, (function (member) {
		var this$0$0;
		if ((member._flags & 8) === 0) {
			propertyNames.push((this$0$0 = member._nameToken, this$0$0._value));
		}
		return true;
	}));
	propertyExprs = [];
	expectedArgIndex = 0;
	statements = funcDef._statements;
	if (statements.length !== propertyNames.length) {
		return null;
	}
	for (statementIndex = 0; statementIndex < statements.length; ++statementIndex) {
		if (! (statements[statementIndex] instanceof ExpressionStatement)) {
			return null;
		}
		this$0 = statements[statementIndex];
		statementExpr = this$0._expr;
		if (! (statementExpr instanceof AssignmentExpression)) {
			return null;
		}
		this$1 = statementExpr;
		lhsExpr = this$1._expr1;
		if (! (lhsExpr instanceof PropertyExpression && (this$2 = lhsExpr, this$2._expr) instanceof ThisExpression)) {
			return null;
		}
		function onRHSExpr(expr) {
			var argIndex;
			var this$0;
			var this$1;
			var this$2;
			var this$3;
			if (expr instanceof AssignmentExpression || expr instanceof FusedAssignmentExpression || expr instanceof PreIncrementExpression || expr instanceof PostIncrementExpression) {
				return false;
			} else if (expr instanceof FunctionExpression) {
				return false;
			} else if (expr instanceof ThisExpression) {
				return false;
			} else if (expr instanceof LocalExpression) {
				argIndex = funcDef._args.map((function (i) {
					return i;
				})).indexOf((this$0 = expr, this$0._local));
				if (argIndex === -1) {
					throw new Error("logic flaw; could not find argument: " + (this$3 = (this$2 = (this$1 = expr, this$1._local), this$2._name), this$3._value));
				}
				if (expectedArgIndex !== argIndex) {
					return false;
				}
				++expectedArgIndex;
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onRHSExpr);
		}
		if (! onRHSExpr((this$3 = statementExpr, this$3._expr2))) {
			return null;
		}
		propertyIndex = propertyNames.indexOf((this$5 = (this$4 = lhsExpr, this$4._identifierToken), this$5._value));
		if (propertyIndex === -1) {
			throw new Error("logic flaw; could not find property: " + (this$7 = (this$6 = lhsExpr, this$6._identifierToken), this$7._value));
		}
		if (propertyExprs[propertyIndex]) {
			return null;
		}
		for ((i = propertyIndex + 1, propertyNames$len$0 = propertyNames.length); i < propertyNames$len$0; ++i) {
			if (propertyExprs[i] != null && _Util$0$exprHasSideEffects$LExpression$(propertyExprs[i])) {
				return null;
			}
		}
		propertyExprs[propertyIndex] = (this$8 = statementExpr, this$8._expr2).clone$();
	}
	return (function (newExpr) {
		return propertyExprs.map((function (expr) {
			var onExpr;
			function onExpr(expr, replaceCb) {
				var args;
				var argIndex;
				var i;
				if (expr instanceof LocalExpression) {
					(args = MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef), argIndex = - 1);
					for (i in args) { i |= 0;
						if (args[i] == LocalExpression$getLocal$LLocalExpression$(expr)) {
							argIndex = i;
							break;
						}
					}
					if (argIndex === - 1) {
						throw new Error("logic flaw");
					}
					replaceCb(NewExpression$getArguments$LNewExpression$(newExpr)[argIndex]);
					return true;
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			}
			expr = expr.clone$();
			onExpr(expr, (function (newExpr) {
				expr = newExpr;
			}));
			return expr;
		}));
	});
};

_UnclassifyOptimizationCommand._createInliner$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$ = _UnclassifyOptimizationCommand$_createInliner$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$;

_UnclassifyOptimizationCommand.prototype._rewriteFunctionAsStatic$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var thisArg;
	thisArg = new ArgumentDeclaration(new Token$2("$this", false), new ObjectType(funcDef._classDef));
	funcDef._args.unshift(thisArg);
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var this$0;
		var this$1;
		if (statement instanceof FunctionStatement) {
			this$1 = statement;
			this$0 = this$1._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
		}
		return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
			if (expr instanceof ThisExpression) {
				replaceCb(new LocalExpression(LocalVariable$getName$LLocalVariable$(thisArg), thisArg));
			} else if (expr instanceof FunctionExpression) {
				return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
			}
			return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), funcDef._statements);
	MemberDefinition$setFlags$LMemberDefinition$N(funcDef, funcDef._flags | 8);
};


function _UnclassifyOptimizationCommand$_rewriteFunctionAsStatic$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$($this, funcDef) {
	var thisArg;
	thisArg = new ArgumentDeclaration(new Token$2("$this", false), new ObjectType(funcDef._classDef));
	funcDef._args.unshift(thisArg);
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var this$0;
		var this$1;
		if (statement instanceof FunctionStatement) {
			this$1 = statement;
			this$0 = this$1._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$0._statements);
		}
		return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
			if (expr instanceof ThisExpression) {
				replaceCb(new LocalExpression(LocalVariable$getName$LLocalVariable$(thisArg), thisArg));
			} else if (expr instanceof FunctionExpression) {
				return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
			}
			return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), funcDef._statements);
	MemberDefinition$setFlags$LMemberDefinition$N(funcDef, funcDef._flags | 8);
};

_UnclassifyOptimizationCommand._rewriteFunctionAsStatic$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$ = _UnclassifyOptimizationCommand$_rewriteFunctionAsStatic$L_UnclassifyOptimizationCommand$LMemberFunctionDefinition$;

_UnclassifyOptimizationCommand.prototype._rewriteMethodCallsToStatic$LExpression$F$LExpression$V$ALClassDefinition$ = function (expr, replaceCb, unclassifyingClassDefs) {
	var $this = this;
	var onExpr;
	onExpr = (function (expr, replaceCb) {
		var calleeExpr;
		var propertyExpr;
		var receiverType;
		var receiverClassDef;
		var funcType;
		var this$0;
		var this$1;
		var this$0$0;
		var this$2;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$7;
		var this$8;
		var this$9;
		var this$10;
		if (expr instanceof CallExpression) {
			this$0 = expr;
			calleeExpr = this$0._expr;
			if (calleeExpr instanceof PropertyExpression && ! (this$6 = calleeExpr, this$6._expr).isClassSpecifier$() && ! (this$7 = calleeExpr, this$7._type).isAssignable$() && ! ((this$9 = (this$8 = calleeExpr, this$8._identifierToken), this$9._value) === "toString" && (this$10 = expr, this$10._args).length === 0)) {
				propertyExpr = calleeExpr;
				this$1 = propertyExpr._expr.getType$();
				receiverType = (this$1 instanceof NullableType ? (this$0$0 = this$1, this$0$0._baseType) : this$1);
				receiverClassDef = receiverType.getClassDef$();
				if (unclassifyingClassDefs.indexOf(receiverClassDef) !== -1) {
					onExpr(propertyExpr._expr, (function (expr) {
						UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
					}));
					Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, (this$2 = expr, this$2._args));
					funcType = propertyExpr._type;
					replaceCb(new CallExpression(expr._token, new PropertyExpression$0(propertyExpr._token, new ClassExpression(new Token$2(receiverClassDef.className$(), true), receiverType), propertyExpr._identifierToken, propertyExpr._typeArgs, new StaticFunctionType(null, (this$3 = funcType, this$3._returnType), [ receiverType ].concat((this$4 = funcType, this$4._argTypes)), false)), [ propertyExpr._expr ].concat((this$5 = expr, this$5._args))));
					return true;
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	});
	onExpr(expr, replaceCb);
};


function _UnclassifyOptimizationCommand$_rewriteMethodCallsToStatic$L_UnclassifyOptimizationCommand$LExpression$F$LExpression$V$ALClassDefinition$($this, expr, replaceCb, unclassifyingClassDefs) {
	var onExpr;
	onExpr = (function (expr, replaceCb) {
		var calleeExpr;
		var propertyExpr;
		var receiverType;
		var receiverClassDef;
		var funcType;
		var this$0;
		var this$1;
		var this$0$0;
		var this$2;
		var this$3;
		var this$4;
		var this$5;
		var this$6;
		var this$7;
		var this$8;
		var this$9;
		var this$10;
		if (expr instanceof CallExpression) {
			this$0 = expr;
			calleeExpr = this$0._expr;
			if (calleeExpr instanceof PropertyExpression && ! (this$6 = calleeExpr, this$6._expr).isClassSpecifier$() && ! (this$7 = calleeExpr, this$7._type).isAssignable$() && ! ((this$9 = (this$8 = calleeExpr, this$8._identifierToken), this$9._value) === "toString" && (this$10 = expr, this$10._args).length === 0)) {
				propertyExpr = calleeExpr;
				this$1 = propertyExpr._expr.getType$();
				receiverType = (this$1 instanceof NullableType ? (this$0$0 = this$1, this$0$0._baseType) : this$1);
				receiverClassDef = receiverType.getClassDef$();
				if (unclassifyingClassDefs.indexOf(receiverClassDef) !== -1) {
					onExpr(propertyExpr._expr, (function (expr) {
						UnaryExpression$setExpr$LUnaryExpression$LExpression$(propertyExpr, expr);
					}));
					Util$forEachExpression$F$LExpression$F$LExpression$V$B$ALExpression$(onExpr, (this$2 = expr, this$2._args));
					funcType = propertyExpr._type;
					replaceCb(new CallExpression(expr._token, new PropertyExpression$0(propertyExpr._token, new ClassExpression(new Token$2(receiverClassDef.className$(), true), receiverType), propertyExpr._identifierToken, propertyExpr._typeArgs, new StaticFunctionType(null, (this$3 = funcType, this$3._returnType), [ receiverType ].concat((this$4 = funcType, this$4._argTypes)), false)), [ propertyExpr._expr ].concat((this$5 = expr, this$5._args))));
					return true;
				}
			}
		}
		return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
	});
	onExpr(expr, replaceCb);
};

_UnclassifyOptimizationCommand._rewriteMethodCallsToStatic$L_UnclassifyOptimizationCommand$LExpression$F$LExpression$V$ALClassDefinition$ = _UnclassifyOptimizationCommand$_rewriteMethodCallsToStatic$L_UnclassifyOptimizationCommand$LExpression$F$LExpression$V$ALClassDefinition$;

function _StructuredStashAccessor$x2E$x3CStash$x3E$3() {
};

$__jsx_extend([_StructuredStashAccessor$x2E$x3CStash$x3E$3], Object);
_StructuredStashAccessor$x2E$x3CStash$x3E$3.prototype.$__jsx_implements__StructuredStashAccessor$x2E$x3CStash$x3E$3 = true;

_StructuredStashAccessor$x2E$x3CStash$x3E$3.prototype.getStash$LStashable$ = function (stashable) {
	var identifier;
	var stash;
	identifier = this._identifier;
	stash = stashable.getStash$S(identifier);
	if (stash == null) {
		stash = new _FoldConstantCommand$x2EStash();
		stashable.setStash$SLStash$(identifier, stash);
	}
	return stash;
};


_StructuredStashAccessor$x2E$x3CStash$x3E$3.prototype.resetStash$LStashable$ = function (stashable) {
	var identifier;
	identifier = this._identifier;
	stashable.setStash$SLStash$(identifier, null);
};


function _FoldConstantCommand() {
	this._identifier = "fold-const";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_FoldConstantCommand], _FunctionOptimizeCommand);
$__jsx_merge_interface(_FoldConstantCommand, _StructuredStashAccessor$x2E$x3CStash$x3E$3);

_FoldConstantCommand.prototype.performOptimization$ = function () {
	var $this = this;
	var this$0$0;
	_FunctionOptimizeCommand.prototype.performOptimization$.call(this);
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$0 = this._optimizer, this$0$0._compiler), (function (parser, classDef) {
		if (classDef instanceof TemplateClassDefinition || (classDef.flags$() & 16) !== 0) {
			return true;
		}
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
			if ((MemberDefinition$flags$LMemberDefinition$(varDef) & ClassDefinition.IS_STATIC) !== 0 && MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef) != null) {
				_OptimizeCommand$log$L_OptimizeCommand$S($this, "starting optimization of " + varDef.getNotation$());
				_FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$($this, MemberVariableDefinition$getInitialValue$LMemberVariableDefinition$(varDef), (function (expr) {
					MemberVariableDefinition$setInitialValue$LMemberVariableDefinition$LExpression$(varDef, expr);
				}));
				_OptimizeCommand$log$L_OptimizeCommand$S($this, "finished optimization of " + varDef.getNotation$());
			}
			return true;
		}));
		return true;
	}));
};


_FoldConstantCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
			return _FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$($this, expr, replaceCb);
		}));
		return true;
	}), funcDef._statements);
	return true;
};


_FoldConstantCommand.prototype._optimizeExpression$LExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var $this = this;
	var propertyExpr;
	var holderType;
	var member;
	var foldedExpr;
	var calculateCb;
	var baseExpr;
	var firstExpr;
	var secondExpr;
	var innerExpr;
	var condition;
	var op;
	var conditionalExpr;
	var condExpr;
	var ifTrueExpr;
	var ifFalseExpr;
	var callExpr;
	var allArgsAreConstants;
	var type$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	var this$1;
	var message$1;
	var this$0$1;
	var message$0$1;
	var this$0$2;
	var this$0$0$0;
	var message$2;
	var this$0$3;
	var message$0$2;
	var this$0$4;
	var this$0$0$1;
	var this$2;
	var message$3;
	var this$0$5;
	var message$0$3;
	var this$0$6;
	var this$0$0$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	var this$9;
	var this$11;
	var this$12;
	var this$13;
	var this$14;
	var _token$0;
	expr.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
		return _FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$($this, expr, replaceCb);
	}));
	if (expr instanceof PropertyExpression) {
		propertyExpr = expr;
		type$0 = propertyExpr._expr.getType$();
		if (type$0 instanceof PrimitiveType) {
			type$0 = new ObjectType(type$0.getClassDef$());
		}
		holderType = type$0;
		if (propertyExpr._expr.isClassSpecifier$()) {
			member = null;
			ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(holderType.getClassDef$(), (function (m) {
				var this$0$0;
				var this$0;
				if ((this$0$0 = m._nameToken, this$0$0._value) === (this$0 = propertyExpr._identifierToken, this$0._value)) {
					member = m;
				}
				return member == null;
			}));
			if (member != null && (member._flags & 1) !== 0) {
				_FoldConstantCommand$_foldStaticConst$L_FoldConstantCommand$LMemberVariableDefinition$(this, member);
				foldedExpr = _FoldConstantCommand$_toFoldedExpr$L_FoldConstantCommand$LExpression$LType$(this, member._initialValue, member.getType$());
				if (foldedExpr != null) {
					foldedExpr = _FoldConstantCommand$_toFoldedExpr$L_FoldConstantCommand$LExpression$LType$(this, foldedExpr, propertyExpr._type);
					if (foldedExpr != null && ! (foldedExpr instanceof StringLiteralExpression && foldedExpr.getDecoded$().length > 64)) {
						message$0 = "folding property " + member.getNotation$() + " at " + (this$9 = _token$0 = propertyExpr._token, this$9._filename) + ":" + ((_token$0, _token$0._lineNumber) + "");
						this$0$0 = this._optimizer;
						message$0$0 = "[" + this._identifier + "] " + message$0;
						this$0$0._log += message$0$0 + "\n";
						replaceCb(foldedExpr);
					}
				}
			}
		} else if (propertyExpr._expr instanceof StringLiteralExpression) {
			if ((this$11 = propertyExpr._identifierToken, this$11._value) === "length") {
				replaceCb(new NumberLiteralExpression(new Token$3(propertyExpr._expr.getDecoded$().length + "")));
			}
		}
	} else if (expr instanceof SignExpression) {
		switch ((this$0 = expr._token, this$0._value)) {
		case "+":
			calculateCb = (function (x) {
				return + x;
			});
			break;
		case "-":
			calculateCb = (function (x) {
				return - x;
			});
			break;
		default:
			return false;
		}
		this$1 = expr;
		baseExpr = this$1._expr;
		if (baseExpr instanceof IntegerLiteralExpression) {
			message$1 = "folding operator (number) " + (this$12 = expr._token, "'" + this$12._value + "'" + " at " + (this$12._filename || "<<unknown>>") + ":" + (this$12._lineNumber + "") + ":" + (this$12._columnNumber + ""));
			this$0$1 = this._optimizer;
			message$0$1 = "[" + this._identifier + "] " + message$1;
			this$0$1._log += message$0$1 + "\n";
			replaceCb(new IntegerLiteralExpression(new Token$3(calculateCb((baseExpr instanceof NumberLiteralExpression ? baseExpr.getDecoded$() : (this$0$2 = baseExpr, (this$0$0$0 = this$0$2._token, this$0$0$0._value) | 0))) + "")));
		} else if (baseExpr instanceof NumberLiteralExpression) {
			message$2 = "folding operator (number) " + (this$13 = expr._token, "'" + this$13._value + "'" + " at " + (this$13._filename || "<<unknown>>") + ":" + (this$13._lineNumber + "") + ":" + (this$13._columnNumber + ""));
			this$0$3 = this._optimizer;
			message$0$2 = "[" + this._identifier + "] " + message$2;
			this$0$3._log += message$0$2 + "\n";
			replaceCb(new NumberLiteralExpression(new Token$3(calculateCb((baseExpr instanceof NumberLiteralExpression ? baseExpr.getDecoded$() : (this$0$4 = baseExpr, (this$0$0$1 = this$0$4._token, this$0$0$1._value) | 0))) + "")));
		}
	} else if (expr instanceof BitwiseNotExpression) {
		this$2 = expr;
		baseExpr = this$2._expr;
		if (baseExpr instanceof NumberLiteralExpression || baseExpr instanceof IntegerLiteralExpression) {
			message$3 = "folding operator " + (this$14 = expr._token, "'" + this$14._value + "'" + " at " + (this$14._filename || "<<unknown>>") + ":" + (this$14._lineNumber + "") + ":" + (this$14._columnNumber + ""));
			this$0$5 = this._optimizer;
			message$0$3 = "[" + this._identifier + "] " + message$3;
			this$0$5._log += message$0$3 + "\n";
			replaceCb(new IntegerLiteralExpression(new Token$3(~ (baseExpr instanceof NumberLiteralExpression ? baseExpr.getDecoded$() : (this$0$6 = baseExpr, (this$0$0$2 = this$0$6._token, this$0$0$2._value) | 0)) + "")));
		}
	} else if (expr instanceof AdditiveExpression) {
		this$3 = expr;
		firstExpr = this$3._expr1;
		this$4 = expr;
		secondExpr = this$4._expr2;
		if (_FoldConstantCommand$_foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$(this, expr, replaceCb)) {
		} else if (firstExpr instanceof StringLiteralExpression && secondExpr instanceof StringLiteralExpression) {
			replaceCb(new StringLiteralExpression(new Token$2(Util$encodeStringLiteral$S(firstExpr.getDecoded$() + secondExpr.getDecoded$()), false)));
		}
	} else if (expr instanceof EqualityExpression) {
		_FoldConstantCommand$_foldEqualityExpression$L_FoldConstantCommand$LEqualityExpression$F$LExpression$V$(this, expr, replaceCb);
	} else if (expr instanceof BinaryNumberExpression || expr instanceof ShiftExpression) {
		_FoldConstantCommand$_foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$(this, expr, replaceCb);
	} else if (expr instanceof AsExpression) {
		_FoldConstantCommand$_foldAsExpression$L_FoldConstantCommand$LAsExpression$F$LExpression$V$(this, expr, replaceCb);
	} else if (expr instanceof LogicalNotExpression) {
		this$5 = expr;
		innerExpr = this$5._expr;
		if ((condition = _Util$0$conditionIsConstant$LExpression$(innerExpr)) != null) {
			replaceCb(new BooleanLiteralExpression(new Token$2((condition ? "false" : "true"), false)));
		}
	} else if (expr instanceof LogicalExpression) {
		this$6 = expr;
		firstExpr = this$6._expr1;
		this$7 = expr;
		secondExpr = this$7._expr2;
		if ((condition = _Util$0$conditionIsConstant$LExpression$(firstExpr)) != null) {
			this$8 = expr._token;
			op = this$8._value;
			if (op === "||" && condition) {
				replaceCb(new AsExpression(firstExpr._token, firstExpr, Type.booleanType));
			} else if (op === "||" && ! condition) {
				replaceCb(new AsExpression(secondExpr._token, secondExpr, Type.booleanType));
			} else if (op === "&&" && condition) {
				replaceCb(new AsExpression(secondExpr._token, secondExpr, Type.booleanType));
			} else if (op === "&&" && ! condition) {
				replaceCb(new AsExpression(firstExpr._token, firstExpr, Type.booleanType));
			} else {
				throw new Error("logic flaw");
			}
		}
	} else if (expr instanceof ConditionalExpression) {
		conditionalExpr = expr;
		condExpr = conditionalExpr._condExpr;
		if ((condition = _Util$0$conditionIsConstant$LExpression$(condExpr)) != null) {
			ifTrueExpr = conditionalExpr._ifTrueExpr || condExpr;
			ifFalseExpr = conditionalExpr._ifFalseExpr;
			replaceCb(condition ? ifTrueExpr : ifFalseExpr);
		}
	} else if (expr instanceof CallExpression) {
		callExpr = expr;
		if (callExpr._expr instanceof PropertyExpression) {
			allArgsAreConstants = true;
			callExpr._args.forEach((function (expr) {
				if (! (expr instanceof IntegerLiteralExpression || expr instanceof NumberLiteralExpression || expr instanceof BooleanLiteralExpression || expr instanceof StringLiteralExpression)) {
					allArgsAreConstants = false;
				}
			}));
			if (allArgsAreConstants) {
				_FoldConstantCommand$_foldCallExpression$L_FoldConstantCommand$LCallExpression$F$LExpression$V$(this, callExpr, replaceCb);
			}
		}
	}
	return true;
};


function _FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$($this, expr, replaceCb) {
	var propertyExpr;
	var holderType;
	var member;
	var foldedExpr;
	var calculateCb;
	var baseExpr;
	var firstExpr;
	var secondExpr;
	var innerExpr;
	var condition;
	var op;
	var conditionalExpr;
	var condExpr;
	var ifTrueExpr;
	var ifFalseExpr;
	var callExpr;
	var allArgsAreConstants;
	var type$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	var this$1;
	var message$1;
	var this$0$1;
	var message$0$1;
	var this$0$2;
	var this$0$0$0;
	var message$2;
	var this$0$3;
	var message$0$2;
	var this$0$4;
	var this$0$0$1;
	var this$2;
	var message$3;
	var this$0$5;
	var message$0$3;
	var this$0$6;
	var this$0$0$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	var this$9;
	var this$11;
	var this$12;
	var this$13;
	var this$14;
	var _token$0;
	expr.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
		return _FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$($this, expr, replaceCb);
	}));
	if (expr instanceof PropertyExpression) {
		propertyExpr = expr;
		type$0 = propertyExpr._expr.getType$();
		if (type$0 instanceof PrimitiveType) {
			type$0 = new ObjectType(type$0.getClassDef$());
		}
		holderType = type$0;
		if (propertyExpr._expr.isClassSpecifier$()) {
			member = null;
			ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(holderType.getClassDef$(), (function (m) {
				var this$0$0;
				var this$0;
				if ((this$0$0 = m._nameToken, this$0$0._value) === (this$0 = propertyExpr._identifierToken, this$0._value)) {
					member = m;
				}
				return member == null;
			}));
			if (member != null && (member._flags & 1) !== 0) {
				_FoldConstantCommand$_foldStaticConst$L_FoldConstantCommand$LMemberVariableDefinition$($this, member);
				foldedExpr = _FoldConstantCommand$_toFoldedExpr$L_FoldConstantCommand$LExpression$LType$($this, member._initialValue, member.getType$());
				if (foldedExpr != null) {
					foldedExpr = _FoldConstantCommand$_toFoldedExpr$L_FoldConstantCommand$LExpression$LType$($this, foldedExpr, propertyExpr._type);
					if (foldedExpr != null && ! (foldedExpr instanceof StringLiteralExpression && foldedExpr.getDecoded$().length > 64)) {
						message$0 = "folding property " + member.getNotation$() + " at " + (this$9 = _token$0 = propertyExpr._token, this$9._filename) + ":" + ((_token$0, _token$0._lineNumber) + "");
						this$0$0 = $this._optimizer;
						message$0$0 = "[" + $this._identifier + "] " + message$0;
						this$0$0._log += message$0$0 + "\n";
						replaceCb(foldedExpr);
					}
				}
			}
		} else if (propertyExpr._expr instanceof StringLiteralExpression) {
			if ((this$11 = propertyExpr._identifierToken, this$11._value) === "length") {
				replaceCb(new NumberLiteralExpression(new Token$3(propertyExpr._expr.getDecoded$().length + "")));
			}
		}
	} else if (expr instanceof SignExpression) {
		switch ((this$0 = expr._token, this$0._value)) {
		case "+":
			calculateCb = (function (x) {
				return + x;
			});
			break;
		case "-":
			calculateCb = (function (x) {
				return - x;
			});
			break;
		default:
			return false;
		}
		this$1 = expr;
		baseExpr = this$1._expr;
		if (baseExpr instanceof IntegerLiteralExpression) {
			message$1 = "folding operator (number) " + (this$12 = expr._token, "'" + this$12._value + "'" + " at " + (this$12._filename || "<<unknown>>") + ":" + (this$12._lineNumber + "") + ":" + (this$12._columnNumber + ""));
			this$0$1 = $this._optimizer;
			message$0$1 = "[" + $this._identifier + "] " + message$1;
			this$0$1._log += message$0$1 + "\n";
			replaceCb(new IntegerLiteralExpression(new Token$3(calculateCb((baseExpr instanceof NumberLiteralExpression ? baseExpr.getDecoded$() : (this$0$2 = baseExpr, (this$0$0$0 = this$0$2._token, this$0$0$0._value) | 0))) + "")));
		} else if (baseExpr instanceof NumberLiteralExpression) {
			message$2 = "folding operator (number) " + (this$13 = expr._token, "'" + this$13._value + "'" + " at " + (this$13._filename || "<<unknown>>") + ":" + (this$13._lineNumber + "") + ":" + (this$13._columnNumber + ""));
			this$0$3 = $this._optimizer;
			message$0$2 = "[" + $this._identifier + "] " + message$2;
			this$0$3._log += message$0$2 + "\n";
			replaceCb(new NumberLiteralExpression(new Token$3(calculateCb((baseExpr instanceof NumberLiteralExpression ? baseExpr.getDecoded$() : (this$0$4 = baseExpr, (this$0$0$1 = this$0$4._token, this$0$0$1._value) | 0))) + "")));
		}
	} else if (expr instanceof BitwiseNotExpression) {
		this$2 = expr;
		baseExpr = this$2._expr;
		if (baseExpr instanceof NumberLiteralExpression || baseExpr instanceof IntegerLiteralExpression) {
			message$3 = "folding operator " + (this$14 = expr._token, "'" + this$14._value + "'" + " at " + (this$14._filename || "<<unknown>>") + ":" + (this$14._lineNumber + "") + ":" + (this$14._columnNumber + ""));
			this$0$5 = $this._optimizer;
			message$0$3 = "[" + $this._identifier + "] " + message$3;
			this$0$5._log += message$0$3 + "\n";
			replaceCb(new IntegerLiteralExpression(new Token$3(~ (baseExpr instanceof NumberLiteralExpression ? baseExpr.getDecoded$() : (this$0$6 = baseExpr, (this$0$0$2 = this$0$6._token, this$0$0$2._value) | 0)) + "")));
		}
	} else if (expr instanceof AdditiveExpression) {
		this$3 = expr;
		firstExpr = this$3._expr1;
		this$4 = expr;
		secondExpr = this$4._expr2;
		if (_FoldConstantCommand$_foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$($this, expr, replaceCb)) {
		} else if (firstExpr instanceof StringLiteralExpression && secondExpr instanceof StringLiteralExpression) {
			replaceCb(new StringLiteralExpression(new Token$2(Util$encodeStringLiteral$S(firstExpr.getDecoded$() + secondExpr.getDecoded$()), false)));
		}
	} else if (expr instanceof EqualityExpression) {
		_FoldConstantCommand$_foldEqualityExpression$L_FoldConstantCommand$LEqualityExpression$F$LExpression$V$($this, expr, replaceCb);
	} else if (expr instanceof BinaryNumberExpression || expr instanceof ShiftExpression) {
		_FoldConstantCommand$_foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$($this, expr, replaceCb);
	} else if (expr instanceof AsExpression) {
		_FoldConstantCommand$_foldAsExpression$L_FoldConstantCommand$LAsExpression$F$LExpression$V$($this, expr, replaceCb);
	} else if (expr instanceof LogicalNotExpression) {
		this$5 = expr;
		innerExpr = this$5._expr;
		if ((condition = _Util$0$conditionIsConstant$LExpression$(innerExpr)) != null) {
			replaceCb(new BooleanLiteralExpression(new Token$2((condition ? "false" : "true"), false)));
		}
	} else if (expr instanceof LogicalExpression) {
		this$6 = expr;
		firstExpr = this$6._expr1;
		this$7 = expr;
		secondExpr = this$7._expr2;
		if ((condition = _Util$0$conditionIsConstant$LExpression$(firstExpr)) != null) {
			this$8 = expr._token;
			op = this$8._value;
			if (op === "||" && condition) {
				replaceCb(new AsExpression(firstExpr._token, firstExpr, Type.booleanType));
			} else if (op === "||" && ! condition) {
				replaceCb(new AsExpression(secondExpr._token, secondExpr, Type.booleanType));
			} else if (op === "&&" && condition) {
				replaceCb(new AsExpression(secondExpr._token, secondExpr, Type.booleanType));
			} else if (op === "&&" && ! condition) {
				replaceCb(new AsExpression(firstExpr._token, firstExpr, Type.booleanType));
			} else {
				throw new Error("logic flaw");
			}
		}
	} else if (expr instanceof ConditionalExpression) {
		conditionalExpr = expr;
		condExpr = conditionalExpr._condExpr;
		if ((condition = _Util$0$conditionIsConstant$LExpression$(condExpr)) != null) {
			ifTrueExpr = conditionalExpr._ifTrueExpr || condExpr;
			ifFalseExpr = conditionalExpr._ifFalseExpr;
			replaceCb(condition ? ifTrueExpr : ifFalseExpr);
		}
	} else if (expr instanceof CallExpression) {
		callExpr = expr;
		if (callExpr._expr instanceof PropertyExpression) {
			allArgsAreConstants = true;
			callExpr._args.forEach((function (expr) {
				if (! (expr instanceof IntegerLiteralExpression || expr instanceof NumberLiteralExpression || expr instanceof BooleanLiteralExpression || expr instanceof StringLiteralExpression)) {
					allArgsAreConstants = false;
				}
			}));
			if (allArgsAreConstants) {
				_FoldConstantCommand$_foldCallExpression$L_FoldConstantCommand$LCallExpression$F$LExpression$V$($this, callExpr, replaceCb);
			}
		}
	}
	return true;
};

_FoldConstantCommand._optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$ = _FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$;

_FoldConstantCommand.prototype._foldCallExpression$LCallExpression$F$LExpression$V$ = function (callExpr, replaceCb) {
	var $this = this;
	var propertyExpr;
	var holderType;
	var argExprs;
	var member;
	var s;
	var recvStr;
	var type$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	var expr$0;
	var this$0$1;
	var this$0$0$0;
	var message$1;
	var this$0$2;
	var message$0$1;
	var expr$1;
	var this$0$3;
	var this$0$0$1;
	var message$2;
	var this$0$4;
	var message$0$2;
	var expr$2;
	var this$0$5;
	var this$0$0$2;
	var expr$3;
	var this$0$6;
	var this$0$0$3;
	var message$3;
	var this$0$7;
	var message$0$3;
	var expr$4;
	var this$0$8;
	var this$0$0$4;
	var message$4;
	var this$0$9;
	var message$0$4;
	var expr$5;
	var this$0$10;
	var this$0$0$5;
	var message$5;
	var this$0$11;
	var message$0$5;
	var message$6;
	var this$0$12;
	var message$0$6;
	var expr$6;
	var this$0$13;
	var this$0$0$6;
	var this$0;
	var this$1;
	var this$2;
	propertyExpr = callExpr._expr;
	type$0 = propertyExpr._expr.getType$();
	if (type$0 instanceof PrimitiveType) {
		type$0 = new ObjectType(type$0.getClassDef$());
	}
	holderType = type$0;
	if ((type$0.getClassDef$().flags$() & 16) === 0) {
		return;
	}
	argExprs = callExpr._args;
	member = null;
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(holderType.getClassDef$(), (function (m) {
		var this$0$0;
		var this$0;
		if ((this$0$0 = m._nameToken, this$0$0._value) === (this$0 = propertyExpr._identifierToken, this$0._value)) {
			member = m;
		}
		return member == null;
	}));
	if (member != null && (member._flags & 2048) === 0) {
		return;
	}
	if (propertyExpr._expr.isClassSpecifier$()) {
		if (ClassDefinition$classFullName$LClassDefinition$(holderType.getClassDef$()) === "Math") {
			switch ((this$0 = propertyExpr._identifierToken, this$0._value)) {
			case "sqrt":
				message$0 = "folding " + member.getNotation$();
				this$0$0 = this._optimizer;
				message$0$0 = "[" + this._identifier + "] " + message$0;
				this$0$0._log += message$0$0 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$3(Math.sqrt((expr$0 = argExprs[0], expr$0 instanceof NumberLiteralExpression ? expr$0.getDecoded$() : (this$0$1 = expr$0, (this$0$0$0 = this$0$1._token, this$0$0$0._value) | 0))) + "")));
				break;
			case "log":
				message$1 = "folding " + member.getNotation$();
				this$0$2 = this._optimizer;
				message$0$1 = "[" + this._identifier + "] " + message$1;
				this$0$2._log += message$0$1 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$3(Math.log((expr$1 = argExprs[0], expr$1 instanceof NumberLiteralExpression ? expr$1.getDecoded$() : (this$0$3 = expr$1, (this$0$0$1 = this$0$3._token, this$0$0$1._value) | 0))) + "")));
				break;
			case "pow":
				message$2 = "folding " + member.getNotation$();
				this$0$4 = this._optimizer;
				message$0$2 = "[" + this._identifier + "] " + message$2;
				this$0$4._log += message$0$2 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$3(Math.pow((expr$2 = argExprs[0], expr$2 instanceof NumberLiteralExpression ? expr$2.getDecoded$() : (this$0$5 = expr$2, (this$0$0$2 = this$0$5._token, this$0$0$2._value) | 0)), (expr$3 = argExprs[1], expr$3 instanceof NumberLiteralExpression ? expr$3.getDecoded$() : (this$0$6 = expr$3, (this$0$0$3 = this$0$6._token, this$0$0$3._value) | 0))) + "")));
				break;
			case "sin":
				message$3 = "folding " + member.getNotation$();
				this$0$7 = this._optimizer;
				message$0$3 = "[" + this._identifier + "] " + message$3;
				this$0$7._log += message$0$3 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$3(Math.sin((expr$4 = argExprs[0], expr$4 instanceof NumberLiteralExpression ? expr$4.getDecoded$() : (this$0$8 = expr$4, (this$0$0$4 = this$0$8._token, this$0$0$4._value) | 0))) + "")));
				break;
			case "cos":
				message$4 = "folding " + member.getNotation$();
				this$0$9 = this._optimizer;
				message$0$4 = "[" + this._identifier + "] " + message$4;
				this$0$9._log += message$0$4 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$3(Math.cos((expr$5 = argExprs[0], expr$5 instanceof NumberLiteralExpression ? expr$5.getDecoded$() : (this$0$10 = expr$5, (this$0$0$5 = this$0$10._token, this$0$0$5._value) | 0))) + "")));
				break;
			}
		}
		if (ClassDefinition$classFullName$LClassDefinition$(holderType.getClassDef$()) === "String") {
			switch ((this$1 = propertyExpr._identifierToken, this$1._value)) {
			case "fromCharCode":
				message$5 = "folding " + member.getNotation$();
				this$0$11 = this._optimizer;
				message$0$5 = "[" + this._identifier + "] " + message$5;
				this$0$11._log += message$0$5 + "\n";
				s = "";
				argExprs.forEach((function (arg) {
					var this$0$0;
					var this$0$0$0;
					s += String.fromCharCode((arg instanceof NumberLiteralExpression ? arg.getDecoded$() : (this$0$0 = arg, (this$0$0$0 = this$0$0._token, this$0$0$0._value) | 0)));
				}));
				replaceCb(new StringLiteralExpression(new Token$3(Util$encodeStringLiteral$S(s))));
				break;
			}
		}
	} else if (propertyExpr._expr instanceof StringLiteralExpression) {
		switch ((this$2 = propertyExpr._identifierToken, this$2._value)) {
		case "charCodeAt":
			message$6 = "folding " + member.getNotation$();
			this$0$12 = this._optimizer;
			message$0$6 = "[" + this._identifier + "] " + message$6;
			this$0$12._log += message$0$6 + "\n";
			recvStr = propertyExpr._expr.getDecoded$();
			replaceCb(new NumberLiteralExpression(new Token$3(recvStr.charCodeAt((expr$6 = argExprs[0], expr$6 instanceof NumberLiteralExpression ? expr$6.getDecoded$() : (this$0$13 = expr$6, (this$0$0$6 = this$0$13._token, this$0$0$6._value) | 0))) + "")));
			break;
		}
	}
};


function _FoldConstantCommand$_foldCallExpression$L_FoldConstantCommand$LCallExpression$F$LExpression$V$($this, callExpr, replaceCb) {
	var propertyExpr;
	var holderType;
	var argExprs;
	var member;
	var s;
	var recvStr;
	var type$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	var expr$0;
	var this$0$1;
	var this$0$0$0;
	var message$1;
	var this$0$2;
	var message$0$1;
	var expr$1;
	var this$0$3;
	var this$0$0$1;
	var message$2;
	var this$0$4;
	var message$0$2;
	var expr$2;
	var this$0$5;
	var this$0$0$2;
	var expr$3;
	var this$0$6;
	var this$0$0$3;
	var message$3;
	var this$0$7;
	var message$0$3;
	var expr$4;
	var this$0$8;
	var this$0$0$4;
	var message$4;
	var this$0$9;
	var message$0$4;
	var expr$5;
	var this$0$10;
	var this$0$0$5;
	var message$5;
	var this$0$11;
	var message$0$5;
	var message$6;
	var this$0$12;
	var message$0$6;
	var expr$6;
	var this$0$13;
	var this$0$0$6;
	var this$0;
	var this$1;
	var this$2;
	propertyExpr = callExpr._expr;
	type$0 = propertyExpr._expr.getType$();
	if (type$0 instanceof PrimitiveType) {
		type$0 = new ObjectType(type$0.getClassDef$());
	}
	holderType = type$0;
	if ((type$0.getClassDef$().flags$() & 16) === 0) {
		return;
	}
	argExprs = callExpr._args;
	member = null;
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(holderType.getClassDef$(), (function (m) {
		var this$0$0;
		var this$0;
		if ((this$0$0 = m._nameToken, this$0$0._value) === (this$0 = propertyExpr._identifierToken, this$0._value)) {
			member = m;
		}
		return member == null;
	}));
	if (member != null && (member._flags & 2048) === 0) {
		return;
	}
	if (propertyExpr._expr.isClassSpecifier$()) {
		if (ClassDefinition$classFullName$LClassDefinition$(holderType.getClassDef$()) === "Math") {
			switch ((this$0 = propertyExpr._identifierToken, this$0._value)) {
			case "sqrt":
				message$0 = "folding " + member.getNotation$();
				this$0$0 = $this._optimizer;
				message$0$0 = "[" + $this._identifier + "] " + message$0;
				this$0$0._log += message$0$0 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$3(Math.sqrt((expr$0 = argExprs[0], expr$0 instanceof NumberLiteralExpression ? expr$0.getDecoded$() : (this$0$1 = expr$0, (this$0$0$0 = this$0$1._token, this$0$0$0._value) | 0))) + "")));
				break;
			case "log":
				message$1 = "folding " + member.getNotation$();
				this$0$2 = $this._optimizer;
				message$0$1 = "[" + $this._identifier + "] " + message$1;
				this$0$2._log += message$0$1 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$3(Math.log((expr$1 = argExprs[0], expr$1 instanceof NumberLiteralExpression ? expr$1.getDecoded$() : (this$0$3 = expr$1, (this$0$0$1 = this$0$3._token, this$0$0$1._value) | 0))) + "")));
				break;
			case "pow":
				message$2 = "folding " + member.getNotation$();
				this$0$4 = $this._optimizer;
				message$0$2 = "[" + $this._identifier + "] " + message$2;
				this$0$4._log += message$0$2 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$3(Math.pow((expr$2 = argExprs[0], expr$2 instanceof NumberLiteralExpression ? expr$2.getDecoded$() : (this$0$5 = expr$2, (this$0$0$2 = this$0$5._token, this$0$0$2._value) | 0)), (expr$3 = argExprs[1], expr$3 instanceof NumberLiteralExpression ? expr$3.getDecoded$() : (this$0$6 = expr$3, (this$0$0$3 = this$0$6._token, this$0$0$3._value) | 0))) + "")));
				break;
			case "sin":
				message$3 = "folding " + member.getNotation$();
				this$0$7 = $this._optimizer;
				message$0$3 = "[" + $this._identifier + "] " + message$3;
				this$0$7._log += message$0$3 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$3(Math.sin((expr$4 = argExprs[0], expr$4 instanceof NumberLiteralExpression ? expr$4.getDecoded$() : (this$0$8 = expr$4, (this$0$0$4 = this$0$8._token, this$0$0$4._value) | 0))) + "")));
				break;
			case "cos":
				message$4 = "folding " + member.getNotation$();
				this$0$9 = $this._optimizer;
				message$0$4 = "[" + $this._identifier + "] " + message$4;
				this$0$9._log += message$0$4 + "\n";
				replaceCb(new NumberLiteralExpression(new Token$3(Math.cos((expr$5 = argExprs[0], expr$5 instanceof NumberLiteralExpression ? expr$5.getDecoded$() : (this$0$10 = expr$5, (this$0$0$5 = this$0$10._token, this$0$0$5._value) | 0))) + "")));
				break;
			}
		}
		if (ClassDefinition$classFullName$LClassDefinition$(holderType.getClassDef$()) === "String") {
			switch ((this$1 = propertyExpr._identifierToken, this$1._value)) {
			case "fromCharCode":
				message$5 = "folding " + member.getNotation$();
				this$0$11 = $this._optimizer;
				message$0$5 = "[" + $this._identifier + "] " + message$5;
				this$0$11._log += message$0$5 + "\n";
				s = "";
				argExprs.forEach((function (arg) {
					var this$0$0;
					var this$0$0$0;
					s += String.fromCharCode((arg instanceof NumberLiteralExpression ? arg.getDecoded$() : (this$0$0 = arg, (this$0$0$0 = this$0$0._token, this$0$0$0._value) | 0)));
				}));
				replaceCb(new StringLiteralExpression(new Token$3(Util$encodeStringLiteral$S(s))));
				break;
			}
		}
	} else if (propertyExpr._expr instanceof StringLiteralExpression) {
		switch ((this$2 = propertyExpr._identifierToken, this$2._value)) {
		case "charCodeAt":
			message$6 = "folding " + member.getNotation$();
			this$0$12 = $this._optimizer;
			message$0$6 = "[" + $this._identifier + "] " + message$6;
			this$0$12._log += message$0$6 + "\n";
			recvStr = propertyExpr._expr.getDecoded$();
			replaceCb(new NumberLiteralExpression(new Token$3(recvStr.charCodeAt((expr$6 = argExprs[0], expr$6 instanceof NumberLiteralExpression ? expr$6.getDecoded$() : (this$0$13 = expr$6, (this$0$0$6 = this$0$13._token, this$0$0$6._value) | 0))) + "")));
			break;
		}
	}
};

_FoldConstantCommand._foldCallExpression$L_FoldConstantCommand$LCallExpression$F$LExpression$V$ = _FoldConstantCommand$_foldCallExpression$L_FoldConstantCommand$LCallExpression$F$LExpression$V$;

_FoldConstantCommand.prototype._foldEqualityExpression$LEqualityExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var $this = this;
	var firstExpr;
	var secondExpr;
	var isEqual;
	var isNullVsPrimitiveLiteral;
	var result;
	var this$0$0;
	var this$0$0$0;
	var this$0$1;
	var this$0$0$1;
	var this$0;
	firstExpr = expr._expr1;
	secondExpr = expr._expr2;
	isEqual = null;
	function isNullVsPrimitiveLiteral(x, y) {
		return x instanceof NullExpression && y instanceof PrimitiveLiteralExpression;
	}
	if (firstExpr instanceof NullExpression && secondExpr instanceof NullExpression) {
		isEqual = true;
	} else if (isNullVsPrimitiveLiteral(firstExpr, secondExpr) || isNullVsPrimitiveLiteral(secondExpr, firstExpr)) {
		isEqual = false;
	} else if (firstExpr instanceof StringLiteralExpression && secondExpr instanceof StringLiteralExpression) {
		isEqual = firstExpr.getDecoded$() === secondExpr.getDecoded$();
	} else if ((firstExpr instanceof NumberLiteralExpression || firstExpr instanceof IntegerLiteralExpression) && (secondExpr instanceof NumberLiteralExpression || secondExpr instanceof IntegerLiteralExpression)) {
		isEqual = (firstExpr instanceof NumberLiteralExpression ? firstExpr.getDecoded$() : (this$0$0 = firstExpr, (this$0$0$0 = this$0$0._token, this$0$0$0._value) | 0)) === (secondExpr instanceof NumberLiteralExpression ? secondExpr.getDecoded$() : (this$0$1 = secondExpr, (this$0$0$1 = this$0$1._token, this$0$0$1._value) | 0));
	}
	if (isEqual != null) {
		result = ((this$0 = expr._token, this$0._value) === "==" ? isEqual : ! isEqual);
		replaceCb(new BooleanLiteralExpression(new Token$2((result ? "true" : "false"), true)));
	}
};


function _FoldConstantCommand$_foldEqualityExpression$L_FoldConstantCommand$LEqualityExpression$F$LExpression$V$($this, expr, replaceCb) {
	var firstExpr;
	var secondExpr;
	var isEqual;
	var isNullVsPrimitiveLiteral;
	var result;
	var this$0$0;
	var this$0$0$0;
	var this$0$1;
	var this$0$0$1;
	var this$0;
	firstExpr = expr._expr1;
	secondExpr = expr._expr2;
	isEqual = null;
	function isNullVsPrimitiveLiteral(x, y) {
		return x instanceof NullExpression && y instanceof PrimitiveLiteralExpression;
	}
	if (firstExpr instanceof NullExpression && secondExpr instanceof NullExpression) {
		isEqual = true;
	} else if (isNullVsPrimitiveLiteral(firstExpr, secondExpr) || isNullVsPrimitiveLiteral(secondExpr, firstExpr)) {
		isEqual = false;
	} else if (firstExpr instanceof StringLiteralExpression && secondExpr instanceof StringLiteralExpression) {
		isEqual = firstExpr.getDecoded$() === secondExpr.getDecoded$();
	} else if ((firstExpr instanceof NumberLiteralExpression || firstExpr instanceof IntegerLiteralExpression) && (secondExpr instanceof NumberLiteralExpression || secondExpr instanceof IntegerLiteralExpression)) {
		isEqual = (firstExpr instanceof NumberLiteralExpression ? firstExpr.getDecoded$() : (this$0$0 = firstExpr, (this$0$0$0 = this$0$0._token, this$0$0$0._value) | 0)) === (secondExpr instanceof NumberLiteralExpression ? secondExpr.getDecoded$() : (this$0$1 = secondExpr, (this$0$0$1 = this$0$1._token, this$0$0$1._value) | 0));
	}
	if (isEqual != null) {
		result = ((this$0 = expr._token, this$0._value) === "==" ? isEqual : ! isEqual);
		replaceCb(new BooleanLiteralExpression(new Token$2((result ? "true" : "false"), true)));
	}
};

_FoldConstantCommand._foldEqualityExpression$L_FoldConstantCommand$LEqualityExpression$F$LExpression$V$ = _FoldConstantCommand$_foldEqualityExpression$L_FoldConstantCommand$LEqualityExpression$F$LExpression$V$;

_FoldConstantCommand.prototype._foldNumericBinaryExpression$LBinaryExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var $this = this;
	var exprIsZero;
	var exprIsOne;
	var expr$0;
	var expr$1;
	var this$0;
	if ((expr$0 = expr._expr1, expr$0 instanceof NumberLiteralExpression || expr$0 instanceof IntegerLiteralExpression) && (expr$1 = expr._expr2, expr$1 instanceof NumberLiteralExpression || expr$1 instanceof IntegerLiteralExpression)) {
		return _FoldConstantCommand$_foldNumericBinaryExpressionOfConstants$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$(this, expr, replaceCb);
	}
	function exprIsZero(expr) {
		return expr instanceof NumberLiteralExpression && expr.getDecoded$() === 0;
	}
	function exprIsOne(expr) {
		return expr instanceof NumberLiteralExpression && expr.getDecoded$() === 1;
	}
	switch ((this$0 = expr._token, this$0._value)) {
	case "+":
		if (exprIsZero(expr._expr1)) {
			replaceCb(expr._expr2);
			return true;
		} else if (exprIsZero(expr._expr2)) {
			replaceCb(expr._expr1);
			return true;
		}
		break;
	case "-":
		if (exprIsZero(expr._expr1)) {
			replaceCb(new SignExpression(new Token$2("-", false), expr._expr2));
			return true;
		} else if (exprIsZero(expr._expr2)) {
			replaceCb(expr._expr1);
			return true;
		}
		break;
	case "*":
		if (exprIsOne(expr._expr1)) {
			replaceCb(expr._expr2);
			return true;
		} else if (exprIsOne(expr._expr2)) {
			replaceCb(expr._expr1);
			return true;
		}
		break;
	case "/":
		if (exprIsOne(expr._expr2)) {
			replaceCb(expr._expr1);
			return true;
		}
		break;
	}
	return false;
};


function _FoldConstantCommand$_foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$($this, expr, replaceCb) {
	var exprIsZero;
	var exprIsOne;
	var expr$0;
	var expr$1;
	var this$0;
	if ((expr$0 = expr._expr1, expr$0 instanceof NumberLiteralExpression || expr$0 instanceof IntegerLiteralExpression) && (expr$1 = expr._expr2, expr$1 instanceof NumberLiteralExpression || expr$1 instanceof IntegerLiteralExpression)) {
		return _FoldConstantCommand$_foldNumericBinaryExpressionOfConstants$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$($this, expr, replaceCb);
	}
	function exprIsZero(expr) {
		return expr instanceof NumberLiteralExpression && expr.getDecoded$() === 0;
	}
	function exprIsOne(expr) {
		return expr instanceof NumberLiteralExpression && expr.getDecoded$() === 1;
	}
	switch ((this$0 = expr._token, this$0._value)) {
	case "+":
		if (exprIsZero(expr._expr1)) {
			replaceCb(expr._expr2);
			return true;
		} else if (exprIsZero(expr._expr2)) {
			replaceCb(expr._expr1);
			return true;
		}
		break;
	case "-":
		if (exprIsZero(expr._expr1)) {
			replaceCb(new SignExpression(new Token$2("-", false), expr._expr2));
			return true;
		} else if (exprIsZero(expr._expr2)) {
			replaceCb(expr._expr1);
			return true;
		}
		break;
	case "*":
		if (exprIsOne(expr._expr1)) {
			replaceCb(expr._expr2);
			return true;
		} else if (exprIsOne(expr._expr2)) {
			replaceCb(expr._expr1);
			return true;
		}
		break;
	case "/":
		if (exprIsOne(expr._expr2)) {
			replaceCb(expr._expr1);
			return true;
		}
		break;
	}
	return false;
};

_FoldConstantCommand._foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$ = _FoldConstantCommand$_foldNumericBinaryExpression$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$;

_FoldConstantCommand.prototype._foldNumericBinaryExpressionOfConstants$LBinaryExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var $this = this;
	var this$0;
	switch ((this$0 = expr._token, this$0._value)) {
	case "+":
		if (expr._expr1 instanceof IntegerLiteralExpression && expr._expr2 instanceof IntegerLiteralExpression) {
			_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$(this, expr, replaceCb, (function (x, y) {
				return ((x + y) | 0);
			}));
		} else {
			_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
				return x + y;
			}));
		}
		break;
	case "-":
		if (expr._expr1 instanceof IntegerLiteralExpression && expr._expr2 instanceof IntegerLiteralExpression) {
			_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$(this, expr, replaceCb, (function (x, y) {
				return ((x - y) | 0);
			}));
		} else {
			_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
				return x - y;
			}));
		}
		break;
	case "*":
		if (expr._expr1 instanceof IntegerLiteralExpression && expr._expr2 instanceof IntegerLiteralExpression) {
			_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$(this, expr, replaceCb, (function (x, y) {
				return $__jsx_imul(x, y);
			}));
		} else {
			_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
				return x * y;
			}));
		}
		break;
	case "/":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
			return x / y;
		}));
		break;
	case "%":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, (function (x, y) {
			return x % y;
		}));
		break;
	case ">>>":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$(this, expr, replaceCb, (function (x, y) {
			return x >>> y;
		}));
		break;
	case ">>":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$(this, expr, replaceCb, (function (x, y) {
			return x >> y;
		}));
		break;
	case "<<":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$(this, expr, replaceCb, (function (x, y) {
			return x << y;
		}));
		break;
	case "&":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$(this, expr, replaceCb, (function (x, y) {
			return x & y;
		}));
		break;
	case "|":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$(this, expr, replaceCb, (function (x, y) {
			return x | y;
		}));
		break;
	case "^":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$(this, expr, replaceCb, (function (x, y) {
			return x ^ y;
		}));
		break;
	case "<":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$(this, expr, replaceCb, (function (x, y) {
			return x < y;
		}));
		break;
	case "<=":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$(this, expr, replaceCb, (function (x, y) {
			return x <= y;
		}));
		break;
	case ">":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$(this, expr, replaceCb, (function (x, y) {
			return x > y;
		}));
		break;
	case ">=":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$(this, expr, replaceCb, (function (x, y) {
			return x >= y;
		}));
		break;
	default:
		return false;
	}
	return true;
};


function _FoldConstantCommand$_foldNumericBinaryExpressionOfConstants$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$($this, expr, replaceCb) {
	var this$0;
	switch ((this$0 = expr._token, this$0._value)) {
	case "+":
		if (expr._expr1 instanceof IntegerLiteralExpression && expr._expr2 instanceof IntegerLiteralExpression) {
			_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$($this, expr, replaceCb, (function (x, y) {
				return ((x + y) | 0);
			}));
		} else {
			_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
				return x + y;
			}));
		}
		break;
	case "-":
		if (expr._expr1 instanceof IntegerLiteralExpression && expr._expr2 instanceof IntegerLiteralExpression) {
			_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$($this, expr, replaceCb, (function (x, y) {
				return ((x - y) | 0);
			}));
		} else {
			_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
				return x - y;
			}));
		}
		break;
	case "*":
		if (expr._expr1 instanceof IntegerLiteralExpression && expr._expr2 instanceof IntegerLiteralExpression) {
			_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$($this, expr, replaceCb, (function (x, y) {
				return $__jsx_imul(x, y);
			}));
		} else {
			_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
				return x * y;
			}));
		}
		break;
	case "/":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
			return x / y;
		}));
		break;
	case "%":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, (function (x, y) {
			return x % y;
		}));
		break;
	case ">>>":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$($this, expr, replaceCb, (function (x, y) {
			return x >>> y;
		}));
		break;
	case ">>":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$($this, expr, replaceCb, (function (x, y) {
			return x >> y;
		}));
		break;
	case "<<":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$($this, expr, replaceCb, (function (x, y) {
			return x << y;
		}));
		break;
	case "&":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$($this, expr, replaceCb, (function (x, y) {
			return x & y;
		}));
		break;
	case "|":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$($this, expr, replaceCb, (function (x, y) {
			return x | y;
		}));
		break;
	case "^":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$($this, expr, replaceCb, (function (x, y) {
			return x ^ y;
		}));
		break;
	case "<":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$($this, expr, replaceCb, (function (x, y) {
			return x < y;
		}));
		break;
	case "<=":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$($this, expr, replaceCb, (function (x, y) {
			return x <= y;
		}));
		break;
	case ">":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$($this, expr, replaceCb, (function (x, y) {
			return x > y;
		}));
		break;
	case ">=":
		_FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$($this, expr, replaceCb, (function (x, y) {
			return x >= y;
		}));
		break;
	default:
		return false;
	}
	return true;
};

_FoldConstantCommand._foldNumericBinaryExpressionOfConstants$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$ = _FoldConstantCommand$_foldNumericBinaryExpressionOfConstants$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$;

_FoldConstantCommand.prototype._foldNumericBinaryExpressionAsNumeric$LBinaryExpression$F$LExpression$V$F$III$F$NNN$ = function (expr, replaceCb, calcCbInt, calcCbNumber) {
	if (expr._expr1 instanceof IntegerLiteralExpression && expr._expr2 instanceof IntegerLiteralExpression) {
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$(this, expr, replaceCb, calcCbInt);
	} else {
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$(this, expr, replaceCb, calcCbNumber);
	}
};


function _FoldConstantCommand$_foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$F$NNN$($this, expr, replaceCb, calcCbInt, calcCbNumber) {
	if (expr._expr1 instanceof IntegerLiteralExpression && expr._expr2 instanceof IntegerLiteralExpression) {
		_FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$($this, expr, replaceCb, calcCbInt);
	} else {
		_FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, calcCbNumber);
	}
};

_FoldConstantCommand._foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$F$NNN$ = _FoldConstantCommand$_foldNumericBinaryExpressionAsNumeric$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$F$NNN$;

_FoldConstantCommand.prototype._foldNumericBinaryExpressionAsInteger$LBinaryExpression$F$LExpression$V$F$III$ = function (expr, replaceCb, calcCb) {
	var value;
	var expr$0;
	var this$0$0;
	var this$0$0$0;
	var expr$1;
	var this$0$1;
	var this$0$0$1;
	var message$0;
	var this$0$2;
	var message$0$0;
	var this$0;
	value = calcCb((expr$0 = expr._expr1, expr$0 instanceof NumberLiteralExpression ? expr$0.getDecoded$() : (this$0$0 = expr$0, (this$0$0$0 = this$0$0._token, this$0$0$0._value) | 0)), (expr$1 = expr._expr2, expr$1 instanceof NumberLiteralExpression ? expr$1.getDecoded$() : (this$0$1 = expr$1, (this$0$0$1 = this$0$1._token, this$0$0$1._value) | 0)));
	message$0 = "folding operator " + (this$0 = expr._token, "'" + this$0._value + "'" + " at " + (this$0._filename || "<<unknown>>") + ":" + (this$0._lineNumber + "") + ":" + (this$0._columnNumber + "")) + " to int: " + (value + "");
	this$0$2 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this$0$2._log += message$0$0 + "\n";
	if (value !== (value | 0)) {
		throw new Error("value is not an integer");
	}
	replaceCb(new IntegerLiteralExpression(new Token$3(value + "")));
};


function _FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$($this, expr, replaceCb, calcCb) {
	var value;
	var expr$0;
	var this$0$0;
	var this$0$0$0;
	var expr$1;
	var this$0$1;
	var this$0$0$1;
	var message$0;
	var this$0$2;
	var message$0$0;
	var this$0;
	value = calcCb((expr$0 = expr._expr1, expr$0 instanceof NumberLiteralExpression ? expr$0.getDecoded$() : (this$0$0 = expr$0, (this$0$0$0 = this$0$0._token, this$0$0$0._value) | 0)), (expr$1 = expr._expr2, expr$1 instanceof NumberLiteralExpression ? expr$1.getDecoded$() : (this$0$1 = expr$1, (this$0$0$1 = this$0$1._token, this$0$0$1._value) | 0)));
	message$0 = "folding operator " + (this$0 = expr._token, "'" + this$0._value + "'" + " at " + (this$0._filename || "<<unknown>>") + ":" + (this$0._lineNumber + "") + ":" + (this$0._columnNumber + "")) + " to int: " + (value + "");
	this$0$2 = $this._optimizer;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	this$0$2._log += message$0$0 + "\n";
	if (value !== (value | 0)) {
		throw new Error("value is not an integer");
	}
	replaceCb(new IntegerLiteralExpression(new Token$3(value + "")));
};

_FoldConstantCommand._foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$ = _FoldConstantCommand$_foldNumericBinaryExpressionAsInteger$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$III$;

_FoldConstantCommand.prototype._foldNumericBinaryExpressionAsNumber$LBinaryExpression$F$LExpression$V$F$NNN$ = function (expr, replaceCb, calcCb) {
	var value;
	var expr$0;
	var this$0$0;
	var this$0$0$0;
	var expr$1;
	var this$0$1;
	var this$0$0$1;
	var message$0;
	var this$0$2;
	var message$0$0;
	var this$0;
	value = calcCb((expr$0 = expr._expr1, expr$0 instanceof NumberLiteralExpression ? expr$0.getDecoded$() : (this$0$0 = expr$0, (this$0$0$0 = this$0$0._token, this$0$0$0._value) | 0)), (expr$1 = expr._expr2, expr$1 instanceof NumberLiteralExpression ? expr$1.getDecoded$() : (this$0$1 = expr$1, (this$0$0$1 = this$0$1._token, this$0$0$1._value) | 0)));
	message$0 = "folding operator " + (this$0 = expr._token, "'" + this$0._value + "'" + " at " + (this$0._filename || "<<unknown>>") + ":" + (this$0._lineNumber + "") + ":" + (this$0._columnNumber + "")) + " to number: " + (value + "");
	this$0$2 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this$0$2._log += message$0$0 + "\n";
	replaceCb(new NumberLiteralExpression(new Token$3(value + "")));
};


function _FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$($this, expr, replaceCb, calcCb) {
	var value;
	var expr$0;
	var this$0$0;
	var this$0$0$0;
	var expr$1;
	var this$0$1;
	var this$0$0$1;
	var message$0;
	var this$0$2;
	var message$0$0;
	var this$0;
	value = calcCb((expr$0 = expr._expr1, expr$0 instanceof NumberLiteralExpression ? expr$0.getDecoded$() : (this$0$0 = expr$0, (this$0$0$0 = this$0$0._token, this$0$0$0._value) | 0)), (expr$1 = expr._expr2, expr$1 instanceof NumberLiteralExpression ? expr$1.getDecoded$() : (this$0$1 = expr$1, (this$0$0$1 = this$0$1._token, this$0$0$1._value) | 0)));
	message$0 = "folding operator " + (this$0 = expr._token, "'" + this$0._value + "'" + " at " + (this$0._filename || "<<unknown>>") + ":" + (this$0._lineNumber + "") + ":" + (this$0._columnNumber + "")) + " to number: " + (value + "");
	this$0$2 = $this._optimizer;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	this$0$2._log += message$0$0 + "\n";
	replaceCb(new NumberLiteralExpression(new Token$3(value + "")));
};

_FoldConstantCommand._foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$ = _FoldConstantCommand$_foldNumericBinaryExpressionAsNumber$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNN$;

_FoldConstantCommand.prototype._foldNumericBinaryExpressionAsBoolean$LBinaryExpression$F$LExpression$V$F$NNB$ = function (expr, replaceCb, calcCb) {
	var value;
	var expr$0;
	var this$0$0;
	var this$0$0$0;
	var expr$1;
	var this$0$1;
	var this$0$0$1;
	var message$0;
	var this$0$2;
	var message$0$0;
	var this$0;
	value = calcCb((expr$0 = expr._expr1, expr$0 instanceof NumberLiteralExpression ? expr$0.getDecoded$() : (this$0$0 = expr$0, (this$0$0$0 = this$0$0._token, this$0$0$0._value) | 0)), (expr$1 = expr._expr2, expr$1 instanceof NumberLiteralExpression ? expr$1.getDecoded$() : (this$0$1 = expr$1, (this$0$0$1 = this$0$1._token, this$0$0$1._value) | 0)));
	message$0 = "folding operator " + (this$0 = expr._token, "'" + this$0._value + "'" + " at " + (this$0._filename || "<<unknown>>") + ":" + (this$0._lineNumber + "") + ":" + (this$0._columnNumber + "")) + " to boolean: " + (value + "");
	this$0$2 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this$0$2._log += message$0$0 + "\n";
	replaceCb(new BooleanLiteralExpression(new Token$3(value + "")));
};


function _FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$($this, expr, replaceCb, calcCb) {
	var value;
	var expr$0;
	var this$0$0;
	var this$0$0$0;
	var expr$1;
	var this$0$1;
	var this$0$0$1;
	var message$0;
	var this$0$2;
	var message$0$0;
	var this$0;
	value = calcCb((expr$0 = expr._expr1, expr$0 instanceof NumberLiteralExpression ? expr$0.getDecoded$() : (this$0$0 = expr$0, (this$0$0$0 = this$0$0._token, this$0$0$0._value) | 0)), (expr$1 = expr._expr2, expr$1 instanceof NumberLiteralExpression ? expr$1.getDecoded$() : (this$0$1 = expr$1, (this$0$0$1 = this$0$1._token, this$0$0$1._value) | 0)));
	message$0 = "folding operator " + (this$0 = expr._token, "'" + this$0._value + "'" + " at " + (this$0._filename || "<<unknown>>") + ":" + (this$0._lineNumber + "") + ":" + (this$0._columnNumber + "")) + " to boolean: " + (value + "");
	this$0$2 = $this._optimizer;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	this$0$2._log += message$0$0 + "\n";
	replaceCb(new BooleanLiteralExpression(new Token$3(value + "")));
};

_FoldConstantCommand._foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$ = _FoldConstantCommand$_foldNumericBinaryExpressionAsBoolean$L_FoldConstantCommand$LBinaryExpression$F$LExpression$V$F$NNB$;

_FoldConstantCommand.prototype._isIntegerOrNumberLiteralExpression$LExpression$ = function (expr) {
	return expr instanceof NumberLiteralExpression || expr instanceof IntegerLiteralExpression;
};


function _FoldConstantCommand$_isIntegerOrNumberLiteralExpression$L_FoldConstantCommand$LExpression$($this, expr) {
	return expr instanceof NumberLiteralExpression || expr instanceof IntegerLiteralExpression;
};

_FoldConstantCommand._isIntegerOrNumberLiteralExpression$L_FoldConstantCommand$LExpression$ = _FoldConstantCommand$_isIntegerOrNumberLiteralExpression$L_FoldConstantCommand$LExpression$;

_FoldConstantCommand.prototype._foldStaticConst$LMemberVariableDefinition$ = function (member) {
	var $this = this;
	var stash;
	var initialValue;
	var identifier$0;
	var stash$0;
	identifier$0 = this._identifier;
	stash$0 = member.getStash$S(identifier$0);
	if (stash$0 == null) {
		stash$0 = new _FoldConstantCommand$x2EStash();
		member.setStash$SLStash$(identifier$0, stash$0);
	}
	stash = stash$0;
	if (stash$0.isOptimized) {
		return;
	}
	stash.isOptimized = true;
	initialValue = member._initialValue;
	if (initialValue != null) {
		_FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$(this, initialValue, (function (expr) {
			member._initialValue = expr;
		}));
	}
};


function _FoldConstantCommand$_foldStaticConst$L_FoldConstantCommand$LMemberVariableDefinition$($this, member) {
	var stash;
	var initialValue;
	var identifier$0;
	var stash$0;
	identifier$0 = $this._identifier;
	stash$0 = member.getStash$S(identifier$0);
	if (stash$0 == null) {
		stash$0 = new _FoldConstantCommand$x2EStash();
		member.setStash$SLStash$(identifier$0, stash$0);
	}
	stash = stash$0;
	if (stash$0.isOptimized) {
		return;
	}
	stash.isOptimized = true;
	initialValue = member._initialValue;
	if (initialValue != null) {
		_FoldConstantCommand$_optimizeExpression$L_FoldConstantCommand$LExpression$F$LExpression$V$($this, initialValue, (function (expr) {
			member._initialValue = expr;
		}));
	}
};

_FoldConstantCommand._foldStaticConst$L_FoldConstantCommand$LMemberVariableDefinition$ = _FoldConstantCommand$_foldStaticConst$L_FoldConstantCommand$LMemberVariableDefinition$;

_FoldConstantCommand.prototype._toFoldedExpr$LExpression$LType$ = function (expr, type) {
	var this$0$0;
	if (expr instanceof NullExpression) {
		return expr;
	} else if (expr instanceof BooleanLiteralExpression) {
		return expr;
	} else if (expr instanceof IntegerLiteralExpression) {
		return expr;
	} else if (expr instanceof NumberLiteralExpression) {
		if ((type instanceof NullableType ? (this$0$0 = type, this$0$0._baseType) : type).equals$LType$(Type.integerType)) {
			return new IntegerLiteralExpression(new Token$3((expr.getDecoded$() | 0) + ""));
		}
		return expr;
	} else if (expr instanceof StringLiteralExpression) {
		return expr;
	}
	return null;
};


function _FoldConstantCommand$_toFoldedExpr$L_FoldConstantCommand$LExpression$LType$($this, expr, type) {
	var this$0$0;
	if (expr instanceof NullExpression) {
		return expr;
	} else if (expr instanceof BooleanLiteralExpression) {
		return expr;
	} else if (expr instanceof IntegerLiteralExpression) {
		return expr;
	} else if (expr instanceof NumberLiteralExpression) {
		if ((type instanceof NullableType ? (this$0$0 = type, this$0$0._baseType) : type).equals$LType$(Type.integerType)) {
			return new IntegerLiteralExpression(new Token$3((expr.getDecoded$() | 0) + ""));
		}
		return expr;
	} else if (expr instanceof StringLiteralExpression) {
		return expr;
	}
	return null;
};

_FoldConstantCommand._toFoldedExpr$L_FoldConstantCommand$LExpression$LType$ = _FoldConstantCommand$_toFoldedExpr$L_FoldConstantCommand$LExpression$LType$;

_FoldConstantCommand.prototype._foldAsExpression$LAsExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var baseExpr;
	var this$0$0;
	var message$0$0;
	var this$0$1;
	var message$0$1;
	var this$0$2;
	var message$0$2;
	var this$0$3;
	var message$0$3;
	var this$0$4;
	var message$0$4;
	var this$0$5;
	var message$0$5;
	var this$0$6;
	var message$0$6;
	var this$0$7;
	var message$0$7;
	var this$0$8;
	var message$0$8;
	var this$0$9;
	var message$0$9;
	var this$0$10;
	var message$0$10;
	var this$0$11;
	var message$0$11;
	var this$0;
	var this$0$12;
	baseExpr = expr._expr;
	if (expr._type.equals$LType$(Type.stringType)) {
		if (baseExpr.getType$().equals$LType$(Type.stringType)) {
			this$0$0 = this._optimizer;
			message$0$0 = "[" + this._identifier + "] " + "folding type cast: string as string";
			this$0$0._log += message$0$0 + "\n";
			replaceCb(baseExpr);
		} else if (baseExpr instanceof PrimitiveLiteralExpression) {
			this$0$1 = this._optimizer;
			message$0$1 = "[" + this._identifier + "] " + "folding type cast: primitive literal as string";
			this$0$1._log += message$0$1 + "\n";
			replaceCb(new StringLiteralExpression(new Token$2(Util$encodeStringLiteral$S(baseExpr.toNormalizedString$()), false)));
		}
	} else if (expr._type.equals$LType$(Type.numberType)) {
		if (baseExpr.getType$().equals$LType$(Type.numberType)) {
			this$0$2 = this._optimizer;
			message$0$2 = "[" + this._identifier + "] " + "folding type cast: number as number";
			this$0$2._log += message$0$2 + "\n";
			replaceCb(baseExpr);
		} else if (baseExpr instanceof StringLiteralExpression) {
			this$0$3 = this._optimizer;
			message$0$3 = "[" + this._identifier + "] " + "folding type cast: string literal as number";
			this$0$3._log += message$0$3 + "\n";
			replaceCb(new NumberLiteralExpression(new Token$2(+baseExpr.getDecoded$() + "", false)));
		} else if (baseExpr instanceof IntegerLiteralExpression) {
			this$0$4 = this._optimizer;
			message$0$4 = "[" + this._identifier + "] " + "folding type cast: int literal as number";
			this$0$4._log += message$0$4 + "\n";
			replaceCb(new NumberLiteralExpression(new Token$2(+baseExpr.getDecoded$() + "", false)));
		}
	} else if (expr._type.equals$LType$(Type.integerType)) {
		if (baseExpr.getType$().equals$LType$(Type.integerType)) {
			this$0$5 = this._optimizer;
			message$0$5 = "[" + this._identifier + "] " + "folding type cast: int as int";
			this$0$5._log += message$0$5 + "\n";
			replaceCb(baseExpr);
		} else if (baseExpr instanceof StringLiteralExpression) {
			this$0$6 = this._optimizer;
			message$0$6 = "[" + this._identifier + "] " + "folding type cast: string literal as int";
			this$0$6._log += message$0$6 + "\n";
			replaceCb(new IntegerLiteralExpression(new Token$2((baseExpr.getDecoded$() | 0) + "", false)));
		} else if (baseExpr instanceof NumberLiteralExpression) {
			this$0$7 = this._optimizer;
			message$0$7 = "[" + this._identifier + "] " + "folding type cast: number literal as int";
			this$0$7._log += message$0$7 + "\n";
			replaceCb(new IntegerLiteralExpression(new Token$2((baseExpr.getDecoded$() | 0) + "", false)));
		}
	} else if (expr._type.equals$LType$(Type.booleanType)) {
		if (baseExpr.getType$().equals$LType$(Type.booleanType)) {
			this$0$8 = this._optimizer;
			message$0$8 = "[" + this._identifier + "] " + "folding type cast: boolean as boolean";
			this$0$8._log += message$0$8 + "\n";
			replaceCb(baseExpr);
		} else if (baseExpr instanceof StringLiteralExpression) {
			this$0$9 = this._optimizer;
			message$0$9 = "[" + this._identifier + "] " + "folding type cast: string literal as boolean";
			this$0$9._log += message$0$9 + "\n";
			replaceCb(new BooleanLiteralExpression(new Token$2(!! baseExpr.getDecoded$() + "", false)));
		} else if (baseExpr instanceof NumberLiteralExpression) {
			this$0$10 = this._optimizer;
			message$0$10 = "[" + this._identifier + "] " + "folding type cast: number literal as boolean";
			this$0$10._log += message$0$10 + "\n";
			replaceCb(new BooleanLiteralExpression(new Token$2((baseExpr.getDecoded$() ? "true" : "false"), false)));
		} else if (baseExpr instanceof IntegerLiteralExpression) {
			this$0$11 = this._optimizer;
			message$0$11 = "[" + this._identifier + "] " + "folding type cast: integer literal as boolean";
			this$0$11._log += message$0$11 + "\n";
			replaceCb(new BooleanLiteralExpression(new Token$2(((this$0 = baseExpr, (this$0$12 = this$0._token, this$0$12._value) | 0) ? "true" : "false"), false)));
		}
	}
};


function _FoldConstantCommand$_foldAsExpression$L_FoldConstantCommand$LAsExpression$F$LExpression$V$($this, expr, replaceCb) {
	var baseExpr;
	var this$0$0;
	var message$0$0;
	var this$0$1;
	var message$0$1;
	var this$0$2;
	var message$0$2;
	var this$0$3;
	var message$0$3;
	var this$0$4;
	var message$0$4;
	var this$0$5;
	var message$0$5;
	var this$0$6;
	var message$0$6;
	var this$0$7;
	var message$0$7;
	var this$0$8;
	var message$0$8;
	var this$0$9;
	var message$0$9;
	var this$0$10;
	var message$0$10;
	var this$0$11;
	var message$0$11;
	var this$0;
	var this$0$12;
	baseExpr = expr._expr;
	if (expr._type.equals$LType$(Type.stringType)) {
		if (baseExpr.getType$().equals$LType$(Type.stringType)) {
			this$0$0 = $this._optimizer;
			message$0$0 = "[" + $this._identifier + "] " + "folding type cast: string as string";
			this$0$0._log += message$0$0 + "\n";
			replaceCb(baseExpr);
		} else if (baseExpr instanceof PrimitiveLiteralExpression) {
			this$0$1 = $this._optimizer;
			message$0$1 = "[" + $this._identifier + "] " + "folding type cast: primitive literal as string";
			this$0$1._log += message$0$1 + "\n";
			replaceCb(new StringLiteralExpression(new Token$2(Util$encodeStringLiteral$S(baseExpr.toNormalizedString$()), false)));
		}
	} else if (expr._type.equals$LType$(Type.numberType)) {
		if (baseExpr.getType$().equals$LType$(Type.numberType)) {
			this$0$2 = $this._optimizer;
			message$0$2 = "[" + $this._identifier + "] " + "folding type cast: number as number";
			this$0$2._log += message$0$2 + "\n";
			replaceCb(baseExpr);
		} else if (baseExpr instanceof StringLiteralExpression) {
			this$0$3 = $this._optimizer;
			message$0$3 = "[" + $this._identifier + "] " + "folding type cast: string literal as number";
			this$0$3._log += message$0$3 + "\n";
			replaceCb(new NumberLiteralExpression(new Token$2(+baseExpr.getDecoded$() + "", false)));
		} else if (baseExpr instanceof IntegerLiteralExpression) {
			this$0$4 = $this._optimizer;
			message$0$4 = "[" + $this._identifier + "] " + "folding type cast: int literal as number";
			this$0$4._log += message$0$4 + "\n";
			replaceCb(new NumberLiteralExpression(new Token$2(+baseExpr.getDecoded$() + "", false)));
		}
	} else if (expr._type.equals$LType$(Type.integerType)) {
		if (baseExpr.getType$().equals$LType$(Type.integerType)) {
			this$0$5 = $this._optimizer;
			message$0$5 = "[" + $this._identifier + "] " + "folding type cast: int as int";
			this$0$5._log += message$0$5 + "\n";
			replaceCb(baseExpr);
		} else if (baseExpr instanceof StringLiteralExpression) {
			this$0$6 = $this._optimizer;
			message$0$6 = "[" + $this._identifier + "] " + "folding type cast: string literal as int";
			this$0$6._log += message$0$6 + "\n";
			replaceCb(new IntegerLiteralExpression(new Token$2((baseExpr.getDecoded$() | 0) + "", false)));
		} else if (baseExpr instanceof NumberLiteralExpression) {
			this$0$7 = $this._optimizer;
			message$0$7 = "[" + $this._identifier + "] " + "folding type cast: number literal as int";
			this$0$7._log += message$0$7 + "\n";
			replaceCb(new IntegerLiteralExpression(new Token$2((baseExpr.getDecoded$() | 0) + "", false)));
		}
	} else if (expr._type.equals$LType$(Type.booleanType)) {
		if (baseExpr.getType$().equals$LType$(Type.booleanType)) {
			this$0$8 = $this._optimizer;
			message$0$8 = "[" + $this._identifier + "] " + "folding type cast: boolean as boolean";
			this$0$8._log += message$0$8 + "\n";
			replaceCb(baseExpr);
		} else if (baseExpr instanceof StringLiteralExpression) {
			this$0$9 = $this._optimizer;
			message$0$9 = "[" + $this._identifier + "] " + "folding type cast: string literal as boolean";
			this$0$9._log += message$0$9 + "\n";
			replaceCb(new BooleanLiteralExpression(new Token$2(!! baseExpr.getDecoded$() + "", false)));
		} else if (baseExpr instanceof NumberLiteralExpression) {
			this$0$10 = $this._optimizer;
			message$0$10 = "[" + $this._identifier + "] " + "folding type cast: number literal as boolean";
			this$0$10._log += message$0$10 + "\n";
			replaceCb(new BooleanLiteralExpression(new Token$2((baseExpr.getDecoded$() ? "true" : "false"), false)));
		} else if (baseExpr instanceof IntegerLiteralExpression) {
			this$0$11 = $this._optimizer;
			message$0$11 = "[" + $this._identifier + "] " + "folding type cast: integer literal as boolean";
			this$0$11._log += message$0$11 + "\n";
			replaceCb(new BooleanLiteralExpression(new Token$2(((this$0 = baseExpr, (this$0$12 = this$0._token, this$0$12._value) | 0) ? "true" : "false"), false)));
		}
	}
};

_FoldConstantCommand._foldAsExpression$L_FoldConstantCommand$LAsExpression$F$LExpression$V$ = _FoldConstantCommand$_foldAsExpression$L_FoldConstantCommand$LAsExpression$F$LExpression$V$;

function _StructuredStashAccessor$x2E$x3CStash$x3E$4() {
};

$__jsx_extend([_StructuredStashAccessor$x2E$x3CStash$x3E$4], Object);
_StructuredStashAccessor$x2E$x3CStash$x3E$4.prototype.$__jsx_implements__StructuredStashAccessor$x2E$x3CStash$x3E$4 = true;

_StructuredStashAccessor$x2E$x3CStash$x3E$4.prototype.getStash$LStashable$ = function (stashable) {
	var identifier;
	var stash;
	identifier = this._identifier;
	stash = stashable.getStash$S(identifier);
	if (stash == null) {
		stash = new _InlineOptimizeCommand$x2EStash();
		stashable.setStash$SLStash$(identifier, stash);
	}
	return stash;
};


_StructuredStashAccessor$x2E$x3CStash$x3E$4.prototype.resetStash$LStashable$ = function (stashable) {
	var identifier;
	identifier = this._identifier;
	stashable.setStash$SLStash$(identifier, null);
};


function _InlineOptimizeCommand() {
	this._identifier = "inline";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_InlineOptimizeCommand], _FunctionOptimizeCommand);
$__jsx_merge_interface(_InlineOptimizeCommand, _StructuredStashAccessor$x2E$x3CStash$x3E$4);

_InlineOptimizeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var stash;
	var identifier$0;
	var stash$0;
	var command$0;
	var optimizer$0$0;
	var command$1;
	var optimizer$0$1;
	identifier$0 = this._identifier;
	stash$0 = funcDef.getStash$S(identifier$0);
	if (stash$0 == null) {
		stash$0 = new _InlineOptimizeCommand$x2EStash();
		funcDef.setStash$SLStash$(identifier$0, stash$0);
	}
	stash = stash$0;
	if (stash$0.isOptimized) {
		return true;
	}
	stash.isOptimized = true;
	if (funcDef._statements == null) {
		return true;
	}
	while (true) {
		while (true) {
			if (! _InlineOptimizeCommand$_handleStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$(this, funcDef, funcDef._statements)) {
				break;
			}
			(command$0 = new _DetermineCalleeCommand(), optimizer$0$0 = this._optimizer, command$0._optimizer = optimizer$0$0, command$0, command$0).optimizeFunction$LMemberFunctionDefinition$(funcDef);
		}
		if (! (command$1 = new _ReturnIfOptimizeCommand(), optimizer$0$1 = this._optimizer, command$1._optimizer = optimizer$0$1, command$1, command$1).optimizeFunction$LMemberFunctionDefinition$(funcDef)) {
			break;
		}
	}
	return true;
};


_InlineOptimizeCommand.prototype._handleStatements$LMemberFunctionDefinition$ALStatement$ = function (funcDef, statements) {
	var altered;
	var i;
	var left;
	altered = false;
	for (i = 0; i < statements.length; ++i) {
		left = statements.length - i;
		if (_InlineOptimizeCommand$_handleStatement$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$N(this, funcDef, statements, i)) {
			altered = true;
		}
		i = statements.length - left;
	}
	return altered;
};


function _InlineOptimizeCommand$_handleStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$($this, funcDef, statements) {
	var altered;
	var i;
	var left;
	altered = false;
	for (i = 0; i < statements.length; ++i) {
		left = statements.length - i;
		if (_InlineOptimizeCommand$_handleStatement$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$N($this, funcDef, statements, i)) {
			altered = true;
		}
		i = statements.length - left;
	}
	return altered;
};

_InlineOptimizeCommand._handleStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$ = _InlineOptimizeCommand$_handleStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$;

_InlineOptimizeCommand.prototype._handleStatement$LMemberFunctionDefinition$ALStatement$N = function (funcDef, statements, stmtIndex) {
	var $this = this;
	var altered;
	var statement;
	var callingFuncDef;
	var stash$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	altered = false;
	statement = statements[stmtIndex];
	if (statement instanceof ConstructorInvocationStatement) {
		stash$0 = statement.getStash$S("determine-callee");
		if (stash$0 == null) {
			throw new Error("callee not searched");
		}
		callingFuncDef = stash$0.callingFuncDef;
		message$0 = "optimizing calling constructor " + callingFuncDef.getNotation$();
		this$0$0 = this._optimizer;
		message$0$0 = "[" + this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
		this.optimizeFunction$LMemberFunctionDefinition$(callingFuncDef);
		if (_InlineOptimizeCommand$_functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$(this, callingFuncDef) && _InlineOptimizeCommand$_argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$(this, callingFuncDef, (this$4 = statement, this$4._args))) {
			statements.splice(stmtIndex, 1);
			_InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$(this, funcDef, statements, stmtIndex, callingFuncDef, (this$0 = statement, this$0._args).concat([ new ThisExpression(null, funcDef._classDef) ]));
		}
	} else if (statement instanceof ExpressionStatement) {
		if (_InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$(this, funcDef, statements, stmtIndex, (this$1 = statement, this$1._expr), (function (stmtIndex) {
			statements.splice(stmtIndex, 1);
		}))) {
			altered = true;
		}
	} else if (statement instanceof ReturnStatement) {
		if (_InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$(this, funcDef, statements, stmtIndex, (this$2 = statement, this$2._expr), (function (stmtIndex) {
			var this$0;
			var this$1;
			statements.splice(stmtIndex, 1);
			if (statements[stmtIndex - 1] instanceof ReturnStatement) {
				statements[stmtIndex - 1] = new ReturnStatement(statement.getToken$(), (this$0 = statements[stmtIndex - 1], this$0._expr));
			} else if (statements[stmtIndex - 1] instanceof ExpressionStatement) {
				statements[stmtIndex - 1] = new ReturnStatement(statement.getToken$(), (this$1 = statements[stmtIndex - 1], this$1._expr));
			}
		}))) {
			altered = true;
		}
	} else if (statement instanceof IfStatement) {
		if (_InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$(this, funcDef, statements, stmtIndex, (this$3 = statement, this$3._expr), (function (stmtIndex) {
			var this$0;
			var expr$0;
			var this$1;
			var this$2;
			this$0 = statement;
			expr$0 = (statements[stmtIndex - 1] instanceof ReturnStatement ? (this$1 = statements[stmtIndex - 1], this$1._expr) : (this$2 = statements[stmtIndex - 1], this$2._expr));
			this$0._expr = expr$0;
			statements.splice(stmtIndex - 1, 1);
		}))) {
			altered = true;
		}
		if (_InlineOptimizeCommand$_handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$(this, funcDef, statement)) {
			altered = true;
		}
	} else if (_InlineOptimizeCommand$_handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$(this, funcDef, statement)) {
		altered = true;
	}
	if (! altered) {
		statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
			var callExpr;
			var argsAndThis;
			expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			if (expr instanceof CallExpression) {
				callExpr = expr;
				argsAndThis = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$($this, callExpr);
				if (argsAndThis != null) {
					if (_InlineOptimizeCommand$_expandCallAsExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$LExpression$ALExpression$F$LExpression$V$($this, funcDef, expr, argsAndThis, replaceCb)) {
						altered = true;
					}
				}
			}
			return true;
		}));
	}
	return altered;
};


function _InlineOptimizeCommand$_handleStatement$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$N($this, funcDef, statements, stmtIndex) {
	var altered;
	var statement;
	var callingFuncDef;
	var stash$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	altered = false;
	statement = statements[stmtIndex];
	if (statement instanceof ConstructorInvocationStatement) {
		stash$0 = statement.getStash$S("determine-callee");
		if (stash$0 == null) {
			throw new Error("callee not searched");
		}
		callingFuncDef = stash$0.callingFuncDef;
		message$0 = "optimizing calling constructor " + callingFuncDef.getNotation$();
		this$0$0 = $this._optimizer;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
		$this.optimizeFunction$LMemberFunctionDefinition$(callingFuncDef);
		if (_InlineOptimizeCommand$_functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, callingFuncDef) && _InlineOptimizeCommand$_argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, callingFuncDef, (this$4 = statement, this$4._args))) {
			statements.splice(stmtIndex, 1);
			_InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$($this, funcDef, statements, stmtIndex, callingFuncDef, (this$0 = statement, this$0._args).concat([ new ThisExpression(null, funcDef._classDef) ]));
		}
	} else if (statement instanceof ExpressionStatement) {
		if (_InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$($this, funcDef, statements, stmtIndex, (this$1 = statement, this$1._expr), (function (stmtIndex) {
			statements.splice(stmtIndex, 1);
		}))) {
			altered = true;
		}
	} else if (statement instanceof ReturnStatement) {
		if (_InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$($this, funcDef, statements, stmtIndex, (this$2 = statement, this$2._expr), (function (stmtIndex) {
			var this$0;
			var this$1;
			statements.splice(stmtIndex, 1);
			if (statements[stmtIndex - 1] instanceof ReturnStatement) {
				statements[stmtIndex - 1] = new ReturnStatement(statement.getToken$(), (this$0 = statements[stmtIndex - 1], this$0._expr));
			} else if (statements[stmtIndex - 1] instanceof ExpressionStatement) {
				statements[stmtIndex - 1] = new ReturnStatement(statement.getToken$(), (this$1 = statements[stmtIndex - 1], this$1._expr));
			}
		}))) {
			altered = true;
		}
	} else if (statement instanceof IfStatement) {
		if (_InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$($this, funcDef, statements, stmtIndex, (this$3 = statement, this$3._expr), (function (stmtIndex) {
			var this$0;
			var expr$0;
			var this$1;
			var this$2;
			this$0 = statement;
			expr$0 = (statements[stmtIndex - 1] instanceof ReturnStatement ? (this$1 = statements[stmtIndex - 1], this$1._expr) : (this$2 = statements[stmtIndex - 1], this$2._expr));
			this$0._expr = expr$0;
			statements.splice(stmtIndex - 1, 1);
		}))) {
			altered = true;
		}
		if (_InlineOptimizeCommand$_handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$($this, funcDef, statement)) {
			altered = true;
		}
	} else if (_InlineOptimizeCommand$_handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$($this, funcDef, statement)) {
		altered = true;
	}
	if (! altered) {
		statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
			var callExpr;
			var argsAndThis;
			expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			if (expr instanceof CallExpression) {
				callExpr = expr;
				argsAndThis = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$($this, callExpr);
				if (argsAndThis != null) {
					if (_InlineOptimizeCommand$_expandCallAsExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$LExpression$ALExpression$F$LExpression$V$($this, funcDef, expr, argsAndThis, replaceCb)) {
						altered = true;
					}
				}
			}
			return true;
		}));
	}
	return altered;
};

_InlineOptimizeCommand._handleStatement$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$N = _InlineOptimizeCommand$_handleStatement$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$N;

_InlineOptimizeCommand.prototype._countNumberOfArgsUsed$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var formalArgs;
	var map;
	var updateCountOfLocal;
	formalArgs = new TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E();
	map = {};
	funcDef._args.forEach((function (formalArg) {
		var this$0;
		TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B(formalArgs, formalArg, true);
		map[(this$0 = formalArg._name, this$0._value)] = 0;
	}));
	map["this"] = 0;
	function updateCountOfLocal(local, delta) {
		var this$0;
		if (TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$(formalArgs, local)) {
			map[(this$0 = local._name, this$0._value)] += delta;
		}
	}
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			var assignExpr;
			var incrExpr;
			Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
			if (expr instanceof LocalExpression) {
				updateCountOfLocal(LocalExpression$getLocal$LLocalExpression$(expr), 1);
			} else if (expr instanceof AssignmentExpression) {
				assignExpr = expr;
				if (BinaryExpression$getFirstExpr$LBinaryExpression$(assignExpr) instanceof LocalExpression) {
					updateCountOfLocal(LocalExpression$getLocal$LLocalExpression$(BinaryExpression$getFirstExpr$LBinaryExpression$(assignExpr)), - Infinity);
				}
			} else if (expr instanceof IncrementExpression) {
				incrExpr = expr;
				if (UnaryExpression$getExpr$LUnaryExpression$(incrExpr) instanceof LocalExpression) {
					updateCountOfLocal(LocalExpression$getLocal$LLocalExpression$(UnaryExpression$getExpr$LUnaryExpression$(incrExpr)), - Infinity);
				}
			} else if (expr instanceof ThisExpression) {
				map["this"]++;
			}
			return true;
		}));
		return true;
	}), funcDef._statements);
	return map;
};


function _InlineOptimizeCommand$_countNumberOfArgsUsed$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var formalArgs;
	var map;
	var updateCountOfLocal;
	formalArgs = new TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E();
	map = {};
	funcDef._args.forEach((function (formalArg) {
		var this$0;
		TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$set$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$B(formalArgs, formalArg, true);
		map[(this$0 = formalArg._name, this$0._value)] = 0;
	}));
	map["this"] = 0;
	function updateCountOfLocal(local, delta) {
		var this$0;
		if (TypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$has$LTypedMap$x2E$x3CLocalVariable$x2Cboolean$x3E$LLocalVariable$(formalArgs, local)) {
			map[(this$0 = local._name, this$0._value)] += delta;
		}
	}
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			var assignExpr;
			var incrExpr;
			Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
			if (expr instanceof LocalExpression) {
				updateCountOfLocal(LocalExpression$getLocal$LLocalExpression$(expr), 1);
			} else if (expr instanceof AssignmentExpression) {
				assignExpr = expr;
				if (BinaryExpression$getFirstExpr$LBinaryExpression$(assignExpr) instanceof LocalExpression) {
					updateCountOfLocal(LocalExpression$getLocal$LLocalExpression$(BinaryExpression$getFirstExpr$LBinaryExpression$(assignExpr)), - Infinity);
				}
			} else if (expr instanceof IncrementExpression) {
				incrExpr = expr;
				if (UnaryExpression$getExpr$LUnaryExpression$(incrExpr) instanceof LocalExpression) {
					updateCountOfLocal(LocalExpression$getLocal$LLocalExpression$(UnaryExpression$getExpr$LUnaryExpression$(incrExpr)), - Infinity);
				}
			} else if (expr instanceof ThisExpression) {
				map["this"]++;
			}
			return true;
		}));
		return true;
	}), funcDef._statements);
	return map;
};

_InlineOptimizeCommand._countNumberOfArgsUsed$L_InlineOptimizeCommand$LMemberFunctionDefinition$ = _InlineOptimizeCommand$_countNumberOfArgsUsed$L_InlineOptimizeCommand$LMemberFunctionDefinition$;

_InlineOptimizeCommand.prototype._handleSubStatements$LMemberFunctionDefinition$LStatement$ = function (funcDef, statement) {
	var $this = this;
	return _Util$0$handleSubStatements$F$ALStatement$B$LStatement$((function (statements) {
		return _InlineOptimizeCommand$_handleStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$($this, funcDef, statements);
	}), statement);
};


function _InlineOptimizeCommand$_handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$($this, funcDef, statement) {
	return _Util$0$handleSubStatements$F$ALStatement$B$LStatement$((function (statements) {
		return _InlineOptimizeCommand$_handleStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$($this, funcDef, statements);
	}), statement);
};

_InlineOptimizeCommand._handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$ = _InlineOptimizeCommand$_handleSubStatements$L_InlineOptimizeCommand$LMemberFunctionDefinition$LStatement$;

_InlineOptimizeCommand.prototype._expandStatementExpression$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$ = function (funcDef, statements, stmtIndex, expr, cb) {
	var args;
	var stmt;
	var rhsExpr;
	var lastExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	if (expr instanceof CallExpression) {
		args = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$(this, expr);
		if (args != null) {
			stmtIndex = _InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$(this, funcDef, statements, stmtIndex, _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr), args);
			cb(stmtIndex);
			return true;
		}
	} else if (expr instanceof AssignmentExpression && ! Expression$hasSideEffects$LExpression$((this$5 = expr, this$5._expr1)) && (this$6 = expr, this$6._expr2) instanceof CallExpression) {
		args = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$(this, (this$0 = expr, this$0._expr2));
		if (args != null) {
			stmtIndex = _InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$(this, funcDef, statements, stmtIndex, _DetermineCalleeCommand$getCallingFuncDef$LStashable$((this$1 = expr, this$1._expr2)), args);
			stmt = statements[stmtIndex - 1];
			if (stmt instanceof ReturnStatement) {
				this$2 = stmt;
				rhsExpr = this$2._expr;
			} else if (stmt instanceof ExpressionStatement) {
				this$3 = stmt;
				rhsExpr = this$3._expr;
			} else {
				return false;
			}
			lastExpr = new AssignmentExpression(expr._token, (this$4 = expr, this$4._expr1), rhsExpr);
			statements[stmtIndex - 1] = new ExpressionStatement(lastExpr);
			cb(stmtIndex);
			return true;
		}
	}
	return false;
};


function _InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$($this, funcDef, statements, stmtIndex, expr, cb) {
	var args;
	var stmt;
	var rhsExpr;
	var lastExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	if (expr instanceof CallExpression) {
		args = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$($this, expr);
		if (args != null) {
			stmtIndex = _InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$($this, funcDef, statements, stmtIndex, _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr), args);
			cb(stmtIndex);
			return true;
		}
	} else if (expr instanceof AssignmentExpression && ! Expression$hasSideEffects$LExpression$((this$5 = expr, this$5._expr1)) && (this$6 = expr, this$6._expr2) instanceof CallExpression) {
		args = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$($this, (this$0 = expr, this$0._expr2));
		if (args != null) {
			stmtIndex = _InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$($this, funcDef, statements, stmtIndex, _DetermineCalleeCommand$getCallingFuncDef$LStashable$((this$1 = expr, this$1._expr2)), args);
			stmt = statements[stmtIndex - 1];
			if (stmt instanceof ReturnStatement) {
				this$2 = stmt;
				rhsExpr = this$2._expr;
			} else if (stmt instanceof ExpressionStatement) {
				this$3 = stmt;
				rhsExpr = this$3._expr;
			} else {
				return false;
			}
			lastExpr = new AssignmentExpression(expr._token, (this$4 = expr, this$4._expr1), rhsExpr);
			statements[stmtIndex - 1] = new ExpressionStatement(lastExpr);
			cb(stmtIndex);
			return true;
		}
	}
	return false;
};

_InlineOptimizeCommand._expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$ = _InlineOptimizeCommand$_expandStatementExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLExpression$F$NV$;

_InlineOptimizeCommand.prototype._getArgsAndThisIfCallExprIsInlineable$LCallExpression$ = function (callExpr) {
	var callingFuncDef;
	var receiverExpr;
	var calleeExpr;
	var argsAndThis;
	var stash$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	stash$0 = callExpr.getStash$S("determine-callee");
	if (stash$0 == null) {
		throw new Error("callee not searched");
	}
	callingFuncDef = stash$0.callingFuncDef;
	if (callingFuncDef == null) {
		return null;
	}
	message$0 = "optimizing calling function " + callingFuncDef.getNotation$();
	this$0$0 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	this.optimizeFunction$LMemberFunctionDefinition$(callingFuncDef);
	receiverExpr = null;
	if ((callingFuncDef._flags & 8) === 0) {
		calleeExpr = callExpr._expr;
		if (! (calleeExpr instanceof PropertyExpression)) {
			throw new Error("unexpected type of expression");
		}
		this$0 = calleeExpr;
		receiverExpr = this$0._expr;
	}
	if (! _InlineOptimizeCommand$_functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$(this, callingFuncDef)) {
		return null;
	}
	if (! _InlineOptimizeCommand$_argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$(this, callingFuncDef, callExpr._args)) {
		return null;
	}
	argsAndThis = callExpr._args.concat([]);
	if (_InlineOptimizeCommand$_functionHasThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$(this, callingFuncDef)) {
		if (receiverExpr != null) {
			argsAndThis.push(receiverExpr);
		} else {
			argsAndThis.push(new ThisExpression(null, callingFuncDef._classDef));
		}
	} else {
		argsAndThis.push(null);
	}
	return argsAndThis;
};


function _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$($this, callExpr) {
	var callingFuncDef;
	var receiverExpr;
	var calleeExpr;
	var argsAndThis;
	var stash$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	stash$0 = callExpr.getStash$S("determine-callee");
	if (stash$0 == null) {
		throw new Error("callee not searched");
	}
	callingFuncDef = stash$0.callingFuncDef;
	if (callingFuncDef == null) {
		return null;
	}
	message$0 = "optimizing calling function " + callingFuncDef.getNotation$();
	this$0$0 = $this._optimizer;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	$this.optimizeFunction$LMemberFunctionDefinition$(callingFuncDef);
	receiverExpr = null;
	if ((callingFuncDef._flags & 8) === 0) {
		calleeExpr = callExpr._expr;
		if (! (calleeExpr instanceof PropertyExpression)) {
			throw new Error("unexpected type of expression");
		}
		this$0 = calleeExpr;
		receiverExpr = this$0._expr;
	}
	if (! _InlineOptimizeCommand$_functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, callingFuncDef)) {
		return null;
	}
	if (! _InlineOptimizeCommand$_argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, callingFuncDef, callExpr._args)) {
		return null;
	}
	argsAndThis = callExpr._args.concat([]);
	if (_InlineOptimizeCommand$_functionHasThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, callingFuncDef)) {
		if (receiverExpr != null) {
			argsAndThis.push(receiverExpr);
		} else {
			argsAndThis.push(new ThisExpression(null, callingFuncDef._classDef));
		}
	} else {
		argsAndThis.push(null);
	}
	return argsAndThis;
};

_InlineOptimizeCommand._getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$ = _InlineOptimizeCommand$_getArgsAndThisIfCallExprIsInlineable$L_InlineOptimizeCommand$LCallExpression$;

_InlineOptimizeCommand.prototype._argsAreInlineable$LMemberFunctionDefinition$ALExpression$ = function (callingFuncDef, actualArgs) {
	var formalArgsTypes;
	var i;
	var argTypes$0;
	var i$0;
	var this$0$0;
	var actualArgs$len$0;
	argTypes$0 = [];
	for (i$0 = 0; i$0 < callingFuncDef._args.length; ++i$0) {
		this$0$0 = callingFuncDef._args[i$0];
		argTypes$0[i$0] = this$0$0._type;
	}
	formalArgsTypes = argTypes$0;
	if (actualArgs.length !== argTypes$0.length) {
		throw new Error("logic flow, number of arguments mismatch");
	}
	for ((i = 0, actualArgs$len$0 = actualArgs.length); i < actualArgs$len$0; ++i) {
		if (! _InlineOptimizeCommand$_argIsInlineable$L_InlineOptimizeCommand$LType$LType$(this, actualArgs[i].getType$(), formalArgsTypes[i])) {
			return false;
		}
	}
	return true;
};


function _InlineOptimizeCommand$_argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$($this, callingFuncDef, actualArgs) {
	var formalArgsTypes;
	var i;
	var argTypes$0;
	var i$0;
	var this$0$0;
	var actualArgs$len$0;
	argTypes$0 = [];
	for (i$0 = 0; i$0 < callingFuncDef._args.length; ++i$0) {
		this$0$0 = callingFuncDef._args[i$0];
		argTypes$0[i$0] = this$0$0._type;
	}
	formalArgsTypes = argTypes$0;
	if (actualArgs.length !== argTypes$0.length) {
		throw new Error("logic flow, number of arguments mismatch");
	}
	for ((i = 0, actualArgs$len$0 = actualArgs.length); i < actualArgs$len$0; ++i) {
		if (! _InlineOptimizeCommand$_argIsInlineable$L_InlineOptimizeCommand$LType$LType$($this, actualArgs[i].getType$(), formalArgsTypes[i])) {
			return false;
		}
	}
	return true;
};

_InlineOptimizeCommand._argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$ = _InlineOptimizeCommand$_argsAreInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALExpression$;

_InlineOptimizeCommand.prototype._argIsInlineable$LType$LType$ = function (actualType, formalType) {
	var this$0;
	var this$0$0;
	var this$0$1;
	this$0 = this._optimizer;
	if (this$0._enableRunTimeTypeCheck) {
		if (actualType instanceof NullableType && ! (formalType instanceof NullableType)) {
			return false;
		}
	}
	actualType = (actualType instanceof NullableType ? (this$0$0 = actualType, this$0$0._baseType) : actualType);
	formalType = (formalType instanceof NullableType ? (this$0$1 = formalType, this$0$1._baseType) : formalType);
	return (actualType instanceof ObjectType && formalType instanceof ObjectType ? actualType.isConvertibleTo$LType$(formalType) : actualType.equals$LType$(formalType));
};


function _InlineOptimizeCommand$_argIsInlineable$L_InlineOptimizeCommand$LType$LType$($this, actualType, formalType) {
	var this$0;
	var this$0$0;
	var this$0$1;
	this$0 = $this._optimizer;
	if (this$0._enableRunTimeTypeCheck) {
		if (actualType instanceof NullableType && ! (formalType instanceof NullableType)) {
			return false;
		}
	}
	actualType = (actualType instanceof NullableType ? (this$0$0 = actualType, this$0$0._baseType) : actualType);
	formalType = (formalType instanceof NullableType ? (this$0$1 = formalType, this$0$1._baseType) : formalType);
	return (actualType instanceof ObjectType && formalType instanceof ObjectType ? actualType.isConvertibleTo$LType$(formalType) : actualType.equals$LType$(formalType));
};

_InlineOptimizeCommand._argIsInlineable$L_InlineOptimizeCommand$LType$LType$ = _InlineOptimizeCommand$_argIsInlineable$L_InlineOptimizeCommand$LType$LType$;

_InlineOptimizeCommand.prototype._isWorthInline$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var n;
	if (funcDef._nameToken == null) {
		return true;
	}
	n = 0;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var cont;
		cont = Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			if (++n >= _InlineOptimizeCommand.INLINE_THRESHOLD) {
				return false;
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}));
		return (! cont ? false : Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement));
	}), funcDef._statements);
	return n < 30;
};


function _InlineOptimizeCommand$_isWorthInline$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var n;
	if (funcDef._nameToken == null) {
		return true;
	}
	n = 0;
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var cont;
		cont = Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			if (++n >= _InlineOptimizeCommand.INLINE_THRESHOLD) {
				return false;
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		}));
		return (! cont ? false : Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement));
	}), funcDef._statements);
	return n < 30;
};

_InlineOptimizeCommand._isWorthInline$L_InlineOptimizeCommand$LMemberFunctionDefinition$ = _InlineOptimizeCommand$_isWorthInline$L_InlineOptimizeCommand$LMemberFunctionDefinition$;

_InlineOptimizeCommand.prototype._functionIsInlineable$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var stash;
	var identifier$0;
	var stash$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	identifier$0 = this._identifier;
	stash$0 = funcDef.getStash$S(identifier$0);
	if (stash$0 == null) {
		stash$0 = new _InlineOptimizeCommand$x2EStash();
		funcDef.setStash$SLStash$(identifier$0, stash$0);
	}
	stash = stash$0;
	if (stash$0.isInlineable == null) {
		stash.isInlineable = (function () {
			var statements;
			var requestsInline;
			statements = funcDef._statements;
			if (statements == null) {
				return false;
			}
			requestsInline = (funcDef._flags & 1024) !== 0;
			if (requestsInline) {
			} else if (! _InlineOptimizeCommand$_isWorthInline$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, funcDef)) {
				return false;
			}
			return Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
				if (statement instanceof ExpressionStatement || statement instanceof BreakStatement || statement instanceof ContinueStatement || statement instanceof CaseStatement || statement instanceof DefaultStatement || statement instanceof ThrowStatement || statement instanceof DebuggerStatement || statement instanceof LogStatement || statement instanceof AssertStatement || statement instanceof ForStatement || statement instanceof ForInStatement || statement instanceof DoWhileStatement || statement instanceof WhileStatement || statement instanceof IfStatement || statement instanceof SwitchStatement) {
				} else if (statement instanceof ReturnStatement && statement == MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef)[MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef).length - 1]) {
				} else {
					return false;
				}
				if (! Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
					if (expr instanceof FunctionExpression) {
						return false;
					} else if (expr instanceof SuperExpression) {
						return false;
					} else if (expr instanceof CallExpression && _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr) == funcDef) {
						return false;
					} else if (expr instanceof LocalExpression) {
						if (MemberFunctionDefinition$getFuncLocal$LMemberFunctionDefinition$(funcDef) != null && MemberFunctionDefinition$getFuncLocal$LMemberFunctionDefinition$(funcDef) == LocalExpression$getLocal$LLocalExpression$(expr)) {
							return false;
						}
					}
					return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
				}))) {
					return false;
				}
				return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
			}), funcDef._statements);
		})();
		message$0 = funcDef.getNotation$() + (stash.isInlineable ? " is" : " is not") + " inlineable";
		this$0$0 = this._optimizer;
		message$0$0 = "[" + this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
	}
	return stash.isInlineable;
};


function _InlineOptimizeCommand$_functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	var stash;
	var identifier$0;
	var stash$0;
	var message$0;
	var this$0$0;
	var message$0$0;
	identifier$0 = $this._identifier;
	stash$0 = funcDef.getStash$S(identifier$0);
	if (stash$0 == null) {
		stash$0 = new _InlineOptimizeCommand$x2EStash();
		funcDef.setStash$SLStash$(identifier$0, stash$0);
	}
	stash = stash$0;
	if (stash$0.isInlineable == null) {
		stash.isInlineable = (function () {
			var statements;
			var requestsInline;
			statements = funcDef._statements;
			if (statements == null) {
				return false;
			}
			requestsInline = (funcDef._flags & 1024) !== 0;
			if (requestsInline) {
			} else if (! _InlineOptimizeCommand$_isWorthInline$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, funcDef)) {
				return false;
			}
			return Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
				if (statement instanceof ExpressionStatement || statement instanceof BreakStatement || statement instanceof ContinueStatement || statement instanceof CaseStatement || statement instanceof DefaultStatement || statement instanceof ThrowStatement || statement instanceof DebuggerStatement || statement instanceof LogStatement || statement instanceof AssertStatement || statement instanceof ForStatement || statement instanceof ForInStatement || statement instanceof DoWhileStatement || statement instanceof WhileStatement || statement instanceof IfStatement || statement instanceof SwitchStatement) {
				} else if (statement instanceof ReturnStatement && statement == MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef)[MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(funcDef).length - 1]) {
				} else {
					return false;
				}
				if (! Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
					if (expr instanceof FunctionExpression) {
						return false;
					} else if (expr instanceof SuperExpression) {
						return false;
					} else if (expr instanceof CallExpression && _DetermineCalleeCommand$getCallingFuncDef$LStashable$(expr) == funcDef) {
						return false;
					} else if (expr instanceof LocalExpression) {
						if (MemberFunctionDefinition$getFuncLocal$LMemberFunctionDefinition$(funcDef) != null && MemberFunctionDefinition$getFuncLocal$LMemberFunctionDefinition$(funcDef) == LocalExpression$getLocal$LLocalExpression$(expr)) {
							return false;
						}
					}
					return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
				}))) {
					return false;
				}
				return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
			}), funcDef._statements);
		})();
		message$0 = funcDef.getNotation$() + (stash.isInlineable ? " is" : " is not") + " inlineable";
		this$0$0 = $this._optimizer;
		message$0$0 = "[" + $this._identifier + "] " + message$0;
		this$0$0._log += message$0$0 + "\n";
	}
	return stash.isInlineable;
};

_InlineOptimizeCommand._functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$ = _InlineOptimizeCommand$_functionIsInlineable$L_InlineOptimizeCommand$LMemberFunctionDefinition$;

_InlineOptimizeCommand.prototype._expandCallingFunction$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$ = function (callerFuncDef, statements, stmtIndex, calleeFuncDef, argsAndThis) {
	var $this = this;
	var argsAndThisAndLocals;
	var calleeStatements;
	var i;
	var statement;
	var returnStatement;
	var onExpr;
	var message$0;
	var this$0$0;
	var message$0$0;
	message$0 = "expanding " + calleeFuncDef.getNotation$();
	this$0$0 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	argsAndThisAndLocals = argsAndThis.concat([  ]);
	_InlineOptimizeCommand$_createVarsAndInit$L_InlineOptimizeCommand$LMemberFunctionDefinition$LMemberFunctionDefinition$ALExpression$F$LExpression$V$(this, callerFuncDef, calleeFuncDef, argsAndThisAndLocals, (function (expr) {
		statements.splice(stmtIndex++, 0, new ExpressionStatement(expr));
	}));
	calleeStatements = calleeFuncDef._statements;
	for (i = 0; i < calleeStatements.length; ++i) {
		if (calleeStatements[i] instanceof ReturnStatement) {
			returnStatement = calleeStatements[i];
			if (returnStatement._expr == null) {
				continue;
			}
			statement = new ExpressionStatement(returnStatement._expr.clone$());
		} else {
			statement = calleeStatements[i].clone$();
		}
		function onExpr(expr, replaceCb) {
			return _InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$($this, expr, null, replaceCb, argsAndThisAndLocals, calleeFuncDef);
		}
		statement.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		Statement$forEachStatement$LStatement$F$LStatement$B$(statement, (function onStatement(statement) {
			Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		}));
		statements.splice(stmtIndex++, 0, statement);
	}
	return stmtIndex;
};


function _InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$($this, callerFuncDef, statements, stmtIndex, calleeFuncDef, argsAndThis) {
	var argsAndThisAndLocals;
	var calleeStatements;
	var i;
	var statement;
	var returnStatement;
	var onExpr;
	var message$0;
	var this$0$0;
	var message$0$0;
	message$0 = "expanding " + calleeFuncDef.getNotation$();
	this$0$0 = $this._optimizer;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	argsAndThisAndLocals = argsAndThis.concat([  ]);
	_InlineOptimizeCommand$_createVarsAndInit$L_InlineOptimizeCommand$LMemberFunctionDefinition$LMemberFunctionDefinition$ALExpression$F$LExpression$V$($this, callerFuncDef, calleeFuncDef, argsAndThisAndLocals, (function (expr) {
		statements.splice(stmtIndex++, 0, new ExpressionStatement(expr));
	}));
	calleeStatements = calleeFuncDef._statements;
	for (i = 0; i < calleeStatements.length; ++i) {
		if (calleeStatements[i] instanceof ReturnStatement) {
			returnStatement = calleeStatements[i];
			if (returnStatement._expr == null) {
				continue;
			}
			statement = new ExpressionStatement(returnStatement._expr.clone$());
		} else {
			statement = calleeStatements[i].clone$();
		}
		function onExpr(expr, replaceCb) {
			return _InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$($this, expr, null, replaceCb, argsAndThisAndLocals, calleeFuncDef);
		}
		statement.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		Statement$forEachStatement$LStatement$F$LStatement$B$(statement, (function onStatement(statement) {
			Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		}));
		statements.splice(stmtIndex++, 0, statement);
	}
	return stmtIndex;
};

_InlineOptimizeCommand._expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$ = _InlineOptimizeCommand$_expandCallingFunction$L_InlineOptimizeCommand$LMemberFunctionDefinition$ALStatement$NLMemberFunctionDefinition$ALExpression$;

_InlineOptimizeCommand.prototype._expandCallAsExpression$LMemberFunctionDefinition$LExpression$ALExpression$F$LExpression$V$ = function (funcDef, expr, argsAndThisAndLocals, replaceCb) {
	var $this = this;
	var callingFuncDef;
	var statements;
	var returnStatement;
	var i;
	var singleExpr;
	var stmt;
	var setupArgs;
	var clonedExpr;
	var stash$0;
	var this$0;
	var this$1;
	var message$0;
	var this$0$0;
	var message$0$0;
	var statements$len$0;
	stash$0 = expr.getStash$S("determine-callee");
	if (stash$0 == null) {
		throw new Error("callee not searched");
	}
	callingFuncDef = stash$0.callingFuncDef;
	statements = callingFuncDef._statements;
	if (statements.length === 0) {
		return false;
	} else if (statements.length !== 1) {
		statements = statements.concat([  ]);
		if (statements[statements.length - 1] instanceof ReturnStatement) {
			returnStatement = statements.pop();
			if (returnStatement._expr == null) {
				returnStatement = null;
			}
		} else {
			returnStatement = null;
		}
		for ((i = 0, statements$len$0 = statements.length); i < statements$len$0; ++i) {
			if (! (statements[i] instanceof ExpressionStatement)) {
				return false;
			}
		}
		singleExpr = statements.reduce((function (prevExpr, stmt) {
			var this$0;
			var this$1;
			return (prevExpr == null ? (this$0 = stmt, this$0._expr) : new CommaExpression(new Token$3(","), prevExpr, (this$1 = stmt, this$1._expr)));
		}), null);
		if (returnStatement) {
			singleExpr = new CommaExpression(new Token$3(","), singleExpr, returnStatement._expr);
			statements.splice(0, statements.length, new ReturnStatement(new Token$3("return"), singleExpr));
		} else {
			statements.splice(0, statements.length, new ExpressionStatement(singleExpr));
		}
	}
	stmt = statements[0];
	if (stmt instanceof ExpressionStatement) {
		this$0 = stmt;
		expr = this$0._expr;
	} else if (stmt instanceof ReturnStatement) {
		this$1 = stmt;
		expr = this$1._expr;
	} else {
		return false;
	}
	message$0 = "expanding " + callingFuncDef.getNotation$() + " as expression";
	this$0$0 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	setupArgs = null;
	_InlineOptimizeCommand$_createVarsAndInit$L_InlineOptimizeCommand$LMemberFunctionDefinition$LMemberFunctionDefinition$ALExpression$F$LExpression$V$(this, funcDef, callingFuncDef, argsAndThisAndLocals, (function (expr) {
		if (setupArgs == null) {
			setupArgs = expr;
		} else {
			setupArgs = new CommaExpression(new Token$3(","), setupArgs, expr);
		}
	}));
	clonedExpr = expr.clone$();
	_InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$(this, clonedExpr, null, (function (expr) {
		clonedExpr = expr;
	}), argsAndThisAndLocals, callingFuncDef);
	if (setupArgs != null) {
		clonedExpr = new CommaExpression(new Token$3(","), setupArgs, clonedExpr);
	}
	replaceCb(clonedExpr);
	return true;
};


function _InlineOptimizeCommand$_expandCallAsExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$LExpression$ALExpression$F$LExpression$V$($this, funcDef, expr, argsAndThisAndLocals, replaceCb) {
	var callingFuncDef;
	var statements;
	var returnStatement;
	var i;
	var singleExpr;
	var stmt;
	var setupArgs;
	var clonedExpr;
	var stash$0;
	var this$0;
	var this$1;
	var message$0;
	var this$0$0;
	var message$0$0;
	var statements$len$0;
	stash$0 = expr.getStash$S("determine-callee");
	if (stash$0 == null) {
		throw new Error("callee not searched");
	}
	callingFuncDef = stash$0.callingFuncDef;
	statements = callingFuncDef._statements;
	if (statements.length === 0) {
		return false;
	} else if (statements.length !== 1) {
		statements = statements.concat([  ]);
		if (statements[statements.length - 1] instanceof ReturnStatement) {
			returnStatement = statements.pop();
			if (returnStatement._expr == null) {
				returnStatement = null;
			}
		} else {
			returnStatement = null;
		}
		for ((i = 0, statements$len$0 = statements.length); i < statements$len$0; ++i) {
			if (! (statements[i] instanceof ExpressionStatement)) {
				return false;
			}
		}
		singleExpr = statements.reduce((function (prevExpr, stmt) {
			var this$0;
			var this$1;
			return (prevExpr == null ? (this$0 = stmt, this$0._expr) : new CommaExpression(new Token$3(","), prevExpr, (this$1 = stmt, this$1._expr)));
		}), null);
		if (returnStatement) {
			singleExpr = new CommaExpression(new Token$3(","), singleExpr, returnStatement._expr);
			statements.splice(0, statements.length, new ReturnStatement(new Token$3("return"), singleExpr));
		} else {
			statements.splice(0, statements.length, new ExpressionStatement(singleExpr));
		}
	}
	stmt = statements[0];
	if (stmt instanceof ExpressionStatement) {
		this$0 = stmt;
		expr = this$0._expr;
	} else if (stmt instanceof ReturnStatement) {
		this$1 = stmt;
		expr = this$1._expr;
	} else {
		return false;
	}
	message$0 = "expanding " + callingFuncDef.getNotation$() + " as expression";
	this$0$0 = $this._optimizer;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	setupArgs = null;
	_InlineOptimizeCommand$_createVarsAndInit$L_InlineOptimizeCommand$LMemberFunctionDefinition$LMemberFunctionDefinition$ALExpression$F$LExpression$V$($this, funcDef, callingFuncDef, argsAndThisAndLocals, (function (expr) {
		if (setupArgs == null) {
			setupArgs = expr;
		} else {
			setupArgs = new CommaExpression(new Token$3(","), setupArgs, expr);
		}
	}));
	clonedExpr = expr.clone$();
	_InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$($this, clonedExpr, null, (function (expr) {
		clonedExpr = expr;
	}), argsAndThisAndLocals, callingFuncDef);
	if (setupArgs != null) {
		clonedExpr = new CommaExpression(new Token$3(","), setupArgs, clonedExpr);
	}
	replaceCb(clonedExpr);
	return true;
};

_InlineOptimizeCommand._expandCallAsExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$LExpression$ALExpression$F$LExpression$V$ = _InlineOptimizeCommand$_expandCallAsExpression$L_InlineOptimizeCommand$LMemberFunctionDefinition$LExpression$ALExpression$F$LExpression$V$;

_InlineOptimizeCommand.prototype._createVarsAndInit$LMemberFunctionDefinition$LMemberFunctionDefinition$ALExpression$F$LExpression$V$ = function (callerFuncDef, calleeFuncDef, argsAndThisAndLocals, initArgExpr) {
	var $this = this;
	var exprIsInlineableFor;
	var createVarWithInit;
	var argUsed;
	var thisIdx;
	var recvExpr;
	var formalArgs;
	var i;
	var numberOfUsed;
	var argExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	function exprIsInlineableFor(expr) {
		var min;
		var this$0;
		var this$1;
		if (expr instanceof LocalExpression) {
			return -1;
		} else if (expr instanceof FunctionExpression) {
			return 1;
		} else if (expr instanceof PropertyExpression && (this$0 = expr, this$0._expr) instanceof ClassExpression && ! (this$1 = expr, this$1._type).isAssignable$()) {
			return Infinity;
		} else if (expr instanceof LeafExpression || expr instanceof LogicalNotExpression || expr instanceof BitwiseNotExpression || expr instanceof SignExpression || expr instanceof AdditiveExpression || expr instanceof EqualityExpression || expr instanceof ShiftExpression || expr instanceof MapLiteralExpression || expr instanceof ArrayLiteralExpression) {
			min = 1;
			Expression$forEachExpression$LExpression$F$LExpression$B$(expr, (function (expr) {
				min = Math.min(min, exprIsInlineableFor(expr));
				return min > 0;
			}));
			return min;
		} else {
			return -1;
		}
	}
	function createVarWithInit(funcDef, type, baseName, initExpr) {
		var tempVar;
		tempVar = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, type, baseName);
		initArgExpr(new AssignmentExpression(new Token$3("="), new LocalExpression(tempVar._name, tempVar), initExpr));
		return new LocalExpression(tempVar._name, tempVar);
	}
	argUsed = _InlineOptimizeCommand$_countNumberOfArgsUsed$L_InlineOptimizeCommand$LMemberFunctionDefinition$(this, calleeFuncDef);
	if ((calleeFuncDef._flags & 8) === 0) {
		thisIdx = argsAndThisAndLocals.length - 1;
		recvExpr = argsAndThisAndLocals[thisIdx];
		if (! (recvExpr instanceof LeafExpression || argUsed["this"] <= exprIsInlineableFor(recvExpr))) {
			argsAndThisAndLocals[thisIdx] = createVarWithInit(callerFuncDef, new ObjectType(calleeFuncDef._classDef), "this", recvExpr);
		}
	}
	formalArgs = calleeFuncDef._args;
	for (i = 0; i < formalArgs.length; ++i) {
		numberOfUsed = argUsed[(this$1 = (this$0 = formalArgs[i], this$0._name), this$1._value)];
		argExpr = argsAndThisAndLocals[i];
		if (numberOfUsed === -Infinity || ! (argExpr instanceof LeafExpression || numberOfUsed <= exprIsInlineableFor(argExpr))) {
			argsAndThisAndLocals[i] = createVarWithInit(callerFuncDef, (this$2 = formalArgs[i], this$2._type), (this$4 = (this$3 = formalArgs[i], this$3._name), this$4._value), argExpr);
		}
	}
	calleeFuncDef._locals.forEach((function (local) {
		var tempVar;
		var this$0;
		tempVar = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, callerFuncDef, local._type, (this$0 = local._name, this$0._value));
		argsAndThisAndLocals.push(new LocalExpression(tempVar._name, tempVar));
	}));
};


function _InlineOptimizeCommand$_createVarsAndInit$L_InlineOptimizeCommand$LMemberFunctionDefinition$LMemberFunctionDefinition$ALExpression$F$LExpression$V$($this, callerFuncDef, calleeFuncDef, argsAndThisAndLocals, initArgExpr) {
	var exprIsInlineableFor;
	var createVarWithInit;
	var argUsed;
	var thisIdx;
	var recvExpr;
	var formalArgs;
	var i;
	var numberOfUsed;
	var argExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	function exprIsInlineableFor(expr) {
		var min;
		var this$0;
		var this$1;
		if (expr instanceof LocalExpression) {
			return -1;
		} else if (expr instanceof FunctionExpression) {
			return 1;
		} else if (expr instanceof PropertyExpression && (this$0 = expr, this$0._expr) instanceof ClassExpression && ! (this$1 = expr, this$1._type).isAssignable$()) {
			return Infinity;
		} else if (expr instanceof LeafExpression || expr instanceof LogicalNotExpression || expr instanceof BitwiseNotExpression || expr instanceof SignExpression || expr instanceof AdditiveExpression || expr instanceof EqualityExpression || expr instanceof ShiftExpression || expr instanceof MapLiteralExpression || expr instanceof ArrayLiteralExpression) {
			min = 1;
			Expression$forEachExpression$LExpression$F$LExpression$B$(expr, (function (expr) {
				min = Math.min(min, exprIsInlineableFor(expr));
				return min > 0;
			}));
			return min;
		} else {
			return -1;
		}
	}
	function createVarWithInit(funcDef, type, baseName, initExpr) {
		var tempVar;
		tempVar = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, type, baseName);
		initArgExpr(new AssignmentExpression(new Token$3("="), new LocalExpression(tempVar._name, tempVar), initExpr));
		return new LocalExpression(tempVar._name, tempVar);
	}
	argUsed = _InlineOptimizeCommand$_countNumberOfArgsUsed$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, calleeFuncDef);
	if ((calleeFuncDef._flags & 8) === 0) {
		thisIdx = argsAndThisAndLocals.length - 1;
		recvExpr = argsAndThisAndLocals[thisIdx];
		if (! (recvExpr instanceof LeafExpression || argUsed["this"] <= exprIsInlineableFor(recvExpr))) {
			argsAndThisAndLocals[thisIdx] = createVarWithInit(callerFuncDef, new ObjectType(calleeFuncDef._classDef), "this", recvExpr);
		}
	}
	formalArgs = calleeFuncDef._args;
	for (i = 0; i < formalArgs.length; ++i) {
		numberOfUsed = argUsed[(this$1 = (this$0 = formalArgs[i], this$0._name), this$1._value)];
		argExpr = argsAndThisAndLocals[i];
		if (numberOfUsed === -Infinity || ! (argExpr instanceof LeafExpression || numberOfUsed <= exprIsInlineableFor(argExpr))) {
			argsAndThisAndLocals[i] = createVarWithInit(callerFuncDef, (this$2 = formalArgs[i], this$2._type), (this$4 = (this$3 = formalArgs[i], this$3._name), this$4._value), argExpr);
		}
	}
	calleeFuncDef._locals.forEach((function (local) {
		var tempVar;
		var this$0;
		tempVar = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, callerFuncDef, local._type, (this$0 = local._name, this$0._value));
		argsAndThisAndLocals.push(new LocalExpression(tempVar._name, tempVar));
	}));
};

_InlineOptimizeCommand._createVarsAndInit$L_InlineOptimizeCommand$LMemberFunctionDefinition$LMemberFunctionDefinition$ALExpression$F$LExpression$V$ = _InlineOptimizeCommand$_createVarsAndInit$L_InlineOptimizeCommand$LMemberFunctionDefinition$LMemberFunctionDefinition$ALExpression$F$LExpression$V$;

_InlineOptimizeCommand.prototype._rewriteExpression$LExpression$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$ = function (expr, parentExpr, replaceCb, argsAndThisAndLocals, calleeFuncDef) {
	var $this = this;
	var formalArgs;
	var localExpr;
	var j;
	var locals;
	var k;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	var formalArgs$len$0;
	var locals$len$0;
	formalArgs = calleeFuncDef._args;
	if (expr instanceof LocalExpression) {
		localExpr = expr;
		for ((j = 0, formalArgs$len$0 = formalArgs.length); j < formalArgs$len$0; ++j) {
			if ((this$1 = (this$0 = formalArgs[j], this$0._name), this$1._value) === (this$3 = (this$2 = localExpr._local, this$2._name), this$3._value)) {
				break;
			}
		}
		if (j === formalArgs.length) {
			++j;
			locals = calleeFuncDef._locals;
			for ((k = 0, locals$len$0 = locals.length); k < locals$len$0; (++k, ++j)) {
				if ((this$5 = (this$4 = locals[k], this$4._name), this$5._value) === (this$7 = (this$6 = localExpr._local, this$6._name), this$7._value)) {
					break;
				}
			}
		}
		if (j !== argsAndThisAndLocals.length) {
			if (argsAndThisAndLocals[j] instanceof FunctionExpression) {
				replaceCb(argsAndThisAndLocals[j]);
				argsAndThisAndLocals[j] = null;
			} else {
				if (parentExpr != null && parentExpr instanceof AssignmentExpression && (this$8 = parentExpr, this$8._expr1) == expr && ! (argsAndThisAndLocals[j] instanceof LocalExpression)) {
					return true;
				}
				replaceCb(argsAndThisAndLocals[j].clone$());
			}
		}
	} else if (expr instanceof ThisExpression) {
		replaceCb(argsAndThisAndLocals[formalArgs.length].clone$());
	}
	expr.forEachExpression$F$LExpression$F$LExpression$V$B$((function (childExpr, replaceCb) {
		return _InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$($this, childExpr, expr, replaceCb, argsAndThisAndLocals, calleeFuncDef);
	}));
	return true;
};


function _InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$($this, expr, parentExpr, replaceCb, argsAndThisAndLocals, calleeFuncDef) {
	var formalArgs;
	var localExpr;
	var j;
	var locals;
	var k;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	var formalArgs$len$0;
	var locals$len$0;
	formalArgs = calleeFuncDef._args;
	if (expr instanceof LocalExpression) {
		localExpr = expr;
		for ((j = 0, formalArgs$len$0 = formalArgs.length); j < formalArgs$len$0; ++j) {
			if ((this$1 = (this$0 = formalArgs[j], this$0._name), this$1._value) === (this$3 = (this$2 = localExpr._local, this$2._name), this$3._value)) {
				break;
			}
		}
		if (j === formalArgs.length) {
			++j;
			locals = calleeFuncDef._locals;
			for ((k = 0, locals$len$0 = locals.length); k < locals$len$0; (++k, ++j)) {
				if ((this$5 = (this$4 = locals[k], this$4._name), this$5._value) === (this$7 = (this$6 = localExpr._local, this$6._name), this$7._value)) {
					break;
				}
			}
		}
		if (j !== argsAndThisAndLocals.length) {
			if (argsAndThisAndLocals[j] instanceof FunctionExpression) {
				replaceCb(argsAndThisAndLocals[j]);
				argsAndThisAndLocals[j] = null;
			} else {
				if (parentExpr != null && parentExpr instanceof AssignmentExpression && (this$8 = parentExpr, this$8._expr1) == expr && ! (argsAndThisAndLocals[j] instanceof LocalExpression)) {
					return true;
				}
				replaceCb(argsAndThisAndLocals[j].clone$());
			}
		}
	} else if (expr instanceof ThisExpression) {
		replaceCb(argsAndThisAndLocals[formalArgs.length].clone$());
	}
	expr.forEachExpression$F$LExpression$F$LExpression$V$B$((function (childExpr, replaceCb) {
		return _InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$($this, childExpr, expr, replaceCb, argsAndThisAndLocals, calleeFuncDef);
	}));
	return true;
};

_InlineOptimizeCommand._rewriteExpression$L_InlineOptimizeCommand$LExpression$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$ = _InlineOptimizeCommand$_rewriteExpression$L_InlineOptimizeCommand$LExpression$LExpression$F$LExpression$V$ALExpression$LMemberFunctionDefinition$;

_InlineOptimizeCommand.prototype._functionHasThis$LMemberFunctionDefinition$ = function (funcDef) {
	do {
		if ((funcDef._flags & 8) === 0) {
			return true;
		}
	} while ((funcDef = funcDef._parent) != null);
	return false;
};


function _InlineOptimizeCommand$_functionHasThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$($this, funcDef) {
	do {
		if ((funcDef._flags & 8) === 0) {
			return true;
		}
	} while ((funcDef = funcDef._parent) != null);
	return false;
};

_InlineOptimizeCommand._functionHasThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$ = _InlineOptimizeCommand$_functionHasThis$L_InlineOptimizeCommand$LMemberFunctionDefinition$;

function _StructuredStashAccessor$x2E$x3CStash$x3E$5() {
};

$__jsx_extend([_StructuredStashAccessor$x2E$x3CStash$x3E$5], Object);
_StructuredStashAccessor$x2E$x3CStash$x3E$5.prototype.$__jsx_implements__StructuredStashAccessor$x2E$x3CStash$x3E$5 = true;

_StructuredStashAccessor$x2E$x3CStash$x3E$5.prototype.getStash$LStashable$ = function (stashable) {
	var identifier;
	var stash;
	identifier = this._identifier;
	stash = stashable.getStash$S(identifier);
	if (stash == null) {
		stash = new _UnboxOptimizeCommand$x2EStash();
		stashable.setStash$SLStash$(identifier, stash);
	}
	return stash;
};


_StructuredStashAccessor$x2E$x3CStash$x3E$5.prototype.resetStash$LStashable$ = function (stashable) {
	var identifier;
	identifier = this._identifier;
	stashable.setStash$SLStash$(identifier, null);
};


function _UnboxOptimizeCommand() {
	this._identifier = "unbox";
	this._optimizer = null;
	this._excludeNative = false;
};

$__jsx_extend([_UnboxOptimizeCommand], _FunctionOptimizeCommand);
$__jsx_merge_interface(_UnboxOptimizeCommand, _StructuredStashAccessor$x2E$x3CStash$x3E$5);

_UnboxOptimizeCommand.prototype.optimizeFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var locals;
	var i;
	var iMax;
	if (funcDef._statements == null) {
		return false;
	}
	locals = funcDef._locals;
	for ((i = 0, iMax = locals.length); i < iMax; ) {
		if (_UnboxOptimizeCommand$_optimizeLocal$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$(this, funcDef, locals[i])) {
			locals.splice(i, 1);
		} else {
			++i;
		}
	}
	return true;
};


_UnboxOptimizeCommand.prototype._optimizeLocal$LMemberFunctionDefinition$LLocalVariable$ = function (funcDef, local) {
	var $this = this;
	var foundNew;
	var onStatement;
	var canUnbox;
	if (! (local._type instanceof ObjectType)) {
		return false;
	}
	if (Util$rootIsNativeClass$LType$(local._type)) {
		return false;
	}
	foundNew = false;
	onStatement = (function (statement) {
		var onExpr;
		var newExpr;
		var this$0;
		var this$1;
		onExpr = (function (expr) {
			var baseExpr;
			if (expr instanceof PropertyExpression) {
				baseExpr = UnaryExpression$getExpr$LUnaryExpression$(expr);
				if (baseExpr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(baseExpr) == local) {
					if (! expr.getType$().isAssignable$()) {
						return false;
					}
					return true;
				}
			} else if (expr instanceof LocalExpression) {
				if (LocalExpression$getLocal$LLocalExpression$(expr) == local) {
					return false;
				}
			} else if (expr instanceof FunctionExpression) {
				return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		});
		newExpr = _UnboxOptimizeCommand$_statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$($this, statement, local);
		if (newExpr != null) {
			if (! newExpr._type.equals$LType$(local._type)) {
				return false;
			}
			if (! _UnboxOptimizeCommand$_newExpressionCanUnbox$L_UnboxOptimizeCommand$LExpression$($this, newExpr)) {
				return false;
			}
			if (! Expression$forEachExpression$LExpression$F$LExpression$B$(newExpr, onExpr)) {
				return false;
			}
			if (! Util$forEachExpression$F$LExpression$B$ALExpression$((function (expr) {
				return ! _Util$0$exprHasSideEffects$LExpression$(expr);
			}), newExpr._args)) {
				return false;
			}
			foundNew = true;
			return true;
		}
		if (statement instanceof FunctionStatement) {
			if (! (this$1 = (this$0 = statement, this$0._funcDef), Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$1._statements))) {
				return false;
			}
		}
		return (! Statement$forEachExpression$LStatement$F$LExpression$B$(statement, onExpr) ? false : Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement));
	});
	canUnbox = Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, funcDef._statements);
	if (canUnbox && foundNew) {
		_UnboxOptimizeCommand$_unboxVariable$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$(this, funcDef, local);
		return true;
	} else {
		return false;
	}
};


function _UnboxOptimizeCommand$_optimizeLocal$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$($this, funcDef, local) {
	var foundNew;
	var onStatement;
	var canUnbox;
	if (! (local._type instanceof ObjectType)) {
		return false;
	}
	if (Util$rootIsNativeClass$LType$(local._type)) {
		return false;
	}
	foundNew = false;
	onStatement = (function (statement) {
		var onExpr;
		var newExpr;
		var this$0;
		var this$1;
		onExpr = (function (expr) {
			var baseExpr;
			if (expr instanceof PropertyExpression) {
				baseExpr = UnaryExpression$getExpr$LUnaryExpression$(expr);
				if (baseExpr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(baseExpr) == local) {
					if (! expr.getType$().isAssignable$()) {
						return false;
					}
					return true;
				}
			} else if (expr instanceof LocalExpression) {
				if (LocalExpression$getLocal$LLocalExpression$(expr) == local) {
					return false;
				}
			} else if (expr instanceof FunctionExpression) {
				return MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStatement);
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		});
		newExpr = _UnboxOptimizeCommand$_statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$($this, statement, local);
		if (newExpr != null) {
			if (! newExpr._type.equals$LType$(local._type)) {
				return false;
			}
			if (! _UnboxOptimizeCommand$_newExpressionCanUnbox$L_UnboxOptimizeCommand$LExpression$($this, newExpr)) {
				return false;
			}
			if (! Expression$forEachExpression$LExpression$F$LExpression$B$(newExpr, onExpr)) {
				return false;
			}
			if (! Util$forEachExpression$F$LExpression$B$ALExpression$((function (expr) {
				return ! _Util$0$exprHasSideEffects$LExpression$(expr);
			}), newExpr._args)) {
				return false;
			}
			foundNew = true;
			return true;
		}
		if (statement instanceof FunctionStatement) {
			if (! (this$1 = (this$0 = statement, this$0._funcDef), Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, this$1._statements))) {
				return false;
			}
		}
		return (! Statement$forEachExpression$LStatement$F$LExpression$B$(statement, onExpr) ? false : Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement));
	});
	canUnbox = Util$forEachStatement$F$LStatement$B$ALStatement$(onStatement, funcDef._statements);
	if (canUnbox && foundNew) {
		_UnboxOptimizeCommand$_unboxVariable$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$($this, funcDef, local);
		return true;
	} else {
		return false;
	}
};

_UnboxOptimizeCommand._optimizeLocal$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$ = _UnboxOptimizeCommand$_optimizeLocal$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$;

_UnboxOptimizeCommand.prototype._newExpressionCanUnbox$LExpression$ = function (newExpr) {
	var $this = this;
	var ctor;
	var stash$0;
	var identifier$0;
	var stash$1;
	if ((newExpr.getType$().getClassDef$().flags$() & 16) !== 0) {
		return false;
	}
	stash$0 = newExpr.getStash$S("determine-callee");
	if (stash$0 == null) {
		throw new Error("callee not searched");
	}
	ctor = stash$0.callingFuncDef;
	identifier$0 = this._identifier;
	stash$1 = ctor.getStash$S(identifier$0);
	if (stash$1 == null) {
		stash$1 = new _UnboxOptimizeCommand$x2EStash();
		ctor.setStash$SLStash$(identifier$0, stash$1);
	}
	return (stash$1.canUnbox != null ? stash$1.canUnbox : stash$1.canUnbox = (function () {
		return (ctor._locals.length !== 0 ? false : Util$forEachStatement$F$LStatement$B$ALStatement$((function (statement) {
			var expr;
			var lhsExpr;
			if (! (statement instanceof ExpressionStatement)) {
				return false;
			}
			expr = UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$(statement);
			if (! (expr instanceof AssignmentExpression)) {
				return false;
			}
			lhsExpr = BinaryExpression$getFirstExpr$LBinaryExpression$(expr);
			if (! (lhsExpr instanceof PropertyExpression && UnaryExpression$getExpr$LUnaryExpression$(lhsExpr) instanceof ThisExpression)) {
				return false;
			}
			return (function onExpr(expr) {
				if (expr instanceof ThisExpression) {
					return false;
				} else if (expr instanceof FunctionExpression) {
					return false;
				}
				return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
			})(BinaryExpression$getSecondExpr$LBinaryExpression$(expr));
		}), ctor._statements));
	})());
};


function _UnboxOptimizeCommand$_newExpressionCanUnbox$L_UnboxOptimizeCommand$LExpression$($this, newExpr) {
	var ctor;
	var stash$0;
	var identifier$0;
	var stash$1;
	if ((newExpr.getType$().getClassDef$().flags$() & 16) !== 0) {
		return false;
	}
	stash$0 = newExpr.getStash$S("determine-callee");
	if (stash$0 == null) {
		throw new Error("callee not searched");
	}
	ctor = stash$0.callingFuncDef;
	identifier$0 = $this._identifier;
	stash$1 = ctor.getStash$S(identifier$0);
	if (stash$1 == null) {
		stash$1 = new _UnboxOptimizeCommand$x2EStash();
		ctor.setStash$SLStash$(identifier$0, stash$1);
	}
	return (stash$1.canUnbox != null ? stash$1.canUnbox : stash$1.canUnbox = (function () {
		return (ctor._locals.length !== 0 ? false : Util$forEachStatement$F$LStatement$B$ALStatement$((function (statement) {
			var expr;
			var lhsExpr;
			if (! (statement instanceof ExpressionStatement)) {
				return false;
			}
			expr = UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$(statement);
			if (! (expr instanceof AssignmentExpression)) {
				return false;
			}
			lhsExpr = BinaryExpression$getFirstExpr$LBinaryExpression$(expr);
			if (! (lhsExpr instanceof PropertyExpression && UnaryExpression$getExpr$LUnaryExpression$(lhsExpr) instanceof ThisExpression)) {
				return false;
			}
			return (function onExpr(expr) {
				if (expr instanceof ThisExpression) {
					return false;
				} else if (expr instanceof FunctionExpression) {
					return false;
				}
				return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
			})(BinaryExpression$getSecondExpr$LBinaryExpression$(expr));
		}), ctor._statements));
	})());
};

_UnboxOptimizeCommand._newExpressionCanUnbox$L_UnboxOptimizeCommand$LExpression$ = _UnboxOptimizeCommand$_newExpressionCanUnbox$L_UnboxOptimizeCommand$LExpression$;

_UnboxOptimizeCommand.prototype._unboxVariable$LMemberFunctionDefinition$LLocalVariable$ = function (funcDef, local) {
	var $this = this;
	var variableMap;
	var createLocalExpressionFor;
	var buildConstructingStatements;
	var onStatements;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	message$0 = "unboxing " + (this$0 = local._name, "'" + this$0._value + "'" + " at " + (this$0._filename || "<<unknown>>") + ":" + (this$0._lineNumber + "") + ":" + (this$0._columnNumber + ""));
	this$0$0 = this._optimizer;
	message$0$0 = "[" + this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	variableMap = {};
	ClassDefinition$forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$(local._type.getClassDef$(), (function (classDef) {
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (member) {
			if ((MemberDefinition$flags$LMemberDefinition$(member) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_ABSTRACT)) === 0) {
				variableMap[MemberDefinition$name$LMemberDefinition$(member)] = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, member.getType$(), Token$getValue$LToken$(LocalVariable$getName$LLocalVariable$(local)) + "$" + MemberDefinition$name$LMemberDefinition$(member));
			}
			return true;
		}));
		return true;
	}));
	createLocalExpressionFor = (function (propertyName) {
		var this$0;
		if (! variableMap[propertyName]) {
			throw new Error("could not find local variable for property name: " + propertyName);
		}
		return new LocalExpression((this$0 = variableMap[propertyName], this$0._name), variableMap[propertyName]);
	});
	buildConstructingStatements = (function (dstStatements, dstStatementIndex, newExpr) {
		var ctor;
		var stash$0;
		stash$0 = newExpr.getStash$S("determine-callee");
		if (stash$0 == null) {
			throw new Error("callee not searched");
		}
		ctor = stash$0.callingFuncDef;
		Util$forEachStatement$F$LStatement$B$ALStatement$((function (statement) {
			var propertyName;
			var rhsExpr;
			var onExpr;
			propertyName = Token$getValue$LToken$(PropertyExpression$getIdentifierToken$LPropertyExpression$(BinaryExpression$getFirstExpr$LBinaryExpression$(UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$(statement))));
			rhsExpr = BinaryExpression$getSecondExpr$LBinaryExpression$(UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$(statement)).clone$();
			onExpr = (function (expr, replaceCb) {
				var argIndex;
				if (expr instanceof LocalExpression) {
					for (argIndex = 0; argIndex < MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(ctor).length; ++argIndex) {
						if (LocalExpression$getLocal$LLocalExpression$(expr) == MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(ctor)[argIndex]) {
							break;
						}
					}
					if (argIndex === MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(ctor).length) {
						throw new Error("logic flaw, could not find the local in arguments");
					}
					replaceCb(NewExpression$getArguments$LNewExpression$(newExpr)[argIndex].clone$());
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			});
			onExpr(rhsExpr, (function (expr) {
				rhsExpr = expr;
			}));
			dstStatements.splice(dstStatementIndex++, 0, new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), createLocalExpressionFor(propertyName), rhsExpr)));
			return true;
		}), ctor._statements);
		return dstStatementIndex;
	});
	onStatements = (function (statements) {
		var statementIndex;
		var onExpr;
		var newExpr;
		var this$0;
		var this$1;
		for (statementIndex = 0; statementIndex < statements.length; ) {
			onExpr = (function (expr, replaceCb) {
				if (expr instanceof PropertyExpression && UnaryExpression$getExpr$LUnaryExpression$(expr) instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(UnaryExpression$getExpr$LUnaryExpression$(expr)) == local) {
					replaceCb(createLocalExpressionFor(Token$getValue$LToken$(PropertyExpression$getIdentifierToken$LPropertyExpression$(expr))));
					return true;
				} else if (expr instanceof FunctionExpression) {
					return onStatements(MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(FunctionExpression$getFuncDef$LFunctionExpression$(expr)));
				} else if (expr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(expr) == local) {
					throw new Error("logic flaw, unexpected pattern");
				}
				expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
				return true;
			});
			if (statements[statementIndex] instanceof FunctionStatement) {
				onStatements((this$1 = (this$0 = statements[statementIndex], this$0._funcDef), this$1._statements));
				++statementIndex;
			} else {
				newExpr = _UnboxOptimizeCommand$_statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$($this, statements[statementIndex], local);
				if (newExpr != null) {
					statements.splice(statementIndex, 1);
					statementIndex = buildConstructingStatements(statements, statementIndex, newExpr);
				} else {
					statements[statementIndex].forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
					statements[statementIndex].handleStatements$F$ALStatement$B$(onStatements);
					++statementIndex;
				}
			}
		}
		return true;
	});
	onStatements(funcDef._statements);
};


function _UnboxOptimizeCommand$_unboxVariable$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$($this, funcDef, local) {
	var variableMap;
	var createLocalExpressionFor;
	var buildConstructingStatements;
	var onStatements;
	var message$0;
	var this$0$0;
	var message$0$0;
	var this$0;
	message$0 = "unboxing " + (this$0 = local._name, "'" + this$0._value + "'" + " at " + (this$0._filename || "<<unknown>>") + ":" + (this$0._lineNumber + "") + ":" + (this$0._columnNumber + ""));
	this$0$0 = $this._optimizer;
	message$0$0 = "[" + $this._identifier + "] " + message$0;
	this$0$0._log += message$0$0 + "\n";
	variableMap = {};
	ClassDefinition$forEachClassFromBase$LClassDefinition$F$LClassDefinition$B$(local._type.getClassDef$(), (function (classDef) {
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (member) {
			if ((MemberDefinition$flags$LMemberDefinition$(member) & (ClassDefinition.IS_STATIC | ClassDefinition.IS_ABSTRACT)) === 0) {
				variableMap[MemberDefinition$name$LMemberDefinition$(member)] = _OptimizeCommand$createVar$L_OptimizeCommand$LMemberFunctionDefinition$LType$S($this, funcDef, member.getType$(), Token$getValue$LToken$(LocalVariable$getName$LLocalVariable$(local)) + "$" + MemberDefinition$name$LMemberDefinition$(member));
			}
			return true;
		}));
		return true;
	}));
	createLocalExpressionFor = (function (propertyName) {
		var this$0;
		if (! variableMap[propertyName]) {
			throw new Error("could not find local variable for property name: " + propertyName);
		}
		return new LocalExpression((this$0 = variableMap[propertyName], this$0._name), variableMap[propertyName]);
	});
	buildConstructingStatements = (function (dstStatements, dstStatementIndex, newExpr) {
		var ctor;
		var stash$0;
		stash$0 = newExpr.getStash$S("determine-callee");
		if (stash$0 == null) {
			throw new Error("callee not searched");
		}
		ctor = stash$0.callingFuncDef;
		Util$forEachStatement$F$LStatement$B$ALStatement$((function (statement) {
			var propertyName;
			var rhsExpr;
			var onExpr;
			propertyName = Token$getValue$LToken$(PropertyExpression$getIdentifierToken$LPropertyExpression$(BinaryExpression$getFirstExpr$LBinaryExpression$(UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$(statement))));
			rhsExpr = BinaryExpression$getSecondExpr$LBinaryExpression$(UnaryExpressionStatement$getExpr$LUnaryExpressionStatement$(statement)).clone$();
			onExpr = (function (expr, replaceCb) {
				var argIndex;
				if (expr instanceof LocalExpression) {
					for (argIndex = 0; argIndex < MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(ctor).length; ++argIndex) {
						if (LocalExpression$getLocal$LLocalExpression$(expr) == MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(ctor)[argIndex]) {
							break;
						}
					}
					if (argIndex === MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(ctor).length) {
						throw new Error("logic flaw, could not find the local in arguments");
					}
					replaceCb(NewExpression$getArguments$LNewExpression$(newExpr)[argIndex].clone$());
				}
				return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
			});
			onExpr(rhsExpr, (function (expr) {
				rhsExpr = expr;
			}));
			dstStatements.splice(dstStatementIndex++, 0, new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), createLocalExpressionFor(propertyName), rhsExpr)));
			return true;
		}), ctor._statements);
		return dstStatementIndex;
	});
	onStatements = (function (statements) {
		var statementIndex;
		var onExpr;
		var newExpr;
		var this$0;
		var this$1;
		for (statementIndex = 0; statementIndex < statements.length; ) {
			onExpr = (function (expr, replaceCb) {
				if (expr instanceof PropertyExpression && UnaryExpression$getExpr$LUnaryExpression$(expr) instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(UnaryExpression$getExpr$LUnaryExpression$(expr)) == local) {
					replaceCb(createLocalExpressionFor(Token$getValue$LToken$(PropertyExpression$getIdentifierToken$LPropertyExpression$(expr))));
					return true;
				} else if (expr instanceof FunctionExpression) {
					return onStatements(MemberFunctionDefinition$getStatements$LMemberFunctionDefinition$(FunctionExpression$getFuncDef$LFunctionExpression$(expr)));
				} else if (expr instanceof LocalExpression && LocalExpression$getLocal$LLocalExpression$(expr) == local) {
					throw new Error("logic flaw, unexpected pattern");
				}
				expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
				return true;
			});
			if (statements[statementIndex] instanceof FunctionStatement) {
				onStatements((this$1 = (this$0 = statements[statementIndex], this$0._funcDef), this$1._statements));
				++statementIndex;
			} else {
				newExpr = _UnboxOptimizeCommand$_statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$($this, statements[statementIndex], local);
				if (newExpr != null) {
					statements.splice(statementIndex, 1);
					statementIndex = buildConstructingStatements(statements, statementIndex, newExpr);
				} else {
					statements[statementIndex].forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
					statements[statementIndex].handleStatements$F$ALStatement$B$(onStatements);
					++statementIndex;
				}
			}
		}
		return true;
	});
	onStatements(funcDef._statements);
};

_UnboxOptimizeCommand._unboxVariable$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$ = _UnboxOptimizeCommand$_unboxVariable$L_UnboxOptimizeCommand$LMemberFunctionDefinition$LLocalVariable$;

_UnboxOptimizeCommand.prototype._statementIsConstructingTheLocal$LStatement$LLocalVariable$ = function (statement, local) {
	var expr;
	var lhsExpr;
	var rhsExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	if (! (statement instanceof ExpressionStatement)) {
		return null;
	}
	this$0 = statement;
	expr = this$0._expr;
	if (! (expr instanceof AssignmentExpression)) {
		return null;
	}
	this$1 = expr;
	lhsExpr = this$1._expr1;
	if (! (lhsExpr instanceof LocalExpression)) {
		return null;
	}
	if ((this$2 = lhsExpr, this$2._local) != local) {
		return null;
	}
	this$3 = expr;
	rhsExpr = this$3._expr2;
	return (! (rhsExpr instanceof NewExpression) ? null : rhsExpr);
};


function _UnboxOptimizeCommand$_statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$($this, statement, local) {
	var expr;
	var lhsExpr;
	var rhsExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	if (! (statement instanceof ExpressionStatement)) {
		return null;
	}
	this$0 = statement;
	expr = this$0._expr;
	if (! (expr instanceof AssignmentExpression)) {
		return null;
	}
	this$1 = expr;
	lhsExpr = this$1._expr1;
	if (! (lhsExpr instanceof LocalExpression)) {
		return null;
	}
	if ((this$2 = lhsExpr, this$2._local) != local) {
		return null;
	}
	this$3 = expr;
	rhsExpr = this$3._expr2;
	return (! (rhsExpr instanceof NewExpression) ? null : rhsExpr);
};

_UnboxOptimizeCommand._statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$ = _UnboxOptimizeCommand$_statementIsConstructingTheLocal$L_UnboxOptimizeCommand$LStatement$LLocalVariable$;

function _StructuredStashAccessor$x2E$x3CStash$x3E$6() {
};

$__jsx_extend([_StructuredStashAccessor$x2E$x3CStash$x3E$6], Object);
_StructuredStashAccessor$x2E$x3CStash$x3E$6.prototype.$__jsx_implements__StructuredStashAccessor$x2E$x3CStash$x3E$6 = true;

_StructuredStashAccessor$x2E$x3CStash$x3E$6.prototype.getStash$LStashable$ = function (stashable) {
	var identifier;
	var stash;
	identifier = this._identifier;
	stash = stashable.getStash$S(identifier);
	if (stash == null) {
		stash = new _NoDebugCommand$x2EStash();
		stashable.setStash$SLStash$(identifier, stash);
	}
	return stash;
};


_StructuredStashAccessor$x2E$x3CStash$x3E$6.prototype.resetStash$LStashable$ = function (stashable) {
	var identifier;
	identifier = this._identifier;
	stashable.setStash$SLStash$(identifier, null);
};


function _NoDebugCommand() {
	this._identifier = "no-debug";
	this._optimizer = null;
};

$__jsx_extend([_NoDebugCommand], _OptimizeCommand);
$__jsx_merge_interface(_NoDebugCommand, _StructuredStashAccessor$x2E$x3CStash$x3E$6);

_NoDebugCommand.prototype.performOptimization$ = function () {
	var $this = this;
	var stash;
	var stashable$0;
	var identifier$0;
	var stash$0;
	var this$0$0;
	var this$0;
	var this$0$1;
	this$0$1 = this._optimizer;
	this$0 = this$0$1._compiler;
	stashable$0 = this$0._emitter;
	identifier$0 = this._identifier;
	stash$0 = stashable$0.getStash$S(identifier$0);
	if (stash$0 == null) {
		stash$0 = new _NoDebugCommand$x2EStash();
		stashable$0.setStash$SLStash$(identifier$0, stash$0);
	}
	stash = stash$0;
	stash$0.debugValue = false;
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$((this$0$0 = this._optimizer, this$0$0._compiler), (function (parser, classDef) {
		if (classDef.className$() === "JSX") {
			ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (memberVariable) {
				var falseExpr;
				if (MemberDefinition$name$LMemberDefinition$(memberVariable) === "DEBUG" && (MemberDefinition$flags$LMemberDefinition$(memberVariable) & ClassDefinition.IS_STATIC) !== 0) {
					_OptimizeCommand$log$L_OptimizeCommand$S($this, "set JSX.DEBUG = " + (stash.debugValue + ""));
					falseExpr = new BooleanLiteralExpression(new Token$2(stash.debugValue + "", true));
					MemberVariableDefinition$setInitialValue$LMemberVariableDefinition$LExpression$(memberVariable, falseExpr);
					return false;
				}
				return true;
			}));
			return false;
		}
		return true;
	}));
};


function Compiler(platform) {
	this._searchPaths = null;
	this._builtinParsers = null;
	this._userEnvironment = null;
	this._emitter = null;
	this._npmModulesParsed = {};
	this._packageJsonCache = {};
	this._platform = platform;
	this._mode = 0;
	this._transformCommands = [  ];
	this._optimizer = null;
	this._warningFilters = [  ];
	this._warningAsError = false;
	this._parsers = [];
	this._fileCache = {};
	this._searchPaths = [ this._platform.getRoot$() + "/lib/common" ];
	Compiler$addSourceFile$LCompiler$LToken$S(this, null, this._platform.getRoot$() + "/lib/built-in.jsx");
	this._builtinParsers = this._parsers.concat([]);
	this._userEnvironment = {};
};

$__jsx_extend([Compiler], Object);
Compiler.prototype.addSearchPath$S = function (path) {
	this._searchPaths.unshift(path);
};


function Compiler$addSearchPath$LCompiler$S($this, path) {
	$this._searchPaths.unshift(path);
};

Compiler.addSearchPath$LCompiler$S = Compiler$addSearchPath$LCompiler$S;

Compiler.prototype.getPlatform$ = function () {
	return this._platform;
};


function Compiler$getPlatform$LCompiler$($this) {
	return $this._platform;
};

Compiler.getPlatform$LCompiler$ = Compiler$getPlatform$LCompiler$;

Compiler.prototype.getMode$ = function () {
	return this._mode;
};


function Compiler$getMode$LCompiler$($this) {
	return $this._mode;
};

Compiler.getMode$LCompiler$ = Compiler$getMode$LCompiler$;

Compiler.prototype.setMode$N = function (mode) {
	this._mode = mode;
	return this;
};


function Compiler$setMode$LCompiler$N($this, mode) {
	$this._mode = mode;
	return $this;
};

Compiler.setMode$LCompiler$N = Compiler$setMode$LCompiler$N;

Compiler.prototype.getEmitter$ = function () {
	return this._emitter;
};


function Compiler$getEmitter$LCompiler$($this) {
	return $this._emitter;
};

Compiler.getEmitter$LCompiler$ = Compiler$getEmitter$LCompiler$;

Compiler.prototype.setEmitter$LEmitter$ = function (emitter) {
	this._emitter = emitter;
};


function Compiler$setEmitter$LCompiler$LEmitter$($this, emitter) {
	$this._emitter = emitter;
};

Compiler.setEmitter$LCompiler$LEmitter$ = Compiler$setEmitter$LCompiler$LEmitter$;

Compiler.prototype.setTransformCommands$AS = function (cmds) {
	var i;
	var cmd;
	for (i = 0; i < cmds.length; ++i) {
		cmd = cmds[i];
		switch (cmd) {
		case "generator":
			this._transformCommands.push(new GeneratorTransformCommand(this));
			break;
		case "cps":
			this._transformCommands.push(new CPSTransformCommand(this));
			break;
		default:
			return "unknown transformation command: " + cmd;
		}
	}
	return null;
};


function Compiler$setTransformCommands$LCompiler$AS($this, cmds) {
	var i;
	var cmd;
	for (i = 0; i < cmds.length; ++i) {
		cmd = cmds[i];
		switch (cmd) {
		case "generator":
			$this._transformCommands.push(new GeneratorTransformCommand($this));
			break;
		case "cps":
			$this._transformCommands.push(new CPSTransformCommand($this));
			break;
		default:
			return "unknown transformation command: " + cmd;
		}
	}
	return null;
};

Compiler.setTransformCommands$LCompiler$AS = Compiler$setTransformCommands$LCompiler$AS;

Compiler.prototype.setOptimizer$LOptimizer$ = function (optimizer) {
	this._optimizer = optimizer;
};


function Compiler$setOptimizer$LCompiler$LOptimizer$($this, optimizer) {
	$this._optimizer = optimizer;
};

Compiler.setOptimizer$LCompiler$LOptimizer$ = Compiler$setOptimizer$LCompiler$LOptimizer$;

Compiler.prototype.getWarningFilters$ = function () {
	return this._warningFilters;
};


function Compiler$getWarningFilters$LCompiler$($this) {
	return $this._warningFilters;
};

Compiler.getWarningFilters$LCompiler$ = Compiler$getWarningFilters$LCompiler$;

Compiler.prototype.setWarningAsError$B = function (f) {
	this._warningAsError = f;
};


function Compiler$setWarningAsError$LCompiler$B($this, f) {
	$this._warningAsError = f;
};

Compiler.setWarningAsError$LCompiler$B = Compiler$setWarningAsError$LCompiler$B;

Compiler.prototype.getParsers$ = function () {
	return this._parsers;
};


function Compiler$getParsers$LCompiler$($this) {
	return $this._parsers;
};

Compiler.getParsers$LCompiler$ = Compiler$getParsers$LCompiler$;

Compiler.prototype.getBuiltinParsers$ = function () {
	return this._builtinParsers;
};


function Compiler$getBuiltinParsers$LCompiler$($this) {
	return $this._builtinParsers;
};

Compiler.getBuiltinParsers$LCompiler$ = Compiler$getBuiltinParsers$LCompiler$;

Compiler.prototype.getUserEnvironment$ = function () {
	return this._userEnvironment;
};


function Compiler$getUserEnvironment$LCompiler$($this) {
	return $this._userEnvironment;
};

Compiler.getUserEnvironment$LCompiler$ = Compiler$getUserEnvironment$LCompiler$;

Compiler.prototype.addSourceFile$LToken$S = function (token, path) {
	return Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$(this, token, path, null);
};


function Compiler$addSourceFile$LCompiler$LToken$S($this, token, path) {
	return Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$($this, token, path, null);
};

Compiler.addSourceFile$LCompiler$LToken$S = Compiler$addSourceFile$LCompiler$LToken$S;

Compiler.prototype.addSourceFile$LToken$SLCompletionRequest$ = function (token, path, completionRequest) {
	var parser;
	if ((parser = Compiler$findParser$LCompiler$S(this, path)) == null) {
		parser = ({_sourceToken: token, _filename: path, _completionRequest: completionRequest, _content: null, _lines: null, _tokenLength: 0, _lineNumber: 0, _columnOffset: 0, _fileLevelDocComment: null, _docComment: null, _errors: null, _templateClassDefs: null, _classDefs: null, _imports: null, _isGenerator: false, _locals: null, _statements: null, _closures: null, _outerClass: null, _classType: null, _extendType: null, _implementTypes: null, _objectTypesUsed: null, _inners: null, _templateInners: null, _templateInstantiationRequests: null, _prevScope: null, _funcLocal: null, _arguments: null, _classFlags: 0, _typeArgs: null});
		this._parsers.push(parser);
	}
	return parser;
};


function Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$($this, token, path, completionRequest) {
	var parser;
	if ((parser = Compiler$findParser$LCompiler$S($this, path)) == null) {
		parser = ({_sourceToken: token, _filename: path, _completionRequest: completionRequest, _content: null, _lines: null, _tokenLength: 0, _lineNumber: 0, _columnOffset: 0, _fileLevelDocComment: null, _docComment: null, _errors: null, _templateClassDefs: null, _classDefs: null, _imports: null, _isGenerator: false, _locals: null, _statements: null, _closures: null, _outerClass: null, _classType: null, _extendType: null, _implementTypes: null, _objectTypesUsed: null, _inners: null, _templateInners: null, _templateInstantiationRequests: null, _prevScope: null, _funcLocal: null, _arguments: null, _classFlags: 0, _typeArgs: null});
		$this._parsers.push(parser);
	}
	return parser;
};

Compiler.addSourceFile$LCompiler$LToken$SLCompletionRequest$ = Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$;

Compiler.prototype.findParser$S = function (path) {
	var i;
	var this$0;
	for (i = 0; i < this._parsers.length; ++i) {
		if ((this$0 = this._parsers[i], this$0._filename) === path) {
			return this._parsers[i];
		}
	}
	return null;
};


function Compiler$findParser$LCompiler$S($this, path) {
	var i;
	var this$0;
	for (i = 0; i < $this._parsers.length; ++i) {
		if ((this$0 = $this._parsers[i], this$0._filename) === path) {
			return $this._parsers[i];
		}
	}
	return null;
};

Compiler.findParser$LCompiler$S = Compiler$findParser$LCompiler$S;

Compiler.prototype.compile$ = function () {
	var errors;
	var i;
	var builtins;
	var this$0$0;
	errors = [];
	for (i = 0; i < this._parsers.length; ++i) {
		if (! Compiler$_parseFile$LCompiler$ALCompileError$N(this, errors, i)) {
			if (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors)) {
				return false;
			}
		}
	}
	switch (this._mode) {
	case 1:
		return true;
	}
	Compiler$normalizeClassDefs$LCompiler$ALCompileError$(this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors)) {
		return false;
	}
	Compiler$_resolveImports$LCompiler$ALCompileError$(this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors)) {
		return false;
	}
	builtins = this._builtinParsers[0];
	BooleanType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "Boolean");
	NumberType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "Number");
	StringType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "String");
	FunctionType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "Function");
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors)) {
		return false;
	}
	Compiler$_resolveTypes$LCompiler$ALCompileError$(this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors)) {
		return false;
	}
	Compiler$_exportEntryPoints$LCompiler$(this);
	Compiler$_analyze$LCompiler$ALCompileError$(this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors)) {
		return false;
	}
	switch (this._mode) {
	case 2:
		return true;
	case 3:
		return true;
	}
	Compiler$_transform$LCompiler$ALCompileError$(this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors)) {
		return false;
	}
	if (this._optimizer != null) {
		Optimizer$performOptimization$LOptimizer$((this$0$0 = this._optimizer, this$0$0._compiler = this, this$0$0));
	}
	Compiler$_generateCode$LCompiler$ALCompileError$(this, errors);
	return (! Compiler$_handleErrors$LCompiler$ALCompileError$(this, errors) ? false : true);
};


function Compiler$compile$LCompiler$($this) {
	var errors;
	var i;
	var builtins;
	var this$0$0;
	errors = [];
	for (i = 0; i < $this._parsers.length; ++i) {
		if (! Compiler$_parseFile$LCompiler$ALCompileError$N($this, errors, i)) {
			if (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors)) {
				return false;
			}
		}
	}
	switch ($this._mode) {
	case 1:
		return true;
	}
	Compiler$normalizeClassDefs$LCompiler$ALCompileError$($this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors)) {
		return false;
	}
	Compiler$_resolveImports$LCompiler$ALCompileError$($this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors)) {
		return false;
	}
	builtins = $this._builtinParsers[0];
	BooleanType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "Boolean");
	NumberType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "Number");
	StringType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "String");
	FunctionType._classDef = Parser$lookup$LParser$ALCompileError$LToken$S(builtins, errors, null, "Function");
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors)) {
		return false;
	}
	Compiler$_resolveTypes$LCompiler$ALCompileError$($this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors)) {
		return false;
	}
	Compiler$_exportEntryPoints$LCompiler$($this);
	Compiler$_analyze$LCompiler$ALCompileError$($this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors)) {
		return false;
	}
	switch ($this._mode) {
	case 2:
		return true;
	case 3:
		return true;
	}
	Compiler$_transform$LCompiler$ALCompileError$($this, errors);
	if (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors)) {
		return false;
	}
	if ($this._optimizer != null) {
		Optimizer$performOptimization$LOptimizer$((this$0$0 = $this._optimizer, this$0$0._compiler = $this, this$0$0));
	}
	Compiler$_generateCode$LCompiler$ALCompileError$($this, errors);
	return (! Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors) ? false : true);
};

Compiler.compile$LCompiler$ = Compiler$compile$LCompiler$;

Compiler.prototype.getAST$ = function () {
	var $this = this;
	var classDefs;
	var i;
	var this$0;
	var this$1;
	var s$0;
	var i$0;
	classDefs = [];
	for (i = 0; i < this._parsers.length; ++i) {
		classDefs = classDefs.concat((this$0 = this._parsers[i], this$0._classDefs));
		classDefs = classDefs.concat((this$1 = this._parsers[i], this$1._templateClassDefs).map((function (classDef) {
			return classDef;
		})));
	}
	s$0 = [];
	for (i$0 = 0; i$0 < classDefs.length; ++i$0) {
		s$0[i$0] = ClassDefinition$serialize$LClassDefinition$(classDefs[i$0]);
	}
	return s$0;
};


function Compiler$getAST$LCompiler$($this) {
	var classDefs;
	var i;
	var this$0;
	var this$1;
	var s$0;
	var i$0;
	classDefs = [];
	for (i = 0; i < $this._parsers.length; ++i) {
		classDefs = classDefs.concat((this$0 = $this._parsers[i], this$0._classDefs));
		classDefs = classDefs.concat((this$1 = $this._parsers[i], this$1._templateClassDefs).map((function (classDef) {
			return classDef;
		})));
	}
	s$0 = [];
	for (i$0 = 0; i$0 < classDefs.length; ++i$0) {
		s$0[i$0] = ClassDefinition$serialize$LClassDefinition$(classDefs[i$0]);
	}
	return s$0;
};

Compiler.getAST$LCompiler$ = Compiler$getAST$LCompiler$;

Compiler.prototype.getFileContent$ALCompileError$LToken$S = function (errors, sourceToken, path) {
	if (this._fileCache[path] == null) {
		try {
			this._fileCache[path] = this._platform.load$S(path);
		} catch ($__jsx_catch_0) {
			if ($__jsx_catch_0 instanceof Error) {
				errors.push(new CompileError(sourceToken, "could not open file: " + path + ", " + $__jsx_catch_0.toString()));
				this._fileCache[path] = null;
			} else {
				throw $__jsx_catch_0;
			}
		}
	}
	return this._fileCache[path];
};


function Compiler$getFileContent$LCompiler$ALCompileError$LToken$S($this, errors, sourceToken, path) {
	if ($this._fileCache[path] == null) {
		try {
			$this._fileCache[path] = $this._platform.load$S(path);
		} catch ($__jsx_catch_0) {
			if ($__jsx_catch_0 instanceof Error) {
				errors.push(new CompileError(sourceToken, "could not open file: " + path + ", " + $__jsx_catch_0.toString()));
				$this._fileCache[path] = null;
			} else {
				throw $__jsx_catch_0;
			}
		}
	}
	return $this._fileCache[path];
};

Compiler.getFileContent$LCompiler$ALCompileError$LToken$S = Compiler$getFileContent$LCompiler$ALCompileError$LToken$S;

Compiler.prototype._parseFile$ALCompileError$N = function (errors, parserIndex) {
	var parser;
	var content;
	var conflictWarning;
	var imports;
	var i;
	var imports$len$0;
	parser = this._parsers[parserIndex];
	content = Compiler$getFileContent$LCompiler$ALCompileError$LToken$S(this, errors, parser._sourceToken, parser._filename);
	if (content == null) {
		Parser$parse$LParser$SALCompileError$(parser, "", []);
		return false;
	}
	conflictWarning = Compiler$_checkConflictOfNpmModulesParsed$LCompiler$N(this, parserIndex) || Compiler$_checkConflictOfIdenticalFiles$LCompiler$NS(this, parserIndex, content);
	if (conflictWarning != null) {
		errors.push(conflictWarning);
	}
	Parser$parse$LParser$SALCompileError$(parser, content, errors);
	if (this._mode !== 1) {
		imports = parser._imports;
		for ((i = 0, imports$len$0 = imports.length); i < imports$len$0; ++i) {
			if (! Compiler$_handleImport$LCompiler$ALCompileError$LParser$LImport$(this, errors, parser, imports[i])) {
				return false;
			}
		}
	}
	return true;
};


function Compiler$_parseFile$LCompiler$ALCompileError$N($this, errors, parserIndex) {
	var parser;
	var content;
	var conflictWarning;
	var imports;
	var i;
	var imports$len$0;
	parser = $this._parsers[parserIndex];
	content = Compiler$getFileContent$LCompiler$ALCompileError$LToken$S($this, errors, parser._sourceToken, parser._filename);
	if (content == null) {
		Parser$parse$LParser$SALCompileError$(parser, "", []);
		return false;
	}
	conflictWarning = Compiler$_checkConflictOfNpmModulesParsed$LCompiler$N($this, parserIndex) || Compiler$_checkConflictOfIdenticalFiles$LCompiler$NS($this, parserIndex, content);
	if (conflictWarning != null) {
		errors.push(conflictWarning);
	}
	Parser$parse$LParser$SALCompileError$(parser, content, errors);
	if ($this._mode !== 1) {
		imports = parser._imports;
		for ((i = 0, imports$len$0 = imports.length); i < imports$len$0; ++i) {
			if (! Compiler$_handleImport$LCompiler$ALCompileError$LParser$LImport$($this, errors, parser, imports[i])) {
				return false;
			}
		}
	}
	return true;
};

Compiler._parseFile$LCompiler$ALCompileError$N = Compiler$_parseFile$LCompiler$ALCompileError$N;

Compiler.prototype._checkConflictOfNpmModulesParsed$N = function (parserIndex) {
	var $this = this;
	var getModuleNameAndPath;
	var parser;
	var moduleNameAndPath;
	var offendingParser;
	var offendingModulePath;
	var this$0;
	var note$0;
	var this$1;
	var note$1;
	function getModuleNameAndPath(path) {
		var match;
		match = path.match(/^(?:.*\/|)node_modules\/([^\/]+)\//);
		return (match == null ? null : [ match[1], match[0].substring(0, match[0].length - 1) ]);
	}
	parser = this._parsers[parserIndex];
	moduleNameAndPath = getModuleNameAndPath(parser._filename);
	if (moduleNameAndPath == null) {
		return null;
	}
	if (! $__jsx_ObjectHasOwnProperty.call(this._npmModulesParsed, moduleNameAndPath[0])) {
		this._npmModulesParsed[moduleNameAndPath[0]] = parserIndex;
		return null;
	}
	offendingParser = this._parsers[this._npmModulesParsed[moduleNameAndPath[0]]];
	offendingModulePath = getModuleNameAndPath(offendingParser._filename)[1];
	return (offendingModulePath === moduleNameAndPath[1] ? null : (this$1 = (this$0 = new CompileWarning(parser._sourceToken, "please consider running \"npm dedupe\"; the NPM module has already been read from a different location:"), note$0 = new CompileNote(offendingParser._sourceToken, "at first from here as: " + offendingParser._filename), this$0._notes.push(note$0), this$0), note$1 = new CompileNote(parser._sourceToken, "and now from here as: " + parser._filename), this$1._notes.push(note$1), this$1));
};


function Compiler$_checkConflictOfNpmModulesParsed$LCompiler$N($this, parserIndex) {
	var getModuleNameAndPath;
	var parser;
	var moduleNameAndPath;
	var offendingParser;
	var offendingModulePath;
	var this$0;
	var note$0;
	var this$1;
	var note$1;
	function getModuleNameAndPath(path) {
		var match;
		match = path.match(/^(?:.*\/|)node_modules\/([^\/]+)\//);
		return (match == null ? null : [ match[1], match[0].substring(0, match[0].length - 1) ]);
	}
	parser = $this._parsers[parserIndex];
	moduleNameAndPath = getModuleNameAndPath(parser._filename);
	if (moduleNameAndPath == null) {
		return null;
	}
	if (! $__jsx_ObjectHasOwnProperty.call($this._npmModulesParsed, moduleNameAndPath[0])) {
		$this._npmModulesParsed[moduleNameAndPath[0]] = parserIndex;
		return null;
	}
	offendingParser = $this._parsers[$this._npmModulesParsed[moduleNameAndPath[0]]];
	offendingModulePath = getModuleNameAndPath(offendingParser._filename)[1];
	return (offendingModulePath === moduleNameAndPath[1] ? null : (this$1 = (this$0 = new CompileWarning(parser._sourceToken, "please consider running \"npm dedupe\"; the NPM module has already been read from a different location:"), note$0 = new CompileNote(offendingParser._sourceToken, "at first from here as: " + offendingParser._filename), this$0._notes.push(note$0), this$0), note$1 = new CompileNote(parser._sourceToken, "and now from here as: " + parser._filename), this$1._notes.push(note$1), this$1));
};

Compiler._checkConflictOfNpmModulesParsed$LCompiler$N = Compiler$_checkConflictOfNpmModulesParsed$LCompiler$N;

Compiler.prototype._checkConflictOfIdenticalFiles$NS = function (parserIndex, content) {
	var parser;
	var i;
	var this$0;
	var note$0;
	var this$1;
	var this$2;
	var this$3;
	var note$1;
	var this$4;
	var this$5;
	var path$0;
	var parts$0;
	var path$1;
	var parts$1;
	var _parsers$0;
	parser = this._parsers[parserIndex];
	for (i = 0; i !== parserIndex; ++i) {
		if ((this$4 = this._parsers[i], this$4._content) === content && (path$0 = (this$5 = this._parsers[i], this$5._filename), parts$0 = Util$_resolvedPathParts$S(path$0), parts$0.pop()) === (path$1 = parser._filename, parts$1 = Util$_resolvedPathParts$S(path$1), parts$1.pop())) {
			return (this$3 = (this$0 = new CompileWarning(parser._sourceToken, "the file (with identical content) has been read from different locations:"), note$0 = new CompileNote(parser._sourceToken, "from here as: " + parser._filename), this$0._notes.push(note$0), this$0), note$1 = new CompileNote((this$1 = (_parsers$0 = this._parsers)[i], this$1._sourceToken), "from here as: " + (this$2 = _parsers$0[i], this$2._filename)), this$3._notes.push(note$1), this$3);
		}
	}
	return null;
};


function Compiler$_checkConflictOfIdenticalFiles$LCompiler$NS($this, parserIndex, content) {
	var parser;
	var i;
	var this$0;
	var note$0;
	var this$1;
	var this$2;
	var this$3;
	var note$1;
	var this$4;
	var this$5;
	var path$0;
	var parts$0;
	var path$1;
	var parts$1;
	var _parsers$0;
	parser = $this._parsers[parserIndex];
	for (i = 0; i !== parserIndex; ++i) {
		if ((this$4 = $this._parsers[i], this$4._content) === content && (path$0 = (this$5 = $this._parsers[i], this$5._filename), parts$0 = Util$_resolvedPathParts$S(path$0), parts$0.pop()) === (path$1 = parser._filename, parts$1 = Util$_resolvedPathParts$S(path$1), parts$1.pop())) {
			return (this$3 = (this$0 = new CompileWarning(parser._sourceToken, "the file (with identical content) has been read from different locations:"), note$0 = new CompileNote(parser._sourceToken, "from here as: " + parser._filename), this$0._notes.push(note$0), this$0), note$1 = new CompileNote((this$1 = (_parsers$0 = $this._parsers)[i], this$1._sourceToken), "from here as: " + (this$2 = _parsers$0[i], this$2._filename)), this$3._notes.push(note$1), this$3);
		}
	}
	return null;
};

Compiler._checkConflictOfIdenticalFiles$LCompiler$NS = Compiler$_checkConflictOfIdenticalFiles$LCompiler$NS;

Compiler.prototype._handleImport$ALCompileError$LParser$LImport$ = function (errors, parser, imprt) {
	var wildImprt;
	var resolvedDir;
	var files;
	var found;
	var i;
	var path;
	var newParser;
	var this$0;
	var this$1;
	var _filenameToken$0;
	if (imprt instanceof WildcardImport) {
		wildImprt = imprt;
		resolvedDir = Compiler$_resolvePath$LCompiler$SSB(this, (this$0 = wildImprt._filenameToken, this$0._filename), wildImprt._directory, true);
		files = [];
		try {
			files = this._platform.getFilesInDirectory$S(resolvedDir);
		} catch ($__jsx_catch_0) {
			if ($__jsx_catch_0 instanceof Error) {
				errors.push(new CompileError(wildImprt._filenameToken, "could not read files in directory: " + resolvedDir + ", " + $__jsx_catch_0.toString()));
				return false;
			} else {
				throw $__jsx_catch_0;
			}
		}
		found = false;
		for (i = 0; i < files.length; ++i) {
			if (files[i].length >= wildImprt._suffix.length && files[i].charAt(0) !== "." && files[i].substring(((files[i].length - wildImprt._suffix.length) | 0)) === wildImprt._suffix) {
				path = resolvedDir + "/" + files[i];
				if (path !== parser._filename) {
					newParser = Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$(this, wildImprt._filenameToken, resolvedDir + "/" + files[i], null);
					wildImprt._sourceParsers.push(newParser);
					found = true;
				}
			}
		}
		if (! found) {
			errors.push(new CompileError(wildImprt._filenameToken, "no matching files found in directory: " + resolvedDir));
			return false;
		}
	} else {
		path = Compiler$_resolvePath$LCompiler$SSB(this, (this$1 = _filenameToken$0 = imprt._filenameToken, this$1._filename), Util$decodeStringLiteral$S((_filenameToken$0, _filenameToken$0._value)), false);
		if (path === parser._filename) {
			errors.push(new CompileError(imprt._filenameToken, "cannot import itself"));
			return false;
		}
		newParser = Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$(this, imprt._filenameToken, path, null);
		imprt._sourceParsers.push(newParser);
	}
	return true;
};


function Compiler$_handleImport$LCompiler$ALCompileError$LParser$LImport$($this, errors, parser, imprt) {
	var wildImprt;
	var resolvedDir;
	var files;
	var found;
	var i;
	var path;
	var newParser;
	var this$0;
	var this$1;
	var _filenameToken$0;
	if (imprt instanceof WildcardImport) {
		wildImprt = imprt;
		resolvedDir = Compiler$_resolvePath$LCompiler$SSB($this, (this$0 = wildImprt._filenameToken, this$0._filename), wildImprt._directory, true);
		files = [];
		try {
			files = $this._platform.getFilesInDirectory$S(resolvedDir);
		} catch ($__jsx_catch_0) {
			if ($__jsx_catch_0 instanceof Error) {
				errors.push(new CompileError(wildImprt._filenameToken, "could not read files in directory: " + resolvedDir + ", " + $__jsx_catch_0.toString()));
				return false;
			} else {
				throw $__jsx_catch_0;
			}
		}
		found = false;
		for (i = 0; i < files.length; ++i) {
			if (files[i].length >= wildImprt._suffix.length && files[i].charAt(0) !== "." && files[i].substring(((files[i].length - wildImprt._suffix.length) | 0)) === wildImprt._suffix) {
				path = resolvedDir + "/" + files[i];
				if (path !== parser._filename) {
					newParser = Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$($this, wildImprt._filenameToken, resolvedDir + "/" + files[i], null);
					wildImprt._sourceParsers.push(newParser);
					found = true;
				}
			}
		}
		if (! found) {
			errors.push(new CompileError(wildImprt._filenameToken, "no matching files found in directory: " + resolvedDir));
			return false;
		}
	} else {
		path = Compiler$_resolvePath$LCompiler$SSB($this, (this$1 = _filenameToken$0 = imprt._filenameToken, this$1._filename), Util$decodeStringLiteral$S((_filenameToken$0, _filenameToken$0._value)), false);
		if (path === parser._filename) {
			errors.push(new CompileError(imprt._filenameToken, "cannot import itself"));
			return false;
		}
		newParser = Compiler$addSourceFile$LCompiler$LToken$SLCompletionRequest$($this, imprt._filenameToken, path, null);
		imprt._sourceParsers.push(newParser);
	}
	return true;
};

Compiler._handleImport$LCompiler$ALCompileError$LParser$LImport$ = Compiler$_handleImport$LCompiler$ALCompileError$LParser$LImport$;

Compiler.prototype.forEachClassDef$F$LParser$LClassDefinition$B$ = function (f) {
	var $this = this;
	var onClassDef;
	var i;
	var parser;
	var classDefs;
	var j;
	var classDefs$len$0;
	function onClassDef(parser, classDef) {
		var inners;
		var i;
		var inners$len$0;
		if (! f(parser, classDef)) {
			return false;
		}
		inners = classDef._inners;
		for ((i = 0, inners$len$0 = inners.length); i < inners$len$0; ++i) {
			if (! onClassDef(parser, inners[i])) {
				return false;
			}
		}
		return true;
	}
	for (i = 0; i < this._parsers.length; ++i) {
		parser = this._parsers[i];
		classDefs = parser._classDefs;
		for ((j = 0, classDefs$len$0 = classDefs.length); j < classDefs$len$0; ++j) {
			if (! onClassDef(parser, classDefs[j])) {
				return false;
			}
		}
	}
	return true;
};


function Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, f) {
	var onClassDef;
	var i;
	var parser;
	var classDefs;
	var j;
	var classDefs$len$0;
	function onClassDef(parser, classDef) {
		var inners;
		var i;
		var inners$len$0;
		if (! f(parser, classDef)) {
			return false;
		}
		inners = classDef._inners;
		for ((i = 0, inners$len$0 = inners.length); i < inners$len$0; ++i) {
			if (! onClassDef(parser, inners[i])) {
				return false;
			}
		}
		return true;
	}
	for (i = 0; i < $this._parsers.length; ++i) {
		parser = $this._parsers[i];
		classDefs = parser._classDefs;
		for ((j = 0, classDefs$len$0 = classDefs.length); j < classDefs$len$0; ++j) {
			if (! onClassDef(parser, classDefs[j])) {
				return false;
			}
		}
	}
	return true;
};

Compiler.forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$ = Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$;

Compiler.prototype.normalizeClassDefs$ALCompileError$ = function (errors) {
	var $this = this;
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		ClassDefinition$normalizeClassDefs$LClassDefinition$ALCompileError$(classDef, errors);
		return true;
	}));
};


function Compiler$normalizeClassDefs$LCompiler$ALCompileError$($this, errors) {
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		ClassDefinition$normalizeClassDefs$LClassDefinition$ALCompileError$(classDef, errors);
		return true;
	}));
};

Compiler.normalizeClassDefs$LCompiler$ALCompileError$ = Compiler$normalizeClassDefs$LCompiler$ALCompileError$;

Compiler.prototype._resolveImports$ALCompileError$ = function (errors) {
	var i;
	var imports;
	var j;
	var this$0;
	var parsers$0;
	var i$0;
	var this$1;
	for (i = 0; i < this._parsers.length; ++i) {
		this$0 = this._parsers[i];
		parsers$0 = this._builtinParsers;
		for (i$0 = parsers$0.length - 1; i$0 >= 0; --i$0) {
			this$0._imports.unshift(new Import(parsers$0[i$0]));
		}
		this$1 = this._parsers[i];
		imports = this$1._imports;
		for (j = 0; j < imports.length; ++j) {
			Import$assertExistenceOfNamedClasses$LImport$ALCompileError$(imports[j], errors);
		}
	}
};


function Compiler$_resolveImports$LCompiler$ALCompileError$($this, errors) {
	var i;
	var imports;
	var j;
	var this$0;
	var parsers$0;
	var i$0;
	var this$1;
	for (i = 0; i < $this._parsers.length; ++i) {
		this$0 = $this._parsers[i];
		parsers$0 = $this._builtinParsers;
		for (i$0 = parsers$0.length - 1; i$0 >= 0; --i$0) {
			this$0._imports.unshift(new Import(parsers$0[i$0]));
		}
		this$1 = $this._parsers[i];
		imports = this$1._imports;
		for (j = 0; j < imports.length; ++j) {
			Import$assertExistenceOfNamedClasses$LImport$ALCompileError$(imports[j], errors);
		}
	}
};

Compiler._resolveImports$LCompiler$ALCompileError$ = Compiler$_resolveImports$LCompiler$ALCompileError$;

Compiler.prototype._resolveTypes$ALCompileError$ = function (errors) {
	var $this = this;
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(classDef, ({errors: errors, parser: parser, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}));
		return true;
	}));
};


function Compiler$_resolveTypes$LCompiler$ALCompileError$($this, errors) {
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(classDef, ({errors: errors, parser: parser, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}));
		return true;
	}));
};

Compiler._resolveTypes$LCompiler$ALCompileError$ = Compiler$_resolveTypes$LCompiler$ALCompileError$;

Compiler.prototype._analyze$ALCompileError$ = function (errors) {
	var $this = this;
	var createContext;
	createContext = (function (parser) {
		return ({errors: errors, parser: parser, postInstantiationCallback: (function (parser, classDef) {
			ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			return classDef;
		}), funcDef: null, blockStack: null, statement: null});
	});
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		ClassDefinition$analyzeUnusedVariables$LClassDefinition$(classDef);
		return true;
	}));
};


function Compiler$_analyze$LCompiler$ALCompileError$($this, errors) {
	var createContext;
	createContext = (function (parser) {
		return ({errors: errors, parser: parser, postInstantiationCallback: (function (parser, classDef) {
			ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			return classDef;
		}), funcDef: null, blockStack: null, statement: null});
	});
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
		return true;
	}));
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		ClassDefinition$analyzeUnusedVariables$LClassDefinition$(classDef);
		return true;
	}));
};

Compiler._analyze$LCompiler$ALCompileError$ = Compiler$_analyze$LCompiler$ALCompileError$;

Compiler.prototype._transform$ALCompileError$ = function (errors) {
	var $this = this;
	var doit;
	var i;
	function doit(cmd) {
		cmd.setup$ALCompileError$(errors);
		cmd.performTransformation$();
		return errors.length === 0;
	}
	for (i = 0; i < this._transformCommands.length; ++i) {
		if (! doit(this._transformCommands[i])) {
			return;
		}
	}
	if (! doit(new FixedExpressionTransformCommand(this))) {
		return;
	}
};


function Compiler$_transform$LCompiler$ALCompileError$($this, errors) {
	var doit;
	var i;
	function doit(cmd) {
		cmd.setup$ALCompileError$(errors);
		cmd.performTransformation$();
		return errors.length === 0;
	}
	for (i = 0; i < $this._transformCommands.length; ++i) {
		if (! doit($this._transformCommands[i])) {
			return;
		}
	}
	if (! doit(new FixedExpressionTransformCommand($this))) {
		return;
	}
};

Compiler._transform$LCompiler$ALCompileError$ = Compiler$_transform$LCompiler$ALCompileError$;

Compiler.prototype._optimize$ = function () {
	var this$0;
	if (this._optimizer != null) {
		Optimizer$performOptimization$LOptimizer$((this$0 = this._optimizer, this$0._compiler = this, this$0));
	}
};


function Compiler$_optimize$LCompiler$($this) {
	var this$0;
	if ($this._optimizer != null) {
		Optimizer$performOptimization$LOptimizer$((this$0 = $this._optimizer, this$0._compiler = $this, this$0));
	}
};

Compiler._optimize$LCompiler$ = Compiler$_optimize$LCompiler$;

Compiler.prototype._generateCode$ALCompileError$ = function (errors) {
	var $this = this;
	var classDefs;
	var i;
	var nativeClassNames;
	var foundConflict;
	var getMaxIndexOfClasses;
	var maxIndexOfClasses;
	var deps;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	var this$9;
	var this$10;
	classDefs = [];
	for (i = 0; i < this._parsers.length; ++i) {
		classDefs = classDefs.concat((this$0 = this._parsers[i], this$0._classDefs));
		(this$1 = this._parsers[i], this$1._templateClassDefs).forEach((function (templateClassDef) {
			if ((templateClassDef._flags & 16) !== 0 && templateClassDef._nativeSource != null) {
				classDefs.push(templateClassDef);
			}
		}));
	}
	for (i = 0; i < classDefs.length; ++i) {
		if ((this$7 = classDefs[i], this$7._inners).length !== 0) {
			classDefs = classDefs.concat((this$2 = classDefs[i], this$2._inners));
		}
	}
	nativeClassNames = {};
	foundConflict = false;
	classDefs.forEach((function (classDef) {
		var this$0;
		var note$0;
		var this$1;
		var this$2;
		if ((classDef.flags$() & 16) === 0) {
			return;
		}
		if ($__jsx_ObjectHasOwnProperty.call(nativeClassNames, classDef.className$()) && ! (classDef instanceof InstantiatedClassDefinition && nativeClassNames[classDef.className$()] instanceof InstantiatedClassDefinition && (this$1 = classDef, this$1._templateClassDef) == (this$2 = nativeClassNames[classDef.className$()], this$2._templateClassDef)) && classDef._nativeSource == null && classDef._outerClassDef == null) {
			errors.push((this$0 = new CompileError(classDef.getToken$(), "native class with same name is already defined"), note$0 = new CompileNote(nativeClassNames[classDef.className$()].getToken$(), "here"), this$0._notes.push(note$0), this$0));
			foundConflict = true;
			return;
		}
		nativeClassNames[classDef.className$()] = classDef;
	}));
	if (foundConflict) {
		return;
	}
	getMaxIndexOfClasses = (function (deps) {
		var i;
		var j;
		deps = deps.concat([  ]);
		if (deps.length === 0) {
			return -1;
		}
		for (i = 0; i < classDefs.length; ++i) {
			for (j = 0; j < deps.length; ++j) {
				if (classDefs[i] == deps[j]) {
					deps.splice(j, 1);
					if (deps.length === 0) {
						return i;
					}
				}
			}
		}
		throw new Error("logic flaw, could not find class definition of '" + deps[0].className$() + "'");
	});
	for (i = 0; i < classDefs.length; ) {
		if ((classDefs[i].flags$() & 16) !== 0) {
			maxIndexOfClasses = -1;
		} else {
			deps = (this$3 = classDefs[i], this$3._implementTypes).map((function (t) {
				return t._classDef;
			})).concat([  ]);
			if ((this$8 = classDefs[i], this$8._extendType) != null) {
				deps.unshift((this$5 = (this$4 = classDefs[i], this$4._extendType), this$5._classDef));
			}
			if ((this$9 = classDefs[i], this$9._outerClassDef) != null && deps.indexOf((this$10 = classDefs[i], this$10._outerClassDef)) === -1) {
				deps.unshift((this$6 = classDefs[i], this$6._outerClassDef));
			}
			maxIndexOfClasses = getMaxIndexOfClasses(deps);
		}
		if (maxIndexOfClasses > i) {
			classDefs.splice(maxIndexOfClasses + 1, 0, classDefs[i]);
			classDefs.splice(i, 1);
		} else {
			++i;
		}
	}
	this._emitter.emit$ALClassDefinition$(classDefs);
};


function Compiler$_generateCode$LCompiler$ALCompileError$($this, errors) {
	var classDefs;
	var i;
	var nativeClassNames;
	var foundConflict;
	var getMaxIndexOfClasses;
	var maxIndexOfClasses;
	var deps;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	var this$9;
	var this$10;
	classDefs = [];
	for (i = 0; i < $this._parsers.length; ++i) {
		classDefs = classDefs.concat((this$0 = $this._parsers[i], this$0._classDefs));
		(this$1 = $this._parsers[i], this$1._templateClassDefs).forEach((function (templateClassDef) {
			if ((templateClassDef._flags & 16) !== 0 && templateClassDef._nativeSource != null) {
				classDefs.push(templateClassDef);
			}
		}));
	}
	for (i = 0; i < classDefs.length; ++i) {
		if ((this$7 = classDefs[i], this$7._inners).length !== 0) {
			classDefs = classDefs.concat((this$2 = classDefs[i], this$2._inners));
		}
	}
	nativeClassNames = {};
	foundConflict = false;
	classDefs.forEach((function (classDef) {
		var this$0;
		var note$0;
		var this$1;
		var this$2;
		if ((classDef.flags$() & 16) === 0) {
			return;
		}
		if ($__jsx_ObjectHasOwnProperty.call(nativeClassNames, classDef.className$()) && ! (classDef instanceof InstantiatedClassDefinition && nativeClassNames[classDef.className$()] instanceof InstantiatedClassDefinition && (this$1 = classDef, this$1._templateClassDef) == (this$2 = nativeClassNames[classDef.className$()], this$2._templateClassDef)) && classDef._nativeSource == null && classDef._outerClassDef == null) {
			errors.push((this$0 = new CompileError(classDef.getToken$(), "native class with same name is already defined"), note$0 = new CompileNote(nativeClassNames[classDef.className$()].getToken$(), "here"), this$0._notes.push(note$0), this$0));
			foundConflict = true;
			return;
		}
		nativeClassNames[classDef.className$()] = classDef;
	}));
	if (foundConflict) {
		return;
	}
	getMaxIndexOfClasses = (function (deps) {
		var i;
		var j;
		deps = deps.concat([  ]);
		if (deps.length === 0) {
			return -1;
		}
		for (i = 0; i < classDefs.length; ++i) {
			for (j = 0; j < deps.length; ++j) {
				if (classDefs[i] == deps[j]) {
					deps.splice(j, 1);
					if (deps.length === 0) {
						return i;
					}
				}
			}
		}
		throw new Error("logic flaw, could not find class definition of '" + deps[0].className$() + "'");
	});
	for (i = 0; i < classDefs.length; ) {
		if ((classDefs[i].flags$() & 16) !== 0) {
			maxIndexOfClasses = -1;
		} else {
			deps = (this$3 = classDefs[i], this$3._implementTypes).map((function (t) {
				return t._classDef;
			})).concat([  ]);
			if ((this$8 = classDefs[i], this$8._extendType) != null) {
				deps.unshift((this$5 = (this$4 = classDefs[i], this$4._extendType), this$5._classDef));
			}
			if ((this$9 = classDefs[i], this$9._outerClassDef) != null && deps.indexOf((this$10 = classDefs[i], this$10._outerClassDef)) === -1) {
				deps.unshift((this$6 = classDefs[i], this$6._outerClassDef));
			}
			maxIndexOfClasses = getMaxIndexOfClasses(deps);
		}
		if (maxIndexOfClasses > i) {
			classDefs.splice(maxIndexOfClasses + 1, 0, classDefs[i]);
			classDefs.splice(i, 1);
		} else {
			++i;
		}
	}
	$this._emitter.emit$ALClassDefinition$(classDefs);
};

Compiler._generateCode$LCompiler$ALCompileError$ = Compiler$_generateCode$LCompiler$ALCompileError$;

Compiler.prototype._exportEntryPoints$ = function () {
	var $this = this;
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this, (function (parser, classDef) {
		switch (ClassDefinition$classFullName$LClassDefinition$(classDef)) {
		case "_Main":
			ClassDefinition$setFlags$LClassDefinition$N(classDef, classDef.flags$() | 16384);
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_STATIC) !== 0 && MemberDefinition$name$LMemberDefinition$(funcDef) === "main" && MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef).length === 1 && Util$isArrayOf$LClassDefinition$LType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)[0].getClassDef$(), Type.stringType)) {
					MemberDefinition$setFlags$LMemberDefinition$N(funcDef, MemberDefinition$flags$LMemberDefinition$(funcDef) | ClassDefinition.IS_EXPORT);
				}
				return true;
			}));
			break;
		case "_Test":
			ClassDefinition$setFlags$LClassDefinition$N(classDef, classDef.flags$() | 16384);
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_STATIC) === 0 && (MemberDefinition$name$LMemberDefinition$(funcDef).match(/^test/) || MemberDefinition$name$LMemberDefinition$(funcDef) === "constructor") && MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef).length === 0) {
					MemberDefinition$setFlags$LMemberDefinition$N(funcDef, MemberDefinition$flags$LMemberDefinition$(funcDef) | ClassDefinition.IS_EXPORT);
				}
				return true;
			}));
			break;
		}
		return true;
	}));
};


function Compiler$_exportEntryPoints$LCompiler$($this) {
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this, (function (parser, classDef) {
		switch (ClassDefinition$classFullName$LClassDefinition$(classDef)) {
		case "_Main":
			ClassDefinition$setFlags$LClassDefinition$N(classDef, classDef.flags$() | 16384);
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_STATIC) !== 0 && MemberDefinition$name$LMemberDefinition$(funcDef) === "main" && MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef).length === 1 && Util$isArrayOf$LClassDefinition$LType$(MemberFunctionDefinition$getArgumentTypes$LMemberFunctionDefinition$(funcDef)[0].getClassDef$(), Type.stringType)) {
					MemberDefinition$setFlags$LMemberDefinition$N(funcDef, MemberDefinition$flags$LMemberDefinition$(funcDef) | ClassDefinition.IS_EXPORT);
				}
				return true;
			}));
			break;
		case "_Test":
			ClassDefinition$setFlags$LClassDefinition$N(classDef, classDef.flags$() | 16384);
			ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
				if ((MemberDefinition$flags$LMemberDefinition$(funcDef) & ClassDefinition.IS_STATIC) === 0 && (MemberDefinition$name$LMemberDefinition$(funcDef).match(/^test/) || MemberDefinition$name$LMemberDefinition$(funcDef) === "constructor") && MemberFunctionDefinition$getArguments$LMemberFunctionDefinition$(funcDef).length === 0) {
					MemberDefinition$setFlags$LMemberDefinition$N(funcDef, MemberDefinition$flags$LMemberDefinition$(funcDef) | ClassDefinition.IS_EXPORT);
				}
				return true;
			}));
			break;
		}
		return true;
	}));
};

Compiler._exportEntryPoints$LCompiler$ = Compiler$_exportEntryPoints$LCompiler$;

Compiler.prototype._handleErrors$ALCompileError$ = function (errors) {
	var $this = this;
	var isFatal;
	if (this._mode === 2) {
		errors.splice(0, errors.length);
		return true;
	}
	isFatal = false;
	errors.forEach((function (error) {
		var warning;
		var doWarn;
		var i;
		var _platform$0;
		var _platform$1;
		if (error instanceof CompileWarning) {
			warning = error;
			for (i = 0; i < $this._warningFilters.length; ++i) {
				if ((doWarn = $this._warningFilters[i](warning)) != null) {
					break;
				}
			}
			if (doWarn !== false) {
				(_platform$0 = $this._platform).warn$S((_platform$0, Util$makeErrorMessage$LPlatform$SUSNNN(_platform$0, "Warning: " + warning._message, warning._filename, warning._lineNumber, warning._columnNumber, warning._size)));
				warning._notes.forEach((function (note) {
					$this._platform.warn$S(CompileIssue$format$LCompileIssue$LPlatform$(note, Compiler$getPlatform$LCompiler$($this)));
				}));
				if ($this._warningAsError) {
					isFatal = true;
				}
			}
		} else {
			(_platform$1 = $this._platform).error$S((_platform$1, Util$makeErrorMessage$LPlatform$SUSNNN(_platform$1, error.getPrefix$() + error._message, error._filename, error._lineNumber, error._columnNumber, error._size)));
			error._notes.forEach((function (note) {
				$this._platform.error$S(CompileIssue$format$LCompileIssue$LPlatform$(note, Compiler$getPlatform$LCompiler$($this)));
			}));
			isFatal = true;
		}
	}));
	errors.splice(0, errors.length);
	return ! isFatal;
};


function Compiler$_handleErrors$LCompiler$ALCompileError$($this, errors) {
	var isFatal;
	if ($this._mode === 2) {
		errors.splice(0, errors.length);
		return true;
	}
	isFatal = false;
	errors.forEach((function (error) {
		var warning;
		var doWarn;
		var i;
		var _platform$0;
		var _platform$1;
		if (error instanceof CompileWarning) {
			warning = error;
			for (i = 0; i < $this._warningFilters.length; ++i) {
				if ((doWarn = $this._warningFilters[i](warning)) != null) {
					break;
				}
			}
			if (doWarn !== false) {
				(_platform$0 = $this._platform).warn$S((_platform$0, Util$makeErrorMessage$LPlatform$SUSNNN(_platform$0, "Warning: " + warning._message, warning._filename, warning._lineNumber, warning._columnNumber, warning._size)));
				warning._notes.forEach((function (note) {
					$this._platform.warn$S(CompileIssue$format$LCompileIssue$LPlatform$(note, Compiler$getPlatform$LCompiler$($this)));
				}));
				if ($this._warningAsError) {
					isFatal = true;
				}
			}
		} else {
			(_platform$1 = $this._platform).error$S((_platform$1, Util$makeErrorMessage$LPlatform$SUSNNN(_platform$1, error.getPrefix$() + error._message, error._filename, error._lineNumber, error._columnNumber, error._size)));
			error._notes.forEach((function (note) {
				$this._platform.error$S(CompileIssue$format$LCompileIssue$LPlatform$(note, Compiler$getPlatform$LCompiler$($this)));
			}));
			isFatal = true;
		}
	}));
	errors.splice(0, errors.length);
	return ! isFatal;
};

Compiler._handleErrors$LCompiler$ALCompileError$ = Compiler$_handleErrors$LCompiler$ALCompileError$;

Compiler.prototype._readPackageJson$S = function (moduleDir) {
	var json;
	var contents;
	if ($__jsx_ObjectHasOwnProperty.call(this._packageJsonCache, moduleDir)) {
		return this._packageJsonCache[moduleDir];
	}
	json = null;
	if (this._platform.fileExists$S(moduleDir + "/package.json")) {
		try {
			contents = this._platform.load$S(moduleDir + "/package.json");
			json = JSON.parse(contents);
		} catch ($__jsx_catch_0) {
			{
				this._platform.warn$S("could not parse file:" + moduleDir + "/package.json");
			}
		}
	}
	this._packageJsonCache[moduleDir] = json;
	return json;
};


function Compiler$_readPackageJson$LCompiler$S($this, moduleDir) {
	var json;
	var contents;
	if ($__jsx_ObjectHasOwnProperty.call($this._packageJsonCache, moduleDir)) {
		return $this._packageJsonCache[moduleDir];
	}
	json = null;
	if ($this._platform.fileExists$S(moduleDir + "/package.json")) {
		try {
			contents = $this._platform.load$S(moduleDir + "/package.json");
			json = JSON.parse(contents);
		} catch ($__jsx_catch_0) {
			{
				$this._platform.warn$S("could not parse file:" + moduleDir + "/package.json");
			}
		}
	}
	$this._packageJsonCache[moduleDir] = json;
	return json;
};

Compiler._readPackageJson$LCompiler$S = Compiler$_readPackageJson$LCompiler$S;

Compiler.prototype._resolvePathFromNodeModules$SSB = function (srcDir, givenPath, isWildcard) {
	var $this = this;
	var firstSlashAtGivenPath;
	var moduleName;
	var lookupInNodeModules;
	var path;
	var match;
	firstSlashAtGivenPath = givenPath.indexOf("/");
	moduleName = (firstSlashAtGivenPath !== -1 ? givenPath.substring(0, firstSlashAtGivenPath) : givenPath);
	function lookupInNodeModules(nodeModulesDir) {
		var moduleDir;
		var packageJson;
		var libDir;
		var subPathWithLeadingSlash;
		var main;
		var path$0;
		var path$1;
		moduleDir = nodeModulesDir + "/" + moduleName;
		if (! $this._platform.fileExists$S(moduleDir)) {
			return "";
		}
		packageJson = Compiler$_readPackageJson$LCompiler$S($this, moduleDir);
		if (packageJson == null) {
			packageJson = ({  });
		}
		if (isWildcard || firstSlashAtGivenPath !== -1) {
			libDir = (packageJson.directories && packageJson.directories.lib ? packageJson.directories.lib + "" : "lib");
			subPathWithLeadingSlash = (firstSlashAtGivenPath !== -1 ? givenPath.substring(firstSlashAtGivenPath) : "");
			path$0 = moduleDir + "/" + libDir + subPathWithLeadingSlash;
			return Util$_resolvedPathParts$S(path$0).join("/");
		} else {
			main = (packageJson.main ? packageJson.main + "" : "index.jsx");
			path$1 = moduleDir + "/" + main;
			return Util$_resolvedPathParts$S(path$1).join("/");
		}
	}
	while (true) {
		path = lookupInNodeModules(srcDir + "/node_modules");
		if (path !== "") {
			return path;
		}
		match = srcDir.match(/^(.*)\/node_modules\/[^\/]+$/);
		if (match == null) {
			break;
		}
		srcDir = match[1];
	}
	return "";
};


function Compiler$_resolvePathFromNodeModules$LCompiler$SSB($this, srcDir, givenPath, isWildcard) {
	var firstSlashAtGivenPath;
	var moduleName;
	var lookupInNodeModules;
	var path;
	var match;
	firstSlashAtGivenPath = givenPath.indexOf("/");
	moduleName = (firstSlashAtGivenPath !== -1 ? givenPath.substring(0, firstSlashAtGivenPath) : givenPath);
	function lookupInNodeModules(nodeModulesDir) {
		var moduleDir;
		var packageJson;
		var libDir;
		var subPathWithLeadingSlash;
		var main;
		var path$0;
		var path$1;
		moduleDir = nodeModulesDir + "/" + moduleName;
		if (! $this._platform.fileExists$S(moduleDir)) {
			return "";
		}
		packageJson = Compiler$_readPackageJson$LCompiler$S($this, moduleDir);
		if (packageJson == null) {
			packageJson = ({  });
		}
		if (isWildcard || firstSlashAtGivenPath !== -1) {
			libDir = (packageJson.directories && packageJson.directories.lib ? packageJson.directories.lib + "" : "lib");
			subPathWithLeadingSlash = (firstSlashAtGivenPath !== -1 ? givenPath.substring(firstSlashAtGivenPath) : "");
			path$0 = moduleDir + "/" + libDir + subPathWithLeadingSlash;
			return Util$_resolvedPathParts$S(path$0).join("/");
		} else {
			main = (packageJson.main ? packageJson.main + "" : "index.jsx");
			path$1 = moduleDir + "/" + main;
			return Util$_resolvedPathParts$S(path$1).join("/");
		}
	}
	while (true) {
		path = lookupInNodeModules(srcDir + "/node_modules");
		if (path !== "") {
			return path;
		}
		match = srcDir.match(/^(.*)\/node_modules\/[^\/]+$/);
		if (match == null) {
			break;
		}
		srcDir = match[1];
	}
	return "";
};

Compiler._resolvePathFromNodeModules$LCompiler$SSB = Compiler$_resolvePathFromNodeModules$LCompiler$SSB;

Compiler.prototype._resolvePath$SSB = function (srcPath, givenPath, isWildcard) {
	var searchPaths;
	var i;
	var path;
	var srcDir;
	var lastSlashAt;
	var path$0;
	var parts$0;
	var path$1;
	if (givenPath.match(/^\.{1,2}\//) == null) {
		searchPaths = this._searchPaths.concat(this._emitter.getSearchPaths$());
		for (i = 0; i < searchPaths.length; ++i) {
			path$0 = searchPaths[i] + "/" + givenPath;
			path = Util$_resolvedPathParts$S(path$0).join("/");
			if (this._platform.fileExists$S(path)) {
				return path;
			}
		}
		parts$0 = Util$_resolvedPathParts$S(srcPath);
		parts$0.pop();
		srcDir = (parts$0.length !== 0 ? parts$0.join("/") : ".");
		path = Compiler$_resolvePathFromNodeModules$LCompiler$SSB(this, srcDir, givenPath, isWildcard);
		if (path !== "") {
			return path;
		}
		if (srcDir !== ".") {
			path = Compiler$_resolvePathFromNodeModules$LCompiler$SSB(this, ".", givenPath, isWildcard);
			if (path !== "") {
				return path;
			}
		}
	}
	lastSlashAt = srcPath.lastIndexOf("/");
	path$1 = (lastSlashAt !== -1 ? srcPath.substring(0, lastSlashAt + 1) : "") + givenPath;
	path = Util$_resolvedPathParts$S(path$1).join("/");
	return path;
};


function Compiler$_resolvePath$LCompiler$SSB($this, srcPath, givenPath, isWildcard) {
	var searchPaths;
	var i;
	var path;
	var srcDir;
	var lastSlashAt;
	var path$0;
	var parts$0;
	var path$1;
	if (givenPath.match(/^\.{1,2}\//) == null) {
		searchPaths = $this._searchPaths.concat($this._emitter.getSearchPaths$());
		for (i = 0; i < searchPaths.length; ++i) {
			path$0 = searchPaths[i] + "/" + givenPath;
			path = Util$_resolvedPathParts$S(path$0).join("/");
			if ($this._platform.fileExists$S(path)) {
				return path;
			}
		}
		parts$0 = Util$_resolvedPathParts$S(srcPath);
		parts$0.pop();
		srcDir = (parts$0.length !== 0 ? parts$0.join("/") : ".");
		path = Compiler$_resolvePathFromNodeModules$LCompiler$SSB($this, srcDir, givenPath, isWildcard);
		if (path !== "") {
			return path;
		}
		if (srcDir !== ".") {
			path = Compiler$_resolvePathFromNodeModules$LCompiler$SSB($this, ".", givenPath, isWildcard);
			if (path !== "") {
				return path;
			}
		}
	}
	lastSlashAt = srcPath.lastIndexOf("/");
	path$1 = (lastSlashAt !== -1 ? srcPath.substring(0, lastSlashAt + 1) : "") + givenPath;
	path = Util$_resolvedPathParts$S(path$1).join("/");
	return path;
};

Compiler._resolvePath$LCompiler$SSB = Compiler$_resolvePath$LCompiler$SSB;

function CompletionRequest(lineNumber, columnOffset) {
	this._lineNumber = lineNumber;
	this._columnOffest = columnOffset;
	this._candidates = [];
};

$__jsx_extend([CompletionRequest], Object);
function CompletionRequest$getLineNumber$LCompletionRequest$($this) {
	return $this._lineNumber;
};

CompletionRequest.getLineNumber$LCompletionRequest$ = CompletionRequest$getLineNumber$LCompletionRequest$;

function CompletionRequest$getColumnOffset$LCompletionRequest$($this) {
	return $this._columnOffest;
};

CompletionRequest.getColumnOffset$LCompletionRequest$ = CompletionRequest$getColumnOffset$LCompletionRequest$;

function CompletionRequest$isInRange$LCompletionRequest$NNN($this, lineNumber, columnOffset, length) {
	return (lineNumber !== $this._lineNumber ? -1 : columnOffset <= $this._columnOffest && $this._columnOffest <= columnOffset + length ? $this._columnOffest - columnOffset : -1);
};

CompletionRequest.isInRange$LCompletionRequest$NNN = CompletionRequest$isInRange$LCompletionRequest$NNN;

function CompletionRequest$pushCandidates$LCompletionRequest$LCompletionCandidates$($this, candidates) {
	$this._candidates.push(candidates);
};

CompletionRequest.pushCandidates$LCompletionRequest$LCompletionCandidates$ = CompletionRequest$pushCandidates$LCompletionRequest$LCompletionCandidates$;

function CompletionRequest$getCandidates$LCompletionRequest$($this) {
	var seen;
	var results;
	seen = {};
	results = [];
	$this._candidates.forEach((function (candidates) {
		var rawCandidates;
		var prefix;
		rawCandidates = [];
		candidates.getCandidates$AHX(rawCandidates);
		prefix = candidates._prefix;
		rawCandidates.forEach((function (s) {
			var word;
			var left;
			var identity;
			word = s.word + "";
			if (prefix === "" && word.substring(0, 2) === "__" && word !== "__noconvert__" && word !== "undefined") {
			} else if (word.substring(0, prefix.length) === prefix) {
				left = word.substring(prefix.length);
				if (left.length === 0) {
					return;
				}
				identity = JSON.stringify([ left, s.args ]);
				if (! $__jsx_ObjectHasOwnProperty.call(seen, identity)) {
					seen[identity] = true;
					if (word !== left) {
						s.partialWord = left;
					}
					delete s.kind;
					results.push(s);
				}
			}
		}));
	}));
	return results;
};

CompletionRequest.getCandidates$LCompletionRequest$ = CompletionRequest$getCandidates$LCompletionRequest$;

function CompletionCandidates() {
	this._prefix = null;
};

$__jsx_extend([CompletionCandidates], Object);
CompletionCandidates.prototype.getPrefix$ = function () {
	return this._prefix;
};


function CompletionCandidates$getPrefix$LCompletionCandidates$($this) {
	return $this._prefix;
};

CompletionCandidates.getPrefix$LCompletionCandidates$ = CompletionCandidates$getPrefix$LCompletionCandidates$;

CompletionCandidates.prototype.setPrefix$S = function (prefix) {
	this._prefix = prefix;
	return this;
};


function CompletionCandidates$setPrefix$LCompletionCandidates$S($this, prefix) {
	$this._prefix = prefix;
	return $this;
};

CompletionCandidates.setPrefix$LCompletionCandidates$S = CompletionCandidates$setPrefix$LCompletionCandidates$S;

function CompletionCandidates$makeClassCandidate$LClassDefinition$(classDef) {
	var data;
	var docComment;
	var this$0;
	var this$1;
	data = {};
	data.word = classDef.className$();
	this$0 = classDef.getToken$();
	data.definedFilename = this$0._filename;
	this$1 = classDef.getToken$();
	data.definedLineNumber = this$1._lineNumber;
	if ((classDef.flags$() & 64) !== 0) {
		data.kind = "interface";
	} else if ((classDef.flags$() & 128) !== 0) {
		data.kind = "mixin";
	} else {
		data.kind = "class";
	}
	docComment = classDef._docComment;
	if (docComment) {
		data.doc = docComment.getDescription$();
	}
	return data;
};

CompletionCandidates.makeClassCandidate$LClassDefinition$ = CompletionCandidates$makeClassCandidate$LClassDefinition$;

function CompletionCandidates$_addClasses$AHXLParser$F$LClassDefinition$B$(candidates, parser, autoCompleteMatchCb) {
	parser._classDefs.forEach((function (classDef) {
		if (classDef instanceof InstantiatedClassDefinition) {
		} else if (autoCompleteMatchCb == null || autoCompleteMatchCb(classDef)) {
			candidates.push(CompletionCandidates$makeClassCandidate$LClassDefinition$(classDef));
		}
	}));
	parser._templateClassDefs.forEach((function (classDef) {
		if (autoCompleteMatchCb == null || autoCompleteMatchCb(classDef)) {
			candidates.push(CompletionCandidates$makeClassCandidate$LClassDefinition$(classDef));
		}
	}));
};

CompletionCandidates._addClasses$AHXLParser$F$LClassDefinition$B$ = CompletionCandidates$_addClasses$AHXLParser$F$LClassDefinition$B$;

function CompletionCandidates$_addImportedClasses$AHXLImport$F$LClassDefinition$B$(candidates, imprt, autoCompleteMatchCb) {
	var classNames;
	classNames = Import$getClassNames$LImport$(imprt);
	if (classNames != null) {
		classNames.forEach((function (className) {
			var data;
			data = {};
			data.word = className;
			data.kind = "class";
			candidates.push(data);
		}));
	} else {
		imprt._sourceParsers.forEach((function (parser) {
			CompletionCandidates$_addClasses$AHXLParser$F$LClassDefinition$B$(candidates, parser, autoCompleteMatchCb);
		}));
	}
};

CompletionCandidates._addImportedClasses$AHXLImport$F$LClassDefinition$B$ = CompletionCandidates$_addImportedClasses$AHXLImport$F$LClassDefinition$B$;

function KeywordCompletionCandidate(expected) {
	this._prefix = null;
	this._expected = expected;
};

$__jsx_extend([KeywordCompletionCandidate], CompletionCandidates);
KeywordCompletionCandidate.prototype.getCandidates$AHX = function (candidates) {
	var data;
	data = {};
	data.word = this._expected;
	data.kind = "keyword";
	candidates.push(data);
};


function CompletionCandidatesOfTopLevel(parser, autoCompleteMatchCb) {
	this._prefix = null;
	this._parser = parser;
	this._autoCompleteMatchCb = autoCompleteMatchCb;
};

$__jsx_extend([CompletionCandidatesOfTopLevel], CompletionCandidates);
CompletionCandidatesOfTopLevel.prototype.getCandidates$AHX = function (candidates) {
	var i;
	var imprt;
	var alias;
	var data;
	var this$0$0;
	CompletionCandidates$_addClasses$AHXLParser$F$LClassDefinition$B$(candidates, this._parser, this._autoCompleteMatchCb);
	for (i = 0; i < this._parser._imports.length; ++i) {
		imprt = this._parser._imports[i];
		alias = (imprt._aliasToken ? (this$0$0 = imprt._aliasToken, this$0$0._value) : null);
		if (alias != null) {
			data = {};
			data.word = alias;
			data.kind = "alias";
			candidates.push(data);
		} else {
			CompletionCandidates$_addImportedClasses$AHXLImport$F$LClassDefinition$B$(candidates, imprt, this._autoCompleteMatchCb);
		}
	}
};


function _CompletionCandidatesWithLocal(parser) {
	var $this = this;
	CompletionCandidatesOfTopLevel.call(this, parser, null);
	this._locals = [];
	Parser$_forEachScope$LParser$F$LLocalVariable$ALLocalVariable$ALArgumentDeclaration$B$(parser, (function (funcName, locals, args) {
		var i;
		if (funcName != null) {
			$this._locals = $this._locals.concat([ funcName ]);
		}
		$this._locals = $this._locals.concat(locals);
		for (i in args) { i |= 0;
			$this._locals.push(args[i]);
		}
		return true;
	}));
};

$__jsx_extend([_CompletionCandidatesWithLocal], CompletionCandidatesOfTopLevel);
_CompletionCandidatesWithLocal.prototype.getCandidates$AHX = function (candidates) {
	var $this = this;
	this._locals.forEach((function (local) {
		var data;
		var type;
		var this$0;
		var this$1;
		var this$2;
		data = {};
		this$0 = local._name;
		data.word = this$0._value;
		data.kind = 'variable';
		this$1 = local._name;
		data.definedFilename = this$1._filename;
		this$2 = local._name;
		data.definedLineNumber = this$2._lineNumber;
		type = local._type;
		if (type != null) {
			data.type = type.toString();
		}
		candidates.push(data);
	}));
	CompletionCandidatesOfTopLevel.prototype.getCandidates$AHX.call(this, candidates);
};


function _CompletionCandidatesOfNamespace(imprt, autoCompleteMatchCb) {
	this._prefix = null;
	this._import = imprt;
	this._autoCompleteMatchCb = autoCompleteMatchCb;
};

$__jsx_extend([_CompletionCandidatesOfNamespace], CompletionCandidates);
_CompletionCandidatesOfNamespace.prototype.getCandidates$AHX = function (candidates) {
	CompletionCandidates$_addImportedClasses$AHXLImport$F$LClassDefinition$B$(candidates, this._import, this._autoCompleteMatchCb);
};


function _CompletionCandidatesOfProperty(expr) {
	this._prefix = null;
	this._expr = expr;
};

$__jsx_extend([_CompletionCandidatesOfProperty], CompletionCandidates);
_CompletionCandidatesOfProperty.prototype.getCandidates$AHX = function (candidates) {
	var $this = this;
	var type;
	var classDef;
	var isStatic;
	var this$0$0;
	type = this._expr.getType$();
	if (type == null) {
		return;
	}
	type = (type instanceof NullableType ? (this$0$0 = type, this$0$0._baseType) : type);
	if (type.equals$LType$(Type.voidType) || type.equals$LType$(Type.nullType) || type.equals$LType$(Type.variantType)) {
		return;
	}
	classDef = type.getClassDef$();
	if (classDef == null) {
		return;
	}
	isStatic = this._expr.isClassSpecifier$();
	ClassDefinition$forEachClassToBase$LClassDefinition$F$LClassDefinition$B$(classDef, (function (c) {
		ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(c, (function (member) {
			if (((MemberDefinition$flags$LMemberDefinition$(member) & ClassDefinition.IS_STATIC) !== 0) === isStatic) {
				if (! isStatic && MemberDefinition$name$LMemberDefinition$(member) === "constructor") {
					return true;
				}
				candidates.push(_CompletionCandidatesOfProperty$_makeMemberCandidate$LMemberDefinition$(member));
			}
			return true;
		}));
		return true;
	}));
};


function _CompletionCandidatesOfProperty$_makeMemberCandidate$LMemberDefinition$(member) {
	var kind;
	var data;
	var docComment;
	var mf;
	var this$0$0;
	var this$0;
	var this$1;
	kind = (member._flags & 8 ? "static member" : "member");
	kind += (member instanceof MemberFunctionDefinition ? " function" : " variable");
	data = {};
	this$0$0 = member._nameToken;
	data.word = this$0$0._value;
	data.type = member.getType$().toString();
	data.kind = kind;
	data.definedClass = member._classDef.className$();
	this$0 = member._token;
	data.definedFilename = this$0._filename;
	this$1 = member._token;
	data.definedLineNumber = this$1._lineNumber;
	docComment = member._docComment;
	if (docComment) {
		data.doc = docComment.getDescription$();
	}
	if (member instanceof MemberFunctionDefinition) {
		mf = member;
		data.returnType = mf._returnType.toString();
		data.args = mf._args.map((function (arg) {
			var pair;
			var this$0;
			pair = {};
			this$0 = arg._name;
			pair.name = this$0._value;
			pair.type = arg._type.toString();
			return pair;
		}));
	}
	return data;
};

_CompletionCandidatesOfProperty._makeMemberCandidate$LMemberDefinition$ = _CompletionCandidatesOfProperty$_makeMemberCandidate$LMemberDefinition$;

function DocCommentNode() {
	this._description = "";
};

$__jsx_extend([DocCommentNode], Object);
DocCommentNode.prototype.getDescription$ = function () {
	return this._description.replace(/^[\r\n]+/, "").replace(/[\r\n\t ]+$/, "");
};


DocCommentNode.prototype.appendDescription$S = function (s) {
	this._description += s;
};


function DocCommentNode$appendDescription$LDocCommentNode$S($this, s) {
	$this._description += s;
};

DocCommentNode.appendDescription$LDocCommentNode$S = DocCommentNode$appendDescription$LDocCommentNode$S;

function DocCommentParameter(token) {
	this._description = "";
	this._token = token;
};

$__jsx_extend([DocCommentParameter], DocCommentNode);
DocCommentParameter.prototype.getToken$ = function () {
	return this._token;
};


function DocCommentParameter$getToken$LDocCommentParameter$($this) {
	return $this._token;
};

DocCommentParameter.getToken$LDocCommentParameter$ = DocCommentParameter$getToken$LDocCommentParameter$;

DocCommentParameter.prototype.getParamName$ = function () {
	var this$0;
	this$0 = this._token;
	return this$0._value;
};


function DocCommentParameter$getParamName$LDocCommentParameter$($this) {
	var this$0;
	this$0 = $this._token;
	return this$0._value;
};

DocCommentParameter.getParamName$LDocCommentParameter$ = DocCommentParameter$getParamName$LDocCommentParameter$;

DocCommentParameter.prototype.getDescription$ = function () {
	var d;
	d = DocCommentNode.prototype.getDescription$.call(this);
	return d.trim();
};


function DocCommentTag(tagName) {
	this._description = "";
	this._tagName = tagName;
};

$__jsx_extend([DocCommentTag], DocCommentNode);
DocCommentTag.prototype.getTagName$ = function () {
	return this._tagName;
};


function DocCommentTag$getTagName$LDocCommentTag$($this) {
	return $this._tagName;
};

DocCommentTag.getTagName$LDocCommentTag$ = DocCommentTag$getTagName$LDocCommentTag$;

function DocComment() {
	this._description = "";
	this._params = [];
	this._tags = [];
};

$__jsx_extend([DocComment], DocCommentNode);
DocComment.prototype.getParams$ = function () {
	return this._params;
};


function DocComment$getParams$LDocComment$($this) {
	return $this._params;
};

DocComment.getParams$LDocComment$ = DocComment$getParams$LDocComment$;

DocComment.prototype.getTags$ = function () {
	return this._tags;
};


function DocComment$getTags$LDocComment$($this) {
	return $this._tags;
};

DocComment.getTags$LDocComment$ = DocComment$getTags$LDocComment$;

DocComment.prototype.getTagByName$S = function (tagName) {
	var i;
	var this$0;
	for (i = 0; i < this._tags.length; ++i) {
		if ((this$0 = this._tags[i], this$0._tagName) === tagName) {
			return this._tags[i];
		}
	}
	return null;
};


function DocComment$getTagByName$LDocComment$S($this, tagName) {
	var i;
	var this$0;
	for (i = 0; i < $this._tags.length; ++i) {
		if ((this$0 = $this._tags[i], this$0._tagName) === tagName) {
			return $this._tags[i];
		}
	}
	return null;
};

DocComment.getTagByName$LDocComment$S = DocComment$getTagByName$LDocComment$S;

DocComment.prototype.getTagsByName$S = function (tagName) {
	var tags;
	var i;
	var this$0;
	tags = [];
	for (i = 0; i < this._tags.length; ++i) {
		if ((this$0 = this._tags[i], this$0._tagName) === tagName) {
			tags.push(this._tags[i]);
		}
	}
	return tags;
};


function DocComment$getTagsByName$LDocComment$S($this, tagName) {
	var tags;
	var i;
	var this$0;
	tags = [];
	for (i = 0; i < $this._tags.length; ++i) {
		if ((this$0 = $this._tags[i], this$0._tagName) === tagName) {
			tags.push($this._tags[i]);
		}
	}
	return tags;
};

DocComment.getTagsByName$LDocComment$S = DocComment$getTagsByName$LDocComment$S;

function DocumentGenerator(compiler, templatePath, outputPath) {
	this._classDefToHTMLCache = new TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E();
	this._compiler = compiler;
	this._templatePath = templatePath;
	this._outputPath = outputPath;
	this._resourceFiles = [];
	this._pathFilter = null;
};

$__jsx_extend([DocumentGenerator], Object);
DocumentGenerator.prototype.setResourceFiles$AS = function (files) {
	this._resourceFiles = files;
	return this;
};


function DocumentGenerator$setResourceFiles$LDocumentGenerator$AS($this, files) {
	$this._resourceFiles = files;
	return $this;
};

DocumentGenerator.setResourceFiles$LDocumentGenerator$AS = DocumentGenerator$setResourceFiles$LDocumentGenerator$AS;

DocumentGenerator.prototype.setPathFilter$F$SB$ = function (pathFilter) {
	this._pathFilter = pathFilter;
	return this;
};


function DocumentGenerator$setPathFilter$LDocumentGenerator$F$SB$($this, pathFilter) {
	$this._pathFilter = pathFilter;
	return $this;
};

DocumentGenerator.setPathFilter$LDocumentGenerator$F$SB$ = DocumentGenerator$setPathFilter$LDocumentGenerator$F$SB$;

DocumentGenerator.prototype.buildDoc$ = function () {
	var $this = this;
	var platform;
	var this$0;
	var this$1;
	this$0 = this._compiler;
	platform = this$0._platform;
	this._resourceFiles.forEach((function (file) {
		platform.save$USS($this._outputPath + "/" + file, platform.load$S($this._templatePath + "/" + file));
	}));
	(this$1 = this._compiler, this$1._parsers).forEach((function (parser) {
		var outputFile;
		var html;
		var filename$0;
		var rootDir$0;
		filename$0 = parser._filename;
		rootDir$0 = platform.getRoot$() + "/";
		if (filename$0.indexOf(rootDir$0) === 0) {
			filename$0 = "system:" + filename$0.substring(rootDir$0.length);
		}
		if ($this._pathFilter(filename$0)) {
			outputFile = $this._outputPath + "/" + parser._filename + ".html";
			html = DocumentGenerator$_buildDocOfFile$LDocumentGenerator$LParser$($this, parser);
			platform.save$USS(outputFile, html);
		}
	}));
};


function DocumentGenerator$buildDoc$LDocumentGenerator$($this) {
	var platform;
	var this$0;
	var this$1;
	this$0 = $this._compiler;
	platform = this$0._platform;
	$this._resourceFiles.forEach((function (file) {
		platform.save$USS($this._outputPath + "/" + file, platform.load$S($this._templatePath + "/" + file));
	}));
	(this$1 = $this._compiler, this$1._parsers).forEach((function (parser) {
		var outputFile;
		var html;
		var filename$0;
		var rootDir$0;
		filename$0 = parser._filename;
		rootDir$0 = platform.getRoot$() + "/";
		if (filename$0.indexOf(rootDir$0) === 0) {
			filename$0 = "system:" + filename$0.substring(rootDir$0.length);
		}
		if ($this._pathFilter(filename$0)) {
			outputFile = $this._outputPath + "/" + parser._filename + ".html";
			html = DocumentGenerator$_buildDocOfFile$LDocumentGenerator$LParser$($this, parser);
			platform.save$USS(outputFile, html);
		}
	}));
};

DocumentGenerator.buildDoc$LDocumentGenerator$ = DocumentGenerator$buildDoc$LDocumentGenerator$;

DocumentGenerator.prototype._buildDocOfFile$LParser$ = function (parser) {
	var $this = this;
	var htmlFile;
	var this$0;
	htmlFile = this._templatePath + "/template.html";
	return (this$0 = this._compiler, this$0._platform).load$S(htmlFile).replace(/<%JSX:(.*?)%>/g, (function (matched) {
		var key;
		key = matched.substring(6, matched.length - 2);
		switch (key) {
		case "BASE_HREF":
			return parser._filename.replace(/\/[^\/]+$/, "").replace(/[^\/]+/g, "..");
		case "TITLE":
			return DocumentGenerator$_escape$LDocumentGenerator$S($this, parser._filename);
		case "BODY":
			return DocumentGenerator$_buildBodyOfFile$LDocumentGenerator$LParser$($this, parser);
		case "FOOTER":
			return DocumentGenerator$_buildFooterOfFile$LDocumentGenerator$LParser$($this, parser);
		default:
			throw new Error("unknown template key:" + key + " in file: " + htmlFile);
		}
	}));
};


function DocumentGenerator$_buildDocOfFile$LDocumentGenerator$LParser$($this, parser) {
	var htmlFile;
	var this$0;
	htmlFile = $this._templatePath + "/template.html";
	return (this$0 = $this._compiler, this$0._platform).load$S(htmlFile).replace(/<%JSX:(.*?)%>/g, (function (matched) {
		var key;
		key = matched.substring(6, matched.length - 2);
		switch (key) {
		case "BASE_HREF":
			return parser._filename.replace(/\/[^\/]+$/, "").replace(/[^\/]+/g, "..");
		case "TITLE":
			return DocumentGenerator$_escape$LDocumentGenerator$S($this, parser._filename);
		case "BODY":
			return DocumentGenerator$_buildBodyOfFile$LDocumentGenerator$LParser$($this, parser);
		case "FOOTER":
			return DocumentGenerator$_buildFooterOfFile$LDocumentGenerator$LParser$($this, parser);
		default:
			throw new Error("unknown template key:" + key + " in file: " + htmlFile);
		}
	}));
};

DocumentGenerator._buildDocOfFile$LDocumentGenerator$LParser$ = DocumentGenerator$_buildDocOfFile$LDocumentGenerator$LParser$;

DocumentGenerator.prototype._buildBodyOfFile$LParser$ = function (parser) {
	var _;
	_ = "";
	_ += "<div class=\"jsxdoc\">\n";
	_ += "<div class=\"file\">\n";
	_ += "<h1>";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, parser._filename).replace(/\n$/, "");
	_ += "</h1>\n";
	_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$(this, parser._fileLevelDocComment).replace(/\n$/, "");
	_ += "\n";
	_ += "</div><!--/file-->\n";
	_ += DocumentGenerator$_buildListOfClasses$LDocumentGenerator$LParser$(this, parser).replace(/\n$/, "");
	_ += "\n";
	_ += "</div><!--/jsxdoc-->\n";
	return _;
};


function DocumentGenerator$_buildBodyOfFile$LDocumentGenerator$LParser$($this, parser) {
	var _;
	_ = "";
	_ += "<div class=\"jsxdoc\">\n";
	_ += "<div class=\"file\">\n";
	_ += "<h1>";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, parser._filename).replace(/\n$/, "");
	_ += "</h1>\n";
	_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$($this, parser._fileLevelDocComment).replace(/\n$/, "");
	_ += "\n";
	_ += "</div><!--/file-->\n";
	_ += DocumentGenerator$_buildListOfClasses$LDocumentGenerator$LParser$($this, parser).replace(/\n$/, "");
	_ += "\n";
	_ += "</div><!--/jsxdoc-->\n";
	return _;
};

DocumentGenerator._buildBodyOfFile$LDocumentGenerator$LParser$ = DocumentGenerator$_buildBodyOfFile$LDocumentGenerator$LParser$;

DocumentGenerator.prototype._buildFooterOfFile$LParser$ = function (parser) {
	var _;
	var docComment;
	var version;
	var author;
	var d;
	var endWithDot;
	_ = "";
	docComment = parser._fileLevelDocComment;
	if (docComment) {
		version = DocComment$getTagByName$LDocComment$S(docComment, "version");
		if (version) {
			_ += "<p>This is <strong>";
			_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, parser._filename).replace(/\n$/, "");
			_ += " version ";
			_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, version.getDescription$()).replace(/\n$/, "");
			_ += "</strong>.</p>\n";
		}
		author = DocComment$getTagByName$LDocComment$S(docComment, "author");
		if (author) {
			d = author.getDescription$();
			endWithDot = d.charAt(d.length - 1) === ".";
			_ += "<p>Copyright &copy; ";
			_ += (DocumentGenerator$_escape$LDocumentGenerator$S(this, d) + (endWithDot ? "" : ".")).replace(/\n$/, "");
			_ += "</p>\n";
		}
	}
	_ += "<p class=\"jsxdoc-notice\">This document was automatically generated by <a href=\"http://jsx.github.io/\">JSX</a> ";
	_ += "0.9.89".replace(/\n$/, "");
	_ += "<br />\n";
	_ += "at ";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, new Date().toISOString()).replace(/\n$/, "");
	_ += ".</p>\n";
	return _;
};


function DocumentGenerator$_buildFooterOfFile$LDocumentGenerator$LParser$($this, parser) {
	var _;
	var docComment;
	var version;
	var author;
	var d;
	var endWithDot;
	_ = "";
	docComment = parser._fileLevelDocComment;
	if (docComment) {
		version = DocComment$getTagByName$LDocComment$S(docComment, "version");
		if (version) {
			_ += "<p>This is <strong>";
			_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, parser._filename).replace(/\n$/, "");
			_ += " version ";
			_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, version.getDescription$()).replace(/\n$/, "");
			_ += "</strong>.</p>\n";
		}
		author = DocComment$getTagByName$LDocComment$S(docComment, "author");
		if (author) {
			d = author.getDescription$();
			endWithDot = d.charAt(d.length - 1) === ".";
			_ += "<p>Copyright &copy; ";
			_ += (DocumentGenerator$_escape$LDocumentGenerator$S($this, d) + (endWithDot ? "" : ".")).replace(/\n$/, "");
			_ += "</p>\n";
		}
	}
	_ += "<p class=\"jsxdoc-notice\">This document was automatically generated by <a href=\"http://jsx.github.io/\">JSX</a> ";
	_ += "0.9.89".replace(/\n$/, "");
	_ += "<br />\n";
	_ += "at ";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, new Date().toISOString()).replace(/\n$/, "");
	_ += ".</p>\n";
	return _;
};

DocumentGenerator._buildFooterOfFile$LDocumentGenerator$LParser$ = DocumentGenerator$_buildFooterOfFile$LDocumentGenerator$LParser$;

DocumentGenerator.prototype._buildListOfClasses$LParser$ = function (parser) {
	var $this = this;
	var _;
	_ = "";
	_ += "<div class=\"classes\">\n";
	parser._templateClassDefs.forEach((function (classDef) {
		if (! (classDef._className.charAt(0) === "_" || classDef._docComment && DocComment$getTagByName$LDocComment$S(classDef._docComment, 'private'))) {
			_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
			_ += "\n";
		}
	}));
	parser._classDefs.forEach((function (classDef) {
		if (! (classDef instanceof InstantiatedClassDefinition) && ! (classDef.className$().charAt(0) === "_" || classDef._docComment && DocComment$getTagByName$LDocComment$S(classDef._docComment, 'private'))) {
			_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
			_ += "\n";
		}
	}));
	_ += "</div>\n";
	return _;
};


function DocumentGenerator$_buildListOfClasses$LDocumentGenerator$LParser$($this, parser) {
	var _;
	_ = "";
	_ += "<div class=\"classes\">\n";
	parser._templateClassDefs.forEach((function (classDef) {
		if (! (classDef._className.charAt(0) === "_" || classDef._docComment && DocComment$getTagByName$LDocComment$S(classDef._docComment, 'private'))) {
			_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
			_ += "\n";
		}
	}));
	parser._classDefs.forEach((function (classDef) {
		if (! (classDef instanceof InstantiatedClassDefinition) && ! (classDef.className$().charAt(0) === "_" || classDef._docComment && DocComment$getTagByName$LDocComment$S(classDef._docComment, 'private'))) {
			_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
			_ += "\n";
		}
	}));
	_ += "</div>\n";
	return _;
};

DocumentGenerator._buildListOfClasses$LDocumentGenerator$LParser$ = DocumentGenerator$_buildListOfClasses$LDocumentGenerator$LParser$;

DocumentGenerator.prototype._buildDocOfClass$LParser$LClassDefinition$ = function (parser, classDef) {
	var $this = this;
	var _;
	var typeName;
	var typeArgs;
	var this$0;
	var name$0;
	_ = "";
	typeName = "class";
	if ((classDef.flags$() & 64) !== 0) {
		typeName = "interface";
	} else if ((classDef.flags$() & 128) !== 0) {
		typeName = "mixin";
	}
	typeArgs = (classDef instanceof TemplateClassDefinition ? (this$0 = classDef, this$0._typeArgs) : []);
	_ += "<div class=\"class\" id=\"class-";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, ClassDefinition$classFullName$LClassDefinition$(classDef)).replace(/\n$/, "");
	_ += "\">\n";
	_ += "<h2>";
	_ += (DocumentGenerator$_flagsToHTML$LDocumentGenerator$N(this, classDef.flags$()) + " " + DocumentGenerator$_escape$LDocumentGenerator$S(this, typeName) + " " + (name$0 = ClassDefinition$classFullName$LClassDefinition$(classDef), "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S(this, name$0) + "</strong>") + DocumentGenerator$_formalTypeArgsToHTML$LDocumentGenerator$ALToken$(this, typeArgs) + DocumentGenerator$_inheritance$LDocumentGenerator$LParser$LClassDefinition$(this, parser, classDef)).replace(/\n$/, "");
	_ += "</h2>\n";
	_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$(this, classDef._docComment).replace(/\n$/, "");
	_ += "\n";
	classDef._templateInners.forEach((function (classDef) {
		if (! (classDef._className.charAt(0) === "_" || classDef._docComment && DocComment$getTagByName$LDocComment$S(classDef._docComment, 'private'))) {
			_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
			_ += "\n";
		}
	}));
	classDef._inners.forEach((function (classDef) {
		if (! (classDef instanceof InstantiatedClassDefinition) && ! (classDef.className$().charAt(0) === "_" || classDef._docComment && DocComment$getTagByName$LDocComment$S(classDef._docComment, 'private'))) {
			_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
			_ += "\n";
		}
	}));
	if (DocumentGenerator$_hasPublicProperties$LDocumentGenerator$LClassDefinition$(this, classDef)) {
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
			var this$0$0;
			var name$0;
			var this$0$0$0;
			if (! ((this$0$0$0 = varDef._nameToken, this$0$0$0._value).charAt(0) === "_" || varDef._docComment && DocComment$getTagByName$LDocComment$S(varDef._docComment, 'private') || (varDef._flags & 32768) !== 0)) {
				_ += "<div class=\"member property\">\n";
				_ += "<h3>\n";
				_ += DocumentGenerator$_flagsToHTML$LDocumentGenerator$N($this, varDef._flags).replace(/\n$/, "");
				_ += " var ";
				_ += (name$0 = (this$0$0 = varDef._nameToken, this$0$0._value), "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S($this, name$0) + "</strong>").replace(/\n$/, "");
				_ += " : ";
				_ += DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, varDef.getType$()).replace(/\n$/, "");
				_ += "\n";
				_ += "</h3>\n";
				_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$($this, varDef._docComment).replace(/\n$/, "");
				_ += "\n";
				_ += "</div>\n";
			}
			return true;
		}));
	}
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
		var this$0$0$0;
		var this$0$0$1;
		if (! (funcDef instanceof InstantiatedMemberFunctionDefinition) && ((this$0$0$0 = funcDef._nameToken, this$0$0$0._value) === "constructor" && (funcDef._flags & 8) === 0) && (funcDef._flags & 4096) === 0 && ! ((this$0$0$1 = funcDef._nameToken, this$0$0$1._value).charAt(0) === "_" || funcDef._docComment && DocComment$getTagByName$LDocComment$S(funcDef._docComment, 'private') || (funcDef._flags & 32768) !== 0)) {
			_ += DocumentGenerator$_buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$($this, parser, funcDef).replace(/\n$/, "");
			_ += "\n";
		}
		return true;
	}));
	if (DocumentGenerator$_hasPublicFunctions$LDocumentGenerator$LClassDefinition$(this, classDef)) {
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
			var this$0$0$0;
			var this$0$0$1;
			if (! (funcDef instanceof InstantiatedMemberFunctionDefinition) && ! ((this$0$0$0 = funcDef._nameToken, this$0$0$0._value) === "constructor" && (funcDef._flags & 8) === 0) && ! ((this$0$0$1 = funcDef._nameToken, this$0$0$1._value).charAt(0) === "_" || funcDef._docComment && DocComment$getTagByName$LDocComment$S(funcDef._docComment, 'private') || (funcDef._flags & 32768) !== 0)) {
				_ += DocumentGenerator$_buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$($this, parser, funcDef).replace(/\n$/, "");
				_ += "\n";
			}
			return true;
		}));
	}
	_ += "</div>\n";
	return _;
};


function DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef) {
	var _;
	var typeName;
	var typeArgs;
	var this$0;
	var name$0;
	_ = "";
	typeName = "class";
	if ((classDef.flags$() & 64) !== 0) {
		typeName = "interface";
	} else if ((classDef.flags$() & 128) !== 0) {
		typeName = "mixin";
	}
	typeArgs = (classDef instanceof TemplateClassDefinition ? (this$0 = classDef, this$0._typeArgs) : []);
	_ += "<div class=\"class\" id=\"class-";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, ClassDefinition$classFullName$LClassDefinition$(classDef)).replace(/\n$/, "");
	_ += "\">\n";
	_ += "<h2>";
	_ += (DocumentGenerator$_flagsToHTML$LDocumentGenerator$N($this, classDef.flags$()) + " " + DocumentGenerator$_escape$LDocumentGenerator$S($this, typeName) + " " + (name$0 = ClassDefinition$classFullName$LClassDefinition$(classDef), "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S($this, name$0) + "</strong>") + DocumentGenerator$_formalTypeArgsToHTML$LDocumentGenerator$ALToken$($this, typeArgs) + DocumentGenerator$_inheritance$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef)).replace(/\n$/, "");
	_ += "</h2>\n";
	_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$($this, classDef._docComment).replace(/\n$/, "");
	_ += "\n";
	classDef._templateInners.forEach((function (classDef) {
		if (! (classDef._className.charAt(0) === "_" || classDef._docComment && DocComment$getTagByName$LDocComment$S(classDef._docComment, 'private'))) {
			_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
			_ += "\n";
		}
	}));
	classDef._inners.forEach((function (classDef) {
		if (! (classDef instanceof InstantiatedClassDefinition) && ! (classDef.className$().charAt(0) === "_" || classDef._docComment && DocComment$getTagByName$LDocComment$S(classDef._docComment, 'private'))) {
			_ += DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef).replace(/\n$/, "");
			_ += "\n";
		}
	}));
	if (DocumentGenerator$_hasPublicProperties$LDocumentGenerator$LClassDefinition$($this, classDef)) {
		ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
			var this$0$0;
			var name$0;
			var this$0$0$0;
			if (! ((this$0$0$0 = varDef._nameToken, this$0$0$0._value).charAt(0) === "_" || varDef._docComment && DocComment$getTagByName$LDocComment$S(varDef._docComment, 'private') || (varDef._flags & 32768) !== 0)) {
				_ += "<div class=\"member property\">\n";
				_ += "<h3>\n";
				_ += DocumentGenerator$_flagsToHTML$LDocumentGenerator$N($this, varDef._flags).replace(/\n$/, "");
				_ += " var ";
				_ += (name$0 = (this$0$0 = varDef._nameToken, this$0$0._value), "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S($this, name$0) + "</strong>").replace(/\n$/, "");
				_ += " : ";
				_ += DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, varDef.getType$()).replace(/\n$/, "");
				_ += "\n";
				_ += "</h3>\n";
				_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$($this, varDef._docComment).replace(/\n$/, "");
				_ += "\n";
				_ += "</div>\n";
			}
			return true;
		}));
	}
	ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
		var this$0$0$0;
		var this$0$0$1;
		if (! (funcDef instanceof InstantiatedMemberFunctionDefinition) && ((this$0$0$0 = funcDef._nameToken, this$0$0$0._value) === "constructor" && (funcDef._flags & 8) === 0) && (funcDef._flags & 4096) === 0 && ! ((this$0$0$1 = funcDef._nameToken, this$0$0$1._value).charAt(0) === "_" || funcDef._docComment && DocComment$getTagByName$LDocComment$S(funcDef._docComment, 'private') || (funcDef._flags & 32768) !== 0)) {
			_ += DocumentGenerator$_buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$($this, parser, funcDef).replace(/\n$/, "");
			_ += "\n";
		}
		return true;
	}));
	if (DocumentGenerator$_hasPublicFunctions$LDocumentGenerator$LClassDefinition$($this, classDef)) {
		ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
			var this$0$0$0;
			var this$0$0$1;
			if (! (funcDef instanceof InstantiatedMemberFunctionDefinition) && ! ((this$0$0$0 = funcDef._nameToken, this$0$0$0._value) === "constructor" && (funcDef._flags & 8) === 0) && ! ((this$0$0$1 = funcDef._nameToken, this$0$0$1._value).charAt(0) === "_" || funcDef._docComment && DocComment$getTagByName$LDocComment$S(funcDef._docComment, 'private') || (funcDef._flags & 32768) !== 0)) {
				_ += DocumentGenerator$_buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$($this, parser, funcDef).replace(/\n$/, "");
				_ += "\n";
			}
			return true;
		}));
	}
	_ += "</div>\n";
	return _;
};

DocumentGenerator._buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$ = DocumentGenerator$_buildDocOfClass$LDocumentGenerator$LParser$LClassDefinition$;

DocumentGenerator.prototype._inheritance$LParser$LClassDefinition$ = function (parser, classDef) {
	var $this = this;
	var extendClassDef;
	var _;
	var implementTypes;
	var this$0;
	if (classDef._extendType == null) {
		return "";
	}
	this$0 = classDef._extendType;
	extendClassDef = this$0._classDef;
	if (extendClassDef == null || ClassDefinition$classFullName$LClassDefinition$(extendClassDef) === "Object") {
		return "";
	}
	_ = " extends " + DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$(this, parser, extendClassDef);
	implementTypes = classDef._implementTypes;
	if (implementTypes.length > 0) {
		_ += " implements " + implementTypes.map((function (type) {
			return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, type._classDef);
		})).join(", ");
	}
	return _;
};


function DocumentGenerator$_inheritance$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef) {
	var extendClassDef;
	var _;
	var implementTypes;
	var this$0;
	if (classDef._extendType == null) {
		return "";
	}
	this$0 = classDef._extendType;
	extendClassDef = this$0._classDef;
	if (extendClassDef == null || ClassDefinition$classFullName$LClassDefinition$(extendClassDef) === "Object") {
		return "";
	}
	_ = " extends " + DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, extendClassDef);
	implementTypes = classDef._implementTypes;
	if (implementTypes.length > 0) {
		_ += " implements " + implementTypes.map((function (type) {
			return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, type._classDef);
		})).join(", ");
	}
	return _;
};

DocumentGenerator._inheritance$LDocumentGenerator$LParser$LClassDefinition$ = DocumentGenerator$_inheritance$LDocumentGenerator$LParser$LClassDefinition$;

DocumentGenerator.prototype._buildDocOfFunction$LParser$LMemberFunctionDefinition$ = function (parser, funcDef) {
	var $this = this;
	var _;
	var ignoreFlags;
	var funcName;
	var args;
	var argsHTML;
	var this$0$0$0;
	var name$0;
	var this$0$0;
	var name$1;
	var this$0;
	var this$0$0$1;
	_ = "";
	ignoreFlags = funcDef._classDef.flags$() & 20 | 1024;
	funcName = ((this$0$0$0 = funcDef._nameToken, this$0$0$0._value) === "constructor" && (funcDef._flags & 8) === 0 ? "new " + (name$0 = ClassDefinition$classFullName$LClassDefinition$(funcDef._classDef), "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S(this, name$0) + "</strong>") : DocumentGenerator$_flagsToHTML$LDocumentGenerator$N(this, funcDef._flags & ~ ignoreFlags) + " function " + (name$1 = (this$0$0 = funcDef._nameToken, this$0$0._value), "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S(this, name$1) + "</strong>"));
	args = funcDef._args;
	argsHTML = args.map((function (arg) {
		var this$0;
		return DocumentGenerator$_escape$LDocumentGenerator$S($this, (this$0 = arg._name, this$0._value)) + " : " + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, arg._type);
	})).join(", ");
	_ += "<div class=\"member function\">\n";
	_ += "<h3>\n";
	_ += (funcName + DocumentGenerator$_formalTypeArgsToHTML$LDocumentGenerator$ALToken$(this, funcDef instanceof TemplateFunctionDefinition ? (this$0 = funcDef, this$0._typeArgs) : [])).replace(/\n$/, "");
	_ += "(";
	_ += argsHTML.replace(/\n$/, "");
	_ += ")\n";
	if (! ((this$0$0$1 = funcDef._nameToken, this$0$0$1._value) === "constructor" && (funcDef._flags & 8) === 0)) {
		_ += " : ";
		_ += DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$(this, parser, funcDef._returnType).replace(/\n$/, "");
		_ += "\n";
	}
	_ += "</h3>\n";
	_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$(this, funcDef._docComment).replace(/\n$/, "");
	_ += "\n";
	if (DocumentGenerator$_argsHasDocComment$LDocumentGenerator$LMemberFunctionDefinition$(this, funcDef)) {
		_ += "<table class=\"arguments\">\n";
		args.forEach((function (arg) {
			var argName;
			var this$0;
			var docComment$0;
			this$0 = arg._name;
			argName = this$0._value;
			_ += "<tr>\n";
			_ += "<td class=\"param-name\">";
			_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, argName).replace(/\n$/, "");
			_ += "</td>\n";
			_ += "<td class=\"param-desc\">";
			_ += (docComment$0 = funcDef._docComment, docComment$0 != null ? DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S($this, docComment$0, argName) : "").replace(/\n$/, "");
			_ += "</td>\n";
			_ += "</tr>\n";
		}));
		_ += "</table>\n";
	}
	_ += "</div>\n";
	return _;
};


function DocumentGenerator$_buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$($this, parser, funcDef) {
	var _;
	var ignoreFlags;
	var funcName;
	var args;
	var argsHTML;
	var this$0$0$0;
	var name$0;
	var this$0$0;
	var name$1;
	var this$0;
	var this$0$0$1;
	_ = "";
	ignoreFlags = funcDef._classDef.flags$() & 20 | 1024;
	funcName = ((this$0$0$0 = funcDef._nameToken, this$0$0$0._value) === "constructor" && (funcDef._flags & 8) === 0 ? "new " + (name$0 = ClassDefinition$classFullName$LClassDefinition$(funcDef._classDef), "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S($this, name$0) + "</strong>") : DocumentGenerator$_flagsToHTML$LDocumentGenerator$N($this, funcDef._flags & ~ ignoreFlags) + " function " + (name$1 = (this$0$0 = funcDef._nameToken, this$0$0._value), "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S($this, name$1) + "</strong>"));
	args = funcDef._args;
	argsHTML = args.map((function (arg) {
		var this$0;
		return DocumentGenerator$_escape$LDocumentGenerator$S($this, (this$0 = arg._name, this$0._value)) + " : " + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, arg._type);
	})).join(", ");
	_ += "<div class=\"member function\">\n";
	_ += "<h3>\n";
	_ += (funcName + DocumentGenerator$_formalTypeArgsToHTML$LDocumentGenerator$ALToken$($this, funcDef instanceof TemplateFunctionDefinition ? (this$0 = funcDef, this$0._typeArgs) : [])).replace(/\n$/, "");
	_ += "(";
	_ += argsHTML.replace(/\n$/, "");
	_ += ")\n";
	if (! ((this$0$0$1 = funcDef._nameToken, this$0$0$1._value) === "constructor" && (funcDef._flags & 8) === 0)) {
		_ += " : ";
		_ += DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, funcDef._returnType).replace(/\n$/, "");
		_ += "\n";
	}
	_ += "</h3>\n";
	_ += DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$($this, funcDef._docComment).replace(/\n$/, "");
	_ += "\n";
	if (DocumentGenerator$_argsHasDocComment$LDocumentGenerator$LMemberFunctionDefinition$($this, funcDef)) {
		_ += "<table class=\"arguments\">\n";
		args.forEach((function (arg) {
			var argName;
			var this$0;
			var docComment$0;
			this$0 = arg._name;
			argName = this$0._value;
			_ += "<tr>\n";
			_ += "<td class=\"param-name\">";
			_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, argName).replace(/\n$/, "");
			_ += "</td>\n";
			_ += "<td class=\"param-desc\">";
			_ += (docComment$0 = funcDef._docComment, docComment$0 != null ? DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S($this, docComment$0, argName) : "").replace(/\n$/, "");
			_ += "</td>\n";
			_ += "</tr>\n";
		}));
		_ += "</table>\n";
	}
	_ += "</div>\n";
	return _;
};

DocumentGenerator._buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$ = DocumentGenerator$_buildDocOfFunction$LDocumentGenerator$LParser$LMemberFunctionDefinition$;

DocumentGenerator.prototype._descriptionToHTML$LDocComment$ = function (docComment) {
	var $this = this;
	var _;
	var seeTags;
	_ = "";
	if (docComment != null) {
		if (docComment.getDescription$() !== "") {
			_ += "<div class=\"description\">\n";
			_ += docComment.getDescription$().replace(/\t/g, "  ").replace(/\n$/, "");
			_ += "\n";
			_ += "</div>\n";
		}
		seeTags = DocComment$getTagsByName$LDocComment$S(docComment, "see");
		if (seeTags.length > 0) {
			_ += "<ul class=\"see\">\n";
			seeTags.forEach((function (tag) {
				_ += "<li>";
				_ += DocumentGenerator$_autoLink$LDocumentGenerator$S($this, tag.getDescription$()).replace(/\n$/, "");
				_ += "</li>\n";
			}));
			_ += "</ul>\n";
		}
	}
	return _;
};


function DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$($this, docComment) {
	var _;
	var seeTags;
	_ = "";
	if (docComment != null) {
		if (docComment.getDescription$() !== "") {
			_ += "<div class=\"description\">\n";
			_ += docComment.getDescription$().replace(/\t/g, "  ").replace(/\n$/, "");
			_ += "\n";
			_ += "</div>\n";
		}
		seeTags = DocComment$getTagsByName$LDocComment$S(docComment, "see");
		if (seeTags.length > 0) {
			_ += "<ul class=\"see\">\n";
			seeTags.forEach((function (tag) {
				_ += "<li>";
				_ += DocumentGenerator$_autoLink$LDocumentGenerator$S($this, tag.getDescription$()).replace(/\n$/, "");
				_ += "</li>\n";
			}));
			_ += "</ul>\n";
		}
	}
	return _;
};

DocumentGenerator._descriptionToHTML$LDocumentGenerator$LDocComment$ = DocumentGenerator$_descriptionToHTML$LDocumentGenerator$LDocComment$;

DocumentGenerator.prototype._autoLink$S = function (str) {
	var $this = this;
	return str.replace(/^https?:\/\/[A-Za-z0-9\-\._~:\/?#\[\]@!$&'()*+,;=]+/g, (function (matched) {
		return Util$format$SAS('<a href="%1">%1</a>', [ matched ]);
	}));
};


function DocumentGenerator$_autoLink$LDocumentGenerator$S($this, str) {
	return str.replace(/^https?:\/\/[A-Za-z0-9\-\._~:\/?#\[\]@!$&'()*+,;=]+/g, (function (matched) {
		return Util$format$SAS('<a href="%1">%1</a>', [ matched ]);
	}));
};

DocumentGenerator._autoLink$LDocumentGenerator$S = DocumentGenerator$_autoLink$LDocumentGenerator$S;

DocumentGenerator.prototype._argumentDescriptionToHTML$SLDocComment$ = function (name, docComment) {
	return (docComment != null ? DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S(this, docComment, name) : "");
};


function DocumentGenerator$_argumentDescriptionToHTML$LDocumentGenerator$SLDocComment$($this, name, docComment) {
	return (docComment != null ? DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S($this, docComment, name) : "");
};

DocumentGenerator._argumentDescriptionToHTML$LDocumentGenerator$SLDocComment$ = DocumentGenerator$_argumentDescriptionToHTML$LDocumentGenerator$SLDocComment$;

DocumentGenerator.prototype._formalTypeArgsToHTML$ALToken$ = function (typeArgs) {
	var $this = this;
	return (typeArgs.length === 0 ? "" : ".&lt;" + typeArgs.map((function (typeArg) {
		return DocumentGenerator$_escape$LDocumentGenerator$S($this, typeArg._value);
	})).join(", ") + "&gt;");
};


function DocumentGenerator$_formalTypeArgsToHTML$LDocumentGenerator$ALToken$($this, typeArgs) {
	return (typeArgs.length === 0 ? "" : ".&lt;" + typeArgs.map((function (typeArg) {
		return DocumentGenerator$_escape$LDocumentGenerator$S($this, typeArg._value);
	})).join(", ") + "&gt;");
};

DocumentGenerator._formalTypeArgsToHTML$LDocumentGenerator$ALToken$ = DocumentGenerator$_formalTypeArgsToHTML$LDocumentGenerator$ALToken$;

DocumentGenerator.prototype._typeToHTML$LParser$LType$ = function (parser, type) {
	var $this = this;
	var classDef;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	if (type instanceof ObjectType) {
		classDef = type.getClassDef$();
		if (classDef != null) {
			return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$(this, parser, classDef);
		} else if (type instanceof ParsedObjectType && (this$5 = type, this$5._typeArguments).length !== 0) {
			classDef = QualifiedName$getTemplateClass$LQualifiedName$LParser$((this$0 = type, this$0._qualifiedName), parser);
			if (classDef != null) {
				return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$(this, parser, classDef) + ".&lt;" + (this$1 = type, this$1._typeArguments).map((function (type) {
					return DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type);
				})).join(", ") + "&gt;";
			}
		}
	} else if (type instanceof FunctionType) {
		return "function (" + (this$2 = type, this$2._argTypes).map((function (type) {
			return ":" + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type);
		})).join(", ") + ") : " + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$(this, parser, (this$3 = type, this$3._returnType));
	} else if (type instanceof VariableLengthArgumentType) {
		return "..." + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$(this, parser, (this$4 = type, this$4._baseType));
	}
	return DocumentGenerator$_escape$LDocumentGenerator$S(this, type.toString());
};


function DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type) {
	var classDef;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	if (type instanceof ObjectType) {
		classDef = type.getClassDef$();
		if (classDef != null) {
			return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef);
		} else if (type instanceof ParsedObjectType && (this$5 = type, this$5._typeArguments).length !== 0) {
			classDef = QualifiedName$getTemplateClass$LQualifiedName$LParser$((this$0 = type, this$0._qualifiedName), parser);
			if (classDef != null) {
				return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef) + ".&lt;" + (this$1 = type, this$1._typeArguments).map((function (type) {
					return DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type);
				})).join(", ") + "&gt;";
			}
		}
	} else if (type instanceof FunctionType) {
		return "function (" + (this$2 = type, this$2._argTypes).map((function (type) {
			return ":" + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type);
		})).join(", ") + ") : " + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, (this$3 = type, this$3._returnType));
	} else if (type instanceof VariableLengthArgumentType) {
		return "..." + DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, (this$4 = type, this$4._baseType));
	}
	return DocumentGenerator$_escape$LDocumentGenerator$S($this, type.toString());
};

DocumentGenerator._typeToHTML$LDocumentGenerator$LParser$LType$ = DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$;

DocumentGenerator.prototype._classDefToHTML$LParser$LClassDefinition$ = function (parser, classDef) {
	var $this = this;
	var result;
	var determineParserOfClassDef;
	var parserOfClassDef;
	var _;
	var this$0;
	var this$1;
	if (classDef instanceof InstantiatedClassDefinition) {
		return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$(this, parser, (this$0 = classDef, this$0._templateClassDef)) + ".&lt;" + (this$1 = classDef, this$1._typeArguments).map((function (type) {
			return DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type);
		})).join(", ") + "&gt;";
	}
	result = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$get$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$(this._classDefToHTMLCache, classDef);
	if (result != null) {
		return result;
	}
	function determineParserOfClassDef() {
		var parsers;
		var i;
		var templateClassDefs;
		var j;
		var classDefs;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var this$4;
		this$0 = $this._compiler;
		parsers = this$0._parsers;
		for (i = 0; i < parsers.length; ++i) {
			if (classDef instanceof TemplateClassDefinition) {
				this$1 = parsers[i];
				templateClassDefs = this$1._templateClassDefs;
				for (j = 0; j < templateClassDefs.length; ++j) {
					templateClassDefs = templateClassDefs.concat((this$2 = templateClassDefs[j], this$2._templateInners));
				}
				if (templateClassDefs.indexOf(classDef) !== -1) {
					return parsers[i];
				}
			} else {
				this$3 = parsers[i];
				classDefs = this$3._classDefs;
				for (j = 0; j < classDefs.length; ++j) {
					classDefs = classDefs.concat((this$4 = classDefs[j], this$4._inners));
				}
				if (classDefs.indexOf(classDef) !== -1) {
					return parsers[i];
				}
			}
		}
		throw new Error("could not determine the parser to which the class belongs:" + ClassDefinition$classFullName$LClassDefinition$(classDef));
	}
	parserOfClassDef = determineParserOfClassDef();
	if (! this._pathFilter(parserOfClassDef._filename)) {
		return DocumentGenerator$_escape$LDocumentGenerator$S(this, ClassDefinition$classFullName$LClassDefinition$(classDef));
	}
	_ = "";
	_ += "<a href=\"";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, parserOfClassDef._filename).replace(/\n$/, "");
	_ += ".html#class-";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, ClassDefinition$classFullName$LClassDefinition$(classDef)).replace(/\n$/, "");
	_ += "\">";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S(this, ClassDefinition$classFullName$LClassDefinition$(classDef)).replace(/\n$/, "");
	_ += "</a>\n";
	_ = _.trim();
	TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$set$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$S(this._classDefToHTMLCache, classDef, _);
	return _;
};


function DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, classDef) {
	var result;
	var determineParserOfClassDef;
	var parserOfClassDef;
	var _;
	var this$0;
	var this$1;
	if (classDef instanceof InstantiatedClassDefinition) {
		return DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$($this, parser, (this$0 = classDef, this$0._templateClassDef)) + ".&lt;" + (this$1 = classDef, this$1._typeArguments).map((function (type) {
			return DocumentGenerator$_typeToHTML$LDocumentGenerator$LParser$LType$($this, parser, type);
		})).join(", ") + "&gt;";
	}
	result = TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$get$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$($this._classDefToHTMLCache, classDef);
	if (result != null) {
		return result;
	}
	function determineParserOfClassDef() {
		var parsers;
		var i;
		var templateClassDefs;
		var j;
		var classDefs;
		var this$0;
		var this$1;
		var this$2;
		var this$3;
		var this$4;
		this$0 = $this._compiler;
		parsers = this$0._parsers;
		for (i = 0; i < parsers.length; ++i) {
			if (classDef instanceof TemplateClassDefinition) {
				this$1 = parsers[i];
				templateClassDefs = this$1._templateClassDefs;
				for (j = 0; j < templateClassDefs.length; ++j) {
					templateClassDefs = templateClassDefs.concat((this$2 = templateClassDefs[j], this$2._templateInners));
				}
				if (templateClassDefs.indexOf(classDef) !== -1) {
					return parsers[i];
				}
			} else {
				this$3 = parsers[i];
				classDefs = this$3._classDefs;
				for (j = 0; j < classDefs.length; ++j) {
					classDefs = classDefs.concat((this$4 = classDefs[j], this$4._inners));
				}
				if (classDefs.indexOf(classDef) !== -1) {
					return parsers[i];
				}
			}
		}
		throw new Error("could not determine the parser to which the class belongs:" + ClassDefinition$classFullName$LClassDefinition$(classDef));
	}
	parserOfClassDef = determineParserOfClassDef();
	if (! $this._pathFilter(parserOfClassDef._filename)) {
		return DocumentGenerator$_escape$LDocumentGenerator$S($this, ClassDefinition$classFullName$LClassDefinition$(classDef));
	}
	_ = "";
	_ += "<a href=\"";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, parserOfClassDef._filename).replace(/\n$/, "");
	_ += ".html#class-";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, ClassDefinition$classFullName$LClassDefinition$(classDef)).replace(/\n$/, "");
	_ += "\">";
	_ += DocumentGenerator$_escape$LDocumentGenerator$S($this, ClassDefinition$classFullName$LClassDefinition$(classDef)).replace(/\n$/, "");
	_ += "</a>\n";
	_ = _.trim();
	TypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$set$LTypedMap$x2E$x3CClassDefinition$x2Cstring$x3E$LClassDefinition$S($this._classDefToHTMLCache, classDef, _);
	return _;
};

DocumentGenerator._classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$ = DocumentGenerator$_classDefToHTML$LDocumentGenerator$LParser$LClassDefinition$;

DocumentGenerator.prototype._flagsToHTML$N = function (flags) {
	var strs;
	strs = [];
	if ((flags & 8) !== 0) {
		strs.push("static");
	}
	if ((flags & 1) !== 0) {
		strs.push("const");
	}
	if ((flags & 512) !== 0) {
		strs.push("__readonly__");
	}
	if ((flags & 2) !== 0) {
		strs.push("abstract");
	}
	if ((flags & 4) !== 0) {
		strs.push("final");
	}
	if ((flags & 32) !== 0) {
		strs.push("override");
	}
	if ((flags & 1024) !== 0) {
		strs.push("inline");
	}
	if ((flags & 16) !== 0) {
		strs.push("native");
	}
	if ((flags & 16384) !== 0) {
		strs.push("__export__");
	}
	return strs.join(" ");
};


function DocumentGenerator$_flagsToHTML$LDocumentGenerator$N($this, flags) {
	var strs;
	strs = [];
	if ((flags & 8) !== 0) {
		strs.push("static");
	}
	if ((flags & 1) !== 0) {
		strs.push("const");
	}
	if ((flags & 512) !== 0) {
		strs.push("__readonly__");
	}
	if ((flags & 2) !== 0) {
		strs.push("abstract");
	}
	if ((flags & 4) !== 0) {
		strs.push("final");
	}
	if ((flags & 32) !== 0) {
		strs.push("override");
	}
	if ((flags & 1024) !== 0) {
		strs.push("inline");
	}
	if ((flags & 16) !== 0) {
		strs.push("native");
	}
	if ((flags & 16384) !== 0) {
		strs.push("__export__");
	}
	return strs.join(" ");
};

DocumentGenerator._flagsToHTML$LDocumentGenerator$N = DocumentGenerator$_flagsToHTML$LDocumentGenerator$N;

DocumentGenerator.prototype._escape$S = function (str) {
	var $this = this;
	return str.replace(/[<>&'"]/g, (function (ch) {
		return ({ "<": "&lt;", ">": "&gt;", "&": "&amp;", "'": "&#39;", "\"": "&quot;" })[ch];
	}));
};


function DocumentGenerator$_escape$LDocumentGenerator$S($this, str) {
	return str.replace(/[<>&'"]/g, (function (ch) {
		return ({ "<": "&lt;", ">": "&gt;", "&": "&amp;", "'": "&#39;", "\"": "&quot;" })[ch];
	}));
};

DocumentGenerator._escape$LDocumentGenerator$S = DocumentGenerator$_escape$LDocumentGenerator$S;

DocumentGenerator.prototype._hasPublicProperties$LClassDefinition$ = function (classDef) {
	var $this = this;
	return ! ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
		var this$0$0$0;
		return (! ((this$0$0$0 = varDef._nameToken, this$0$0$0._value).charAt(0) === "_" || varDef._docComment && DocComment$getTagByName$LDocComment$S(varDef._docComment, 'private') || (varDef._flags & 32768) !== 0) ? false : true);
	}));
};


function DocumentGenerator$_hasPublicProperties$LDocumentGenerator$LClassDefinition$($this, classDef) {
	return ! ClassDefinition$forEachMemberVariable$LClassDefinition$F$LMemberVariableDefinition$B$(classDef, (function (varDef) {
		var this$0$0$0;
		return (! ((this$0$0$0 = varDef._nameToken, this$0$0$0._value).charAt(0) === "_" || varDef._docComment && DocComment$getTagByName$LDocComment$S(varDef._docComment, 'private') || (varDef._flags & 32768) !== 0) ? false : true);
	}));
};

DocumentGenerator._hasPublicProperties$LDocumentGenerator$LClassDefinition$ = DocumentGenerator$_hasPublicProperties$LDocumentGenerator$LClassDefinition$;

DocumentGenerator.prototype._hasPublicFunctions$LClassDefinition$ = function (classDef) {
	var $this = this;
	return ! ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
		var this$0$0$0;
		var this$0$0$1;
		return (funcDef instanceof InstantiatedMemberFunctionDefinition || (this$0$0$0 = funcDef._nameToken, this$0$0$0._value) === "constructor" && (funcDef._flags & 8) === 0 || ((this$0$0$1 = funcDef._nameToken, this$0$0$1._value).charAt(0) === "_" || funcDef._docComment && DocComment$getTagByName$LDocComment$S(funcDef._docComment, 'private') || (funcDef._flags & 32768) !== 0) ? true : false);
	}));
};


function DocumentGenerator$_hasPublicFunctions$LDocumentGenerator$LClassDefinition$($this, classDef) {
	return ! ClassDefinition$forEachMemberFunction$LClassDefinition$F$LMemberFunctionDefinition$B$(classDef, (function (funcDef) {
		var this$0$0$0;
		var this$0$0$1;
		return (funcDef instanceof InstantiatedMemberFunctionDefinition || (this$0$0$0 = funcDef._nameToken, this$0$0$0._value) === "constructor" && (funcDef._flags & 8) === 0 || ((this$0$0$1 = funcDef._nameToken, this$0$0$1._value).charAt(0) === "_" || funcDef._docComment && DocComment$getTagByName$LDocComment$S(funcDef._docComment, 'private') || (funcDef._flags & 32768) !== 0) ? true : false);
	}));
};

DocumentGenerator._hasPublicFunctions$LDocumentGenerator$LClassDefinition$ = DocumentGenerator$_hasPublicFunctions$LDocumentGenerator$LClassDefinition$;

DocumentGenerator.prototype._argsHasDocComment$LMemberFunctionDefinition$ = function (funcDef) {
	var docComment;
	var args;
	var argIndex;
	var this$0;
	var this$1;
	var args$len$0;
	docComment = funcDef._docComment;
	if (docComment == null) {
		return false;
	}
	args = funcDef._args;
	for ((argIndex = 0, args$len$0 = args.length); argIndex < args$len$0; ++argIndex) {
		if (DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S(this, docComment, (this$1 = (this$0 = args[argIndex], this$0._name), this$1._value)) !== "") {
			return true;
		}
	}
	return false;
};


function DocumentGenerator$_argsHasDocComment$LDocumentGenerator$LMemberFunctionDefinition$($this, funcDef) {
	var docComment;
	var args;
	var argIndex;
	var this$0;
	var this$1;
	var args$len$0;
	docComment = funcDef._docComment;
	if (docComment == null) {
		return false;
	}
	args = funcDef._args;
	for ((argIndex = 0, args$len$0 = args.length); argIndex < args$len$0; ++argIndex) {
		if (DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S($this, docComment, (this$1 = (this$0 = args[argIndex], this$0._name), this$1._value)) !== "") {
			return true;
		}
	}
	return false;
};

DocumentGenerator._argsHasDocComment$LDocumentGenerator$LMemberFunctionDefinition$ = DocumentGenerator$_argsHasDocComment$LDocumentGenerator$LMemberFunctionDefinition$;

DocumentGenerator.prototype._getDescriptionOfNamedArgument$LDocComment$S = function (docComment, argName) {
	var params;
	var paramIndex;
	var this$0;
	var this$0$0;
	params = docComment._params;
	for (paramIndex = 0; paramIndex < params.length; ++paramIndex) {
		if ((this$0 = params[paramIndex], this$0$0 = this$0._token, this$0$0._value) === argName) {
			return params[paramIndex].getDescription$();
		}
	}
	return "";
};


function DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S($this, docComment, argName) {
	var params;
	var paramIndex;
	var this$0;
	var this$0$0;
	params = docComment._params;
	for (paramIndex = 0; paramIndex < params.length; ++paramIndex) {
		if ((this$0 = params[paramIndex], this$0$0 = this$0._token, this$0$0._value) === argName) {
			return params[paramIndex].getDescription$();
		}
	}
	return "";
};

DocumentGenerator._getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S = DocumentGenerator$_getDescriptionOfNamedArgument$LDocumentGenerator$LDocComment$S;

DocumentGenerator.prototype._isConstructor$LMemberFunctionDefinition$ = function (funcDef) {
	var this$0$0;
	return (this$0$0 = funcDef._nameToken, this$0$0._value) === "constructor" && (funcDef._flags & 8) === 0;
};


function DocumentGenerator$_isConstructor$LDocumentGenerator$LMemberFunctionDefinition$($this, funcDef) {
	var this$0$0;
	return (this$0$0 = funcDef._nameToken, this$0$0._value) === "constructor" && (funcDef._flags & 8) === 0;
};

DocumentGenerator._isConstructor$LDocumentGenerator$LMemberFunctionDefinition$ = DocumentGenerator$_isConstructor$LDocumentGenerator$LMemberFunctionDefinition$;

DocumentGenerator.prototype._isPrivate$LClassDefinition$ = function (classDef) {
	return !! (classDef.className$().charAt(0) === "_" || classDef._docComment && DocComment$getTagByName$LDocComment$S(classDef._docComment, 'private'));
};


function DocumentGenerator$_isPrivate$LDocumentGenerator$LClassDefinition$($this, classDef) {
	return !! (classDef.className$().charAt(0) === "_" || classDef._docComment && DocComment$getTagByName$LDocComment$S(classDef._docComment, 'private'));
};

DocumentGenerator._isPrivate$LDocumentGenerator$LClassDefinition$ = DocumentGenerator$_isPrivate$LDocumentGenerator$LClassDefinition$;

DocumentGenerator.prototype._isPrivate$LMemberDefinition$ = function (memberDef) {
	var this$0$0;
	return !! ((this$0$0 = memberDef._nameToken, this$0$0._value).charAt(0) === "_" || memberDef._docComment && DocComment$getTagByName$LDocComment$S(memberDef._docComment, 'private') || (memberDef._flags & 32768) !== 0);
};


function DocumentGenerator$_isPrivate$LDocumentGenerator$LMemberDefinition$($this, memberDef) {
	var this$0$0;
	return !! ((this$0$0 = memberDef._nameToken, this$0$0._value).charAt(0) === "_" || memberDef._docComment && DocComment$getTagByName$LDocComment$S(memberDef._docComment, 'private') || (memberDef._flags & 32768) !== 0);
};

DocumentGenerator._isPrivate$LDocumentGenerator$LMemberDefinition$ = DocumentGenerator$_isPrivate$LDocumentGenerator$LMemberDefinition$;

DocumentGenerator.prototype._name$S = function (name) {
	return "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S(this, name) + "</strong>";
};


function DocumentGenerator$_name$LDocumentGenerator$S($this, name) {
	return "<strong>" + DocumentGenerator$_escape$LDocumentGenerator$S($this, name) + "</strong>";
};

DocumentGenerator._name$LDocumentGenerator$S = DocumentGenerator$_name$LDocumentGenerator$S;

function _ExpressionTransformer(transformer, identifier) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap[identifier] == null) {
		_ExpressionTransformer._expressionCountMap[identifier] = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap[identifier]++;
};

$__jsx_extend([_ExpressionTransformer], Object);
_ExpressionTransformer.prototype.getID$ = function () {
	return this._id;
};


function _ExpressionTransformer$getID$L_ExpressionTransformer$($this) {
	return $this._id;
};

_ExpressionTransformer.getID$L_ExpressionTransformer$ = _ExpressionTransformer$getID$L_ExpressionTransformer$;

function _MultiaryOperatorTransformer(transformer, identifier) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap[identifier] == null) {
		_ExpressionTransformer._expressionCountMap[identifier] = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap[identifier]++;
};

$__jsx_extend([_MultiaryOperatorTransformer], _ExpressionTransformer);
_MultiaryOperatorTransformer.prototype.doCPSTransform$LMemberFunctionDefinition$LExpression$LType$ = function (parent, continuation, returnType) {
	if (continuation != null) {
	}
	return _MultiaryOperatorTransformer$transformOp$L_MultiaryOperatorTransformer$LMemberFunctionDefinition$LExpression$ALExpression$LType$(this, parent, continuation, this.getArgumentExprs$(), returnType);
};


_MultiaryOperatorTransformer.prototype.transformOp$LMemberFunctionDefinition$LExpression$ALExpression$LType$ = function (parent, continuation, exprs, returnType) {
	var result;
	var arg$0;
	if (exprs.length === 0) {
		arg$0 = this.constructOp$ALExpression$([  ]);
		return (continuation == null ? arg$0 : new CallExpression(arg$0._token, continuation, [ arg$0 ]));
	} else {
		if (continuation != null) {
		}
		result = {};
		_MultiaryOperatorTransformer$_transformArgs$L_MultiaryOperatorTransformer$LMemberFunctionDefinition$ALExpression$LType$HX(this, parent, exprs, returnType, result);
		this._injectBody$ALExpression$LExpression$LMemberFunctionDefinition$LMemberFunctionDefinition$LExpression$(result.newArgs, result.topExpr, result.topFuncDef, result.botFuncDef, continuation);
		return result.topExpr;
	}
};


function _MultiaryOperatorTransformer$transformOp$L_MultiaryOperatorTransformer$LMemberFunctionDefinition$LExpression$ALExpression$LType$($this, parent, continuation, exprs, returnType) {
	var result;
	var arg$0;
	if (exprs.length === 0) {
		arg$0 = $this.constructOp$ALExpression$([  ]);
		return (continuation == null ? arg$0 : new CallExpression(arg$0._token, continuation, [ arg$0 ]));
	} else {
		if (continuation != null) {
		}
		result = {};
		_MultiaryOperatorTransformer$_transformArgs$L_MultiaryOperatorTransformer$LMemberFunctionDefinition$ALExpression$LType$HX($this, parent, exprs, returnType, result);
		$this._injectBody$ALExpression$LExpression$LMemberFunctionDefinition$LMemberFunctionDefinition$LExpression$(result.newArgs, result.topExpr, result.topFuncDef, result.botFuncDef, continuation);
		return result.topExpr;
	}
};

_MultiaryOperatorTransformer.transformOp$L_MultiaryOperatorTransformer$LMemberFunctionDefinition$LExpression$ALExpression$LType$ = _MultiaryOperatorTransformer$transformOp$L_MultiaryOperatorTransformer$LMemberFunctionDefinition$LExpression$ALExpression$LType$;

_MultiaryOperatorTransformer.prototype._transformArgs$LMemberFunctionDefinition$ALExpression$LType$HX = function (parent, exprs, returnType, result) {
	var newArgs;
	var i;
	var newArgLocals;
	var topExpr;
	var rootFuncDef;
	var prevFuncDef;
	var funcDef;
	var cont;
	var body;
	var type$0;
	var id$0;
	var this$0;
	var token$0;
	var args$0;
	var this$1;
	var this$2;
	newArgs = [];
	for (i = 0; i < exprs.length; ++i) {
		newArgs.push((type$0 = exprs[i].getType$(), id$0 = _Util$1._numUniqVar++, new ArgumentDeclaration(new Token$2("$a" + (id$0 + ""), true), type$0)));
	}
	newArgLocals = [];
	for (i = 0; i < exprs.length; ++i) {
		newArgLocals.push(new LocalExpression((this$0 = exprs[i], this$0._token), newArgs[i]));
	}
	topExpr = null;
	rootFuncDef = null;
	prevFuncDef = parent;
	for (i = 0; i < exprs.length; ++i) {
		this$2 = this.getExpression$();
		token$0 = this$2._token;
		args$0 = [ newArgs[i] ];
		funcDef = _Util$1$_createNamedFunction$LMemberFunctionDefinition$LToken$LToken$ALArgumentDeclaration$LType$(prevFuncDef, token$0, null, args$0, returnType);
		if (rootFuncDef == null) {
			rootFuncDef = funcDef;
		}
		cont = new FunctionExpression(funcDef._token, funcDef);
		body = CPSTransformCommand$_getExpressionTransformerFor$LCPSTransformCommand$LExpression$(this._transformer, exprs[i]).doCPSTransform$LMemberFunctionDefinition$LExpression$LType$(prevFuncDef, cont, returnType);
		if (i === 0) {
			topExpr = body;
		} else {
			prevFuncDef._statements.push(new ReturnStatement(new Token$2("return", false), body));
		}
		prevFuncDef = funcDef;
	}
	this$1 = this.getExpression$();
	topExpr._token = this$1._token;
	result.newArgs = newArgLocals;
	result.topExpr = topExpr;
	result.topFuncDef = rootFuncDef;
	result.botFuncDef = prevFuncDef;
};


function _MultiaryOperatorTransformer$_transformArgs$L_MultiaryOperatorTransformer$LMemberFunctionDefinition$ALExpression$LType$HX($this, parent, exprs, returnType, result) {
	var newArgs;
	var i;
	var newArgLocals;
	var topExpr;
	var rootFuncDef;
	var prevFuncDef;
	var funcDef;
	var cont;
	var body;
	var type$0;
	var id$0;
	var this$0;
	var token$0;
	var args$0;
	var this$1;
	var this$2;
	newArgs = [];
	for (i = 0; i < exprs.length; ++i) {
		newArgs.push((type$0 = exprs[i].getType$(), id$0 = _Util$1._numUniqVar++, new ArgumentDeclaration(new Token$2("$a" + (id$0 + ""), true), type$0)));
	}
	newArgLocals = [];
	for (i = 0; i < exprs.length; ++i) {
		newArgLocals.push(new LocalExpression((this$0 = exprs[i], this$0._token), newArgs[i]));
	}
	topExpr = null;
	rootFuncDef = null;
	prevFuncDef = parent;
	for (i = 0; i < exprs.length; ++i) {
		this$2 = $this.getExpression$();
		token$0 = this$2._token;
		args$0 = [ newArgs[i] ];
		funcDef = _Util$1$_createNamedFunction$LMemberFunctionDefinition$LToken$LToken$ALArgumentDeclaration$LType$(prevFuncDef, token$0, null, args$0, returnType);
		if (rootFuncDef == null) {
			rootFuncDef = funcDef;
		}
		cont = new FunctionExpression(funcDef._token, funcDef);
		body = CPSTransformCommand$_getExpressionTransformerFor$LCPSTransformCommand$LExpression$($this._transformer, exprs[i]).doCPSTransform$LMemberFunctionDefinition$LExpression$LType$(prevFuncDef, cont, returnType);
		if (i === 0) {
			topExpr = body;
		} else {
			prevFuncDef._statements.push(new ReturnStatement(new Token$2("return", false), body));
		}
		prevFuncDef = funcDef;
	}
	this$1 = $this.getExpression$();
	topExpr._token = this$1._token;
	result.newArgs = newArgLocals;
	result.topExpr = topExpr;
	result.topFuncDef = rootFuncDef;
	result.botFuncDef = prevFuncDef;
};

_MultiaryOperatorTransformer._transformArgs$L_MultiaryOperatorTransformer$LMemberFunctionDefinition$ALExpression$LType$HX = _MultiaryOperatorTransformer$_transformArgs$L_MultiaryOperatorTransformer$LMemberFunctionDefinition$ALExpression$LType$HX;

_MultiaryOperatorTransformer.prototype._injectBody$ALExpression$LExpression$LMemberFunctionDefinition$LMemberFunctionDefinition$LExpression$ = function (args, topExpr, topFuncDef, botFuncDef, continuation) {
	var body;
	var arg$0;
	arg$0 = this.constructOp$ALExpression$(args);
	body = (continuation == null ? arg$0 : new CallExpression(arg$0._token, continuation, [ arg$0 ]));
	botFuncDef._statements = [ new ReturnStatement(new Token$2("return", false), body) ];
	Util$rebaseClosures$LMemberFunctionDefinition$LMemberFunctionDefinition$(topFuncDef, botFuncDef);
};


_MultiaryOperatorTransformer.prototype._createContinuationCall$LExpression$LExpression$ = function (proc, arg) {
	return (proc == null ? arg : new CallExpression(arg._token, proc, [ arg ]));
};


function _MultiaryOperatorTransformer$_createContinuationCall$L_MultiaryOperatorTransformer$LExpression$LExpression$($this, proc, arg) {
	return (proc == null ? arg : new CallExpression(arg._token, proc, [ arg ]));
};

_MultiaryOperatorTransformer._createContinuationCall$L_MultiaryOperatorTransformer$LExpression$LExpression$ = _MultiaryOperatorTransformer$_createContinuationCall$L_MultiaryOperatorTransformer$LExpression$LExpression$;

function _LeafExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap.LEAF == null) {
		_ExpressionTransformer._expressionCountMap.LEAF = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap.LEAF++;
	this._expr = expr;
};

$__jsx_extend([_LeafExpressionTransformer], _MultiaryOperatorTransformer);
_LeafExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_LeafExpressionTransformer.prototype.getArgumentExprs$ = function () {
	return [];
};


_LeafExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	return this._expr;
};


function _ArrayLiteralExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap["ARRAY-LITERAL"] == null) {
		_ExpressionTransformer._expressionCountMap["ARRAY-LITERAL"] = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap["ARRAY-LITERAL"]++;
	this._expr = expr;
};

$__jsx_extend([_ArrayLiteralExpressionTransformer], _MultiaryOperatorTransformer);
_ArrayLiteralExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_ArrayLiteralExpressionTransformer.prototype.getArgumentExprs$ = function () {
	var this$0;
	this$0 = this._expr;
	return this$0._exprs;
};


_ArrayLiteralExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	var arrayLiteralExpr;
	var this$0;
	this$0 = this._expr;
	arrayLiteralExpr = new ArrayLiteralExpression(this$0._token, Util$cloneArray$ALExpression$(this$0._exprs), this$0._type);
	arrayLiteralExpr._exprs = exprs;
	return arrayLiteralExpr;
};


function _MapLiteralExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap["MAP-LITERAL"] == null) {
		_ExpressionTransformer._expressionCountMap["MAP-LITERAL"] = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap["MAP-LITERAL"]++;
	this._expr = expr;
};

$__jsx_extend([_MapLiteralExpressionTransformer], _MultiaryOperatorTransformer);
_MapLiteralExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_MapLiteralExpressionTransformer.prototype.getArgumentExprs$ = function () {
	var $this = this;
	var this$0;
	return (this$0 = this._expr, this$0._elements).map((function (elt) {
		return elt._expr;
	}));
};


_MapLiteralExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	var elts;
	var i;
	var elt;
	var this$0;
	var this$1;
	var this$3;
	var _expr$0;
	elts = [];
	for (i = 0; i < (this$3 = this._expr, this$3._elements).length; ++i) {
		elt = (this$0 = this._expr, this$0._elements)[i];
		elts[i] = ({_key: elt._key, _expr: exprs[i]});
	}
	return new MapLiteralExpression((this$1 = _expr$0 = this._expr, this$1._token), elts, (_expr$0, _expr$0._type));
};


function _FunctionExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap.FUNCTION == null) {
		_ExpressionTransformer._expressionCountMap.FUNCTION = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap.FUNCTION++;
	this._expr = expr;
};

$__jsx_extend([_FunctionExpressionTransformer], _MultiaryOperatorTransformer);
_FunctionExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_FunctionExpressionTransformer.prototype.getArgumentExprs$ = function () {
	return [];
};


_FunctionExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	return this._expr;
};


function _UnaryExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap.UNARY == null) {
		_ExpressionTransformer._expressionCountMap.UNARY = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap.UNARY++;
	this._expr = expr;
};

$__jsx_extend([_UnaryExpressionTransformer], _MultiaryOperatorTransformer);
_UnaryExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_UnaryExpressionTransformer.prototype.getArgumentExprs$ = function () {
	var this$0;
	return [ (this$0 = this._expr, this$0._expr) ];
};


_UnaryExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	return this._clone$LExpression$(exprs[0]);
};


function _BitwiseNotExpressionTransformer(transformer, expr) {
	_UnaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_BitwiseNotExpressionTransformer], _UnaryExpressionTransformer);
_BitwiseNotExpressionTransformer.prototype._clone$LExpression$ = function (arg) {
	var this$0;
	return new BitwiseNotExpression((this$0 = this._expr, this$0._token), arg);
};


function _InstanceofExpressionTransformer(transformer, expr) {
	_UnaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_InstanceofExpressionTransformer], _UnaryExpressionTransformer);
_InstanceofExpressionTransformer.prototype._clone$LExpression$ = function (arg) {
	var this$0;
	var this$1;
	var _expr$0;
	return new InstanceofExpression((this$0 = _expr$0 = this._expr, this$0._token), arg, (this$1 = _expr$0, this$1._expectedType));
};


function _AsExpressionTransformer(transformer, expr) {
	_UnaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_AsExpressionTransformer], _UnaryExpressionTransformer);
_AsExpressionTransformer.prototype._clone$LExpression$ = function (arg) {
	var this$0;
	var _expr$0;
	return new AsExpression((this$0 = _expr$0 = this._expr, this$0._token), arg, _expr$0.getType$());
};


function _AsNoConvertExpressionTransformer(transformer, expr) {
	_UnaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_AsNoConvertExpressionTransformer], _UnaryExpressionTransformer);
_AsNoConvertExpressionTransformer.prototype._clone$LExpression$ = function (arg) {
	var this$0;
	var _expr$0;
	return new AsNoConvertExpression((this$0 = _expr$0 = this._expr, this$0._token), arg, _expr$0.getType$());
};


function _LogicalNotExpressionTransformer(transformer, expr) {
	_UnaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_LogicalNotExpressionTransformer], _UnaryExpressionTransformer);
_LogicalNotExpressionTransformer.prototype._clone$LExpression$ = function (arg) {
	var this$0;
	return new LogicalNotExpression((this$0 = this._expr, this$0._token), arg);
};


function _IncrementExpressionTransformer(transformer, expr) {
	_UnaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_IncrementExpressionTransformer], _UnaryExpressionTransformer);
_IncrementExpressionTransformer.prototype.getArgumentExprs$ = function () {
	var expr;
	var arrayExpr;
	var this$0;
	var this$1;
	var this$2;
	this$0 = this._expr;
	expr = this$0._expr;
	if (expr instanceof LocalExpression || expr instanceof PropertyExpression && (this$2 = expr, this$2._expr).isClassSpecifier$()) {
		return [];
	} else if (expr instanceof PropertyExpression) {
		return [ (this$1 = expr, this$1._expr) ];
	} else if (expr instanceof ArrayExpression) {
		arrayExpr = expr;
		return [ arrayExpr._expr1, arrayExpr._expr2 ];
	} else {
		throw new Error("logic flaw");
	}
};


_IncrementExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	var expr;
	var arrayExpr;
	var this$0;
	var this$1;
	var propExpr$0;
	this$0 = this._expr;
	expr = this$0._expr;
	if (expr instanceof PropertyExpression) {
		this$1 = expr;
		propExpr$0 = new PropertyExpression$0(this$1._token, this$1._expr.clone$(), this$1._identifierToken, this$1._typeArgs, this$1._type);
		propExpr$0._isInner = this$1._isInner;
		propExpr$0._expr = exprs[0];
		return this._clone$LExpression$(propExpr$0);
	} else if (expr instanceof ArrayExpression) {
		arrayExpr = new ArrayExpression(expr._token, exprs[0], exprs[1]);
		arrayExpr._type = expr.getType$();
		return this._clone$LExpression$(arrayExpr);
	} else {
		return this._expr;
	}
};


function _PostIncrementExpressionTransformer(transformer, expr) {
	_IncrementExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_PostIncrementExpressionTransformer], _IncrementExpressionTransformer);
_PostIncrementExpressionTransformer.prototype._clone$LExpression$ = function (arg) {
	var this$0;
	return new PostIncrementExpression((this$0 = this._expr, this$0._token), arg);
};


function _PreIncrementExpressionTransformer(transformer, expr) {
	_IncrementExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_PreIncrementExpressionTransformer], _IncrementExpressionTransformer);
_PreIncrementExpressionTransformer.prototype._clone$LExpression$ = function (arg) {
	var this$0;
	return new PreIncrementExpression((this$0 = this._expr, this$0._token), arg);
};


function _PropertyExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap.PROPERTY == null) {
		_ExpressionTransformer._expressionCountMap.PROPERTY = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap.PROPERTY++;
	this._expr = expr;
};

$__jsx_extend([_PropertyExpressionTransformer], _MultiaryOperatorTransformer);
_PropertyExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_PropertyExpressionTransformer.prototype.getArgumentExprs$ = function () {
	var this$0;
	var this$1;
	var this$2;
	if ((this$0 = this._expr, this$0._type) instanceof MemberFunctionType) {
		throw new Error("logic flaw");
	}
	return ((this$1 = this._expr, this$1._expr).isClassSpecifier$() ? [] : [ (this$2 = this._expr, this$2._expr) ]);
};


_PropertyExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	var propExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$4;
	var _expr$0;
	if ((this$4 = this._expr, this$4._expr).isClassSpecifier$()) {
		return this._expr;
	} else {
		propExpr = new PropertyExpression$0((this$0 = _expr$0 = this._expr, this$0._token), exprs[0], (this$1 = _expr$0, this$1._identifierToken), (this$2 = _expr$0, this$2._typeArgs), (_expr$0, _expr$0._type));
		propExpr._isInner = this._expr._isInner;
		return propExpr;
	}
};


function _TypeofExpressionTransformer(transformer, expr) {
	_UnaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_TypeofExpressionTransformer], _UnaryExpressionTransformer);
_TypeofExpressionTransformer.prototype._clone$LExpression$ = function (arg) {
	var this$0;
	return new TypeofExpression((this$0 = this._expr, this$0._token), arg);
};


function _SignExpressionTransformer(transformer, expr) {
	_UnaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_SignExpressionTransformer], _UnaryExpressionTransformer);
_SignExpressionTransformer.prototype._clone$LExpression$ = function (arg) {
	var this$0;
	return new SignExpression((this$0 = this._expr, this$0._token), arg);
};


function _YieldExpressionTransformer(transformer, expr) {
	_UnaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_YieldExpressionTransformer], _UnaryExpressionTransformer);
_YieldExpressionTransformer.prototype._clone$LExpression$ = function (arg) {
	var this$0;
	var this$1;
	var this$2;
	var _expr$0;
	return new YieldExpression$0((this$0 = _expr$0 = this._expr, this$0._token), arg, (this$1 = _expr$0, this$1._seedType), (this$2 = _expr$0, this$2._genType));
};


function _BinaryExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap.BINARY == null) {
		_ExpressionTransformer._expressionCountMap.BINARY = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap.BINARY++;
	this._expr = expr;
};

$__jsx_extend([_BinaryExpressionTransformer], _MultiaryOperatorTransformer);
_BinaryExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_BinaryExpressionTransformer.prototype.getArgumentExprs$ = function () {
	var this$0;
	var _expr$0;
	return [ (this$0 = _expr$0 = this._expr, this$0._expr1), (_expr$0, _expr$0._expr2) ];
};


_BinaryExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	return this._clone$LExpression$LExpression$(exprs[0], exprs[1]);
};


function _AdditiveExpressionTransformer(transformer, expr) {
	_BinaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_AdditiveExpressionTransformer], _BinaryExpressionTransformer);
_AdditiveExpressionTransformer.prototype._clone$LExpression$LExpression$ = function (arg1, arg2) {
	var ret;
	var this$0;
	ret = new AdditiveExpression((this$0 = this._expr, this$0._token), arg1, arg2);
	ret._type = this._expr._type;
	return ret;
};


function _ArrayExpressionTransformer(transformer, expr) {
	_BinaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_ArrayExpressionTransformer], _BinaryExpressionTransformer);
_ArrayExpressionTransformer.prototype._clone$LExpression$LExpression$ = function (arg1, arg2) {
	var aryExpr;
	var this$0;
	aryExpr = new ArrayExpression((this$0 = this._expr, this$0._token), arg1, arg2);
	aryExpr._type = this._expr._type;
	return aryExpr;
};


function _AssignmentExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap.ASSIGNMENT == null) {
		_ExpressionTransformer._expressionCountMap.ASSIGNMENT = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap.ASSIGNMENT++;
	this._expr = expr;
};

$__jsx_extend([_AssignmentExpressionTransformer], _MultiaryOperatorTransformer);
_AssignmentExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_AssignmentExpressionTransformer.prototype.getArgumentExprs$ = function () {
	var lhsExpr;
	var arrayExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var _expr$0;
	var _expr$1;
	this$0 = this._expr;
	lhsExpr = this$0._expr1;
	if (lhsExpr instanceof LocalExpression || lhsExpr instanceof PropertyExpression && (this$7 = lhsExpr, this$7._expr).isClassSpecifier$()) {
		return [ (this$1 = this._expr, this$1._expr2) ];
	} else if (lhsExpr instanceof PropertyExpression) {
		return [ (this$3 = (this$2 = _expr$0 = this._expr, this$2._expr1), this$3._expr), (this$4 = _expr$0, this$4._expr2) ];
	} else if (lhsExpr instanceof ArrayExpression) {
		arrayExpr = (this$5 = _expr$1 = this._expr, this$5._expr1);
		return [ arrayExpr._expr1, arrayExpr._expr2, (this$6 = _expr$1, this$6._expr2) ];
	} else {
		throw new Error("logic flaw");
	}
};


_AssignmentExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	var lhsExpr;
	var this$0;
	var expr$0;
	var this$0$0;
	var this$1$0;
	var this$1;
	var _expr$0;
	this$0 = this._expr;
	lhsExpr = this$0._expr1;
	if (lhsExpr instanceof LocalExpression || lhsExpr instanceof PropertyExpression && (this$1 = lhsExpr, this$1._expr).isClassSpecifier$()) {
		expr$0 = exprs[0];
		return new AssignmentExpression((this$0$0 = _expr$0 = this._expr, this$0$0._token), (this$1$0 = _expr$0, this$1$0._expr1), expr$0);
	} else if (lhsExpr instanceof PropertyExpression) {
		return _AssignmentExpressionTransformer$_constructPropertyAssignment$L_AssignmentExpressionTransformer$LExpression$LExpression$(this, exprs[0], exprs[1]);
	} else if (lhsExpr instanceof ArrayExpression) {
		return _AssignmentExpressionTransformer$_constructArrayAssignment$L_AssignmentExpressionTransformer$LExpression$LExpression$LExpression$(this, exprs[0], exprs[1], exprs[2]);
	} else {
		throw new Error("logic flaw");
	}
};


_AssignmentExpressionTransformer.prototype._constructSimpleAssignment$LExpression$ = function (expr) {
	var this$0;
	var this$1;
	var _expr$0;
	return new AssignmentExpression((this$0 = _expr$0 = this._expr, this$0._token), (this$1 = _expr$0, this$1._expr1), expr);
};


function _AssignmentExpressionTransformer$_constructSimpleAssignment$L_AssignmentExpressionTransformer$LExpression$($this, expr) {
	var this$0;
	var this$1;
	var _expr$0;
	return new AssignmentExpression((this$0 = _expr$0 = $this._expr, this$0._token), (this$1 = _expr$0, this$1._expr1), expr);
};

_AssignmentExpressionTransformer._constructSimpleAssignment$L_AssignmentExpressionTransformer$LExpression$ = _AssignmentExpressionTransformer$_constructSimpleAssignment$L_AssignmentExpressionTransformer$LExpression$;

_AssignmentExpressionTransformer.prototype._constructPropertyAssignment$LExpression$LExpression$ = function (expr1, expr2) {
	var this$0;
	var propExpr$0;
	var this$1;
	var this$2;
	this$0 = (this$2 = this._expr, this$2._expr1);
	propExpr$0 = new PropertyExpression$0(this$0._token, this$0._expr.clone$(), this$0._identifierToken, this$0._typeArgs, this$0._type);
	propExpr$0._isInner = this$0._isInner;
	propExpr$0._expr = expr1;
	return new AssignmentExpression((this$1 = this._expr, this$1._token), propExpr$0, expr2);
};


function _AssignmentExpressionTransformer$_constructPropertyAssignment$L_AssignmentExpressionTransformer$LExpression$LExpression$($this, expr1, expr2) {
	var this$0;
	var propExpr$0;
	var this$1;
	var this$2;
	this$0 = (this$2 = $this._expr, this$2._expr1);
	propExpr$0 = new PropertyExpression$0(this$0._token, this$0._expr.clone$(), this$0._identifierToken, this$0._typeArgs, this$0._type);
	propExpr$0._isInner = this$0._isInner;
	propExpr$0._expr = expr1;
	return new AssignmentExpression((this$1 = $this._expr, this$1._token), propExpr$0, expr2);
};

_AssignmentExpressionTransformer._constructPropertyAssignment$L_AssignmentExpressionTransformer$LExpression$LExpression$ = _AssignmentExpressionTransformer$_constructPropertyAssignment$L_AssignmentExpressionTransformer$LExpression$LExpression$;

_AssignmentExpressionTransformer.prototype._constructArrayAssignment$LExpression$LExpression$LExpression$ = function (receiver, key, value) {
	var arrayExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	arrayExpr = new ArrayExpression((this$1 = (this$0 = this._expr, this$0._expr1), this$1._token), receiver, key);
	arrayExpr._type = (this$2 = this._expr, this$2._expr1).getType$();
	return new AssignmentExpression((this$3 = this._expr, this$3._token), arrayExpr, value);
};


function _AssignmentExpressionTransformer$_constructArrayAssignment$L_AssignmentExpressionTransformer$LExpression$LExpression$LExpression$($this, receiver, key, value) {
	var arrayExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	arrayExpr = new ArrayExpression((this$1 = (this$0 = $this._expr, this$0._expr1), this$1._token), receiver, key);
	arrayExpr._type = (this$2 = $this._expr, this$2._expr1).getType$();
	return new AssignmentExpression((this$3 = $this._expr, this$3._token), arrayExpr, value);
};

_AssignmentExpressionTransformer._constructArrayAssignment$L_AssignmentExpressionTransformer$LExpression$LExpression$LExpression$ = _AssignmentExpressionTransformer$_constructArrayAssignment$L_AssignmentExpressionTransformer$LExpression$LExpression$LExpression$;

function _FusedAssignmentExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap["FUSED-ASSIGNMENT"] == null) {
		_ExpressionTransformer._expressionCountMap["FUSED-ASSIGNMENT"] = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap["FUSED-ASSIGNMENT"]++;
	this._expr = expr;
};

$__jsx_extend([_FusedAssignmentExpressionTransformer], _MultiaryOperatorTransformer);
_FusedAssignmentExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_FusedAssignmentExpressionTransformer.prototype.getArgumentExprs$ = function () {
	var lhsExpr;
	var arrayExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var _expr$0;
	var _expr$1;
	this$0 = this._expr;
	lhsExpr = this$0._expr1;
	if (lhsExpr instanceof LocalExpression || lhsExpr instanceof PropertyExpression && (this$7 = lhsExpr, this$7._expr).isClassSpecifier$()) {
		return [ (this$1 = this._expr, this$1._expr2) ];
	} else if (lhsExpr instanceof PropertyExpression) {
		return [ (this$3 = (this$2 = _expr$0 = this._expr, this$2._expr1), this$3._expr), (this$4 = _expr$0, this$4._expr2) ];
	} else if (lhsExpr instanceof ArrayExpression) {
		arrayExpr = (this$5 = _expr$1 = this._expr, this$5._expr1);
		return [ arrayExpr._expr1, arrayExpr._expr2, (this$6 = _expr$1, this$6._expr2) ];
	} else {
		throw new Error("logic flaw");
	}
};


_FusedAssignmentExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	var lhsExpr;
	var this$0;
	var expr$0;
	var this$0$0;
	var this$1$0;
	var this$1;
	var _expr$0;
	this$0 = this._expr;
	lhsExpr = this$0._expr1;
	if (lhsExpr instanceof LocalExpression || lhsExpr instanceof PropertyExpression && (this$1 = lhsExpr, this$1._expr).isClassSpecifier$()) {
		expr$0 = exprs[0];
		return new FusedAssignmentExpression((this$0$0 = _expr$0 = this._expr, this$0$0._token), (this$1$0 = _expr$0, this$1$0._expr1), expr$0);
	} else if (lhsExpr instanceof PropertyExpression) {
		return _FusedAssignmentExpressionTransformer$_constructPropertyAssignment$L_FusedAssignmentExpressionTransformer$LExpression$LExpression$(this, exprs[0], exprs[1]);
	} else if (lhsExpr instanceof ArrayExpression) {
		return _FusedAssignmentExpressionTransformer$_constructArrayAssignment$L_FusedAssignmentExpressionTransformer$LExpression$LExpression$LExpression$(this, exprs[0], exprs[1], exprs[2]);
	} else {
		throw new Error("logic flaw");
	}
};


_FusedAssignmentExpressionTransformer.prototype._constructSimpleAssignment$LExpression$ = function (expr) {
	var this$0;
	var this$1;
	var _expr$0;
	return new FusedAssignmentExpression((this$0 = _expr$0 = this._expr, this$0._token), (this$1 = _expr$0, this$1._expr1), expr);
};


function _FusedAssignmentExpressionTransformer$_constructSimpleAssignment$L_FusedAssignmentExpressionTransformer$LExpression$($this, expr) {
	var this$0;
	var this$1;
	var _expr$0;
	return new FusedAssignmentExpression((this$0 = _expr$0 = $this._expr, this$0._token), (this$1 = _expr$0, this$1._expr1), expr);
};

_FusedAssignmentExpressionTransformer._constructSimpleAssignment$L_FusedAssignmentExpressionTransformer$LExpression$ = _FusedAssignmentExpressionTransformer$_constructSimpleAssignment$L_FusedAssignmentExpressionTransformer$LExpression$;

_FusedAssignmentExpressionTransformer.prototype._constructPropertyAssignment$LExpression$LExpression$ = function (expr1, expr2) {
	var this$0;
	var propExpr$0;
	var this$1;
	var this$2;
	this$0 = (this$2 = this._expr, this$2._expr1);
	propExpr$0 = new PropertyExpression$0(this$0._token, this$0._expr.clone$(), this$0._identifierToken, this$0._typeArgs, this$0._type);
	propExpr$0._isInner = this$0._isInner;
	propExpr$0._expr = expr1;
	return new FusedAssignmentExpression((this$1 = this._expr, this$1._token), propExpr$0, expr2);
};


function _FusedAssignmentExpressionTransformer$_constructPropertyAssignment$L_FusedAssignmentExpressionTransformer$LExpression$LExpression$($this, expr1, expr2) {
	var this$0;
	var propExpr$0;
	var this$1;
	var this$2;
	this$0 = (this$2 = $this._expr, this$2._expr1);
	propExpr$0 = new PropertyExpression$0(this$0._token, this$0._expr.clone$(), this$0._identifierToken, this$0._typeArgs, this$0._type);
	propExpr$0._isInner = this$0._isInner;
	propExpr$0._expr = expr1;
	return new FusedAssignmentExpression((this$1 = $this._expr, this$1._token), propExpr$0, expr2);
};

_FusedAssignmentExpressionTransformer._constructPropertyAssignment$L_FusedAssignmentExpressionTransformer$LExpression$LExpression$ = _FusedAssignmentExpressionTransformer$_constructPropertyAssignment$L_FusedAssignmentExpressionTransformer$LExpression$LExpression$;

_FusedAssignmentExpressionTransformer.prototype._constructArrayAssignment$LExpression$LExpression$LExpression$ = function (receiver, key, value) {
	var arrayExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	arrayExpr = new ArrayExpression((this$1 = (this$0 = this._expr, this$0._expr1), this$1._token), receiver, key);
	arrayExpr._type = (this$2 = this._expr, this$2._expr1).getType$();
	return new FusedAssignmentExpression((this$3 = this._expr, this$3._token), arrayExpr, value);
};


function _FusedAssignmentExpressionTransformer$_constructArrayAssignment$L_FusedAssignmentExpressionTransformer$LExpression$LExpression$LExpression$($this, receiver, key, value) {
	var arrayExpr;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	arrayExpr = new ArrayExpression((this$1 = (this$0 = $this._expr, this$0._expr1), this$1._token), receiver, key);
	arrayExpr._type = (this$2 = $this._expr, this$2._expr1).getType$();
	return new FusedAssignmentExpression((this$3 = $this._expr, this$3._token), arrayExpr, value);
};

_FusedAssignmentExpressionTransformer._constructArrayAssignment$L_FusedAssignmentExpressionTransformer$LExpression$LExpression$LExpression$ = _FusedAssignmentExpressionTransformer$_constructArrayAssignment$L_FusedAssignmentExpressionTransformer$LExpression$LExpression$LExpression$;

function _BinaryNumberExpressionTransformer(transformer, expr) {
	_BinaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_BinaryNumberExpressionTransformer], _BinaryExpressionTransformer);
_BinaryNumberExpressionTransformer.prototype._clone$LExpression$LExpression$ = function (arg1, arg2) {
	var this$0;
	return new BinaryNumberExpression((this$0 = this._expr, this$0._token), arg1, arg2);
};


function _EqualityExpressionTransformer(transformer, expr) {
	_BinaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_EqualityExpressionTransformer], _BinaryExpressionTransformer);
_EqualityExpressionTransformer.prototype._clone$LExpression$LExpression$ = function (arg1, arg2) {
	var this$0;
	return new EqualityExpression((this$0 = this._expr, this$0._token), arg1, arg2);
};


function _InExpressionTransformer(transformer, expr) {
	_BinaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_InExpressionTransformer], _BinaryExpressionTransformer);
_InExpressionTransformer.prototype._clone$LExpression$LExpression$ = function (arg1, arg2) {
	var this$0;
	return new InExpression((this$0 = this._expr, this$0._token), arg1, arg2);
};


function _LogicalExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap.LOGICAL == null) {
		_ExpressionTransformer._expressionCountMap.LOGICAL = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap.LOGICAL++;
	this._expr = expr;
};

$__jsx_extend([_LogicalExpressionTransformer], _ExpressionTransformer);
_LogicalExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_LogicalExpressionTransformer.prototype.doCPSTransform$LMemberFunctionDefinition$LExpression$LType$ = function (parent, continuation, returnType) {
	var argVar;
	var contFuncDef;
	var contVar;
	var condStmt;
	var ifTrueExpr;
	var ifFalseExpr;
	var ifTrueCont;
	var ifFalseCont;
	var condExpr;
	var returnStmt;
	var cont;
	var type$0;
	var id$0;
	var type$1;
	var id$1;
	var this$0;
	var this$1;
	var this$2;
	var this$0$0;
	var this$3;
	var this$0$1;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var this$8;
	if (continuation != null) {
	}
	type$0 = (this$6 = this._expr, this$6._expr1).getType$();
	id$0 = _Util$1._numUniqVar++;
	argVar = new ArgumentDeclaration(new Token$2("$a" + (id$0 + ""), true), type$0);
	contFuncDef = _Util$1$_createAnonymousFunction$LMemberFunctionDefinition$LToken$ALArgumentDeclaration$LType$(parent, null, [ argVar ], returnType);
	contVar = null;
	if (continuation != null) {
		type$1 = continuation.getType$();
		id$1 = _Util$1._numUniqVar++;
		contVar = new LocalVariable(new Token$2("$a" + (id$1 + ""), true), type$1, false);
		contFuncDef._locals.push(contVar);
		condStmt = new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(contVar._name, contVar), continuation));
		contFuncDef._statements.push(condStmt);
	}
	if ((this$8 = (this$7 = this._expr, this$7._token), this$8._value) === "&&") {
		this$0 = this._expr;
		ifTrueExpr = this$0._expr2;
		ifFalseExpr = new LocalExpression(argVar._name, argVar);
	} else {
		ifTrueExpr = new LocalExpression(argVar._name, argVar);
		this$1 = this._expr;
		ifFalseExpr = this$1._expr2;
	}
	if ((this$2 = ifTrueExpr.getType$(), this$2 instanceof NullableType ? (this$0$0 = this$2, this$0$0._baseType) : this$2) instanceof PrimitiveType) {
		ifTrueExpr = new AsExpression(new Token$2("as", false), ifTrueExpr, Type.booleanType);
	} else {
		ifTrueExpr = new LogicalNotExpression(new Token$2("!", false), new LogicalNotExpression(new Token$2("!", false), ifTrueExpr));
	}
	if ((this$3 = ifFalseExpr.getType$(), this$3 instanceof NullableType ? (this$0$1 = this$3, this$0$1._baseType) : this$3) instanceof PrimitiveType) {
		ifFalseExpr = new AsExpression(new Token$2("as", false), ifFalseExpr, Type.booleanType);
	} else {
		ifFalseExpr = new LogicalNotExpression(new Token$2("!", false), new LogicalNotExpression(new Token$2("!", false), ifFalseExpr));
	}
	ifTrueCont = null;
	ifFalseCont = null;
	if (continuation != null) {
		ifTrueCont = new LocalExpression(contVar._name, contVar);
		ifFalseCont = new LocalExpression(contVar._name, contVar);
	}
	condExpr = new ConditionalExpression((this$4 = this._expr, this$4._token), new LocalExpression(argVar._name, argVar), CPSTransformCommand$_getExpressionTransformerFor$LCPSTransformCommand$LExpression$(this._transformer, ifTrueExpr).doCPSTransform$LMemberFunctionDefinition$LExpression$LType$(contFuncDef, ifTrueCont, returnType), CPSTransformCommand$_getExpressionTransformerFor$LCPSTransformCommand$LExpression$(this._transformer, ifFalseExpr).doCPSTransform$LMemberFunctionDefinition$LExpression$LType$(contFuncDef, ifFalseCont, returnType));
	condExpr._type = returnType;
	returnStmt = new ReturnStatement(new Token$2("return", false), condExpr);
	contFuncDef._statements.push(returnStmt);
	Util$rebaseClosures$LMemberFunctionDefinition$LMemberFunctionDefinition$(parent, contFuncDef);
	cont = new FunctionExpression(contFuncDef._token, contFuncDef);
	return CPSTransformCommand$_getExpressionTransformerFor$LCPSTransformCommand$LExpression$(this._transformer, (this$5 = this._expr, this$5._expr1)).doCPSTransform$LMemberFunctionDefinition$LExpression$LType$(parent, cont, returnType);
};


function _ShiftExpressionTransformer(transformer, expr) {
	_BinaryExpressionTransformer.call(this, transformer, expr);
};

$__jsx_extend([_ShiftExpressionTransformer], _BinaryExpressionTransformer);
_ShiftExpressionTransformer.prototype._clone$LExpression$LExpression$ = function (arg1, arg2) {
	var this$0;
	return new ShiftExpression((this$0 = this._expr, this$0._token), arg1, arg2);
};


function _ConditionalExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap.CONDITIONAL == null) {
		_ExpressionTransformer._expressionCountMap.CONDITIONAL = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap.CONDITIONAL++;
	this._expr = expr;
};

$__jsx_extend([_ConditionalExpressionTransformer], _ExpressionTransformer);
_ConditionalExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_ConditionalExpressionTransformer.prototype.doCPSTransform$LMemberFunctionDefinition$LExpression$LType$ = function (parent, continuation, returnType) {
	var argVar;
	var contFuncDef;
	var contVar;
	var condStmt;
	var ifTrueExpr;
	var ifFalseExpr;
	var ifTrueCont;
	var ifFalseCont;
	var condExpr;
	var returnStmt;
	var cont;
	var type$0;
	var id$0;
	var type$1;
	var id$1;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	if (continuation != null) {
	}
	type$0 = (this$4 = this._expr, this$4._condExpr).getType$();
	id$0 = _Util$1._numUniqVar++;
	argVar = new ArgumentDeclaration(new Token$2("$a" + (id$0 + ""), true), type$0);
	contFuncDef = _Util$1$_createAnonymousFunction$LMemberFunctionDefinition$LToken$ALArgumentDeclaration$LType$(parent, null, [ argVar ], returnType);
	contVar = null;
	if (continuation != null) {
		type$1 = continuation.getType$();
		id$1 = _Util$1._numUniqVar++;
		contVar = new LocalVariable(new Token$2("$a" + (id$1 + ""), true), type$1, false);
		contFuncDef._locals.push(contVar);
		condStmt = new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(contVar._name, contVar), continuation));
		contFuncDef._statements.push(condStmt);
	}
	this$0 = this._expr;
	ifTrueExpr = this$0._ifTrueExpr;
	if (ifTrueExpr == null) {
		ifTrueExpr = new LocalExpression(argVar._name, argVar);
	}
	this$1 = this._expr;
	ifFalseExpr = this$1._ifFalseExpr;
	ifTrueCont = null;
	ifFalseCont = null;
	if (continuation != null) {
		ifTrueCont = new LocalExpression(contVar._name, contVar);
		ifFalseCont = new LocalExpression(contVar._name, contVar);
	}
	condExpr = new ConditionalExpression((this$2 = this._expr, this$2._token), new LocalExpression(argVar._name, argVar), CPSTransformCommand$_getExpressionTransformerFor$LCPSTransformCommand$LExpression$(this._transformer, ifTrueExpr).doCPSTransform$LMemberFunctionDefinition$LExpression$LType$(contFuncDef, ifTrueCont, returnType), CPSTransformCommand$_getExpressionTransformerFor$LCPSTransformCommand$LExpression$(this._transformer, ifFalseExpr).doCPSTransform$LMemberFunctionDefinition$LExpression$LType$(contFuncDef, ifFalseCont, returnType));
	condExpr._type = returnType;
	returnStmt = new ReturnStatement(new Token$2("return", false), condExpr);
	contFuncDef._statements.push(returnStmt);
	Util$rebaseClosures$LMemberFunctionDefinition$LMemberFunctionDefinition$(parent, contFuncDef);
	cont = new FunctionExpression(contFuncDef._token, contFuncDef);
	return CPSTransformCommand$_getExpressionTransformerFor$LCPSTransformCommand$LExpression$(this._transformer, (this$3 = this._expr, this$3._condExpr)).doCPSTransform$LMemberFunctionDefinition$LExpression$LType$(parent, cont, returnType);
};


function _CallExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap.CALL == null) {
		_ExpressionTransformer._expressionCountMap.CALL = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap.CALL++;
	this._expr = expr;
};

$__jsx_extend([_CallExpressionTransformer], _MultiaryOperatorTransformer);
_CallExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_CallExpressionTransformer.prototype._isMethodCall$ = function () {
	var propertyExpr;
	var this$0;
	var this$1;
	if ((this$1 = this._expr, this$1._expr) instanceof PropertyExpression) {
		propertyExpr = (this$0 = this._expr, this$0._expr);
		if (propertyExpr._type instanceof MemberFunctionType) {
			return true;
		}
	}
	return false;
};


function _CallExpressionTransformer$_isMethodCall$L_CallExpressionTransformer$($this) {
	var propertyExpr;
	var this$0;
	var this$1;
	if ((this$1 = $this._expr, this$1._expr) instanceof PropertyExpression) {
		propertyExpr = (this$0 = $this._expr, this$0._expr);
		if (propertyExpr._type instanceof MemberFunctionType) {
			return true;
		}
	}
	return false;
};

_CallExpressionTransformer._isMethodCall$L_CallExpressionTransformer$ = _CallExpressionTransformer$_isMethodCall$L_CallExpressionTransformer$;

_CallExpressionTransformer.prototype.getArgumentExprs$ = function () {
	var receiver;
	var this$0;
	var this$2;
	var this$3;
	var this$5;
	var this$6;
	var _expr$0;
	var _expr$1;
	if (_CallExpressionTransformer$_isMethodCall$L_CallExpressionTransformer$(this)) {
		this$0 = (this$5 = _expr$0 = this._expr, this$5._expr);
		receiver = this$0._expr;
		return [ receiver ].concat((_expr$0, _expr$0._args));
	} else if ((this$6 = this._transformer._compiler, this$6._emitter).isSpecialCall$LCallExpression$(this._expr)) {
		return (this$2 = this._expr, this$2._args).concat([  ]);
	} else {
		return [ (this$3 = _expr$1 = this._expr, this$3._expr) ].concat((_expr$1, _expr$1._args));
	}
};


_CallExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	var propertyExpr;
	var this$0;
	var this$1;
	var this$2;
	if (_CallExpressionTransformer$_isMethodCall$L_CallExpressionTransformer$(this)) {
		propertyExpr = (this$0 = this._expr, this$0._expr);
		return new CallExpression(new Token$2("(", false), new PropertyExpression$0(propertyExpr._token, exprs[0], propertyExpr._identifierToken, propertyExpr._typeArgs, propertyExpr._type), exprs.slice(1));
	} else if ((this$2 = this._transformer._compiler, this$2._emitter).isSpecialCall$LCallExpression$(this._expr)) {
		return new CallExpression(new Token$2("(", false), (this$1 = this._expr, this$1._expr), exprs);
	} else {
		return new CallExpression(new Token$2("(", false), exprs[0], exprs.slice(1));
	}
};


function _SuperExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap.SUPER == null) {
		_ExpressionTransformer._expressionCountMap.SUPER = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap.SUPER++;
	this._expr = expr;
};

$__jsx_extend([_SuperExpressionTransformer], _MultiaryOperatorTransformer);
_SuperExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_SuperExpressionTransformer.prototype.getArgumentExprs$ = function () {
	var this$0;
	this$0 = this._expr;
	return this$0._args;
};


_SuperExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	var superExpr;
	superExpr = new SuperExpression$0(this._expr);
	superExpr._args = exprs;
	return superExpr;
};


function _NewExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap.NEW == null) {
		_ExpressionTransformer._expressionCountMap.NEW = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap.NEW++;
	this._expr = expr;
};

$__jsx_extend([_NewExpressionTransformer], _MultiaryOperatorTransformer);
_NewExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_NewExpressionTransformer.prototype.getArgumentExprs$ = function () {
	var this$0;
	this$0 = this._expr;
	return this$0._args;
};


_NewExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	var newExpr;
	newExpr = new NewExpression$0(this._expr);
	newExpr._args = exprs;
	return newExpr;
};


function _CommaExpressionTransformer(transformer, expr) {
	this._id = 0;
	this._transformer = transformer;
	if (_ExpressionTransformer._expressionCountMap.COMMA == null) {
		_ExpressionTransformer._expressionCountMap.COMMA = 0;
	}
	this._id = _ExpressionTransformer._expressionCountMap.COMMA++;
	this._expr = expr;
};

$__jsx_extend([_CommaExpressionTransformer], _MultiaryOperatorTransformer);
_CommaExpressionTransformer.prototype.getExpression$ = function () {
	return this._expr;
};


_CommaExpressionTransformer.prototype.getArgumentExprs$ = function () {
	var this$0;
	var _expr$0;
	return [ (this$0 = _expr$0 = this._expr, this$0._expr1), (_expr$0, _expr$0._expr2) ];
};


_CommaExpressionTransformer.prototype.constructOp$ALExpression$ = function (exprs) {
	var this$0;
	return new CommaExpression((this$0 = this._expr, this$0._token), exprs[0], exprs[1]);
};


function _StatementTransformer(transformer, identifier) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap[identifier] == null) {
		_StatementTransformer._statementCountMap[identifier] = 0;
	}
	this._id = _StatementTransformer._statementCountMap[identifier]++;
};

$__jsx_extend([_StatementTransformer], Object);
_StatementTransformer.prototype.getID$ = function () {
	return this._id;
};


function _StatementTransformer$getID$L_StatementTransformer$($this) {
	return $this._id;
};

_StatementTransformer.getID$L_StatementTransformer$ = _StatementTransformer$getID$L_StatementTransformer$;

_StatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	var $this = this;
	var funcDef;
	var funcDef$0;
	var funcStmt$0;
	var this$0;
	var _funcDefs$0;
	if (this._transformer._transformExprs) {
		this$0 = this._transformer;
		funcDef$0 = (_funcDefs$0 = this$0._funcDefs)[_funcDefs$0.length - 1];
		funcStmt$0 = funcDef$0._statements[1];
		funcDef = funcStmt$0._funcDef;
		this.getStatement$().forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
			var id;
			id = _Util$1$_createIdentityFunction$LMemberFunctionDefinition$LType$(funcDef, expr.getType$());
			if ((expr = CPSTransformCommand$_getExpressionTransformerFor$LCPSTransformCommand$LExpression$($this._transformer, expr).doCPSTransform$LMemberFunctionDefinition$LExpression$LType$(funcDef, id, expr.getType$())) == null) {
				throw new Error("fatal error in expression transformation");
			}
			replaceCb(expr);
			return true;
		}));
	}
	this._replaceControlStructuresWithGotos$();
};


function _ConstructorInvocationStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap["CONSTRUCTOR-INVOCATION"] == null) {
		_StatementTransformer._statementCountMap["CONSTRUCTOR-INVOCATION"] = 0;
	}
	this._id = _StatementTransformer._statementCountMap["CONSTRUCTOR-INVOCATION"]++;
	this._statement = statement;
};

$__jsx_extend([_ConstructorInvocationStatementTransformer], _StatementTransformer);
_ConstructorInvocationStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ConstructorInvocationStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var this$0;
	var statement$0;
	this$0 = this._transformer;
	statement$0 = this._statement;
	this$0._outputStatements.push(statement$0);
};


function _ExpressionStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.EXPRESSION == null) {
		_StatementTransformer._statementCountMap.EXPRESSION = 0;
	}
	this._id = _StatementTransformer._statementCountMap.EXPRESSION++;
	this._statement = statement;
};

$__jsx_extend([_ExpressionStatementTransformer], _StatementTransformer);
_ExpressionStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ExpressionStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var this$0;
	var statement$0;
	this$0 = this._transformer;
	statement$0 = this._statement;
	this$0._outputStatements.push(statement$0);
};


function _FunctionStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.FUNCTION == null) {
		_StatementTransformer._statementCountMap.FUNCTION = 0;
	}
	this._id = _StatementTransformer._statementCountMap.FUNCTION++;
	this._statement = statement;
};

$__jsx_extend([_FunctionStatementTransformer], _StatementTransformer);
_FunctionStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_FunctionStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var funcDef;
	var statement;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var _funcLocal$0;
	this$0 = this._statement;
	funcDef = this$0._funcDef;
	statement = new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression((this$1 = _funcLocal$0 = funcDef._funcLocal, this$1._name), _funcLocal$0), new FunctionExpression((this$2 = this._statement, this$2._token), funcDef)));
	MemberFunctionDefinition$setFuncLocal$LMemberFunctionDefinition$LLocalVariable$(funcDef, null);
	this$3 = this._transformer;
	this$3._outputStatements.push(statement);
};


function _ReturnStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.RETURN == null) {
		_StatementTransformer._statementCountMap.RETURN = 0;
	}
	this._id = _StatementTransformer._statementCountMap.RETURN++;
	this._statement = statement;
};

$__jsx_extend([_ReturnStatementTransformer], _StatementTransformer);
_ReturnStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ReturnStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var returnLocal;
	var funcDef$0;
	var this$0;
	var expr$0;
	var statement$0$0;
	var this$1;
	var expr$1;
	var statement$0$1;
	var this$2;
	var statement$0$2;
	var this$3;
	var this$4;
	var this$5;
	var this$6;
	var _funcDefs$0;
	if ((this$6 = this._statement, this$6._expr) != null) {
		this$3 = this._transformer;
		funcDef$0 = (_funcDefs$0 = this$3._funcDefs)[_funcDefs$0.length - 1];
		returnLocal = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef$0, "$return");
		if (returnLocal == null) {
			this$0 = this._transformer;
			this$4 = this._statement;
			expr$0 = this$4._expr;
			statement$0$0 = new ExpressionStatement(expr$0);
			this$0._outputStatements.push(statement$0$0);
		} else {
			this$1 = this._transformer;
			expr$1 = new AssignmentExpression(new Token$2("=", false), new LocalExpression(returnLocal._name, returnLocal), (this$5 = this._statement, this$5._expr));
			statement$0$1 = new ExpressionStatement(expr$1);
			this$1._outputStatements.push(statement$0$1);
		}
	}
	this$2 = this._transformer;
	statement$0$2 = new GotoStatement("$L_exit");
	this$2._outputStatements.push(statement$0$2);
};


function _DeleteStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.DELETE == null) {
		_StatementTransformer._statementCountMap.DELETE = 0;
	}
	this._id = _StatementTransformer._statementCountMap.DELETE++;
	this._statement = statement;
};

$__jsx_extend([_DeleteStatementTransformer], _StatementTransformer);
_DeleteStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_DeleteStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	var funcDef;
	var aryExpr;
	var funcDef$0;
	var funcStmt$0;
	var this$0;
	var this$1;
	var expr$0;
	var statement$0$0;
	var this$2;
	var statement$0;
	var this$3;
	var _funcDefs$0;
	var _transformer$0;
	var _statement$0;
	if (this._transformer._transformExprs) {
		this$3 = _transformer$0 = this._transformer;
		funcDef$0 = (_funcDefs$0 = this$3._funcDefs)[_funcDefs$0.length - 1];
		funcStmt$0 = funcDef$0._statements[1];
		funcDef = funcStmt$0._funcDef;
		aryExpr = (this$0 = _statement$0 = this._statement, this$0._expr);
		this$1 = _transformer$0;
		expr$0 = new _DeleteStatementTransformer$x2E_Stash(_transformer$0, _statement$0).doCPSTransform$LMemberFunctionDefinition$LExpression$LType$(funcDef, null, aryExpr._type);
		statement$0$0 = new ExpressionStatement(expr$0);
		this$1._outputStatements.push(statement$0$0);
	} else {
		this$2 = this._transformer;
		statement$0 = this._statement;
		this$2._outputStatements.push(statement$0);
	}
};


_DeleteStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	throw new Error("logic flaw");
};


function _BreakStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.BREAK == null) {
		_StatementTransformer._statementCountMap.BREAK = 0;
	}
	this._id = _StatementTransformer._statementCountMap.BREAK++;
	this._statement = statement;
};

$__jsx_extend([_BreakStatementTransformer], _StatementTransformer);
_BreakStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_BreakStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var label;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var statement$0$0;
	var this$4;
	var _labelStack$0;
	if ((this$4 = this._statement, this$4._label) != null) {
		label = CPSTransformCommand$_getStatementTransformerByLabel$LCPSTransformCommand$S(this._transformer, (this$1 = (this$0 = this._statement, this$0._label), this$1._value)).getBreakingLabel$();
	} else {
		label = (this$2 = this._transformer, (_labelStack$0 = this$2._labelStack)[_labelStack$0.length - 1]).getBreakingLabel$();
	}
	this$3 = this._transformer;
	statement$0$0 = new GotoStatement(label);
	this$3._outputStatements.push(statement$0$0);
};


function _ContinueStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.CONTINUE == null) {
		_StatementTransformer._statementCountMap.CONTINUE = 0;
	}
	this._id = _StatementTransformer._statementCountMap.CONTINUE++;
	this._statement = statement;
};

$__jsx_extend([_ContinueStatementTransformer], _StatementTransformer);
_ContinueStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ContinueStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var label;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var statement$0$0;
	var this$4;
	var _labelStack$0;
	if ((this$4 = this._statement, this$4._label) != null) {
		label = CPSTransformCommand$_getStatementTransformerByLabel$LCPSTransformCommand$S(this._transformer, (this$1 = (this$0 = this._statement, this$0._label), this$1._value)).getContinuingLabel$();
	} else {
		label = (this$2 = this._transformer, (_labelStack$0 = this$2._labelStack)[_labelStack$0.length - 1]).getContinuingLabel$();
	}
	this$3 = this._transformer;
	statement$0$0 = new GotoStatement(label);
	this$3._outputStatements.push(statement$0$0);
};


function _LabellableStatementTransformer(transformer, identifier) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap[identifier] == null) {
		_StatementTransformer._statementCountMap[identifier] = 0;
	}
	this._id = _StatementTransformer._statementCountMap[identifier]++;
};

$__jsx_extend([_LabellableStatementTransformer], _StatementTransformer);
function _DoWhileStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap["DO-WHILE"] == null) {
		_StatementTransformer._statementCountMap["DO-WHILE"] = 0;
	}
	this._id = _StatementTransformer._statementCountMap["DO-WHILE"]++;
	this._statement = statement;
};

$__jsx_extend([_DoWhileStatementTransformer], _LabellableStatementTransformer);
_DoWhileStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_DoWhileStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var $this = this;
	var bodyLabel;
	var testLabel;
	var endLabel;
	var this$0;
	var statement$0$0;
	var this$1;
	var statement$0$1;
	var this$2;
	var this$3;
	var this$4;
	var statement$0$2;
	var this$5;
	var statement$0$3;
	var this$6;
	var expr$0;
	var statement$0$4;
	var this$7;
	var statement$0$5;
	var this$8;
	bodyLabel = "$L_body_do_while_" + (this._id + "");
	this$0 = this._transformer;
	statement$0$0 = new GotoStatement(bodyLabel);
	this$0._outputStatements.push(statement$0$0);
	this$1 = this._transformer;
	statement$0$1 = new LabelStatement(bodyLabel);
	this$1._outputStatements.push(statement$0$1);
	this$2 = this._transformer;
	this$2._labelStack.push(this);
	this._statement.getStatements$().forEach((function (statement) {
		CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$($this._transformer, statement).replaceControlStructuresWithGotos$();
	}));
	this$3 = this._transformer;
	this$3._labelStack.pop();
	testLabel = "$L_test_do_while_" + (this._id + "");
	this$4 = this._transformer;
	statement$0$2 = new GotoStatement(testLabel);
	this$4._outputStatements.push(statement$0$2);
	this$5 = this._transformer;
	statement$0$3 = new LabelStatement(testLabel);
	this$5._outputStatements.push(statement$0$3);
	endLabel = "$L_end_do_while_" + (this._id + "");
	this$6 = this._transformer;
	this$8 = this._statement;
	expr$0 = this$8._expr;
	statement$0$4 = new IfStatement(new Token$2("if", false), expr$0, [ new GotoStatement(bodyLabel) ], [ new GotoStatement(endLabel) ]);
	this$6._outputStatements.push(statement$0$4);
	this$7 = this._transformer;
	statement$0$5 = new LabelStatement(endLabel);
	this$7._outputStatements.push(statement$0$5);
};


_DoWhileStatementTransformer.prototype.getBreakingLabel$ = function () {
	return "$L_end_do_while_" + (this._id + "");
};


_DoWhileStatementTransformer.prototype.getContinuingLabel$ = function () {
	return "$L_body_do_while_" + (this._id + "");
};


function _ForInStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap["FOR-IN"] == null) {
		_StatementTransformer._statementCountMap["FOR-IN"] = 0;
	}
	this._id = _StatementTransformer._statementCountMap["FOR-IN"]++;
	this._statement = statement;
};

$__jsx_extend([_ForInStatementTransformer], _LabellableStatementTransformer);
_ForInStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ForInStatementTransformer.prototype.replaceControlStructuresWithGotos$ = function () {
	var this$0;
	var statement$0;
	this$0 = this._transformer;
	statement$0 = this._statement;
	this$0._outputStatements.push(statement$0);
};


_ForInStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	throw new Error("logic flaw");
};


_ForInStatementTransformer.prototype.getBreakingLabel$ = function () {
	throw new Error("logic flaw");
};


_ForInStatementTransformer.prototype.getContinuingLabel$ = function () {
	throw new Error("logic flaw");
};


function _ForStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.FOR == null) {
		_StatementTransformer._statementCountMap.FOR = 0;
	}
	this._id = _StatementTransformer._statementCountMap.FOR++;
	this._statement = statement;
};

$__jsx_extend([_ForStatementTransformer], _LabellableStatementTransformer);
_ForStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ForStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var $this = this;
	var initLabel;
	var testLabel;
	var bodyLabel;
	var endLabel;
	var postLabel;
	var this$0;
	var statement$0$0;
	var this$1;
	var statement$0$1;
	var this$2;
	var expr$0;
	var statement$0$2;
	var this$3;
	var statement$0$3;
	var this$4;
	var statement$0$4;
	var this$5;
	var expr$1;
	var statement$0$5;
	var this$6;
	var expr$2;
	var statement$0$6;
	var this$7;
	var statement$0$7;
	var this$8;
	var this$9;
	var this$10;
	var this$11;
	var statement$0$8;
	var this$12;
	var statement$0$9;
	var this$13;
	var expr$3;
	var statement$0$10;
	var this$14;
	var statement$0$11;
	var this$15;
	var statement$0$12;
	var this$16;
	var this$17;
	var this$18;
	var this$19;
	var this$20;
	var this$21;
	var _id$0;
	initLabel = "$L_init_for_" + (this._id + "");
	this$0 = this._transformer;
	statement$0$0 = new GotoStatement(initLabel);
	this$0._outputStatements.push(statement$0$0);
	this$1 = this._transformer;
	statement$0$1 = new LabelStatement(initLabel);
	this$1._outputStatements.push(statement$0$1);
	if ((this$19 = this._statement, this$19._initExpr) != null) {
		this$2 = this._transformer;
		this$16 = this._statement;
		expr$0 = this$16._initExpr;
		statement$0$2 = new ExpressionStatement(expr$0);
		this$2._outputStatements.push(statement$0$2);
	}
	testLabel = "$L_test_for_" + (this._id + "");
	this$3 = this._transformer;
	statement$0$3 = new GotoStatement(testLabel);
	this$3._outputStatements.push(statement$0$3);
	this$4 = this._transformer;
	statement$0$4 = new LabelStatement(testLabel);
	this$4._outputStatements.push(statement$0$4);
	bodyLabel = "$L_body_for_" + ((_id$0 = this._id) + "");
	endLabel = "$L_end_for_" + (_id$0 + "");
	if ((this$20 = this._statement, this$20._condExpr) != null) {
		this$5 = this._transformer;
		this$17 = this._statement;
		expr$1 = this$17._condExpr;
		statement$0$5 = new IfStatement(new Token$2("if", false), expr$1, [ new GotoStatement(bodyLabel) ], [ new GotoStatement(endLabel) ]);
		this$5._outputStatements.push(statement$0$5);
	} else {
		this$6 = this._transformer;
		expr$2 = new BooleanLiteralExpression(new Token$2("true", false));
		statement$0$6 = new IfStatement(new Token$2("if", false), expr$2, [ new GotoStatement(bodyLabel) ], [ new GotoStatement(endLabel) ]);
		this$6._outputStatements.push(statement$0$6);
	}
	this$7 = this._transformer;
	statement$0$7 = new LabelStatement(bodyLabel);
	this$7._outputStatements.push(statement$0$7);
	this$8 = this._transformer;
	this$8._labelStack.push(this);
	(this$9 = this._statement, this$9._statements).forEach((function (statement) {
		CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$($this._transformer, statement).replaceControlStructuresWithGotos$();
	}));
	this$10 = this._transformer;
	this$10._labelStack.pop();
	postLabel = "$L_post_for_" + (this._id + "");
	this$11 = this._transformer;
	statement$0$8 = new GotoStatement(postLabel);
	this$11._outputStatements.push(statement$0$8);
	this$12 = this._transformer;
	statement$0$9 = new LabelStatement(postLabel);
	this$12._outputStatements.push(statement$0$9);
	if ((this$21 = this._statement, this$21._postExpr) != null) {
		this$13 = this._transformer;
		this$18 = this._statement;
		expr$3 = this$18._postExpr;
		statement$0$10 = new ExpressionStatement(expr$3);
		this$13._outputStatements.push(statement$0$10);
	}
	this$14 = this._transformer;
	statement$0$11 = new GotoStatement(testLabel);
	this$14._outputStatements.push(statement$0$11);
	this$15 = this._transformer;
	statement$0$12 = new LabelStatement(endLabel);
	this$15._outputStatements.push(statement$0$12);
};


_ForStatementTransformer.prototype.getBreakingLabel$ = function () {
	return "$L_end_for_" + (this._id + "");
};


_ForStatementTransformer.prototype.getContinuingLabel$ = function () {
	return "$L_post_for_" + (this._id + "");
};


function _IfStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.IF == null) {
		_StatementTransformer._statementCountMap.IF = 0;
	}
	this._id = _StatementTransformer._statementCountMap.IF++;
	this._statement = statement;
};

$__jsx_extend([_IfStatementTransformer], _StatementTransformer);
_IfStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_IfStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var $this = this;
	var testLabel;
	var succLabel;
	var failLabel;
	var endLabel;
	var this$0;
	var statement$0$0;
	var this$1;
	var statement$0$1;
	var this$2;
	var expr$0;
	var statement$0$2;
	var this$3;
	var statement$0$3;
	var this$4;
	var this$5;
	var statement$0$4;
	var this$6;
	var statement$0$5;
	var this$7;
	var this$8;
	var statement$0$6;
	var this$9;
	var statement$0$7;
	var this$10;
	var _id$0;
	testLabel = "$L_test_if_" + ((_id$0 = this._id) + "");
	succLabel = "$L_succ_if_" + (_id$0 + "");
	failLabel = "$L_fail_if_" + (_id$0 + "");
	this$0 = this._transformer;
	statement$0$0 = new GotoStatement(testLabel);
	this$0._outputStatements.push(statement$0$0);
	this$1 = this._transformer;
	statement$0$1 = new LabelStatement(testLabel);
	this$1._outputStatements.push(statement$0$1);
	this$2 = this._transformer;
	this$10 = this._statement;
	expr$0 = this$10._expr;
	statement$0$2 = new IfStatement(new Token$2("if", false), expr$0, [ new GotoStatement(succLabel) ], [ new GotoStatement(failLabel) ]);
	this$2._outputStatements.push(statement$0$2);
	this$3 = this._transformer;
	statement$0$3 = new LabelStatement(succLabel);
	this$3._outputStatements.push(statement$0$3);
	(this$4 = this._statement, this$4._onTrueStatements).forEach((function (statement) {
		CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$($this._transformer, statement).replaceControlStructuresWithGotos$();
	}));
	endLabel = "$L_end_if_" + (this._id + "");
	this$5 = this._transformer;
	statement$0$4 = new GotoStatement(endLabel);
	this$5._outputStatements.push(statement$0$4);
	this$6 = this._transformer;
	statement$0$5 = new LabelStatement(failLabel);
	this$6._outputStatements.push(statement$0$5);
	(this$7 = this._statement, this$7._onFalseStatements).forEach((function (statement) {
		CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$($this._transformer, statement).replaceControlStructuresWithGotos$();
	}));
	this$8 = this._transformer;
	statement$0$6 = new GotoStatement(endLabel);
	this$8._outputStatements.push(statement$0$6);
	this$9 = this._transformer;
	statement$0$7 = new LabelStatement(endLabel);
	this$9._outputStatements.push(statement$0$7);
};


function _SwitchStatementTransformer(transformer, statement) {
	var $this = this;
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.SWITCH == null) {
		_StatementTransformer._statementCountMap.SWITCH = 0;
	}
	this._id = _StatementTransformer._statementCountMap.SWITCH++;
	this._hasDefault = false;
	this._statement = statement;
	statement._statements.forEach((function (statement) {
		if (statement instanceof CaseStatement) {
			statement.setStash$SLStash$("CASE-ID", new _SwitchStatementTransformer$x2ECaseStash());
		} else if (statement instanceof DefaultStatement) {
			$this._hasDefault = true;
		}
	}));
};

$__jsx_extend([_SwitchStatementTransformer], _LabellableStatementTransformer);
_SwitchStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_SwitchStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var beginLabel;
	var endLabel;
	var this$0;
	var statement$0$0;
	var this$1;
	var statement$0$1;
	var this$2;
	var statement$0$2;
	var this$3;
	var statement$0$3;
	beginLabel = "$L_begin_switch_" + (this._id + "");
	this$0 = this._transformer;
	statement$0$0 = new GotoStatement(beginLabel);
	this$0._outputStatements.push(statement$0$0);
	this$1 = this._transformer;
	statement$0$1 = new LabelStatement(beginLabel);
	this$1._outputStatements.push(statement$0$1);
	_SwitchStatementTransformer$_emitSwitchConditionals$L_SwitchStatementTransformer$(this);
	_SwitchStatementTransformer$_emitSwitchBodies$L_SwitchStatementTransformer$(this);
	endLabel = "$L_end_switch_" + (this._id + "");
	this$2 = this._transformer;
	statement$0$2 = new GotoStatement(endLabel);
	this$2._outputStatements.push(statement$0$2);
	this$3 = this._transformer;
	statement$0$3 = new LabelStatement(endLabel);
	this$3._outputStatements.push(statement$0$3);
};


_SwitchStatementTransformer.prototype._emitSwitchConditionals$ = function () {
	var exprVar;
	var statements;
	var i;
	var caseStmt;
	var type$0;
	var id$0;
	var this$0;
	var this$1;
	var this$2;
	var statement$0;
	var this$3;
	var this$4;
	var expr$0;
	var succLabel$0;
	var failLabel$0;
	var statement$0$0;
	var this$5;
	var label$0;
	var statement$0$1;
	var this$6;
	var label$1;
	var statement$0$2;
	var this$7;
	var label$2;
	var statement$0$3;
	var this$8;
	var this$9;
	var _funcDefs$0;
	type$0 = (this$8 = this._statement, this$8._expr).getType$();
	id$0 = _Util$1._numUniqVar++;
	exprVar = new LocalVariable(new Token$2("$a" + (id$0 + ""), true), type$0, false);
	(this$1 = (this$0 = this._transformer, (_funcDefs$0 = this$0._funcDefs)[_funcDefs$0.length - 1]), this$1._locals).push(exprVar);
	this$2 = this._transformer;
	statement$0 = new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(exprVar._name, exprVar), (this$9 = this._statement, this$9._expr)));
	this$2._outputStatements.push(statement$0);
	this$3 = this._statement;
	statements = this$3._statements;
	for (i = 0; i < statements.length; ++i) {
		if (statements[i] instanceof CaseStatement) {
			caseStmt = statements[i];
			this$4 = this._transformer;
			expr$0 = new EqualityExpression(new Token$2("==", false), new LocalExpression(exprVar._name, exprVar), caseStmt._expr);
			succLabel$0 = "$L_switch_" + (this._id + "") + "_case_" + (caseStmt.getStash$S("CASE-ID").index + "");
			failLabel$0 = "$L_switch_" + (this._id + "") + "_end_case_" + (caseStmt.getStash$S("CASE-ID").index + "");
			statement$0$0 = new IfStatement(new Token$2("if", false), expr$0, [ new GotoStatement(succLabel$0) ], [ new GotoStatement(failLabel$0) ]);
			this$4._outputStatements.push(statement$0$0);
			this$5 = this._transformer;
			label$0 = "$L_switch_" + (this._id + "") + "_end_case_" + (caseStmt.getStash$S("CASE-ID").index + "");
			statement$0$1 = new LabelStatement(label$0);
			this$5._outputStatements.push(statement$0$1);
		}
	}
	if (this._hasDefault) {
		this$6 = this._transformer;
		label$1 = "$L_switch_" + (this._id + "") + "_default";
		statement$0$2 = new GotoStatement(label$1);
		this$6._outputStatements.push(statement$0$2);
	} else {
		this$7 = this._transformer;
		label$2 = "$L_end_switch_" + (this._id + "");
		statement$0$3 = new GotoStatement(label$2);
		this$7._outputStatements.push(statement$0$3);
	}
};


function _SwitchStatementTransformer$_emitSwitchConditionals$L_SwitchStatementTransformer$($this) {
	var exprVar;
	var statements;
	var i;
	var caseStmt;
	var type$0;
	var id$0;
	var this$0;
	var this$1;
	var this$2;
	var statement$0;
	var this$3;
	var this$4;
	var expr$0;
	var succLabel$0;
	var failLabel$0;
	var statement$0$0;
	var this$5;
	var label$0;
	var statement$0$1;
	var this$6;
	var label$1;
	var statement$0$2;
	var this$7;
	var label$2;
	var statement$0$3;
	var this$8;
	var this$9;
	var _funcDefs$0;
	type$0 = (this$8 = $this._statement, this$8._expr).getType$();
	id$0 = _Util$1._numUniqVar++;
	exprVar = new LocalVariable(new Token$2("$a" + (id$0 + ""), true), type$0, false);
	(this$1 = (this$0 = $this._transformer, (_funcDefs$0 = this$0._funcDefs)[_funcDefs$0.length - 1]), this$1._locals).push(exprVar);
	this$2 = $this._transformer;
	statement$0 = new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(exprVar._name, exprVar), (this$9 = $this._statement, this$9._expr)));
	this$2._outputStatements.push(statement$0);
	this$3 = $this._statement;
	statements = this$3._statements;
	for (i = 0; i < statements.length; ++i) {
		if (statements[i] instanceof CaseStatement) {
			caseStmt = statements[i];
			this$4 = $this._transformer;
			expr$0 = new EqualityExpression(new Token$2("==", false), new LocalExpression(exprVar._name, exprVar), caseStmt._expr);
			succLabel$0 = "$L_switch_" + ($this._id + "") + "_case_" + (caseStmt.getStash$S("CASE-ID").index + "");
			failLabel$0 = "$L_switch_" + ($this._id + "") + "_end_case_" + (caseStmt.getStash$S("CASE-ID").index + "");
			statement$0$0 = new IfStatement(new Token$2("if", false), expr$0, [ new GotoStatement(succLabel$0) ], [ new GotoStatement(failLabel$0) ]);
			this$4._outputStatements.push(statement$0$0);
			this$5 = $this._transformer;
			label$0 = "$L_switch_" + ($this._id + "") + "_end_case_" + (caseStmt.getStash$S("CASE-ID").index + "");
			statement$0$1 = new LabelStatement(label$0);
			this$5._outputStatements.push(statement$0$1);
		}
	}
	if ($this._hasDefault) {
		this$6 = $this._transformer;
		label$1 = "$L_switch_" + ($this._id + "") + "_default";
		statement$0$2 = new GotoStatement(label$1);
		this$6._outputStatements.push(statement$0$2);
	} else {
		this$7 = $this._transformer;
		label$2 = "$L_end_switch_" + ($this._id + "");
		statement$0$3 = new GotoStatement(label$2);
		this$7._outputStatements.push(statement$0$3);
	}
};

_SwitchStatementTransformer._emitSwitchConditionals$L_SwitchStatementTransformer$ = _SwitchStatementTransformer$_emitSwitchConditionals$L_SwitchStatementTransformer$;

_SwitchStatementTransformer.prototype._emitSwitchBodies$ = function () {
	var statements;
	var i;
	var stmt;
	var label;
	var this$0;
	var this$1;
	var caseStmt$0;
	var this$2;
	var statement$0$0;
	var this$3;
	var statement$0$1;
	var this$4;
	var statement$0$2;
	var this$5;
	var statement$0$3;
	var this$6;
	this$0 = this._statement;
	statements = this$0._statements;
	this$1 = this._transformer;
	this$1._labelStack.push(this);
	for (i = 0; i < statements.length; ++i) {
		stmt = statements[i];
		if (stmt instanceof CaseStatement) {
			caseStmt$0 = stmt;
			label = "$L_switch_" + (this._id + "") + "_case_" + (caseStmt$0.getStash$S("CASE-ID").index + "");
			this$2 = this._transformer;
			statement$0$0 = new GotoStatement(label);
			this$2._outputStatements.push(statement$0$0);
			this$3 = this._transformer;
			statement$0$1 = new LabelStatement(label);
			this$3._outputStatements.push(statement$0$1);
		} else if (stmt instanceof DefaultStatement) {
			label = "$L_switch_" + (this._id + "") + "_default";
			this$4 = this._transformer;
			statement$0$2 = new GotoStatement(label);
			this$4._outputStatements.push(statement$0$2);
			this$5 = this._transformer;
			statement$0$3 = new LabelStatement(label);
			this$5._outputStatements.push(statement$0$3);
		} else {
			CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$(this._transformer, stmt).replaceControlStructuresWithGotos$();
		}
	}
	this$6 = this._transformer;
	this$6._labelStack.pop();
};


function _SwitchStatementTransformer$_emitSwitchBodies$L_SwitchStatementTransformer$($this) {
	var statements;
	var i;
	var stmt;
	var label;
	var this$0;
	var this$1;
	var caseStmt$0;
	var this$2;
	var statement$0$0;
	var this$3;
	var statement$0$1;
	var this$4;
	var statement$0$2;
	var this$5;
	var statement$0$3;
	var this$6;
	this$0 = $this._statement;
	statements = this$0._statements;
	this$1 = $this._transformer;
	this$1._labelStack.push($this);
	for (i = 0; i < statements.length; ++i) {
		stmt = statements[i];
		if (stmt instanceof CaseStatement) {
			caseStmt$0 = stmt;
			label = "$L_switch_" + ($this._id + "") + "_case_" + (caseStmt$0.getStash$S("CASE-ID").index + "");
			this$2 = $this._transformer;
			statement$0$0 = new GotoStatement(label);
			this$2._outputStatements.push(statement$0$0);
			this$3 = $this._transformer;
			statement$0$1 = new LabelStatement(label);
			this$3._outputStatements.push(statement$0$1);
		} else if (stmt instanceof DefaultStatement) {
			label = "$L_switch_" + ($this._id + "") + "_default";
			this$4 = $this._transformer;
			statement$0$2 = new GotoStatement(label);
			this$4._outputStatements.push(statement$0$2);
			this$5 = $this._transformer;
			statement$0$3 = new LabelStatement(label);
			this$5._outputStatements.push(statement$0$3);
		} else {
			CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$($this._transformer, stmt).replaceControlStructuresWithGotos$();
		}
	}
	this$6 = $this._transformer;
	this$6._labelStack.pop();
};

_SwitchStatementTransformer._emitSwitchBodies$L_SwitchStatementTransformer$ = _SwitchStatementTransformer$_emitSwitchBodies$L_SwitchStatementTransformer$;

_SwitchStatementTransformer.prototype._getLabelFromCaseStatement$LCaseStatement$ = function (caseStmt) {
	return "$L_switch_" + (this._id + "") + "_case_" + (caseStmt.getStash$S("CASE-ID").index + "");
};


function _SwitchStatementTransformer$_getLabelFromCaseStatement$L_SwitchStatementTransformer$LCaseStatement$($this, caseStmt) {
	return "$L_switch_" + ($this._id + "") + "_case_" + (caseStmt.getStash$S("CASE-ID").index + "");
};

_SwitchStatementTransformer._getLabelFromCaseStatement$L_SwitchStatementTransformer$LCaseStatement$ = _SwitchStatementTransformer$_getLabelFromCaseStatement$L_SwitchStatementTransformer$LCaseStatement$;

_SwitchStatementTransformer.prototype._getLabelFromEndCaseStatement$LCaseStatement$ = function (caseStmt) {
	return "$L_switch_" + (this._id + "") + "_end_case_" + (caseStmt.getStash$S("CASE-ID").index + "");
};


function _SwitchStatementTransformer$_getLabelFromEndCaseStatement$L_SwitchStatementTransformer$LCaseStatement$($this, caseStmt) {
	return "$L_switch_" + ($this._id + "") + "_end_case_" + (caseStmt.getStash$S("CASE-ID").index + "");
};

_SwitchStatementTransformer._getLabelFromEndCaseStatement$L_SwitchStatementTransformer$LCaseStatement$ = _SwitchStatementTransformer$_getLabelFromEndCaseStatement$L_SwitchStatementTransformer$LCaseStatement$;

_SwitchStatementTransformer.prototype._getLabelFromDefaultStatement$ = function () {
	return "$L_switch_" + (this._id + "") + "_default";
};


function _SwitchStatementTransformer$_getLabelFromDefaultStatement$L_SwitchStatementTransformer$($this) {
	return "$L_switch_" + ($this._id + "") + "_default";
};

_SwitchStatementTransformer._getLabelFromDefaultStatement$L_SwitchStatementTransformer$ = _SwitchStatementTransformer$_getLabelFromDefaultStatement$L_SwitchStatementTransformer$;

_SwitchStatementTransformer.prototype.getBreakingLabel$ = function () {
	return "$L_end_switch_" + (this._id + "");
};


_SwitchStatementTransformer.prototype.getContinuingLabel$ = function () {
	throw new Error("logic flaw");
};


function _CaseStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.CASE == null) {
		_StatementTransformer._statementCountMap.CASE = 0;
	}
	this._id = _StatementTransformer._statementCountMap.CASE++;
	this._statement = statement;
};

$__jsx_extend([_CaseStatementTransformer], _StatementTransformer);
_CaseStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_CaseStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	throw new Error("logic flaw");
};


function _DefaultStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.DEFAULT == null) {
		_StatementTransformer._statementCountMap.DEFAULT = 0;
	}
	this._id = _StatementTransformer._statementCountMap.DEFAULT++;
	this._statement = statement;
};

$__jsx_extend([_DefaultStatementTransformer], _StatementTransformer);
_DefaultStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_DefaultStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	throw new Error("logic flaw");
};


function _WhileStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.WHILE == null) {
		_StatementTransformer._statementCountMap.WHILE = 0;
	}
	this._id = _StatementTransformer._statementCountMap.WHILE++;
	this._statement = statement;
};

$__jsx_extend([_WhileStatementTransformer], _LabellableStatementTransformer);
_WhileStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_WhileStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var $this = this;
	var testLabel;
	var bodyLabel;
	var endLabel;
	var this$0;
	var statement$0$0;
	var this$1;
	var statement$0$1;
	var this$2;
	var expr$0;
	var statement$0$2;
	var this$3;
	var statement$0$3;
	var this$4;
	var this$5;
	var this$6;
	var this$7;
	var statement$0$4;
	var this$8;
	var statement$0$5;
	var this$9;
	var _id$0;
	testLabel = "$L_test_while_" + (this._id + "");
	this$0 = this._transformer;
	statement$0$0 = new GotoStatement(testLabel);
	this$0._outputStatements.push(statement$0$0);
	this$1 = this._transformer;
	statement$0$1 = new LabelStatement(testLabel);
	this$1._outputStatements.push(statement$0$1);
	bodyLabel = "$L_body_while_" + ((_id$0 = this._id) + "");
	endLabel = "$L_end_while_" + (_id$0 + "");
	this$2 = this._transformer;
	this$9 = this._statement;
	expr$0 = this$9._expr;
	statement$0$2 = new IfStatement(new Token$2("if", false), expr$0, [ new GotoStatement(bodyLabel) ], [ new GotoStatement(endLabel) ]);
	this$2._outputStatements.push(statement$0$2);
	this$3 = this._transformer;
	statement$0$3 = new LabelStatement(bodyLabel);
	this$3._outputStatements.push(statement$0$3);
	this$4 = this._transformer;
	this$4._labelStack.push(this);
	(this$5 = this._statement, this$5._statements).forEach((function (statement) {
		CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$($this._transformer, statement).replaceControlStructuresWithGotos$();
	}));
	this$6 = this._transformer;
	this$6._labelStack.pop();
	this$7 = this._transformer;
	statement$0$4 = new GotoStatement(testLabel);
	this$7._outputStatements.push(statement$0$4);
	this$8 = this._transformer;
	statement$0$5 = new LabelStatement(endLabel);
	this$8._outputStatements.push(statement$0$5);
};


_WhileStatementTransformer.prototype.getBreakingLabel$ = function () {
	return "$L_end_while_" + (this._id + "");
};


_WhileStatementTransformer.prototype.getContinuingLabel$ = function () {
	return "$L_test_while_" + (this._id + "");
};


function _TryStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.TRY == null) {
		_StatementTransformer._statementCountMap.TRY = 0;
	}
	this._id = _StatementTransformer._statementCountMap.TRY++;
	this._statement = statement;
};

$__jsx_extend([_TryStatementTransformer], _StatementTransformer);
_TryStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_TryStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var $this = this;
	var funcDef;
	var raisedLocal;
	var errorLocal;
	var beginLabel;
	var finallyLabel;
	var catchLabel;
	var endLabel;
	var catchStmt;
	var endCatchLabel;
	var endFinallyLabel;
	var this$0;
	var this$1;
	var statement$0;
	var this$2;
	var statement$1;
	var this$3;
	var statement$2;
	var this$4;
	var statement$3;
	var this$5;
	var statement$4;
	var this$6;
	var statement$5;
	var this$7;
	var this$8;
	var statement$6;
	var this$9;
	var statement$7;
	var this$10;
	var this$11;
	var statement$8;
	var this$12;
	var statement$9;
	var this$13;
	var statement$10;
	var this$14;
	var statement$11;
	var this$15;
	var statement$12;
	var this$16;
	var statement$13;
	var this$17;
	var statement$14;
	var this$18;
	var statement$15;
	var this$19;
	var this$20;
	var statement$16;
	var _funcDefs$0;
	this$0 = this._transformer;
	funcDef = (_funcDefs$0 = this$0._funcDefs)[_funcDefs$0.length - 1];
	raisedLocal = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$raised");
	errorLocal = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$error");
	beginLabel = "$L_begin_try_" + (this._id + "");
	this$1 = this._transformer;
	statement$0 = new GotoStatement(beginLabel);
	this$1._outputStatements.push(statement$0);
	this$2 = this._transformer;
	statement$1 = new LabelStatement(beginLabel);
	this$2._outputStatements.push(statement$1);
	this$3 = this._transformer;
	statement$2 = new GotoStatement("$__push_local_jump__");
	this$3._outputStatements.push(statement$2);
	finallyLabel = "$L_begin_finally_" + (this._id + "");
	this$4 = this._transformer;
	statement$3 = new GotoStatement(finallyLabel);
	this$4._outputStatements.push(statement$3);
	this$5 = this._transformer;
	statement$4 = new GotoStatement("$__push_local_jump__");
	this$5._outputStatements.push(statement$4);
	catchLabel = "$L_begin_catch_" + (this._id + "");
	this$6 = this._transformer;
	statement$5 = new GotoStatement(catchLabel);
	this$6._outputStatements.push(statement$5);
	(this$7 = this._statement, this$7._tryStatements).forEach((function (statement) {
		CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$($this._transformer, statement).replaceControlStructuresWithGotos$();
	}));
	endLabel = "$L_end_try_" + (this._id + "");
	this$8 = this._transformer;
	statement$6 = new GotoStatement(endLabel);
	this$8._outputStatements.push(statement$6);
	this$9 = this._transformer;
	statement$7 = new LabelStatement(endLabel);
	this$9._outputStatements.push(statement$7);
	catchStmt = (this$10 = this._statement, this$10._catchStatements)[0];
	Statement$forEachStatement$LStatement$F$LStatement$B$(catchStmt, (function onStmt(stmt) {
		return stmt.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
			var local;
			if (expr instanceof LocalExpression) {
				local = LocalExpression$getLocal$LLocalExpression$(expr);
				if (local == CatchStatement$getLocal$LCatchStatement$(catchStmt)) {
					expr = new AsNoConvertExpression(new Token$2("as", false), new LocalExpression(LocalVariable$getName$LLocalVariable$(errorLocal), errorLocal), LocalVariable$getType$LLocalVariable$(local));
					replaceCb(expr);
					return true;
				}
			}
			return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
		})) && Statement$forEachStatement$LStatement$F$LStatement$B$(stmt, onStmt);
	}));
	this$11 = this._transformer;
	statement$8 = new GotoStatement(catchLabel);
	this$11._outputStatements.push(statement$8);
	this$12 = this._transformer;
	statement$9 = new LabelStatement(catchLabel);
	this$12._outputStatements.push(statement$9);
	this$13 = this._transformer;
	statement$10 = new GotoStatement("$__pop_local_jump__");
	this$13._outputStatements.push(statement$10);
	CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$(this._transformer, new IfStatement(new Token$2("if", false), new LocalExpression(raisedLocal._name, raisedLocal), [ new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(raisedLocal._name, raisedLocal), new BooleanLiteralExpression(new Token$2("false", false)))) ].concat(catchStmt._statements), [  ])).replaceControlStructuresWithGotos$();
	endCatchLabel = "$L_end_catch_" + (this._id + "");
	this$14 = this._transformer;
	statement$11 = new GotoStatement(endCatchLabel);
	this$14._outputStatements.push(statement$11);
	this$15 = this._transformer;
	statement$12 = new LabelStatement(endCatchLabel);
	this$15._outputStatements.push(statement$12);
	this$16 = this._transformer;
	statement$13 = new GotoStatement(finallyLabel);
	this$16._outputStatements.push(statement$13);
	this$17 = this._transformer;
	statement$14 = new LabelStatement(finallyLabel);
	this$17._outputStatements.push(statement$14);
	this$18 = this._transformer;
	statement$15 = new GotoStatement("$__pop_local_jump__");
	this$18._outputStatements.push(statement$15);
	(this$19 = this._statement, this$19._finallyStatements).forEach((function (statement) {
		CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$($this._transformer, statement).replaceControlStructuresWithGotos$();
	}));
	endFinallyLabel = "$L_end_finally_" + (this._id + "");
	CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$(this._transformer, new IfStatement(new Token$2("if", false), new LocalExpression(raisedLocal._name, raisedLocal), [ new ThrowStatement(new Token$2("throw", false), new LocalExpression(errorLocal._name, errorLocal)) ], [  ])).replaceControlStructuresWithGotos$();
	this$20 = this._transformer;
	statement$16 = new LabelStatement(endFinallyLabel);
	this$20._outputStatements.push(statement$16);
};


function _CatchStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.CATCH == null) {
		_StatementTransformer._statementCountMap.CATCH = 0;
	}
	this._id = _StatementTransformer._statementCountMap.CATCH++;
	this._statement = statement;
};

$__jsx_extend([_CatchStatementTransformer], _StatementTransformer);
_CatchStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_CatchStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	throw new Error("logic flaw");
};


function _ThrowStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.THROW == null) {
		_StatementTransformer._statementCountMap.THROW = 0;
	}
	this._id = _StatementTransformer._statementCountMap.THROW++;
	this._statement = statement;
};

$__jsx_extend([_ThrowStatementTransformer], _StatementTransformer);
_ThrowStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_ThrowStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var this$0;
	var statement$0;
	this$0 = this._transformer;
	statement$0 = this._statement;
	this$0._outputStatements.push(statement$0);
};


function _AssertStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.ASSERT == null) {
		_StatementTransformer._statementCountMap.ASSERT = 0;
	}
	this._id = _StatementTransformer._statementCountMap.ASSERT++;
	this._statement = statement;
};

$__jsx_extend([_AssertStatementTransformer], _StatementTransformer);
_AssertStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_AssertStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var this$0;
	var statement$0;
	this$0 = this._transformer;
	statement$0 = this._statement;
	this$0._outputStatements.push(statement$0);
};


function _LogStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.LOG == null) {
		_StatementTransformer._statementCountMap.LOG = 0;
	}
	this._id = _StatementTransformer._statementCountMap.LOG++;
	this._statement = statement;
};

$__jsx_extend([_LogStatementTransformer], _StatementTransformer);
_LogStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_LogStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var this$0;
	var statement$0;
	this$0 = this._transformer;
	statement$0 = this._statement;
	this$0._outputStatements.push(statement$0);
};


function _DebuggerStatementTransformer(transformer, statement) {
	this._id = 0;
	this._transformer = transformer;
	if (_StatementTransformer._statementCountMap.DEBUGGER == null) {
		_StatementTransformer._statementCountMap.DEBUGGER = 0;
	}
	this._id = _StatementTransformer._statementCountMap.DEBUGGER++;
	this._statement = statement;
};

$__jsx_extend([_DebuggerStatementTransformer], _StatementTransformer);
_DebuggerStatementTransformer.prototype.getStatement$ = function () {
	return this._statement;
};


_DebuggerStatementTransformer.prototype._replaceControlStructuresWithGotos$ = function () {
	var this$0;
	var statement$0;
	this$0 = this._transformer;
	statement$0 = this._statement;
	this$0._outputStatements.push(statement$0);
};


function _Util$1() {
};

$__jsx_extend([_Util$1], Object);
function _Util$1$_createFreshArgumentDeclaration$LType$(type) {
	var id;
	id = _Util$1._numUniqVar++;
	return new ArgumentDeclaration(new Token$2("$a" + (id + ""), true), type);
};

_Util$1._createFreshArgumentDeclaration$LType$ = _Util$1$_createFreshArgumentDeclaration$LType$;

function _Util$1$_createFreshLocalVariable$LType$(type) {
	var id;
	id = _Util$1._numUniqVar++;
	return new LocalVariable(new Token$2("$a" + (id + ""), true), type, false);
};

_Util$1._createFreshLocalVariable$LType$ = _Util$1$_createFreshLocalVariable$LType$;

function _Util$1$_createAnonymousFunction$LMemberFunctionDefinition$LToken$ALArgumentDeclaration$LType$(parent, token, args, returnType) {
	return _Util$1$_createNamedFunction$LMemberFunctionDefinition$LToken$LToken$ALArgumentDeclaration$LType$(parent, token, null, args, returnType);
};

_Util$1._createAnonymousFunction$LMemberFunctionDefinition$LToken$ALArgumentDeclaration$LType$ = _Util$1$_createAnonymousFunction$LMemberFunctionDefinition$LToken$ALArgumentDeclaration$LType$;

function _Util$1$_createNamedFunction$LMemberFunctionDefinition$LToken$LToken$ALArgumentDeclaration$LType$(parent, token, nameToken, args, returnType) {
	var funcDef;
	var classDef$0$0;
	if (token == null) {
		token = new Token$2("function", false);
	}
	funcDef = new MemberFunctionDefinition(token, nameToken, 8, returnType, args, [  ], [  ], [  ], null, null);
	parent._closures.push(funcDef);
	funcDef._parent = parent;
	classDef$0$0 = parent._classDef;
	funcDef._classDef = classDef$0$0;
	return funcDef;
};

_Util$1._createNamedFunction$LMemberFunctionDefinition$LToken$LToken$ALArgumentDeclaration$LType$ = _Util$1$_createNamedFunction$LMemberFunctionDefinition$LToken$LToken$ALArgumentDeclaration$LType$;

function _Util$1$_createIdentityFunction$LMemberFunctionDefinition$LType$(parent, type) {
	var arg;
	var identity;
	var id$0;
	var this$0;
	var classDef$0$0;
	id$0 = _Util$1._numUniqVar++;
	arg = new ArgumentDeclaration(new Token$2("$a" + (id$0 + ""), true), type);
	identity = new MemberFunctionDefinition(new Token$2("function", false), null, 8, type, [ arg ], [  ], [ new ReturnStatement(new Token$2("return", false), new LocalExpression(new Token$2((this$0 = arg._name, this$0._value), true), arg)) ], [  ], null, null);
	parent._closures.push(identity);
	identity._parent = parent;
	classDef$0$0 = parent._classDef;
	identity._classDef = classDef$0$0;
	return new FunctionExpression(identity._token, identity);
};

_Util$1._createIdentityFunction$LMemberFunctionDefinition$LType$ = _Util$1$_createIdentityFunction$LMemberFunctionDefinition$LType$;

function _Util$1$instantiateBuiltinTemplate$LCompiler$SALType$(compiler, name, typeArgs) {
	var createContext;
	var context;
	function createContext(parser) {
		return ({errors: [  ], parser: parser, postInstantiationCallback: (function (parser, classDef) {
			ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			return classDef;
		}), funcDef: null, blockStack: null, statement: null});
	}
	context = createContext(compiler._builtinParsers[0]);
	return Util$instantiateTemplate$LAnalysisContext$LToken$SALType$(context, null, name, typeArgs);
};

_Util$1.instantiateBuiltinTemplate$LCompiler$SALType$ = _Util$1$instantiateBuiltinTemplate$LCompiler$SALType$;

function TransformCommand(compiler, identifier) {
	this.errors = null;
	this._compiler = compiler;
	this._identifier = identifier;
};

$__jsx_extend([TransformCommand], Object);
TransformCommand.prototype.setup$ALCompileError$ = function (errors) {
	this.errors = errors;
};


TransformCommand.prototype.getCompiler$ = function () {
	return this._compiler;
};


function TransformCommand$getCompiler$LTransformCommand$($this) {
	return $this._compiler;
};

TransformCommand.getCompiler$LTransformCommand$ = TransformCommand$getCompiler$LTransformCommand$;

function FunctionTransformCommand(compiler, identifier) {
	this.errors = null;
	this._compiler = compiler;
	this._identifier = identifier;
};

$__jsx_extend([FunctionTransformCommand], TransformCommand);
FunctionTransformCommand.prototype.performTransformation$ = function () {
	var $this = this;
	FunctionTransformCommand$_getAllClosures$LFunctionTransformCommand$(this).forEach((function (funcDef) {
		$this.transformFunction$LMemberFunctionDefinition$(funcDef);
	}));
};


FunctionTransformCommand.prototype._getAllClosures$ = function () {
	var $this = this;
	var closures;
	closures = [];
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._compiler, (function (parser, classDef) {
		return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function onMember(member) {
			MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(member, (function (funcDef) {
				return onMember(funcDef);
			}));
			if (member instanceof MemberFunctionDefinition) {
				closures.push(member);
			}
			return true;
		}));
	}));
	return closures;
};


function FunctionTransformCommand$_getAllClosures$LFunctionTransformCommand$($this) {
	var closures;
	closures = [];
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$($this._compiler, (function (parser, classDef) {
		return ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function onMember(member) {
			MemberDefinition$forEachClosure$LMemberDefinition$F$LMemberFunctionDefinition$B$(member, (function (funcDef) {
				return onMember(funcDef);
			}));
			if (member instanceof MemberFunctionDefinition) {
				closures.push(member);
			}
			return true;
		}));
	}));
	return closures;
};

FunctionTransformCommand._getAllClosures$LFunctionTransformCommand$ = FunctionTransformCommand$_getAllClosures$LFunctionTransformCommand$;

function GeneratorTransformCommand(compiler) {
	this.errors = null;
	this._compiler = compiler;
	this._identifier = "generator";
	this._jsxGeneratorObject = null;
};

$__jsx_extend([GeneratorTransformCommand], FunctionTransformCommand);
GeneratorTransformCommand.prototype.setup$ALCompileError$ = function (errors) {
	var builtins;
	var i;
	var this$0;
	var this$1;
	TransformCommand.prototype.setup$ALCompileError$.call(this, errors);
	builtins = (this$0 = this._compiler, this$0._builtinParsers)[0];
	for (i = 0; i < builtins._templateClassDefs.length; ++i) {
		if ((this$1 = builtins._templateClassDefs[i], this$1._className) === "__jsx_generator_object") {
			this._jsxGeneratorObject = builtins._templateClassDefs[i];
			break;
		}
	}
};


GeneratorTransformCommand.prototype.transformFunction$LMemberFunctionDefinition$ = function (funcDef) {
	if (! ((funcDef._flags & 8192) !== 0)) {
		return;
	}
	GeneratorTransformCommand$_transformGeneratorCore$LGeneratorTransformCommand$LMemberFunctionDefinition$(this, funcDef);
	MemberDefinition$setFlags$LMemberDefinition$N(funcDef, funcDef._flags & -8193);
};


GeneratorTransformCommand.prototype._performANFTransformation$LMemberFunctionDefinition$ = function (funcDef) {
	var anfTransformer;
	anfTransformer = new ANFTransformCommand(this._compiler);
	anfTransformer.setup$ALCompileError$([  ]);
	anfTransformer.transformFunction$LMemberFunctionDefinition$(funcDef);
};


function GeneratorTransformCommand$_performANFTransformation$LGeneratorTransformCommand$LMemberFunctionDefinition$($this, funcDef) {
	var anfTransformer;
	anfTransformer = new ANFTransformCommand($this._compiler);
	anfTransformer.setup$ALCompileError$([  ]);
	anfTransformer.transformFunction$LMemberFunctionDefinition$(funcDef);
};

GeneratorTransformCommand._performANFTransformation$LGeneratorTransformCommand$LMemberFunctionDefinition$ = GeneratorTransformCommand$_performANFTransformation$LGeneratorTransformCommand$LMemberFunctionDefinition$;

GeneratorTransformCommand.prototype._transformGeneratorCore$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var generatorClassDef;
	var seedType;
	var genType;
	var jsxGenType;
	var jsxGenLocal;
	var statements;
	var caseCnt;
	var i;
	var exprStmt;
	var assignExpr;
	var yieldExpr;
	var caseLabel;
	var newExpr;
	var anfTransformer$0;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var _typeArguments$0;
	generatorClassDef = funcDef._returnType.getClassDef$();
	seedType = null;
	genType = null;
	if (generatorClassDef._typeArguments.length === 2) {
		seedType = (_typeArguments$0 = generatorClassDef._typeArguments)[0];
		genType = _typeArguments$0[1];
	} else {
		throw new Error("logic flaw!");
	}
	jsxGenType = GeneratorTransformCommand$_instantiateJSXGeneratorType$LGeneratorTransformCommand$LType$LType$(this, seedType, genType);
	jsxGenLocal = new LocalVariable(new Token$2("$generator", false), jsxGenType, false);
	funcDef._locals.push(jsxGenLocal);
	anfTransformer$0 = new ANFTransformCommand(this._compiler);
	anfTransformer$0.setup$ALCompileError$([  ]);
	anfTransformer$0.transformFunction$LMemberFunctionDefinition$(funcDef);
	statements = CPSTransformCommand$_extractVMDispatchBody$LMemberFunctionDefinition$(funcDef);
	caseCnt = 0;
	statements.forEach((function (statement) {
		if (statement instanceof CaseStatement) {
			caseCnt++;
		}
	}));
	for (i = 0; i < statements.length; ++i) {
		if (statements[i] instanceof ExpressionStatement && (this$3 = exprStmt = statements[i], this$3._expr) instanceof AssignmentExpression && (this$4 = assignExpr = exprStmt._expr, this$4._expr2) instanceof YieldExpression) {
			yieldExpr = assignExpr._expr2;
			caseLabel = caseCnt++;
			statements.splice(i, 1, new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__value", false), [  ], genType instanceof PrimitiveType || genType.equals$LType$(Type.voidType) ? new NullableType(genType) : genType), yieldExpr._expr)), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__next", true), [  ], (this$0 = Type.integerType, this$0 instanceof PrimitiveType || this$0.equals$LType$(Type.voidType) ? new NullableType(this$0) : this$0)), new IntegerLiteralExpression(new Token$2("" + (caseLabel + ""), false)))), new ReturnStatement(new Token$2("return", false), null), new CaseStatement(new Token$2("case", false), new IntegerLiteralExpression(new Token$2("" + (caseLabel + ""), false))), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), assignExpr._expr1, new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__seed", true), [  ], seedType instanceof PrimitiveType || seedType.equals$LType$(Type.voidType) ? new NullableType(seedType) : seedType))));
			i += 4;
		} else if (statements[i] instanceof ReturnStatement) {
			statements.splice(i, 0, new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__value", false), [  ], genType instanceof PrimitiveType || genType.equals$LType$(Type.voidType) ? new NullableType(genType) : genType), new LocalExpression(new Token$2("$return", true), CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$return")))), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__next", true), [  ], (this$1 = Type.integerType, this$1 instanceof PrimitiveType || this$1.equals$LType$(Type.voidType) ? new NullableType(this$1) : this$1)), new IntegerLiteralExpression(new Token$2("-1", false)))));
			i += 2;
		}
	}
	newExpr = new NewExpression(new Token$2("new", false), jsxGenType, [  ]);
	newExpr.analyze$LAnalysisContext$LExpression$(({errors: [  ], parser: null, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}), null);
	funcDef._statements.unshift(new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), newExpr)));
	statements = funcDef._statements;
	statements.splice(statements.length - 2, 2, new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__next", true), [  ], (this$2 = Type.integerType, this$2 instanceof PrimitiveType || this$2.equals$LType$(Type.voidType) ? new NullableType(this$2) : this$2)), new IntegerLiteralExpression(new Token$2("0", false)))), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__loop", true), [  ], new StaticFunctionType(null, Type.voidType, [ Type.integerType ], true)), new LocalExpression(new Token$2("$loop", true), CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$loop")))));
	statements.push(new ReturnStatement(new Token$2("return", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal)));
};


function GeneratorTransformCommand$_transformGeneratorCore$LGeneratorTransformCommand$LMemberFunctionDefinition$($this, funcDef) {
	var generatorClassDef;
	var seedType;
	var genType;
	var jsxGenType;
	var jsxGenLocal;
	var statements;
	var caseCnt;
	var i;
	var exprStmt;
	var assignExpr;
	var yieldExpr;
	var caseLabel;
	var newExpr;
	var anfTransformer$0;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
	var this$4;
	var _typeArguments$0;
	generatorClassDef = funcDef._returnType.getClassDef$();
	seedType = null;
	genType = null;
	if (generatorClassDef._typeArguments.length === 2) {
		seedType = (_typeArguments$0 = generatorClassDef._typeArguments)[0];
		genType = _typeArguments$0[1];
	} else {
		throw new Error("logic flaw!");
	}
	jsxGenType = GeneratorTransformCommand$_instantiateJSXGeneratorType$LGeneratorTransformCommand$LType$LType$($this, seedType, genType);
	jsxGenLocal = new LocalVariable(new Token$2("$generator", false), jsxGenType, false);
	funcDef._locals.push(jsxGenLocal);
	anfTransformer$0 = new ANFTransformCommand($this._compiler);
	anfTransformer$0.setup$ALCompileError$([  ]);
	anfTransformer$0.transformFunction$LMemberFunctionDefinition$(funcDef);
	statements = CPSTransformCommand$_extractVMDispatchBody$LMemberFunctionDefinition$(funcDef);
	caseCnt = 0;
	statements.forEach((function (statement) {
		if (statement instanceof CaseStatement) {
			caseCnt++;
		}
	}));
	for (i = 0; i < statements.length; ++i) {
		if (statements[i] instanceof ExpressionStatement && (this$3 = exprStmt = statements[i], this$3._expr) instanceof AssignmentExpression && (this$4 = assignExpr = exprStmt._expr, this$4._expr2) instanceof YieldExpression) {
			yieldExpr = assignExpr._expr2;
			caseLabel = caseCnt++;
			statements.splice(i, 1, new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__value", false), [  ], genType instanceof PrimitiveType || genType.equals$LType$(Type.voidType) ? new NullableType(genType) : genType), yieldExpr._expr)), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__next", true), [  ], (this$0 = Type.integerType, this$0 instanceof PrimitiveType || this$0.equals$LType$(Type.voidType) ? new NullableType(this$0) : this$0)), new IntegerLiteralExpression(new Token$2("" + (caseLabel + ""), false)))), new ReturnStatement(new Token$2("return", false), null), new CaseStatement(new Token$2("case", false), new IntegerLiteralExpression(new Token$2("" + (caseLabel + ""), false))), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), assignExpr._expr1, new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__seed", true), [  ], seedType instanceof PrimitiveType || seedType.equals$LType$(Type.voidType) ? new NullableType(seedType) : seedType))));
			i += 4;
		} else if (statements[i] instanceof ReturnStatement) {
			statements.splice(i, 0, new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__value", false), [  ], genType instanceof PrimitiveType || genType.equals$LType$(Type.voidType) ? new NullableType(genType) : genType), new LocalExpression(new Token$2("$return", true), CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$return")))), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__next", true), [  ], (this$1 = Type.integerType, this$1 instanceof PrimitiveType || this$1.equals$LType$(Type.voidType) ? new NullableType(this$1) : this$1)), new IntegerLiteralExpression(new Token$2("-1", false)))));
			i += 2;
		}
	}
	newExpr = new NewExpression(new Token$2("new", false), jsxGenType, [  ]);
	newExpr.analyze$LAnalysisContext$LExpression$(({errors: [  ], parser: null, postInstantiationCallback: null, funcDef: null, blockStack: null, statement: null}), null);
	funcDef._statements.unshift(new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), newExpr)));
	statements = funcDef._statements;
	statements.splice(statements.length - 2, 2, new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__next", true), [  ], (this$2 = Type.integerType, this$2 instanceof PrimitiveType || this$2.equals$LType$(Type.voidType) ? new NullableType(this$2) : this$2)), new IntegerLiteralExpression(new Token$2("0", false)))), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal), new Token$2("__loop", true), [  ], new StaticFunctionType(null, Type.voidType, [ Type.integerType ], true)), new LocalExpression(new Token$2("$loop", true), CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$loop")))));
	statements.push(new ReturnStatement(new Token$2("return", false), new LocalExpression(new Token$2("$generator", false), jsxGenLocal)));
};

GeneratorTransformCommand._transformGeneratorCore$LGeneratorTransformCommand$LMemberFunctionDefinition$ = GeneratorTransformCommand$_transformGeneratorCore$LGeneratorTransformCommand$LMemberFunctionDefinition$;

GeneratorTransformCommand.prototype._instantiateJSXGeneratorType$LType$LType$ = function (seedType, genType) {
	var $this = this;
	var genClassDef;
	var createContext;
	var parser;
	var this$0;
	var this$1;
	genClassDef = Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$((this$0 = this._jsxGeneratorObject, this$0._parser), [  ], ({_token: null, _className: "__jsx_generator_object", _typeArgs: [ seedType, genType ]}), (function (parser, classDef) {
		return null;
	}));
	createContext = (function (parser) {
		return ({errors: [  ], parser: parser, postInstantiationCallback: (function (parser, classDef) {
			ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			return classDef;
		}), funcDef: null, blockStack: null, statement: null});
	});
	this$1 = this._jsxGeneratorObject;
	parser = this$1._parser;
	ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(genClassDef, createContext(parser));
	ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(genClassDef, createContext(parser));
	return new ObjectType(genClassDef);
};


function GeneratorTransformCommand$_instantiateJSXGeneratorType$LGeneratorTransformCommand$LType$LType$($this, seedType, genType) {
	var genClassDef;
	var createContext;
	var parser;
	var this$0;
	var this$1;
	genClassDef = Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$((this$0 = $this._jsxGeneratorObject, this$0._parser), [  ], ({_token: null, _className: "__jsx_generator_object", _typeArgs: [ seedType, genType ]}), (function (parser, classDef) {
		return null;
	}));
	createContext = (function (parser) {
		return ({errors: [  ], parser: parser, postInstantiationCallback: (function (parser, classDef) {
			ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			return classDef;
		}), funcDef: null, blockStack: null, statement: null});
	});
	this$1 = $this._jsxGeneratorObject;
	parser = this$1._parser;
	ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(genClassDef, createContext(parser));
	ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(genClassDef, createContext(parser));
	return new ObjectType(genClassDef);
};

GeneratorTransformCommand._instantiateJSXGeneratorType$LGeneratorTransformCommand$LType$LType$ = GeneratorTransformCommand$_instantiateJSXGeneratorType$LGeneratorTransformCommand$LType$LType$;

function ANFTransformCommand(compiler) {
	this.errors = null;
	this._compiler = compiler;
	this._identifier = "anf";
	this._vm = null;
};

$__jsx_extend([ANFTransformCommand], FunctionTransformCommand);
ANFTransformCommand.prototype._performCPSTransformation$LMemberFunctionDefinition$ = function (funcDef) {
	var cpsTransformer;
	cpsTransformer = new CPSTransformCommand(this._compiler);
	cpsTransformer.setup$ALCompileError$([  ]);
	cpsTransformer._transformYield = true;
	cpsTransformer._transformExprs = true;
	cpsTransformer.transformFunction$LMemberFunctionDefinition$(funcDef);
};


function ANFTransformCommand$_performCPSTransformation$LANFTransformCommand$LMemberFunctionDefinition$($this, funcDef) {
	var cpsTransformer;
	cpsTransformer = new CPSTransformCommand($this._compiler);
	cpsTransformer.setup$ALCompileError$([  ]);
	cpsTransformer._transformYield = true;
	cpsTransformer._transformExprs = true;
	cpsTransformer.transformFunction$LMemberFunctionDefinition$(funcDef);
};

ANFTransformCommand._performCPSTransformation$LANFTransformCommand$LMemberFunctionDefinition$ = ANFTransformCommand$_performCPSTransformation$LANFTransformCommand$LMemberFunctionDefinition$;

ANFTransformCommand.prototype.transformFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var cpsTransformer$0;
	var funcStmt$0;
	cpsTransformer$0 = new CPSTransformCommand(this._compiler);
	cpsTransformer$0.setup$ALCompileError$([  ]);
	cpsTransformer$0._transformYield = true;
	cpsTransformer$0._transformExprs = true;
	cpsTransformer$0.transformFunction$LMemberFunctionDefinition$(funcDef);
	funcStmt$0 = funcDef._statements[1];
	this._vm = funcStmt$0._funcDef;
	try {
		ANFTransformCommand$_unfoldExpressions$LANFTransformCommand$ALStatement$(this, CPSTransformCommand$_extractVMDispatchBody$LMemberFunctionDefinition$(funcDef));
	} finally {
		this._vm = null;
	}
};


ANFTransformCommand.prototype._unfoldExpressions$ALStatement$ = function (statements) {
	var $this = this;
	var i;
	var assignExprs;
	var j;
	for (i = 0; i < statements.length; ++i) {
		assignExprs = [];
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				if (! (expr instanceof CallExpression)) {
					return true;
				}
				if (! (CallExpression$getExpr$LCallExpression$(expr) instanceof FunctionExpression)) {
					return true;
				}
				replaceCb(ANFTransformCommand$_unfoldExpr$LANFTransformCommand$LExpression$ALAssignmentExpression$($this, expr, assignExprs));
				return true;
			})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), [ statements[i] ]);
		for (j = assignExprs.length - 1; j >= 0; --j) {
			statements.splice(i, 0, new ExpressionStatement(assignExprs[j]));
		}
		i += assignExprs.length;
	}
};


function ANFTransformCommand$_unfoldExpressions$LANFTransformCommand$ALStatement$($this, statements) {
	var i;
	var assignExprs;
	var j;
	for (i = 0; i < statements.length; ++i) {
		assignExprs = [];
		Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
			return statement.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
				if (! (expr instanceof CallExpression)) {
					return true;
				}
				if (! (CallExpression$getExpr$LCallExpression$(expr) instanceof FunctionExpression)) {
					return true;
				}
				replaceCb(ANFTransformCommand$_unfoldExpr$LANFTransformCommand$LExpression$ALAssignmentExpression$($this, expr, assignExprs));
				return true;
			})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
		}), [ statements[i] ]);
		for (j = assignExprs.length - 1; j >= 0; --j) {
			statements.splice(i, 0, new ExpressionStatement(assignExprs[j]));
		}
		i += assignExprs.length;
	}
};

ANFTransformCommand._unfoldExpressions$LANFTransformCommand$ALStatement$ = ANFTransformCommand$_unfoldExpressions$LANFTransformCommand$ALStatement$;

ANFTransformCommand.prototype._unfoldExpr$LExpression$ALAssignmentExpression$ = function (expr, assignExprs) {
	var $this = this;
	var callExpr;
	var funcExpr;
	var argVar;
	var localVar;
	var retStmt;
	var expr$0;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
$TAIL_REC:
	while (true) {
		if (expr instanceof CallExpression) {
			callExpr = expr;
			funcExpr = callExpr._expr;
			argVar = (this$0 = funcExpr._funcDef, this$0._args)[0];
			localVar = new LocalVariable(argVar._name, argVar._type, false);
			(this$1 = this._vm, this$1._locals).push(localVar);
			assignExprs.push(new AssignmentExpression(new Token$2("=", false), new LocalExpression(localVar._name, localVar), callExpr._args[0]));
			this$2 = funcExpr._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$((function onStmt(stmt) {
				return Statement$forEachExpression$LStatement$F$LExpression$B$(stmt, (function onExpr(expr) {
					var local;
					if (expr instanceof LocalExpression) {
						local = LocalExpression$getLocal$LLocalExpression$(expr);
						if (local == argVar) {
							LocalExpression$setLocal$LLocalExpression$LLocalVariable$(expr, localVar);
						}
					}
					if (expr instanceof FunctionExpression) {
						MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStmt);
					}
					return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
				})) && Statement$forEachStatement$LStatement$F$LStatement$B$(stmt, onStmt);
			}), this$2._statements);
			retStmt = (this$3 = funcExpr._funcDef, this$3._statements)[0];
			(expr$0 = retStmt._expr, assignExprs);
			(expr = expr$0, assignExprs = assignExprs);
			continue $TAIL_REC;
		} else if (expr instanceof LocalExpression) {
			return expr;
		} else {
			throw new Error('logic flaw!');
		}
	}
};


function ANFTransformCommand$_unfoldExpr$LANFTransformCommand$LExpression$ALAssignmentExpression$($this, expr, assignExprs) {
	var callExpr;
	var funcExpr;
	var argVar;
	var localVar;
	var retStmt;
	var expr$0;
	var this$0;
	var this$1;
	var this$2;
	var this$3;
$TAIL_REC:
	while (true) {
		if (expr instanceof CallExpression) {
			callExpr = expr;
			funcExpr = callExpr._expr;
			argVar = (this$0 = funcExpr._funcDef, this$0._args)[0];
			localVar = new LocalVariable(argVar._name, argVar._type, false);
			(this$1 = $this._vm, this$1._locals).push(localVar);
			assignExprs.push(new AssignmentExpression(new Token$2("=", false), new LocalExpression(localVar._name, localVar), callExpr._args[0]));
			this$2 = funcExpr._funcDef;
			Util$forEachStatement$F$LStatement$B$ALStatement$((function onStmt(stmt) {
				return Statement$forEachExpression$LStatement$F$LExpression$B$(stmt, (function onExpr(expr) {
					var local;
					if (expr instanceof LocalExpression) {
						local = LocalExpression$getLocal$LLocalExpression$(expr);
						if (local == argVar) {
							LocalExpression$setLocal$LLocalExpression$LLocalVariable$(expr, localVar);
						}
					}
					if (expr instanceof FunctionExpression) {
						MemberFunctionDefinition$forEachStatement$LMemberFunctionDefinition$F$LStatement$B$(FunctionExpression$getFuncDef$LFunctionExpression$(expr), onStmt);
					}
					return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
				})) && Statement$forEachStatement$LStatement$F$LStatement$B$(stmt, onStmt);
			}), this$2._statements);
			retStmt = (this$3 = funcExpr._funcDef, this$3._statements)[0];
			(expr$0 = retStmt._expr, assignExprs);
			(expr = expr$0, assignExprs = assignExprs);
			continue $TAIL_REC;
		} else if (expr instanceof LocalExpression) {
			return expr;
		} else {
			throw new Error('logic flaw!');
		}
	}
};

ANFTransformCommand._unfoldExpr$LANFTransformCommand$LExpression$ALAssignmentExpression$ = ANFTransformCommand$_unfoldExpr$LANFTransformCommand$LExpression$ALAssignmentExpression$;

function CPSTransformCommand(compiler) {
	this.errors = null;
	this._compiler = compiler;
	this._identifier = "cps";
	this._outputStatements = null;
	this._labelStack = [];
	this._funcDefs = [];
	this._transformYield = false;
	this._transformExprs = false;
};

$__jsx_extend([CPSTransformCommand], FunctionTransformCommand);
CPSTransformCommand.prototype.setTransformYield$B = function (flag) {
	this._transformYield = flag;
};


function CPSTransformCommand$setTransformYield$LCPSTransformCommand$B($this, flag) {
	$this._transformYield = flag;
};

CPSTransformCommand.setTransformYield$LCPSTransformCommand$B = CPSTransformCommand$setTransformYield$LCPSTransformCommand$B;

CPSTransformCommand.prototype.setTransformExprs$B = function (flag) {
	this._transformExprs = flag;
};


function CPSTransformCommand$setTransformExprs$LCPSTransformCommand$B($this, flag) {
	$this._transformExprs = flag;
};

CPSTransformCommand.setTransformExprs$LCPSTransformCommand$B = CPSTransformCommand$setTransformExprs$LCPSTransformCommand$B;

CPSTransformCommand.prototype._functionIsTransformable$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var this$0$0;
	return (funcDef instanceof TemplateFunctionDefinition ? false : funcDef._statements == null ? false : funcDef._nameToken != null && (this$0$0 = funcDef._nameToken, this$0$0._value) === "constructor" ? false : Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		return Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			if (! $this._transformYield && expr instanceof YieldExpression) {
				return false;
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), funcDef._statements));
};


function CPSTransformCommand$_functionIsTransformable$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef) {
	var this$0$0;
	return (funcDef instanceof TemplateFunctionDefinition ? false : funcDef._statements == null ? false : funcDef._nameToken != null && (this$0$0 = funcDef._nameToken, this$0$0._value) === "constructor" ? false : Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		return Statement$forEachExpression$LStatement$F$LExpression$B$(statement, (function onExpr(expr) {
			if (! $this._transformYield && expr instanceof YieldExpression) {
				return false;
			}
			return Expression$forEachExpression$LExpression$F$LExpression$B$(expr, onExpr);
		})) && Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), funcDef._statements));
};

CPSTransformCommand._functionIsTransformable$LCPSTransformCommand$LMemberFunctionDefinition$ = CPSTransformCommand$_functionIsTransformable$LCPSTransformCommand$LMemberFunctionDefinition$;

CPSTransformCommand.prototype.transformFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var cmd;
	if (! CPSTransformCommand$_functionIsTransformable$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef)) {
		return;
	}
	cmd = new NormalizeTryStatementTransformCommand(this._compiler);
	cmd.setup$ALCompileError$([  ]);
	cmd.transformFunction$LMemberFunctionDefinition$(funcDef);
	cmd = new ForInStatementTransformCommand(this._compiler);
	cmd.setup$ALCompileError$([  ]);
	cmd.transformFunction$LMemberFunctionDefinition$(funcDef);
	CPSTransformCommand$_createAndSetVMReady$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef);
	CPSTransformCommand$_replaceControlStructuresWithGotos$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef);
	CPSTransformCommand$_eliminateDeadBranches$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef);
	CPSTransformCommand$_resolveLabels$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef);
	CPSTransformCommand$_convertPseudoInstructions$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef);
	CPSTransformCommand$_eliminateGotos$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef);
};


CPSTransformCommand.prototype._doCPSTransform$LMemberFunctionDefinition$ = function (funcDef) {
	CPSTransformCommand$_createAndSetVMReady$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef);
	CPSTransformCommand$_replaceControlStructuresWithGotos$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef);
	CPSTransformCommand$_eliminateDeadBranches$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef);
	CPSTransformCommand$_resolveLabels$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef);
	CPSTransformCommand$_convertPseudoInstructions$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef);
	CPSTransformCommand$_eliminateGotos$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef);
};


function CPSTransformCommand$_doCPSTransform$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef) {
	CPSTransformCommand$_createAndSetVMReady$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef);
	CPSTransformCommand$_replaceControlStructuresWithGotos$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef);
	CPSTransformCommand$_eliminateDeadBranches$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef);
	CPSTransformCommand$_resolveLabels$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef);
	CPSTransformCommand$_convertPseudoInstructions$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef);
	CPSTransformCommand$_eliminateGotos$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef);
};

CPSTransformCommand._doCPSTransform$LCPSTransformCommand$LMemberFunctionDefinition$ = CPSTransformCommand$_doCPSTransform$LCPSTransformCommand$LMemberFunctionDefinition$;

CPSTransformCommand.prototype._createAndSetVMReady$LMemberFunctionDefinition$ = function (funcDef) {
	var loopVar;
	var vm;
	var localJumpsVar;
	loopVar = new LocalVariable(new Token$2("$loop", true), new StaticFunctionType(null, Type.voidType, [ Type.integerType ], true), false);
	funcDef._locals.push(loopVar);
	vm = _Util$1$_createNamedFunction$LMemberFunctionDefinition$LToken$LToken$ALArgumentDeclaration$LType$(funcDef, null, new Token$2("$loop", true), [ new ArgumentDeclaration(new Token$2("$next", true), Type.integerType) ], Type.voidType);
	vm._funcLocal = loopVar;
	localJumpsVar = new LocalVariable(new Token$2("$localJumps", true), CPSTransformCommand$_instantiateArrayType$LCPSTransformCommand$LType$(this, Type.integerType), false);
	funcDef._locals.push(localJumpsVar);
	vm._statements = funcDef._statements;
	Util$rebaseClosures$LMemberFunctionDefinition$LMemberFunctionDefinition$(funcDef, vm);
	funcDef._statements = [ new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(new Token$2("$localJumps", true), localJumpsVar), new ArrayLiteralExpression(new Token$2("[", false), [  ], CPSTransformCommand$_instantiateArrayType$LCPSTransformCommand$LType$(this, Type.integerType)))), new FunctionStatement(new Token$2("function", false), vm), new ExpressionStatement(new CallExpression(new Token$2("(", false), new LocalExpression(new Token$2("$loop", true), loopVar), [ new IntegerLiteralExpression(new Token$2("0", false)) ])) ];
};


function CPSTransformCommand$_createAndSetVMReady$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef) {
	var loopVar;
	var vm;
	var localJumpsVar;
	loopVar = new LocalVariable(new Token$2("$loop", true), new StaticFunctionType(null, Type.voidType, [ Type.integerType ], true), false);
	funcDef._locals.push(loopVar);
	vm = _Util$1$_createNamedFunction$LMemberFunctionDefinition$LToken$LToken$ALArgumentDeclaration$LType$(funcDef, null, new Token$2("$loop", true), [ new ArgumentDeclaration(new Token$2("$next", true), Type.integerType) ], Type.voidType);
	vm._funcLocal = loopVar;
	localJumpsVar = new LocalVariable(new Token$2("$localJumps", true), CPSTransformCommand$_instantiateArrayType$LCPSTransformCommand$LType$($this, Type.integerType), false);
	funcDef._locals.push(localJumpsVar);
	vm._statements = funcDef._statements;
	Util$rebaseClosures$LMemberFunctionDefinition$LMemberFunctionDefinition$(funcDef, vm);
	funcDef._statements = [ new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(new Token$2("$localJumps", true), localJumpsVar), new ArrayLiteralExpression(new Token$2("[", false), [  ], CPSTransformCommand$_instantiateArrayType$LCPSTransformCommand$LType$($this, Type.integerType)))), new FunctionStatement(new Token$2("function", false), vm), new ExpressionStatement(new CallExpression(new Token$2("(", false), new LocalExpression(new Token$2("$loop", true), loopVar), [ new IntegerLiteralExpression(new Token$2("0", false)) ])) ];
};

CPSTransformCommand._createAndSetVMReady$LCPSTransformCommand$LMemberFunctionDefinition$ = CPSTransformCommand$_createAndSetVMReady$LCPSTransformCommand$LMemberFunctionDefinition$;

CPSTransformCommand.prototype._replaceControlStructuresWithGotos$LMemberFunctionDefinition$ = function (funcDef) {
	var inStatements;
	var outStatements;
	var i;
	var funcStmt$0;
	var this$0$0;
	var funcStmt$1;
	CPSTransformCommand$_enterFunction$LCPSTransformCommand$LMemberFunctionDefinition$(this, funcDef);
	try {
		funcStmt$0 = funcDef._statements[1];
		this$0$0 = funcStmt$0._funcDef;
		inStatements = this$0$0._statements;
		outStatements = [];
		this._outputStatements = outStatements;
		for (i = 0; i < inStatements.length; ++i) {
			CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$(this, inStatements[i]).replaceControlStructuresWithGotos$();
		}
		outStatements.unshift(new LabelStatement("$L_enter"));
		outStatements.push(new GotoStatement("$L_exit"), new LabelStatement("$L_exit"), new ReturnStatement(new Token$2("return", false), null));
		(funcStmt$1 = funcDef._statements[1], funcStmt$1._funcDef)._statements = outStatements;
	} finally {
		CPSTransformCommand$_leaveFunction$LCPSTransformCommand$(this);
	}
};


function CPSTransformCommand$_replaceControlStructuresWithGotos$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef) {
	var inStatements;
	var outStatements;
	var i;
	var funcStmt$0;
	var this$0$0;
	var funcStmt$1;
	CPSTransformCommand$_enterFunction$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef);
	try {
		funcStmt$0 = funcDef._statements[1];
		this$0$0 = funcStmt$0._funcDef;
		inStatements = this$0$0._statements;
		outStatements = [];
		$this._outputStatements = outStatements;
		for (i = 0; i < inStatements.length; ++i) {
			CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$($this, inStatements[i]).replaceControlStructuresWithGotos$();
		}
		outStatements.unshift(new LabelStatement("$L_enter"));
		outStatements.push(new GotoStatement("$L_exit"), new LabelStatement("$L_exit"), new ReturnStatement(new Token$2("return", false), null));
		(funcStmt$1 = funcDef._statements[1], funcStmt$1._funcDef)._statements = outStatements;
	} finally {
		CPSTransformCommand$_leaveFunction$LCPSTransformCommand$($this);
	}
};

CPSTransformCommand._replaceControlStructuresWithGotos$LCPSTransformCommand$LMemberFunctionDefinition$ = CPSTransformCommand$_replaceControlStructuresWithGotos$LCPSTransformCommand$LMemberFunctionDefinition$;

CPSTransformCommand.prototype._eliminateDeadBranches$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var statements;
	var isPseudoStatement;
	var i;
	var j;
	var srcLabel;
	var destLabel;
	var labelRenames;
	var labels;
	var fusedLabel;
	var funcStmt$0;
	var this$0$0;
	var this$0;
	var this$1;
	var this$2;
	var statements$len$0;
	var statements$len$1;
	funcStmt$0 = funcDef._statements[1];
	this$0$0 = funcStmt$0._funcDef;
	statements = this$0$0._statements;
	function isPseudoStatement(statement) {
		var this$0;
		return statement instanceof GotoStatement && (this$0 = statement, this$0._label).search(/\$__/) !== -1;
	}
	for (i = 0; i < statements.length; ++i) {
		if (isPseudoStatement(statements[i])) {
			switch ((this$0 = statements[i], this$0._label)) {
			case "$__push_local_jump__":
				i += 1;
				break;
			}
		} else if (statements[i] instanceof GotoStatement) {
			for ((j = i, statements$len$0 = statements.length); j < statements$len$0; ++j) {
				if (statements[j] instanceof LabelStatement) {
					break;
				}
			}
			statements.splice(i + 1, j - i - 1);
		}
	}
	for (i = 0; i < statements.length - 1; ++i) {
		if (statements[i] instanceof LabelStatement && statements[i + 1] instanceof GotoStatement && ! isPseudoStatement(statements[i + 1])) {
			srcLabel = statements[i];
			this$1 = statements[i + 1];
			destLabel = this$1._label;
			statements.splice(i, 2);
			for ((j = 0, statements$len$1 = statements.length); j < statements$len$1; ++j) {
				if (statements[j] instanceof LabelStatement && (this$2 = statements[j], this$2._name) === destLabel) {
					break;
				}
			}
			if (j === statements.length) {
				throw new Error("logic flaw");
			}
			statements.splice(j, 0, srcLabel);
			if (i <= j) {
				i--;
			}
		}
	}
	labelRenames = {};
	for (i = 0; i < statements.length; ++i) {
		if (statements[i] instanceof LabelStatement) {
			labels = [];
			for (j = i; statements[j] instanceof LabelStatement; ++j) {
				labels.push(statements[j]);
			}
			fusedLabel = labels.reduce((function (fuse, label) {
				if (fuse !== "") {
					fuse += "_";
				}
				return fuse + label._name;
			}), "");
			labels.forEach((function (label) {
				labelRenames[label._name] = fusedLabel;
			}));
			statements.splice(i, labels.length, new LabelStatement(fusedLabel));
		}
	}
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var gotoStmt;
		var label$0;
		if (statement instanceof GotoStatement && ! isPseudoStatement(statement)) {
			gotoStmt = statement;
			label$0 = labelRenames[gotoStmt._label];
			gotoStmt._label = label$0;
		}
		return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), statements);
};


function CPSTransformCommand$_eliminateDeadBranches$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef) {
	var statements;
	var isPseudoStatement;
	var i;
	var j;
	var srcLabel;
	var destLabel;
	var labelRenames;
	var labels;
	var fusedLabel;
	var funcStmt$0;
	var this$0$0;
	var this$0;
	var this$1;
	var this$2;
	var statements$len$0;
	var statements$len$1;
	funcStmt$0 = funcDef._statements[1];
	this$0$0 = funcStmt$0._funcDef;
	statements = this$0$0._statements;
	function isPseudoStatement(statement) {
		var this$0;
		return statement instanceof GotoStatement && (this$0 = statement, this$0._label).search(/\$__/) !== -1;
	}
	for (i = 0; i < statements.length; ++i) {
		if (isPseudoStatement(statements[i])) {
			switch ((this$0 = statements[i], this$0._label)) {
			case "$__push_local_jump__":
				i += 1;
				break;
			}
		} else if (statements[i] instanceof GotoStatement) {
			for ((j = i, statements$len$0 = statements.length); j < statements$len$0; ++j) {
				if (statements[j] instanceof LabelStatement) {
					break;
				}
			}
			statements.splice(i + 1, j - i - 1);
		}
	}
	for (i = 0; i < statements.length - 1; ++i) {
		if (statements[i] instanceof LabelStatement && statements[i + 1] instanceof GotoStatement && ! isPseudoStatement(statements[i + 1])) {
			srcLabel = statements[i];
			this$1 = statements[i + 1];
			destLabel = this$1._label;
			statements.splice(i, 2);
			for ((j = 0, statements$len$1 = statements.length); j < statements$len$1; ++j) {
				if (statements[j] instanceof LabelStatement && (this$2 = statements[j], this$2._name) === destLabel) {
					break;
				}
			}
			if (j === statements.length) {
				throw new Error("logic flaw");
			}
			statements.splice(j, 0, srcLabel);
			if (i <= j) {
				i--;
			}
		}
	}
	labelRenames = {};
	for (i = 0; i < statements.length; ++i) {
		if (statements[i] instanceof LabelStatement) {
			labels = [];
			for (j = i; statements[j] instanceof LabelStatement; ++j) {
				labels.push(statements[j]);
			}
			fusedLabel = labels.reduce((function (fuse, label) {
				if (fuse !== "") {
					fuse += "_";
				}
				return fuse + label._name;
			}), "");
			labels.forEach((function (label) {
				labelRenames[label._name] = fusedLabel;
			}));
			statements.splice(i, labels.length, new LabelStatement(fusedLabel));
		}
	}
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var gotoStmt;
		var label$0;
		if (statement instanceof GotoStatement && ! isPseudoStatement(statement)) {
			gotoStmt = statement;
			label$0 = labelRenames[gotoStmt._label];
			gotoStmt._label = label$0;
		}
		return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), statements);
};

CPSTransformCommand._eliminateDeadBranches$LCPSTransformCommand$LMemberFunctionDefinition$ = CPSTransformCommand$_eliminateDeadBranches$LCPSTransformCommand$LMemberFunctionDefinition$;

CPSTransformCommand.prototype._resolveLabels$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var statements;
	var labelIDs;
	var i;
	var c;
	var labelStmt;
	var funcStmt$0;
	var this$0$0;
	funcStmt$0 = funcDef._statements[1];
	this$0$0 = funcStmt$0._funcDef;
	statements = this$0$0._statements;
	labelIDs = {};
	for ((i = 0, c = 0); i < statements.length; ++i) {
		if (statements[i] instanceof LabelStatement) {
			labelStmt = statements[i];
			LabelStatement$setID$LLabelStatement$I(labelStmt, (c | 0));
			labelIDs[labelStmt._name] = (c | 0);
			c++;
		}
	}
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var gotoStmt;
		var label;
		var id$0;
		if (statement instanceof GotoStatement) {
			gotoStmt = statement;
			if (gotoStmt._label.search(/^\$__/) !== -1) {
				return true;
			}
			label = gotoStmt._label;
			if (! (label in labelIDs)) {
				throw new Error("logic flaw! label not found: " + label);
			}
			id$0 = labelIDs[label];
			gotoStmt._id = id$0;
		}
		return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), statements);
};


function CPSTransformCommand$_resolveLabels$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef) {
	var statements;
	var labelIDs;
	var i;
	var c;
	var labelStmt;
	var funcStmt$0;
	var this$0$0;
	funcStmt$0 = funcDef._statements[1];
	this$0$0 = funcStmt$0._funcDef;
	statements = this$0$0._statements;
	labelIDs = {};
	for ((i = 0, c = 0); i < statements.length; ++i) {
		if (statements[i] instanceof LabelStatement) {
			labelStmt = statements[i];
			LabelStatement$setID$LLabelStatement$I(labelStmt, (c | 0));
			labelIDs[labelStmt._name] = (c | 0);
			c++;
		}
	}
	Util$forEachStatement$F$LStatement$B$ALStatement$((function onStatement(statement) {
		var gotoStmt;
		var label;
		var id$0;
		if (statement instanceof GotoStatement) {
			gotoStmt = statement;
			if (gotoStmt._label.search(/^\$__/) !== -1) {
				return true;
			}
			label = gotoStmt._label;
			if (! (label in labelIDs)) {
				throw new Error("logic flaw! label not found: " + label);
			}
			id$0 = labelIDs[label];
			gotoStmt._id = id$0;
		}
		return Statement$forEachStatement$LStatement$F$LStatement$B$(statement, onStatement);
	}), statements);
};

CPSTransformCommand._resolveLabels$LCPSTransformCommand$LMemberFunctionDefinition$ = CPSTransformCommand$_resolveLabels$LCPSTransformCommand$LMemberFunctionDefinition$;

CPSTransformCommand.prototype._convertPseudoInstructions$LMemberFunctionDefinition$ = function (funcDef) {
	var statements;
	var localJumpsVar;
	var i;
	var gotoStmt;
	var gotoBeginFinally;
	var funcStmt$0;
	var this$0$0;
	var this$0;
	var this$1;
	var this$2;
	funcStmt$0 = funcDef._statements[1];
	this$0$0 = funcStmt$0._funcDef;
	statements = this$0$0._statements;
	localJumpsVar = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$localJumps");
	CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$raised");
	for (i = 0; i < statements.length; ++i) {
		if (statements[i] instanceof GotoStatement && (this$2 = statements[i], this$2._label).search(/^\$__/) !== -1) {
			gotoStmt = statements[i];
			switch (gotoStmt._label) {
			case '$__push_local_jump__':
				gotoBeginFinally = statements[i + 1];
				statements.splice(i, 2, new ExpressionStatement(new CallExpression(new Token$2("(", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$localJumps", true), localJumpsVar), new Token$2("push", true), [  ], new MemberFunctionType(null, localJumpsVar._type, Type.integerType, [ new VariableLengthArgumentType((this$0 = Type.integerType, this$0 instanceof PrimitiveType || this$0.equals$LType$(Type.voidType) ? new NullableType(this$0) : this$0)) ], false)), [ new IntegerLiteralExpression(new Token$2("" + (gotoBeginFinally._id + ""), false)) ])));
				break;
			case '$__pop_local_jump__':
				statements.splice(i, 1, new ExpressionStatement(new CallExpression(new Token$2("(", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$localJumps", true), localJumpsVar), new Token$2("pop", true), [  ], new MemberFunctionType(null, localJumpsVar._type, (this$1 = Type.integerType, this$1 instanceof PrimitiveType || this$1.equals$LType$(Type.voidType) ? new NullableType(this$1) : this$1), [  ], false)), [  ])));
				break;
			default:
				throw new Error('got unknown pseudo-instruction');
			}
		}
	}
};


function CPSTransformCommand$_convertPseudoInstructions$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef) {
	var statements;
	var localJumpsVar;
	var i;
	var gotoStmt;
	var gotoBeginFinally;
	var funcStmt$0;
	var this$0$0;
	var this$0;
	var this$1;
	var this$2;
	funcStmt$0 = funcDef._statements[1];
	this$0$0 = funcStmt$0._funcDef;
	statements = this$0$0._statements;
	localJumpsVar = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$localJumps");
	CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$raised");
	for (i = 0; i < statements.length; ++i) {
		if (statements[i] instanceof GotoStatement && (this$2 = statements[i], this$2._label).search(/^\$__/) !== -1) {
			gotoStmt = statements[i];
			switch (gotoStmt._label) {
			case '$__push_local_jump__':
				gotoBeginFinally = statements[i + 1];
				statements.splice(i, 2, new ExpressionStatement(new CallExpression(new Token$2("(", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$localJumps", true), localJumpsVar), new Token$2("push", true), [  ], new MemberFunctionType(null, localJumpsVar._type, Type.integerType, [ new VariableLengthArgumentType((this$0 = Type.integerType, this$0 instanceof PrimitiveType || this$0.equals$LType$(Type.voidType) ? new NullableType(this$0) : this$0)) ], false)), [ new IntegerLiteralExpression(new Token$2("" + (gotoBeginFinally._id + ""), false)) ])));
				break;
			case '$__pop_local_jump__':
				statements.splice(i, 1, new ExpressionStatement(new CallExpression(new Token$2("(", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$localJumps", true), localJumpsVar), new Token$2("pop", true), [  ], new MemberFunctionType(null, localJumpsVar._type, (this$1 = Type.integerType, this$1 instanceof PrimitiveType || this$1.equals$LType$(Type.voidType) ? new NullableType(this$1) : this$1), [  ], false)), [  ])));
				break;
			default:
				throw new Error('got unknown pseudo-instruction');
			}
		}
	}
};

CPSTransformCommand._convertPseudoInstructions$LCPSTransformCommand$LMemberFunctionDefinition$ = CPSTransformCommand$_convertPseudoInstructions$LCPSTransformCommand$LMemberFunctionDefinition$;

CPSTransformCommand.prototype._eliminateGotos$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var statements;
	var nextVar;
	var localJumpsVar;
	var raisedVar;
	var errorVar;
	var replaceGoto;
	var i;
	var stmt;
	var ifStmt;
	var replaceBasicBlock;
	var index;
	var eVar;
	var switchStmt;
	var inferiorWhileStmt;
	var tryStmt;
	var superiorWhileStmt;
	var funcStmt$0;
	var this$0$0;
	var funcStmt$0$0;
	var this$0$1;
	var funcStmt$1;
	var _statements$0;
	var statements$len$0;
	var statements$len$1;
	funcStmt$0 = (_statements$0 = funcDef._statements)[1];
	this$0$0 = funcStmt$0._funcDef;
	statements = this$0$0._statements;
	nextVar = (this$0$1 = (funcStmt$0$0 = _statements$0[1], funcStmt$0$0._funcDef), this$0$1._args)[0];
	localJumpsVar = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$localJumps");
	raisedVar = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$raised");
	errorVar = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$error");
	function replaceGoto(statements, index) {
		var gotoStmt;
		gotoStmt = statements[index];
		statements.splice(index, 1, new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(new Token$2("$next", true), nextVar), new IntegerLiteralExpression(new Token$2("" + (gotoStmt._id + ""), false)))), new BreakStatement(new Token$2("break", false), null));
		return (index + 1 | 0);
	}
	for (i = 0; i < statements.length; ++i) {
		stmt = statements[i];
		if (stmt instanceof GotoStatement) {
			i = replaceGoto(statements, (i | 0));
		} else if (stmt instanceof IfStatement) {
			ifStmt = stmt;
			replaceGoto(ifStmt._onTrueStatements, 0);
			replaceGoto(ifStmt._onFalseStatements, 0);
		}
	}
	function replaceBasicBlock(statements, index, end) {
		var labelStmt;
		labelStmt = statements[index];
		statements.splice(index, 1, new CaseStatement(new Token$2("case", false), new IntegerLiteralExpression(new Token$2("" + (labelStmt._id + ""), false))));
		return end;
	}
	for ((i = 0, statements$len$1 = statements.length); i < statements$len$1; ) {
		index = i;
		for ((i += 1, statements$len$0 = statements$len$1); i < statements$len$0; ++i) {
			if (statements[i] instanceof LabelStatement) {
				break;
			}
		}
		i = replaceBasicBlock(statements, (index | 0), (i | 0));
	}
	eVar = new CaughtVariable(new Token$2("$e", true), Type.variantType);
	switchStmt = new SwitchStatement(new Token$2("switch", false), null, new LocalExpression(new Token$2("$next", true), nextVar), statements);
	inferiorWhileStmt = new WhileStatement(new Token$2("while", false), null, new BooleanLiteralExpression(new Token$2("true", false)), [ switchStmt ]);
	tryStmt = new TryStatement(new Token$2("try", false), [ inferiorWhileStmt ], [ new CatchStatement(new Token$2("catch", false), eVar, [ new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(new Token$2("$raised", true), raisedVar), new BooleanLiteralExpression(new Token$2("true", false)))), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(new Token$2("$error", true), errorVar), new LocalExpression(new Token$2("$e", true), eVar))), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(new Token$2("$next", true), nextVar), new ArrayExpression$0(new Token$2("[", false), new LocalExpression(new Token$2("$localJumps", true), localJumpsVar), new BinaryNumberExpression(new Token$2("-", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$localJumps", true), localJumpsVar), new Token$2("length", true), [  ], Type.numberType), new IntegerLiteralExpression(new Token$2("1", false))), Type.integerType))) ]) ], [ new IfStatement(new Token$2("if", false), new LogicalExpression(new Token$2("&&", false), new EqualityExpression(new Token$2("==", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$localJumps", true), localJumpsVar), new Token$2("length", true), [  ], Type.numberType), new IntegerLiteralExpression(new Token$2("0", false))), new LocalExpression(new Token$2("$raised", true), raisedVar)), [ new ThrowStatement(new Token$2("throw", false), new LocalExpression(new Token$2("$error", true), errorVar)) ], [  ]) ]);
	superiorWhileStmt = new WhileStatement(new Token$2("while", false), null, new BooleanLiteralExpression(new Token$2("true", false)), [ tryStmt ]);
	(funcStmt$1 = funcDef._statements[1], funcStmt$1._funcDef)._statements = [ superiorWhileStmt ];
};


function CPSTransformCommand$_eliminateGotos$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef) {
	var statements;
	var nextVar;
	var localJumpsVar;
	var raisedVar;
	var errorVar;
	var replaceGoto;
	var i;
	var stmt;
	var ifStmt;
	var replaceBasicBlock;
	var index;
	var eVar;
	var switchStmt;
	var inferiorWhileStmt;
	var tryStmt;
	var superiorWhileStmt;
	var funcStmt$0;
	var this$0$0;
	var funcStmt$0$0;
	var this$0$1;
	var funcStmt$1;
	var _statements$0;
	var statements$len$0;
	var statements$len$1;
	funcStmt$0 = (_statements$0 = funcDef._statements)[1];
	this$0$0 = funcStmt$0._funcDef;
	statements = this$0$0._statements;
	nextVar = (this$0$1 = (funcStmt$0$0 = _statements$0[1], funcStmt$0$0._funcDef), this$0$1._args)[0];
	localJumpsVar = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$localJumps");
	raisedVar = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$raised");
	errorVar = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$error");
	function replaceGoto(statements, index) {
		var gotoStmt;
		gotoStmt = statements[index];
		statements.splice(index, 1, new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(new Token$2("$next", true), nextVar), new IntegerLiteralExpression(new Token$2("" + (gotoStmt._id + ""), false)))), new BreakStatement(new Token$2("break", false), null));
		return (index + 1 | 0);
	}
	for (i = 0; i < statements.length; ++i) {
		stmt = statements[i];
		if (stmt instanceof GotoStatement) {
			i = replaceGoto(statements, (i | 0));
		} else if (stmt instanceof IfStatement) {
			ifStmt = stmt;
			replaceGoto(ifStmt._onTrueStatements, 0);
			replaceGoto(ifStmt._onFalseStatements, 0);
		}
	}
	function replaceBasicBlock(statements, index, end) {
		var labelStmt;
		labelStmt = statements[index];
		statements.splice(index, 1, new CaseStatement(new Token$2("case", false), new IntegerLiteralExpression(new Token$2("" + (labelStmt._id + ""), false))));
		return end;
	}
	for ((i = 0, statements$len$1 = statements.length); i < statements$len$1; ) {
		index = i;
		for ((i += 1, statements$len$0 = statements$len$1); i < statements$len$0; ++i) {
			if (statements[i] instanceof LabelStatement) {
				break;
			}
		}
		i = replaceBasicBlock(statements, (index | 0), (i | 0));
	}
	eVar = new CaughtVariable(new Token$2("$e", true), Type.variantType);
	switchStmt = new SwitchStatement(new Token$2("switch", false), null, new LocalExpression(new Token$2("$next", true), nextVar), statements);
	inferiorWhileStmt = new WhileStatement(new Token$2("while", false), null, new BooleanLiteralExpression(new Token$2("true", false)), [ switchStmt ]);
	tryStmt = new TryStatement(new Token$2("try", false), [ inferiorWhileStmt ], [ new CatchStatement(new Token$2("catch", false), eVar, [ new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(new Token$2("$raised", true), raisedVar), new BooleanLiteralExpression(new Token$2("true", false)))), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(new Token$2("$error", true), errorVar), new LocalExpression(new Token$2("$e", true), eVar))), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(new Token$2("$next", true), nextVar), new ArrayExpression$0(new Token$2("[", false), new LocalExpression(new Token$2("$localJumps", true), localJumpsVar), new BinaryNumberExpression(new Token$2("-", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$localJumps", true), localJumpsVar), new Token$2("length", true), [  ], Type.numberType), new IntegerLiteralExpression(new Token$2("1", false))), Type.integerType))) ]) ], [ new IfStatement(new Token$2("if", false), new LogicalExpression(new Token$2("&&", false), new EqualityExpression(new Token$2("==", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(new Token$2("$localJumps", true), localJumpsVar), new Token$2("length", true), [  ], Type.numberType), new IntegerLiteralExpression(new Token$2("0", false))), new LocalExpression(new Token$2("$raised", true), raisedVar)), [ new ThrowStatement(new Token$2("throw", false), new LocalExpression(new Token$2("$error", true), errorVar)) ], [  ]) ]);
	superiorWhileStmt = new WhileStatement(new Token$2("while", false), null, new BooleanLiteralExpression(new Token$2("true", false)), [ tryStmt ]);
	(funcStmt$1 = funcDef._statements[1], funcStmt$1._funcDef)._statements = [ superiorWhileStmt ];
};

CPSTransformCommand._eliminateGotos$LCPSTransformCommand$LMemberFunctionDefinition$ = CPSTransformCommand$_eliminateGotos$LCPSTransformCommand$LMemberFunctionDefinition$;

CPSTransformCommand.prototype._instantiateArrayType$LType$ = function (type) {
	var $this = this;
	var arrayClass;
	var builtins;
	var i;
	var arrayClassDef;
	var createContext;
	var parser;
	var this$0;
	var this$1;
	arrayClass = null;
	builtins = (this$0 = this._compiler, this$0._builtinParsers)[0];
	for (i = 0; i < builtins._templateClassDefs.length; ++i) {
		if ((this$1 = builtins._templateClassDefs[i], this$1._className) === "Array") {
			arrayClass = builtins._templateClassDefs[i];
			break;
		}
	}
	if (arrayClass == null) {
		throw new Error("logic flaw");
	}
	arrayClassDef = Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(arrayClass._parser, [  ], ({_token: null, _className: "Array", _typeArgs: [ type ]}), (function (parser, classDef) {
		return null;
	}));
	if (arrayClassDef == null) {
		throw new Error("logic flaw");
	}
	createContext = (function (parser) {
		return ({errors: [  ], parser: parser, postInstantiationCallback: (function (parser, classDef) {
			ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			return classDef;
		}), funcDef: null, blockStack: null, statement: null});
	});
	parser = arrayClass._parser;
	ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(arrayClassDef, createContext(parser));
	ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(arrayClassDef, createContext(parser));
	return new ObjectType(arrayClassDef);
};


function CPSTransformCommand$_instantiateArrayType$LCPSTransformCommand$LType$($this, type) {
	var arrayClass;
	var builtins;
	var i;
	var arrayClassDef;
	var createContext;
	var parser;
	var this$0;
	var this$1;
	arrayClass = null;
	builtins = (this$0 = $this._compiler, this$0._builtinParsers)[0];
	for (i = 0; i < builtins._templateClassDefs.length; ++i) {
		if ((this$1 = builtins._templateClassDefs[i], this$1._className) === "Array") {
			arrayClass = builtins._templateClassDefs[i];
			break;
		}
	}
	if (arrayClass == null) {
		throw new Error("logic flaw");
	}
	arrayClassDef = Parser$lookupTemplate$LParser$ALCompileError$LTemplateInstantiationRequest$F$LParser$LClassDefinition$LClassDefinition$$(arrayClass._parser, [  ], ({_token: null, _className: "Array", _typeArgs: [ type ]}), (function (parser, classDef) {
		return null;
	}));
	if (arrayClassDef == null) {
		throw new Error("logic flaw");
	}
	createContext = (function (parser) {
		return ({errors: [  ], parser: parser, postInstantiationCallback: (function (parser, classDef) {
			ClassDefinition$setAnalysisContextOfVariables$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(classDef, createContext(parser));
			return classDef;
		}), funcDef: null, blockStack: null, statement: null});
	});
	parser = arrayClass._parser;
	ClassDefinition$resolveTypes$LClassDefinition$LAnalysisContext$(arrayClassDef, createContext(parser));
	ClassDefinition$analyze$LClassDefinition$LAnalysisContext$(arrayClassDef, createContext(parser));
	return new ObjectType(arrayClassDef);
};

CPSTransformCommand._instantiateArrayType$LCPSTransformCommand$LType$ = CPSTransformCommand$_instantiateArrayType$LCPSTransformCommand$LType$;

CPSTransformCommand.prototype._setOutputStatements$ALStatement$ = function (statements) {
	this._outputStatements = statements;
};


function CPSTransformCommand$_setOutputStatements$LCPSTransformCommand$ALStatement$($this, statements) {
	$this._outputStatements = statements;
};

CPSTransformCommand._setOutputStatements$LCPSTransformCommand$ALStatement$ = CPSTransformCommand$_setOutputStatements$LCPSTransformCommand$ALStatement$;

CPSTransformCommand.prototype._getOutputStatements$ = function () {
	return this._outputStatements;
};


function CPSTransformCommand$_getOutputStatements$LCPSTransformCommand$($this) {
	return $this._outputStatements;
};

CPSTransformCommand._getOutputStatements$LCPSTransformCommand$ = CPSTransformCommand$_getOutputStatements$LCPSTransformCommand$;

CPSTransformCommand.prototype._emit$LStatement$ = function (statement) {
	this._outputStatements.push(statement);
};


function CPSTransformCommand$_emit$LCPSTransformCommand$LStatement$($this, statement) {
	$this._outputStatements.push(statement);
};

CPSTransformCommand._emit$LCPSTransformCommand$LStatement$ = CPSTransformCommand$_emit$LCPSTransformCommand$LStatement$;

CPSTransformCommand.prototype._emitLabelStatement$S = function (label) {
	var statement$0;
	statement$0 = new LabelStatement(label);
	this._outputStatements.push(statement$0);
};


function CPSTransformCommand$_emitLabelStatement$LCPSTransformCommand$S($this, label) {
	var statement$0;
	statement$0 = new LabelStatement(label);
	$this._outputStatements.push(statement$0);
};

CPSTransformCommand._emitLabelStatement$LCPSTransformCommand$S = CPSTransformCommand$_emitLabelStatement$LCPSTransformCommand$S;

CPSTransformCommand.prototype._emitGotoStatement$S = function (label) {
	var statement$0;
	statement$0 = new GotoStatement(label);
	this._outputStatements.push(statement$0);
};


function CPSTransformCommand$_emitGotoStatement$LCPSTransformCommand$S($this, label) {
	var statement$0;
	statement$0 = new GotoStatement(label);
	$this._outputStatements.push(statement$0);
};

CPSTransformCommand._emitGotoStatement$LCPSTransformCommand$S = CPSTransformCommand$_emitGotoStatement$LCPSTransformCommand$S;

CPSTransformCommand.prototype._emitExpressionStatement$LExpression$ = function (expr) {
	var statement$0;
	statement$0 = new ExpressionStatement(expr);
	this._outputStatements.push(statement$0);
};


function CPSTransformCommand$_emitExpressionStatement$LCPSTransformCommand$LExpression$($this, expr) {
	var statement$0;
	statement$0 = new ExpressionStatement(expr);
	$this._outputStatements.push(statement$0);
};

CPSTransformCommand._emitExpressionStatement$LCPSTransformCommand$LExpression$ = CPSTransformCommand$_emitExpressionStatement$LCPSTransformCommand$LExpression$;

CPSTransformCommand.prototype._emitConditionalBranch$LExpression$SS = function (expr, succLabel, failLabel) {
	var statement$0;
	statement$0 = new IfStatement(new Token$2("if", false), expr, [ new GotoStatement(succLabel) ], [ new GotoStatement(failLabel) ]);
	this._outputStatements.push(statement$0);
};


function CPSTransformCommand$_emitConditionalBranch$LCPSTransformCommand$LExpression$SS($this, expr, succLabel, failLabel) {
	var statement$0;
	statement$0 = new IfStatement(new Token$2("if", false), expr, [ new GotoStatement(succLabel) ], [ new GotoStatement(failLabel) ]);
	$this._outputStatements.push(statement$0);
};

CPSTransformCommand._emitConditionalBranch$LCPSTransformCommand$LExpression$SS = CPSTransformCommand$_emitConditionalBranch$LCPSTransformCommand$LExpression$SS;

CPSTransformCommand.prototype._getStatementTransformerByLabel$S = function (label) {
	var i;
	var trans;
	var this$0;
	var this$1;
	for (i = 0; this._labelStack.length; ++i) {
		trans = this._labelStack[i];
		if ((this$1 = (this$0 = trans.getStatement$(), this$0._label), this$1._value) === label) {
			return trans;
		}
	}
	throw new Error("fatal error: no corresponding transformer for label \"" + label + "\"");
};


function CPSTransformCommand$_getStatementTransformerByLabel$LCPSTransformCommand$S($this, label) {
	var i;
	var trans;
	var this$0;
	var this$1;
	for (i = 0; $this._labelStack.length; ++i) {
		trans = $this._labelStack[i];
		if ((this$1 = (this$0 = trans.getStatement$(), this$0._label), this$1._value) === label) {
			return trans;
		}
	}
	throw new Error("fatal error: no corresponding transformer for label \"" + label + "\"");
};

CPSTransformCommand._getStatementTransformerByLabel$LCPSTransformCommand$S = CPSTransformCommand$_getStatementTransformerByLabel$LCPSTransformCommand$S;

CPSTransformCommand.prototype._getTopLabelledBlock$ = function () {
	var _labelStack$0;
	return (_labelStack$0 = this._labelStack)[_labelStack$0.length - 1];
};


function CPSTransformCommand$_getTopLabelledBlock$LCPSTransformCommand$($this) {
	var _labelStack$0;
	return (_labelStack$0 = $this._labelStack)[_labelStack$0.length - 1];
};

CPSTransformCommand._getTopLabelledBlock$LCPSTransformCommand$ = CPSTransformCommand$_getTopLabelledBlock$LCPSTransformCommand$;

CPSTransformCommand.prototype._enterLabelledBlock$L_LabellableStatementTransformer$ = function (transformer) {
	this._labelStack.push(transformer);
};


function CPSTransformCommand$_enterLabelledBlock$LCPSTransformCommand$L_LabellableStatementTransformer$($this, transformer) {
	$this._labelStack.push(transformer);
};

CPSTransformCommand._enterLabelledBlock$LCPSTransformCommand$L_LabellableStatementTransformer$ = CPSTransformCommand$_enterLabelledBlock$LCPSTransformCommand$L_LabellableStatementTransformer$;

CPSTransformCommand.prototype._leaveLabelledBlock$ = function () {
	this._labelStack.pop();
};


function CPSTransformCommand$_leaveLabelledBlock$LCPSTransformCommand$($this) {
	$this._labelStack.pop();
};

CPSTransformCommand._leaveLabelledBlock$LCPSTransformCommand$ = CPSTransformCommand$_leaveLabelledBlock$LCPSTransformCommand$;

CPSTransformCommand.prototype._enterFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var returnLocal;
	var raisedVar;
	var errorVar;
	this._funcDefs.push(funcDef);
	if (! Type.voidType.equals$LType$(funcDef._returnType)) {
		returnLocal = new LocalVariable(new Token$2("$return", true), funcDef._returnType, false);
		funcDef._locals.push(returnLocal);
	}
	raisedVar = new LocalVariable(new Token$2("$raised", true), Type.booleanType, false);
	funcDef._locals.push(raisedVar);
	errorVar = new LocalVariable(new Token$2("$error", true), Type.variantType, false);
	funcDef._locals.push(errorVar);
};


function CPSTransformCommand$_enterFunction$LCPSTransformCommand$LMemberFunctionDefinition$($this, funcDef) {
	var returnLocal;
	var raisedVar;
	var errorVar;
	$this._funcDefs.push(funcDef);
	if (! Type.voidType.equals$LType$(funcDef._returnType)) {
		returnLocal = new LocalVariable(new Token$2("$return", true), funcDef._returnType, false);
		funcDef._locals.push(returnLocal);
	}
	raisedVar = new LocalVariable(new Token$2("$raised", true), Type.booleanType, false);
	funcDef._locals.push(raisedVar);
	errorVar = new LocalVariable(new Token$2("$error", true), Type.variantType, false);
	funcDef._locals.push(errorVar);
};

CPSTransformCommand._enterFunction$LCPSTransformCommand$LMemberFunctionDefinition$ = CPSTransformCommand$_enterFunction$LCPSTransformCommand$LMemberFunctionDefinition$;

CPSTransformCommand.prototype._leaveFunction$ = function () {
	var funcDef;
	var returnLocal;
	funcDef = this._funcDefs.pop();
	returnLocal = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$return");
	if (! Type.voidType.equals$LType$(funcDef._returnType)) {
		funcDef._statements.push(new ReturnStatement(new Token$2("return", false), new LocalExpression(returnLocal._name, returnLocal)));
	}
};


function CPSTransformCommand$_leaveFunction$LCPSTransformCommand$($this) {
	var funcDef;
	var returnLocal;
	funcDef = $this._funcDefs.pop();
	returnLocal = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$return");
	if (! Type.voidType.equals$LType$(funcDef._returnType)) {
		funcDef._statements.push(new ReturnStatement(new Token$2("return", false), new LocalExpression(returnLocal._name, returnLocal)));
	}
};

CPSTransformCommand._leaveFunction$LCPSTransformCommand$ = CPSTransformCommand$_leaveFunction$LCPSTransformCommand$;

CPSTransformCommand.prototype._getTransformingFuncDef$ = function () {
	var _funcDefs$0;
	return (_funcDefs$0 = this._funcDefs)[_funcDefs$0.length - 1];
};


function CPSTransformCommand$_getTransformingFuncDef$LCPSTransformCommand$($this) {
	var _funcDefs$0;
	return (_funcDefs$0 = $this._funcDefs)[_funcDefs$0.length - 1];
};

CPSTransformCommand._getTransformingFuncDef$LCPSTransformCommand$ = CPSTransformCommand$_getTransformingFuncDef$LCPSTransformCommand$;

CPSTransformCommand.prototype._getStatementTransformerFor$LStatement$ = function (statement) {
	if (statement instanceof ConstructorInvocationStatement) {
		return new _ConstructorInvocationStatementTransformer(this, statement);
	} else if (statement instanceof ExpressionStatement) {
		return new _ExpressionStatementTransformer(this, statement);
	} else if (statement instanceof FunctionStatement) {
		return new _FunctionStatementTransformer(this, statement);
	} else if (statement instanceof ReturnStatement) {
		return new _ReturnStatementTransformer(this, statement);
	} else if (statement instanceof DeleteStatement) {
		return new _DeleteStatementTransformer(this, statement);
	} else if (statement instanceof BreakStatement) {
		return new _BreakStatementTransformer(this, statement);
	} else if (statement instanceof ContinueStatement) {
		return new _ContinueStatementTransformer(this, statement);
	} else if (statement instanceof DoWhileStatement) {
		return new _DoWhileStatementTransformer(this, statement);
	} else if (statement instanceof ForInStatement) {
		return new _ForInStatementTransformer(this, statement);
	} else if (statement instanceof ForStatement) {
		return new _ForStatementTransformer(this, statement);
	} else if (statement instanceof IfStatement) {
		return new _IfStatementTransformer(this, statement);
	} else if (statement instanceof SwitchStatement) {
		return new _SwitchStatementTransformer(this, statement);
	} else if (statement instanceof CaseStatement) {
		return new _CaseStatementTransformer(this, statement);
	} else if (statement instanceof DefaultStatement) {
		return new _DefaultStatementTransformer(this, statement);
	} else if (statement instanceof WhileStatement) {
		return new _WhileStatementTransformer(this, statement);
	} else if (statement instanceof TryStatement) {
		return new _TryStatementTransformer(this, statement);
	} else if (statement instanceof CatchStatement) {
		return new _CatchStatementTransformer(this, statement);
	} else if (statement instanceof ThrowStatement) {
		return new _ThrowStatementTransformer(this, statement);
	} else if (statement instanceof AssertStatement) {
		return new _AssertStatementTransformer(this, statement);
	} else if (statement instanceof LogStatement) {
		return new _LogStatementTransformer(this, statement);
	} else if (statement instanceof DebuggerStatement) {
		return new _DebuggerStatementTransformer(this, statement);
	}
	throw new Error("got unexpected type of statement: " + JSON.stringify(statement.serialize$()));
};


function CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$($this, statement) {
	if (statement instanceof ConstructorInvocationStatement) {
		return new _ConstructorInvocationStatementTransformer($this, statement);
	} else if (statement instanceof ExpressionStatement) {
		return new _ExpressionStatementTransformer($this, statement);
	} else if (statement instanceof FunctionStatement) {
		return new _FunctionStatementTransformer($this, statement);
	} else if (statement instanceof ReturnStatement) {
		return new _ReturnStatementTransformer($this, statement);
	} else if (statement instanceof DeleteStatement) {
		return new _DeleteStatementTransformer($this, statement);
	} else if (statement instanceof BreakStatement) {
		return new _BreakStatementTransformer($this, statement);
	} else if (statement instanceof ContinueStatement) {
		return new _ContinueStatementTransformer($this, statement);
	} else if (statement instanceof DoWhileStatement) {
		return new _DoWhileStatementTransformer($this, statement);
	} else if (statement instanceof ForInStatement) {
		return new _ForInStatementTransformer($this, statement);
	} else if (statement instanceof ForStatement) {
		return new _ForStatementTransformer($this, statement);
	} else if (statement instanceof IfStatement) {
		return new _IfStatementTransformer($this, statement);
	} else if (statement instanceof SwitchStatement) {
		return new _SwitchStatementTransformer($this, statement);
	} else if (statement instanceof CaseStatement) {
		return new _CaseStatementTransformer($this, statement);
	} else if (statement instanceof DefaultStatement) {
		return new _DefaultStatementTransformer($this, statement);
	} else if (statement instanceof WhileStatement) {
		return new _WhileStatementTransformer($this, statement);
	} else if (statement instanceof TryStatement) {
		return new _TryStatementTransformer($this, statement);
	} else if (statement instanceof CatchStatement) {
		return new _CatchStatementTransformer($this, statement);
	} else if (statement instanceof ThrowStatement) {
		return new _ThrowStatementTransformer($this, statement);
	} else if (statement instanceof AssertStatement) {
		return new _AssertStatementTransformer($this, statement);
	} else if (statement instanceof LogStatement) {
		return new _LogStatementTransformer($this, statement);
	} else if (statement instanceof DebuggerStatement) {
		return new _DebuggerStatementTransformer($this, statement);
	}
	throw new Error("got unexpected type of statement: " + JSON.stringify(statement.serialize$()));
};

CPSTransformCommand._getStatementTransformerFor$LCPSTransformCommand$LStatement$ = CPSTransformCommand$_getStatementTransformerFor$LCPSTransformCommand$LStatement$;

CPSTransformCommand.prototype._getExpressionTransformerFor$LExpression$ = function (expr) {
	if (expr instanceof LocalExpression) {
		return new _LeafExpressionTransformer(this, expr);
	} else if (expr instanceof ClassExpression) {
		throw new Error("logic flaw");
	} else if (expr instanceof NullExpression) {
		return new _LeafExpressionTransformer(this, expr);
	} else if (expr instanceof BooleanLiteralExpression) {
		return new _LeafExpressionTransformer(this, expr);
	} else if (expr instanceof IntegerLiteralExpression) {
		return new _LeafExpressionTransformer(this, expr);
	} else if (expr instanceof NumberLiteralExpression) {
		return new _LeafExpressionTransformer(this, expr);
	} else if (expr instanceof StringLiteralExpression) {
		return new _LeafExpressionTransformer(this, expr);
	} else if (expr instanceof RegExpLiteralExpression) {
		return new _LeafExpressionTransformer(this, expr);
	} else if (expr instanceof ArrayLiteralExpression) {
		return new _ArrayLiteralExpressionTransformer(this, expr);
	} else if (expr instanceof MapLiteralExpression) {
		return new _MapLiteralExpressionTransformer(this, expr);
	} else if (expr instanceof ThisExpression) {
		return new _LeafExpressionTransformer(this, expr);
	} else if (expr instanceof BitwiseNotExpression) {
		return new _BitwiseNotExpressionTransformer(this, expr);
	} else if (expr instanceof InstanceofExpression) {
		return new _InstanceofExpressionTransformer(this, expr);
	} else if (expr instanceof AsExpression) {
		return new _AsExpressionTransformer(this, expr);
	} else if (expr instanceof AsNoConvertExpression) {
		return new _AsNoConvertExpressionTransformer(this, expr);
	} else if (expr instanceof LogicalNotExpression) {
		return new _LogicalNotExpressionTransformer(this, expr);
	} else if (expr instanceof TypeofExpression) {
		return new _TypeofExpressionTransformer(this, expr);
	} else if (expr instanceof PostIncrementExpression) {
		return new _PostIncrementExpressionTransformer(this, expr);
	} else if (expr instanceof PreIncrementExpression) {
		return new _PreIncrementExpressionTransformer(this, expr);
	} else if (expr instanceof PropertyExpression) {
		return new _PropertyExpressionTransformer(this, expr);
	} else if (expr instanceof SignExpression) {
		return new _SignExpressionTransformer(this, expr);
	} else if (expr instanceof YieldExpression) {
		return new _YieldExpressionTransformer(this, expr);
	} else if (expr instanceof AdditiveExpression) {
		return new _AdditiveExpressionTransformer(this, expr);
	} else if (expr instanceof ArrayExpression) {
		return new _ArrayExpressionTransformer(this, expr);
	} else if (expr instanceof AssignmentExpression) {
		return new _AssignmentExpressionTransformer(this, expr);
	} else if (expr instanceof FusedAssignmentExpression) {
		return new _FusedAssignmentExpressionTransformer(this, expr);
	} else if (expr instanceof BinaryNumberExpression) {
		return new _BinaryNumberExpressionTransformer(this, expr);
	} else if (expr instanceof EqualityExpression) {
		return new _EqualityExpressionTransformer(this, expr);
	} else if (expr instanceof InExpression) {
		return new _InExpressionTransformer(this, expr);
	} else if (expr instanceof LogicalExpression) {
		return new _LogicalExpressionTransformer(this, expr);
	} else if (expr instanceof ShiftExpression) {
		return new _ShiftExpressionTransformer(this, expr);
	} else if (expr instanceof ConditionalExpression) {
		return new _ConditionalExpressionTransformer(this, expr);
	} else if (expr instanceof CallExpression) {
		return new _CallExpressionTransformer(this, expr);
	} else if (expr instanceof SuperExpression) {
		return new _SuperExpressionTransformer(this, expr);
	} else if (expr instanceof NewExpression) {
		return new _NewExpressionTransformer(this, expr);
	} else if (expr instanceof FunctionExpression) {
		return new _FunctionExpressionTransformer(this, expr);
	} else if (expr instanceof CommaExpression) {
		return new _CommaExpressionTransformer(this, expr);
	}
	throw new Error("got unexpected type of expression: " + (expr != null ? JSON.stringify(expr.serialize$()) : expr.toString()));
};


function CPSTransformCommand$_getExpressionTransformerFor$LCPSTransformCommand$LExpression$($this, expr) {
	if (expr instanceof LocalExpression) {
		return new _LeafExpressionTransformer($this, expr);
	} else if (expr instanceof ClassExpression) {
		throw new Error("logic flaw");
	} else if (expr instanceof NullExpression) {
		return new _LeafExpressionTransformer($this, expr);
	} else if (expr instanceof BooleanLiteralExpression) {
		return new _LeafExpressionTransformer($this, expr);
	} else if (expr instanceof IntegerLiteralExpression) {
		return new _LeafExpressionTransformer($this, expr);
	} else if (expr instanceof NumberLiteralExpression) {
		return new _LeafExpressionTransformer($this, expr);
	} else if (expr instanceof StringLiteralExpression) {
		return new _LeafExpressionTransformer($this, expr);
	} else if (expr instanceof RegExpLiteralExpression) {
		return new _LeafExpressionTransformer($this, expr);
	} else if (expr instanceof ArrayLiteralExpression) {
		return new _ArrayLiteralExpressionTransformer($this, expr);
	} else if (expr instanceof MapLiteralExpression) {
		return new _MapLiteralExpressionTransformer($this, expr);
	} else if (expr instanceof ThisExpression) {
		return new _LeafExpressionTransformer($this, expr);
	} else if (expr instanceof BitwiseNotExpression) {
		return new _BitwiseNotExpressionTransformer($this, expr);
	} else if (expr instanceof InstanceofExpression) {
		return new _InstanceofExpressionTransformer($this, expr);
	} else if (expr instanceof AsExpression) {
		return new _AsExpressionTransformer($this, expr);
	} else if (expr instanceof AsNoConvertExpression) {
		return new _AsNoConvertExpressionTransformer($this, expr);
	} else if (expr instanceof LogicalNotExpression) {
		return new _LogicalNotExpressionTransformer($this, expr);
	} else if (expr instanceof TypeofExpression) {
		return new _TypeofExpressionTransformer($this, expr);
	} else if (expr instanceof PostIncrementExpression) {
		return new _PostIncrementExpressionTransformer($this, expr);
	} else if (expr instanceof PreIncrementExpression) {
		return new _PreIncrementExpressionTransformer($this, expr);
	} else if (expr instanceof PropertyExpression) {
		return new _PropertyExpressionTransformer($this, expr);
	} else if (expr instanceof SignExpression) {
		return new _SignExpressionTransformer($this, expr);
	} else if (expr instanceof YieldExpression) {
		return new _YieldExpressionTransformer($this, expr);
	} else if (expr instanceof AdditiveExpression) {
		return new _AdditiveExpressionTransformer($this, expr);
	} else if (expr instanceof ArrayExpression) {
		return new _ArrayExpressionTransformer($this, expr);
	} else if (expr instanceof AssignmentExpression) {
		return new _AssignmentExpressionTransformer($this, expr);
	} else if (expr instanceof FusedAssignmentExpression) {
		return new _FusedAssignmentExpressionTransformer($this, expr);
	} else if (expr instanceof BinaryNumberExpression) {
		return new _BinaryNumberExpressionTransformer($this, expr);
	} else if (expr instanceof EqualityExpression) {
		return new _EqualityExpressionTransformer($this, expr);
	} else if (expr instanceof InExpression) {
		return new _InExpressionTransformer($this, expr);
	} else if (expr instanceof LogicalExpression) {
		return new _LogicalExpressionTransformer($this, expr);
	} else if (expr instanceof ShiftExpression) {
		return new _ShiftExpressionTransformer($this, expr);
	} else if (expr instanceof ConditionalExpression) {
		return new _ConditionalExpressionTransformer($this, expr);
	} else if (expr instanceof CallExpression) {
		return new _CallExpressionTransformer($this, expr);
	} else if (expr instanceof SuperExpression) {
		return new _SuperExpressionTransformer($this, expr);
	} else if (expr instanceof NewExpression) {
		return new _NewExpressionTransformer($this, expr);
	} else if (expr instanceof FunctionExpression) {
		return new _FunctionExpressionTransformer($this, expr);
	} else if (expr instanceof CommaExpression) {
		return new _CommaExpressionTransformer($this, expr);
	}
	throw new Error("got unexpected type of expression: " + (expr != null ? JSON.stringify(expr.serialize$()) : expr.toString()));
};

CPSTransformCommand._getExpressionTransformerFor$LCPSTransformCommand$LExpression$ = CPSTransformCommand$_getExpressionTransformerFor$LCPSTransformCommand$LExpression$;

function CPSTransformCommand$_extractVM$LMemberFunctionDefinition$(funcDef) {
	var funcStmt;
	funcStmt = funcDef._statements[1];
	return funcStmt._funcDef;
};

CPSTransformCommand._extractVM$LMemberFunctionDefinition$ = CPSTransformCommand$_extractVM$LMemberFunctionDefinition$;

function CPSTransformCommand$_extractVMBody$LMemberFunctionDefinition$(funcDef) {
	var funcStmt;
	var this$0;
	funcStmt = funcDef._statements[1];
	this$0 = funcStmt._funcDef;
	return this$0._statements;
};

CPSTransformCommand._extractVMBody$LMemberFunctionDefinition$ = CPSTransformCommand$_extractVMBody$LMemberFunctionDefinition$;

function CPSTransformCommand$_extractVMDispatchBody$LMemberFunctionDefinition$(funcDef) {
	var funcStmt;
	var superiorWhileStmt;
	var tryStmt;
	var inferiorWhileStmt;
	var switchStmt;
	var this$0;
	funcStmt = funcDef._statements[1];
	superiorWhileStmt = (this$0 = funcStmt._funcDef, this$0._statements)[0];
	tryStmt = superiorWhileStmt._statements[0];
	inferiorWhileStmt = tryStmt._tryStatements[0];
	switchStmt = inferiorWhileStmt._statements[0];
	return switchStmt._statements;
};

CPSTransformCommand._extractVMDispatchBody$LMemberFunctionDefinition$ = CPSTransformCommand$_extractVMDispatchBody$LMemberFunctionDefinition$;

function CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, name) {
	var locals;
	var i;
	var this$0;
	var this$1;
	var locals$len$0;
	locals = funcDef._locals;
	for ((i = 0, locals$len$0 = locals.length); i < locals$len$0; ++i) {
		if ((this$1 = (this$0 = locals[i], this$0._name), this$1._value) === name) {
			return locals[i];
		}
	}
	return null;
};

CPSTransformCommand._extractLocal$LMemberFunctionDefinition$S = CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S;

function CPSTransformCommand$_extractReturnLocal$LMemberFunctionDefinition$(funcDef) {
	return CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$return");
};

CPSTransformCommand._extractReturnLocal$LMemberFunctionDefinition$ = CPSTransformCommand$_extractReturnLocal$LMemberFunctionDefinition$;

function CPSTransformCommand$_extractNextLocal$LMemberFunctionDefinition$(funcDef) {
	var funcStmt$0;
	var this$0;
	return (this$0 = (funcStmt$0 = funcDef._statements[1], funcStmt$0._funcDef), this$0._args)[0];
};

CPSTransformCommand._extractNextLocal$LMemberFunctionDefinition$ = CPSTransformCommand$_extractNextLocal$LMemberFunctionDefinition$;

function CPSTransformCommand$_extractLoopLocal$LMemberFunctionDefinition$(funcDef) {
	return CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$loop");
};

CPSTransformCommand._extractLoopLocal$LMemberFunctionDefinition$ = CPSTransformCommand$_extractLoopLocal$LMemberFunctionDefinition$;

function CPSTransformCommand$_extractLocalJumpsLocal$LMemberFunctionDefinition$(funcDef) {
	return CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$localJumps");
};

CPSTransformCommand._extractLocalJumpsLocal$LMemberFunctionDefinition$ = CPSTransformCommand$_extractLocalJumpsLocal$LMemberFunctionDefinition$;

function CPSTransformCommand$_extractRaisedLocal$LMemberFunctionDefinition$(funcDef) {
	return CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$raised");
};

CPSTransformCommand._extractRaisedLocal$LMemberFunctionDefinition$ = CPSTransformCommand$_extractRaisedLocal$LMemberFunctionDefinition$;

function CPSTransformCommand$_extractErrorLocal$LMemberFunctionDefinition$(funcDef) {
	return CPSTransformCommand$_extractLocal$LMemberFunctionDefinition$S(funcDef, "$error");
};

CPSTransformCommand._extractErrorLocal$LMemberFunctionDefinition$ = CPSTransformCommand$_extractErrorLocal$LMemberFunctionDefinition$;

function ExpressionTransformCommand(compiler, identifier) {
	this.errors = null;
	this._compiler = compiler;
	this._identifier = identifier;
};

$__jsx_extend([ExpressionTransformCommand], TransformCommand);
ExpressionTransformCommand.prototype.performTransformation$ = function () {
	var $this = this;
	var touchMemberFunction;
	var touchMemberVariable;
	function touchMemberFunction(member) {
		Util$forEachStatement$F$LStatement$B$ALStatement$((function (stmt) {
			return ExpressionTransformCommand$touchStatement$LExpressionTransformCommand$LStatement$($this, stmt);
		}), member._statements);
	}
	function touchMemberVariable(member) {
		var expr;
		expr = member._initialValue;
		if (expr != null) {
			$this.touchExpression$LExpression$F$LExpression$V$(expr, (function (expr) {
				return MemberVariableDefinition$setInitialValue$LMemberVariableDefinition$LExpression$(member, expr);
			}));
		}
	}
	Compiler$forEachClassDef$LCompiler$F$LParser$LClassDefinition$B$(this._compiler, (function (parser, classDef) {
		if (! (classDef instanceof TemplateClassDefinition)) {
			ClassDefinition$forEachMember$LClassDefinition$F$LMemberDefinition$B$(classDef, (function (member) {
				if (! (classDef instanceof TemplateFunctionDefinition)) {
					if (member instanceof MemberFunctionDefinition) {
						touchMemberFunction(member);
					} else {
						if (! (member instanceof MemberVariableDefinition)) {
							debugger;
							throw new Error("[src/transformer.jsx:191:42] assertion failure\n                            assert member instanceof MemberVariableDefinition;\n                                          ^^^^^^^^^^\n");
						}
						touchMemberVariable(member);
					}
				}
				return true;
			}));
		}
		return true;
	}));
};


ExpressionTransformCommand.prototype.touchStatement$LStatement$ = function (stmt) {
	var $this = this;
	var this$0;
	var this$1;
	if (stmt instanceof FunctionStatement) {
		this$1 = stmt;
		this$0 = this$1._funcDef;
		Util$forEachStatement$F$LStatement$B$ALStatement$((function (stmt) {
			return ExpressionTransformCommand$touchStatement$LExpressionTransformCommand$LStatement$($this, stmt);
		}), this$0._statements);
	}
	Statement$forEachStatement$LStatement$F$LStatement$B$(stmt, (function (stmt) {
		return ExpressionTransformCommand$touchStatement$LExpressionTransformCommand$LStatement$($this, stmt);
	}));
	stmt.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
		return $this.touchExpression$LExpression$F$LExpression$V$(expr, replaceCb);
	}));
	return true;
};


function ExpressionTransformCommand$touchStatement$LExpressionTransformCommand$LStatement$($this, stmt) {
	var this$0;
	var this$1;
	if (stmt instanceof FunctionStatement) {
		this$1 = stmt;
		this$0 = this$1._funcDef;
		Util$forEachStatement$F$LStatement$B$ALStatement$((function (stmt) {
			return ExpressionTransformCommand$touchStatement$LExpressionTransformCommand$LStatement$($this, stmt);
		}), this$0._statements);
	}
	Statement$forEachStatement$LStatement$F$LStatement$B$(stmt, (function (stmt) {
		return ExpressionTransformCommand$touchStatement$LExpressionTransformCommand$LStatement$($this, stmt);
	}));
	stmt.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
		return $this.touchExpression$LExpression$F$LExpression$V$(expr, replaceCb);
	}));
	return true;
};

ExpressionTransformCommand.touchStatement$LExpressionTransformCommand$LStatement$ = ExpressionTransformCommand$touchStatement$LExpressionTransformCommand$LStatement$;

ExpressionTransformCommand.prototype.touchExpression$LExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var $this = this;
	var this$0;
	var this$1;
	if (expr instanceof FunctionExpression) {
		this$1 = expr;
		this$0 = this$1._funcDef;
		Util$forEachStatement$F$LStatement$B$ALStatement$((function (stmt) {
			return ExpressionTransformCommand$touchStatement$LExpressionTransformCommand$LStatement$($this, stmt);
		}), this$0._statements);
	}
	expr.forEachExpression$F$LExpression$F$LExpression$V$B$((function (expr, replaceCb) {
		return $this.touchExpression$LExpression$F$LExpression$V$(expr, replaceCb);
	}));
	return true;
};


function FixedExpressionTransformCommand(compiler) {
	this.errors = null;
	this._compiler = compiler;
	this._identifier = "fixed";
};

$__jsx_extend([FixedExpressionTransformCommand], ExpressionTransformCommand);
FixedExpressionTransformCommand.prototype.touchExpression$LExpression$F$LExpression$V$ = function (expr, replaceCb) {
	var envName;
	var envVar;
	var this$0;
	var this$1;
	var expr$0;
	var this$0$0;
	var this$1$0;
	var this$2$0;
	var this$2;
	var this$3;
	var expr$1;
	var this$0$1;
	var this$1$1;
	var this$2$1;
	var this$4;
	if (expr instanceof ArrayExpression && (this$2 = expr, this$2._expr1) instanceof PropertyExpression && (expr$1 = (this$3 = expr, this$3._expr1), expr$1._expr instanceof ClassExpression && (this$1$1 = (this$0$1 = expr$1._expr, this$0$1._token), this$1$1._value) === "JSX" && (this$2$1 = expr$1._identifierToken, this$2$1._value) === "ENV") && (this$4 = expr, this$4._expr2) instanceof StringLiteralExpression) {
		envName = (this$0 = expr, this$0._expr2).getDecoded$();
		envVar = (this$1 = this._compiler, this$1._userEnvironment)[envName];
		if (envVar != null) {
			replaceCb(new StringLiteralExpression(new Token$2(Util$encodeStringLiteral$S(envVar), false)));
		} else {
			replaceCb(new NullExpression(new Token$2("null", false), new NullableType(Type.stringType)));
		}
		return true;
	} else if (expr instanceof PropertyExpression && (expr$0 = expr, expr$0._expr instanceof ClassExpression && (this$1$0 = (this$0$0 = expr$0._expr, this$0$0._token), this$1$0._value) === "JSX" && (this$2$0 = expr$0._identifierToken, this$2$0._value) === "ENV")) {
		this.errors.push(new CompileError(expr._token, "JSX.ENV can only be accessed via: JSX.ENV[\"string-literal\"]"));
	}
	return ExpressionTransformCommand.prototype.touchExpression$LExpression$F$LExpression$V$.call(this, expr, replaceCb);
};


function FixedExpressionTransformCommand$_refersToJSXENV$LPropertyExpression$(expr) {
	var this$0;
	var this$1;
	var this$2;
	return expr._expr instanceof ClassExpression && (this$1 = (this$0 = expr._expr, this$0._token), this$1._value) === "JSX" && (this$2 = expr._identifierToken, this$2._value) === "ENV";
};

FixedExpressionTransformCommand._refersToJSXENV$LPropertyExpression$ = FixedExpressionTransformCommand$_refersToJSXENV$LPropertyExpression$;

function StatementTransformCommand(compiler, identifier) {
	this.errors = null;
	this._compiler = compiler;
	this._identifier = identifier;
	this._funcDef = null;
};

$__jsx_extend([StatementTransformCommand], FunctionTransformCommand);
StatementTransformCommand.prototype.transformFunction$LMemberFunctionDefinition$ = function (funcDef) {
	var $this = this;
	var prev;
	prev = this._funcDef;
	try {
		this._funcDef = funcDef;
		Util$forEachStatement$F$LStatement$F$LStatement$V$B$ALStatement$((function (stmt, replaceCb) {
			return $this.touchStatement$LStatement$F$LStatement$V$(stmt, replaceCb);
		}), funcDef._statements);
	} finally {
		this._funcDef = prev;
	}
};


StatementTransformCommand.prototype.touchStatement$LStatement$F$LStatement$V$ = function (stmt, replaceCb) {
	var $this = this;
	stmt.forEachStatement$F$LStatement$F$LStatement$V$B$((function (stmt, replaceCb) {
		return $this.touchStatement$LStatement$F$LStatement$V$(stmt, replaceCb);
	}));
	return true;
};


StatementTransformCommand.prototype.getProcessingFuncDef$ = function () {
	return this._funcDef;
};


function StatementTransformCommand$getProcessingFuncDef$LStatementTransformCommand$($this) {
	return $this._funcDef;
};

StatementTransformCommand.getProcessingFuncDef$LStatementTransformCommand$ = StatementTransformCommand$getProcessingFuncDef$LStatementTransformCommand$;

function NormalizeTryStatementTransformCommand(compiler) {
	this.errors = null;
	this._compiler = compiler;
	this._identifier = "normalize-try";
	this._funcDef = null;
};

$__jsx_extend([NormalizeTryStatementTransformCommand], StatementTransformCommand);
NormalizeTryStatementTransformCommand.prototype.touchStatement$LStatement$F$LStatement$V$ = function (statement, replaceCb) {
	var $this = this;
	var tryStatement;
	var catchStatements;
	var newCaught;
	var newBody;
	var newCatch;
	var _catchStatements$0;
	if (statement instanceof TryStatement) {
		tryStatement = statement;
		catchStatements = tryStatement._catchStatements;
		newCaught = new CaughtVariable(new Token$2("e", true), Type.variantType);
		catchStatements.forEach((function (catchStmt) {
			Statement$forEachStatement$LStatement$F$LStatement$B$(catchStmt, (function onStmt(stmt) {
				return stmt.forEachExpression$F$LExpression$F$LExpression$V$B$((function onExpr(expr, replaceCb) {
					var local;
					if (expr instanceof LocalExpression) {
						local = LocalExpression$getLocal$LLocalExpression$(expr);
						if (local == CatchStatement$getLocal$LCatchStatement$(catchStmt)) {
							expr = new AsNoConvertExpression(new Token$2("as", false), new LocalExpression(LocalVariable$getName$LLocalVariable$(newCaught), newCaught), LocalVariable$getType$LLocalVariable$(local));
							replaceCb(expr);
							return true;
						}
					}
					return expr.forEachExpression$F$LExpression$F$LExpression$V$B$(onExpr);
				})) && Statement$forEachStatement$LStatement$F$LStatement$B$(stmt, onStmt);
			}));
		}));
		newBody = catchStatements.reduceRight((function (elseStmts, catchStmt) {
			var caughtVar;
			caughtVar = catchStmt._local;
			return (caughtVar._type instanceof ObjectType ? [ new IfStatement(new Token$2("if", false), new InstanceofExpression(new Token$2("instanceof", false), new LocalExpression(newCaught._name, newCaught), caughtVar._type), catchStmt._statements, elseStmts) ] : catchStmt._statements);
		}), [ new ThrowStatement(new Token$2("throw", false), new LocalExpression(newCaught._name, newCaught)) ]);
		newCatch = new CatchStatement(new Token$2("catch", false), newCaught, newBody);
		(_catchStatements$0 = tryStatement._catchStatements).length = 0;
		_catchStatements$0.push(newCatch);
	}
	return StatementTransformCommand.prototype.touchStatement$LStatement$F$LStatement$V$.call(this, statement, replaceCb);
};


function ForInStatementTransformCommand(compiler) {
	this.errors = null;
	this._compiler = compiler;
	this._identifier = "transform-for-in";
	this._funcDef = null;
};

$__jsx_extend([ForInStatementTransformCommand], StatementTransformCommand);
ForInStatementTransformCommand.prototype.touchStatement$LStatement$F$LStatement$V$ = function (statement, replaceCb) {
	var funcDef;
	funcDef = this._funcDef;
	if (statement instanceof ForInStatement) {
		StatementTransformCommand.prototype.touchStatement$LStatement$F$LStatement$V$.call(this, statement, replaceCb);
		replaceCb(ForInStatementTransformCommand$_transformForIn$LForInStatementTransformCommand$LMemberFunctionDefinition$LForInStatement$(this, funcDef, statement));
		return true;
	}
	return StatementTransformCommand.prototype.touchStatement$LStatement$F$LStatement$V$.call(this, statement, replaceCb);
};


ForInStatementTransformCommand.prototype._transformForIn$LMemberFunctionDefinition$LForInStatement$ = function (funcDef, forInStmt) {
	var listExpr;
	var vLocal;
	var listLocal;
	var propsLocal;
	var propLocal;
	var indexLocal;
	var statements;
	var this$0;
	var type$0;
	var id$0;
	var type$1;
	var id$1;
	var type$2;
	var id$2;
	var type$3;
	var id$3;
	listExpr = forInStmt._listExpr;
	this$0 = forInStmt._lhsExpr;
	vLocal = this$0._local;
	type$0 = listExpr.getType$();
	id$0 = _Util$1._numUniqVar++;
	listLocal = new LocalVariable(new Token$2("$a" + (id$0 + ""), true), type$0, false);
	type$1 = new ObjectType(_Util$1$instantiateBuiltinTemplate$LCompiler$SALType$(this._compiler, "Array", [ Type.stringType ]));
	id$1 = _Util$1._numUniqVar++;
	propsLocal = new LocalVariable(new Token$2("$a" + (id$1 + ""), true), type$1, false);
	type$2 = Type.stringType;
	id$2 = _Util$1._numUniqVar++;
	propLocal = new LocalVariable(new Token$2("$a" + (id$2 + ""), true), type$2, false);
	type$3 = Type.integerType;
	id$3 = _Util$1._numUniqVar++;
	indexLocal = new LocalVariable(new Token$2("$a" + (id$3 + ""), true), type$3, false);
	funcDef._locals.push(listLocal, propsLocal, propLocal, indexLocal);
	statements = [ new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(listLocal._name, listLocal), listExpr)), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(propsLocal._name, propsLocal), new ArrayLiteralExpression(new Token$2("[", false), [  ], propsLocal._type))), new ForInStatement(new Token$2("for", false), null, new LocalExpression(propLocal._name, propLocal), new LocalExpression(listLocal._name, listLocal), [ new ExpressionStatement(new CallExpression(new Token$2("(", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(propsLocal._name, propsLocal), new Token$2("push", true), [  ], ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(propsLocal._type.getClassDef$(), [  ], null, "push", false, [  ], 0)), [ new LocalExpression(propLocal._name, propLocal) ])) ]), new ForStatement(new Token$2("for", false), null, new AssignmentExpression(new Token$2("=", false), new LocalExpression(indexLocal._name, indexLocal), new IntegerLiteralExpression(new Token$2("0", false))), new BinaryNumberExpression(new Token$2("<", false), new LocalExpression(indexLocal._name, indexLocal), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(propsLocal._name, propsLocal), new Token$2("length", true), [  ], Type.integerType)), new PreIncrementExpression(new Token$2("++", false), new LocalExpression(indexLocal._name, indexLocal)), [ new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(vLocal._name, vLocal), new ArrayExpression$0(new Token$2("[", false), new LocalExpression(propsLocal._name, propsLocal), new LocalExpression(indexLocal._name, indexLocal), vLocal._type))), new IfStatement(new Token$2("if", false), new LogicalNotExpression(new Token$2("!", false), new InExpression(new Token$2("in", false), new LocalExpression(vLocal._name, vLocal), new LocalExpression(listLocal._name, listLocal))), [ new ContinueStatement(new Token$2("continue", false), null) ], [  ]) ].concat(forInStmt._statements)) ];
	return new DoWhileStatement(new Token$2("do", false), null, new BooleanLiteralExpression(new Token$2("false", false)), statements);
};


function ForInStatementTransformCommand$_transformForIn$LForInStatementTransformCommand$LMemberFunctionDefinition$LForInStatement$($this, funcDef, forInStmt) {
	var listExpr;
	var vLocal;
	var listLocal;
	var propsLocal;
	var propLocal;
	var indexLocal;
	var statements;
	var this$0;
	var type$0;
	var id$0;
	var type$1;
	var id$1;
	var type$2;
	var id$2;
	var type$3;
	var id$3;
	listExpr = forInStmt._listExpr;
	this$0 = forInStmt._lhsExpr;
	vLocal = this$0._local;
	type$0 = listExpr.getType$();
	id$0 = _Util$1._numUniqVar++;
	listLocal = new LocalVariable(new Token$2("$a" + (id$0 + ""), true), type$0, false);
	type$1 = new ObjectType(_Util$1$instantiateBuiltinTemplate$LCompiler$SALType$($this._compiler, "Array", [ Type.stringType ]));
	id$1 = _Util$1._numUniqVar++;
	propsLocal = new LocalVariable(new Token$2("$a" + (id$1 + ""), true), type$1, false);
	type$2 = Type.stringType;
	id$2 = _Util$1._numUniqVar++;
	propLocal = new LocalVariable(new Token$2("$a" + (id$2 + ""), true), type$2, false);
	type$3 = Type.integerType;
	id$3 = _Util$1._numUniqVar++;
	indexLocal = new LocalVariable(new Token$2("$a" + (id$3 + ""), true), type$3, false);
	funcDef._locals.push(listLocal, propsLocal, propLocal, indexLocal);
	statements = [ new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(listLocal._name, listLocal), listExpr)), new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(propsLocal._name, propsLocal), new ArrayLiteralExpression(new Token$2("[", false), [  ], propsLocal._type))), new ForInStatement(new Token$2("for", false), null, new LocalExpression(propLocal._name, propLocal), new LocalExpression(listLocal._name, listLocal), [ new ExpressionStatement(new CallExpression(new Token$2("(", false), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(propsLocal._name, propsLocal), new Token$2("push", true), [  ], ClassDefinition$getMemberTypeByName$LClassDefinition$ALCompileError$LToken$SBALType$N(propsLocal._type.getClassDef$(), [  ], null, "push", false, [  ], 0)), [ new LocalExpression(propLocal._name, propLocal) ])) ]), new ForStatement(new Token$2("for", false), null, new AssignmentExpression(new Token$2("=", false), new LocalExpression(indexLocal._name, indexLocal), new IntegerLiteralExpression(new Token$2("0", false))), new BinaryNumberExpression(new Token$2("<", false), new LocalExpression(indexLocal._name, indexLocal), new PropertyExpression$0(new Token$2(".", false), new LocalExpression(propsLocal._name, propsLocal), new Token$2("length", true), [  ], Type.integerType)), new PreIncrementExpression(new Token$2("++", false), new LocalExpression(indexLocal._name, indexLocal)), [ new ExpressionStatement(new AssignmentExpression(new Token$2("=", false), new LocalExpression(vLocal._name, vLocal), new ArrayExpression$0(new Token$2("[", false), new LocalExpression(propsLocal._name, propsLocal), new LocalExpression(indexLocal._name, indexLocal), vLocal._type))), new IfStatement(new Token$2("if", false), new LogicalNotExpression(new Token$2("!", false), new InExpression(new Token$2("in", false), new LocalExpression(vLocal._name, vLocal), new LocalExpression(listLocal._name, listLocal))), [ new ContinueStatement(new Token$2("continue", false), null) ], [  ]) ].concat(forInStmt._statements)) ];
	return new DoWhileStatement(new Token$2("do", false), null, new BooleanLiteralExpression(new Token$2("false", false)), statements);
};

ForInStatementTransformCommand._transformForIn$LForInStatementTransformCommand$LMemberFunctionDefinition$LForInStatement$ = ForInStatementTransformCommand$_transformForIn$LForInStatementTransformCommand$LMemberFunctionDefinition$LForInStatement$;

function Util$x2EArgumentTypeRequest(argTypes, typeArgs) {
	this.argTypes = argTypes;
	this.typeArgs = typeArgs;
};

$__jsx_extend([Util$x2EArgumentTypeRequest], Object);
function Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I($this, i) {
	return $this.argTypes[i];
};

Util$x2EArgumentTypeRequest.at$LUtil$x2EArgumentTypeRequest$I = Util$x2EArgumentTypeRequest$at$LUtil$x2EArgumentTypeRequest$I;

function _Util$x2EOutputNameStash(outputName) {
	this.outputName = outputName;
};

$__jsx_extend([_Util$x2EOutputNameStash], Stash);
_Util$x2EOutputNameStash.prototype.clone$ = function () {
	throw new Error("not supported");
};


function _Namer$x2E_TryStash(catchName) {
	this.catchName = catchName;
};

$__jsx_extend([_Namer$x2E_TryStash], Stash);
_Namer$x2E_TryStash.prototype.clone$ = function () {
	throw new Error("operation not supported");
};


function _Namer$x2E_CatchTargetStash(tryStmt) {
	this.tryStmt = tryStmt;
};

$__jsx_extend([_Namer$x2E_CatchTargetStash], Stash);
_Namer$x2E_CatchTargetStash.prototype.clone$ = function () {
	throw new Error("operation not supported");
};


function _Minifier$x2E_ClassStash() {
	this.staticVariableUseCount = {};
	this.staticVariableConversionTable = {};
};

$__jsx_extend([_Minifier$x2E_ClassStash], Stash);
_Minifier$x2E_ClassStash.prototype.clone$ = function () {
	throw new Error("operation not supported");
};


function _Minifier$x2E_ScopeStash() {
	this.usedGlobals = {};
	this.usedOuterLocals = [];
};

$__jsx_extend([_Minifier$x2E_ScopeStash], Stash);
_Minifier$x2E_ScopeStash.prototype.clone$ = function () {
	throw new Error("operation not supported");
};


function _Minifier$x2E_LocalStash() {
	this.useCount = 0;
	this.minifiedName = null;
};

$__jsx_extend([_Minifier$x2E_LocalStash], Stash);
_Minifier$x2E_LocalStash.prototype.clone$ = function () {
	throw new Error("operation not supported");
};


function _Minifier$x2E_MinifyingNamer() {
	this._emitter = null;
	this._catchLevel = -1;
	this._minifier = null;
};

$__jsx_extend([_Minifier$x2E_MinifyingNamer], _Namer);
_Minifier$x2E_MinifyingNamer.prototype.setup$L_Minifier$ = function (minifier) {
	this._minifier = minifier;
	_Namer$setup$L_Namer$LJavaScriptEmitter$(this, minifier._emitter);
	return this;
};


_Minifier$x2E_MinifyingNamer.prototype._getMangler$ = function () {
	var this$0;
	this$0 = this._minifier._emitter;
	return this$0._mangler;
};


function _Minifier$x2E_MinifyingNamer$_getMangler$L_Minifier$x2E_MinifyingNamer$($this) {
	var this$0;
	this$0 = $this._minifier._emitter;
	return this$0._mangler;
};

_Minifier$x2E_MinifyingNamer._getMangler$L_Minifier$x2E_MinifyingNamer$ = _Minifier$x2E_MinifyingNamer$_getMangler$L_Minifier$x2E_MinifyingNamer$;

_Minifier$x2E_MinifyingNamer.prototype._isCounting$ = function () {
	var this$0;
	this$0 = this._minifier;
	return this$0._propertyConversionTable == null;
};


function _Minifier$x2E_MinifyingNamer$_isCounting$L_Minifier$x2E_MinifyingNamer$($this) {
	var this$0;
	this$0 = $this._minifier;
	return this$0._propertyConversionTable == null;
};

_Minifier$x2E_MinifyingNamer._isCounting$L_Minifier$x2E_MinifyingNamer$ = _Minifier$x2E_MinifyingNamer$_isCounting$L_Minifier$x2E_MinifyingNamer$;

_Minifier$x2E_MinifyingNamer.prototype.getNameOfProperty$LClassDefinition$S = function (classDef, name) {
	var this$0$0;
	var useCount$0;
	if (Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, null, false) || Util$memberIsExported$LClassDefinition$SALType$B(classDef, name, null, false)) {
		return name;
	}
	this$0$0 = this._minifier;
	if (this$0$0._propertyConversionTable == null) {
		useCount$0 = this._minifier._propertyUseCount;
		if ($__jsx_ObjectHasOwnProperty.call(useCount$0, name)) {
			++useCount$0[name];
		} else {
			useCount$0[name] = 1;
		}
	} else {
		name = this._minifier._propertyConversionTable[name];
	}
	return name;
};


_Minifier$x2E_MinifyingNamer.prototype.getNameOfMethod$LClassDefinition$SALType$ = function (classDef, name, argTypes) {
	var mangledName;
	var this$0;
	var this$0$0;
	var useCount$0;
	var this$0$1;
	if (Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, argTypes, false)) {
		return name;
	}
	this$0$1 = this._minifier._emitter;
	this$0 = this$0$1._mangler;
	mangledName = name + _Mangler$mangleFunctionArguments$L_Mangler$ALType$(this$0, argTypes);
	this$0$0 = this._minifier;
	if (this$0$0._propertyConversionTable == null) {
		useCount$0 = this._minifier._propertyUseCount;
		if ($__jsx_ObjectHasOwnProperty.call(useCount$0, mangledName)) {
			++useCount$0[mangledName];
		} else {
			useCount$0[mangledName] = 1;
		}
	} else {
		mangledName = this._minifier._propertyConversionTable[mangledName];
	}
	return mangledName;
};


_Minifier$x2E_MinifyingNamer.prototype.getNameOfStaticVariable$LClassDefinition$S = function (classDef, name) {
	var this$0$0;
	var useCount$0;
	if (Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, null, true) || Util$memberIsExported$LClassDefinition$SALType$B(classDef, name, null, true)) {
		return name;
	}
	this$0$0 = this._minifier;
	if (this$0$0._propertyConversionTable == null) {
		useCount$0 = _Minifier$_getClassStash$LClassDefinition$(classDef).staticVariableUseCount;
		if ($__jsx_ObjectHasOwnProperty.call(useCount$0, name)) {
			++useCount$0[name];
		} else {
			useCount$0[name] = 1;
		}
	} else {
		name = _Minifier$_getClassStash$LClassDefinition$(classDef).staticVariableConversionTable[name];
	}
	return name;
};


_Minifier$x2E_MinifyingNamer.prototype.getNameOfStaticFunction$LClassDefinition$SALType$ = function (classDef, name, argTypes) {
	var mangledName;
	var stash$0;
	var this$0$0;
	var this$0;
	var this$0$1;
	var useCount$0;
	if (Util$memberRootIsNative$LClassDefinition$SALType$B(classDef, name, argTypes, true)) {
		return this.getNameOfClass$LClassDefinition$(classDef) + "." + name;
	}
	mangledName = (stash$0 = classDef.getStash$S("emitter.outputname"), stash$0.outputName) + "$" + (this$0 = (this$0$0 = this._minifier._emitter, this$0$0._mangler), name + _Mangler$mangleFunctionArguments$L_Mangler$ALType$(this$0, argTypes));
	this$0$1 = this._minifier;
	if (this$0$1._propertyConversionTable == null) {
		useCount$0 = this._minifier._globalUseCount;
		if ($__jsx_ObjectHasOwnProperty.call(useCount$0, mangledName)) {
			++useCount$0[mangledName];
		} else {
			useCount$0[mangledName] = 1;
		}
	} else {
		mangledName = this._minifier._globalConversionTable[mangledName];
	}
	return mangledName;
};


_Minifier$x2E_MinifyingNamer.prototype.getNameOfConstructor$LClassDefinition$ALType$ = function (classDef, argTypes) {
	var name;
	var mangledName;
	var this$0$0;
	var useCount$0;
	var this$0$1;
	var useCount$1;
	if ((classDef.flags$() & 16) !== 0) {
		name = _Util$getNameOfNativeConstructor$LClassDefinition$(classDef);
		this$0$0 = this._minifier;
		if (this$0$0._propertyConversionTable == null) {
			useCount$0 = this._minifier._globalUseCount;
			if ($__jsx_ObjectHasOwnProperty.call(useCount$0, name)) {
				++useCount$0[name];
			} else {
				useCount$0[name] = 1;
			}
		}
		return name;
	}
	mangledName = _Util$getOutputConstructorName$LClassDefinition$ALType$(classDef, argTypes);
	this$0$1 = this._minifier;
	if (this$0$1._propertyConversionTable == null) {
		useCount$1 = this._minifier._globalUseCount;
		if ($__jsx_ObjectHasOwnProperty.call(useCount$1, mangledName)) {
			++useCount$1[mangledName];
		} else {
			useCount$1[mangledName] = 1;
		}
	} else {
		mangledName = this._minifier._globalConversionTable[mangledName];
	}
	return mangledName;
};


_Minifier$x2E_MinifyingNamer.prototype.getNameOfClass$LClassDefinition$ = function (classDef) {
	var name;
	var stash$0;
	var this$0$0;
	var useCount$0;
	var this$0$1;
	stash$0 = classDef.getStash$S("emitter.outputname");
	name = stash$0.outputName;
	this$0$0 = this._minifier;
	if (this$0$0._propertyConversionTable == null) {
		useCount$0 = this._minifier._globalUseCount;
		if ($__jsx_ObjectHasOwnProperty.call(useCount$0, name)) {
			++useCount$0[name];
		} else {
			useCount$0[name] = 1;
		}
	}
	return ((classDef.flags$() & 272) === 0 && ! (this$0$1 = this._minifier, this$0$1._propertyConversionTable == null) ? this._minifier._globalConversionTable[name] : name);
};


_Minifier$x2E_MinifyingNamer.prototype.enterScope$LLocalVariable$F$V$ = function (local, cb) {
	var $this = this;
	var this$0$0;
	if (local == null) {
		cb();
	} else {
		this$0$0 = this._minifier;
		if (this$0$0._propertyConversionTable == null) {
			_Minifier$_recordUsedIdentifiers$L_Minifier$LStashable$F$V$(this._minifier, local, (function () {
				$this._minifier._outerLocals.push(local);
				cb();
				$this._minifier._outerLocals.pop();
			}));
		} else {
			_Minifier$_buildConversionTable$L_Minifier$ALLocalVariable$L_Minifier$x2E_ScopeStash$(this._minifier, [ local ], _Minifier$_getScopeStash$LStashable$(local));
			cb();
		}
	}
};


_Minifier$x2E_MinifyingNamer.prototype.enterFunction$LMemberFunctionDefinition$F$V$ = function (funcDef, cb) {
	var $this = this;
	var this$0$0;
	this$0$0 = this._minifier;
	if (this$0$0._propertyConversionTable == null) {
		_Minifier$_recordUsedIdentifiers$L_Minifier$LStashable$F$V$(this._minifier, funcDef, (function () {
			var _minifier$0;
			(_minifier$0 = $this._minifier)._outerLocals = _minifier$0._outerLocals.concat(_Minifier$_getArgsAndLocals$LMemberFunctionDefinition$(funcDef));
			cb();
			$this._minifier._outerLocals.length -= funcDef._args.length + funcDef._locals.length;
		}));
	} else {
		_Minifier$_buildConversionTable$L_Minifier$ALLocalVariable$L_Minifier$x2E_ScopeStash$(this._minifier, _Minifier$_getArgsAndLocals$LMemberFunctionDefinition$(funcDef), _Minifier$_getScopeStash$LStashable$(funcDef));
		cb();
	}
};


_Minifier$x2E_MinifyingNamer.prototype.getNameOfLocalVariable$LLocalVariable$ = function (local) {
	var caught$0;
	var tryStmt$0$0;
	var this$0$0;
	var this$0;
	if (local instanceof CaughtVariable) {
		caught$0 = local;
		tryStmt$0$0 = caught$0.getStash$S("namer").tryStmt;
		return tryStmt$0$0.getStash$S("namer").catchName;
	}
	this$0$0 = this._minifier;
	if (this$0$0._propertyConversionTable == null) {
		++_Minifier$_getLocalStash$LLocalVariable$(local).useCount;
		this$0 = local._name;
		return this$0._value;
	} else {
		return _Minifier$_getLocalStash$LLocalVariable$(local).minifiedName;
	}
};


function MemberFunctionDefinition$x2E_CloneStash() {
	this.newLocal = null;
	this.newFuncDef = null;
};

function MemberFunctionDefinition$x2E_CloneStash$0(that) {
	this.newLocal = that.newLocal;
	this.newFuncDef = that.newFuncDef;
};

$__jsx_extend([MemberFunctionDefinition$x2E_CloneStash, MemberFunctionDefinition$x2E_CloneStash$0], Stash);
MemberFunctionDefinition$x2E_CloneStash.prototype.clone$ = function () {
	return new MemberFunctionDefinition$x2E_CloneStash$0(this);
};


function _LinkTimeOptimizationCommand$x2EStash() {
	this.extendedBy = [];
};

$__jsx_extend([_LinkTimeOptimizationCommand$x2EStash], Stash);
_LinkTimeOptimizationCommand$x2EStash.prototype.clone$ = function () {
	throw new Error("not supported");
};


function _StripOptimizeCommand$x2E_Stash() {
	this.touched = false;
};

$__jsx_extend([_StripOptimizeCommand$x2E_Stash], Stash);
_StripOptimizeCommand$x2E_Stash.prototype.clone$ = function () {
	throw new Error("not supported");
};


function _DetermineCalleeCommand$x2EStash() {
	this.callingFuncDef = null;
};

function _DetermineCalleeCommand$x2EStash$0(that) {
	this.callingFuncDef = that.callingFuncDef;
};

$__jsx_extend([_DetermineCalleeCommand$x2EStash, _DetermineCalleeCommand$x2EStash$0], Stash);
_DetermineCalleeCommand$x2EStash.prototype.clone$ = function () {
	return new _DetermineCalleeCommand$x2EStash$0(this);
};


function _StaticizeOptimizeCommand$x2EStash() {
	this.altName = null;
};

function _StaticizeOptimizeCommand$x2EStash$0(that) {
	this.altName = that.altName;
};

$__jsx_extend([_StaticizeOptimizeCommand$x2EStash, _StaticizeOptimizeCommand$x2EStash$0], Stash);
_StaticizeOptimizeCommand$x2EStash.prototype.clone$ = function () {
	return new _StaticizeOptimizeCommand$x2EStash$0(this);
};


function _UnclassifyOptimizationCommand$x2EStash() {
	this.inliner = null;
};

function _UnclassifyOptimizationCommand$x2EStash$0(that) {
	this.inliner = that.inliner;
};

$__jsx_extend([_UnclassifyOptimizationCommand$x2EStash, _UnclassifyOptimizationCommand$x2EStash$0], Stash);
_UnclassifyOptimizationCommand$x2EStash.prototype.clone$ = function () {
	return new _UnclassifyOptimizationCommand$x2EStash$0(this);
};


function _FoldConstantCommand$x2EStash() {
	this.isOptimized = false;
};

function _FoldConstantCommand$x2EStash$0(that) {
	this.isOptimized = that.isOptimized;
};

$__jsx_extend([_FoldConstantCommand$x2EStash, _FoldConstantCommand$x2EStash$0], Stash);
_FoldConstantCommand$x2EStash.prototype.clone$ = function () {
	return new _FoldConstantCommand$x2EStash$0(this);
};


function _InlineOptimizeCommand$x2EStash() {
	this.isOptimized = false;
	this.isInlineable = null;
};

function _InlineOptimizeCommand$x2EStash$0(that) {
	this.isOptimized = that.isOptimized;
	this.isInlineable = that.isInlineable;
};

$__jsx_extend([_InlineOptimizeCommand$x2EStash, _InlineOptimizeCommand$x2EStash$0], Stash);
_InlineOptimizeCommand$x2EStash.prototype.clone$ = function () {
	return new _InlineOptimizeCommand$x2EStash$0(this);
};


function _UnboxOptimizeCommand$x2EStash() {
	this.canUnbox = null;
};

$__jsx_extend([_UnboxOptimizeCommand$x2EStash], Stash);
_UnboxOptimizeCommand$x2EStash.prototype.clone$ = function () {
	var tmp;
	tmp = new _UnboxOptimizeCommand$x2EStash();
	tmp.canUnbox = this.canUnbox;
	return tmp;
};


function _NoDebugCommand$x2EStash() {
	this.debugValue = true;
};

$__jsx_extend([_NoDebugCommand$x2EStash], Stash);
_NoDebugCommand$x2EStash.prototype.clone$ = function () {
	var tmp;
	tmp = new _NoDebugCommand$x2EStash();
	tmp.debugValue = this.debugValue;
	return tmp;
};


function _DeleteStatementTransformer$x2E_Stash(transformer, statement) {
	_BinaryExpressionTransformer.call(this, transformer, statement._expr);
	this._statement = statement;
};

$__jsx_extend([_DeleteStatementTransformer$x2E_Stash], _BinaryExpressionTransformer);
_DeleteStatementTransformer$x2E_Stash.prototype._injectBody$ALExpression$LExpression$LMemberFunctionDefinition$LMemberFunctionDefinition$LExpression$ = function (args, topExpr, topFuncDef, botFuncDef, continuation) {
	var this$0;
	var arg1$0;
	var arg2$0;
	var this$0$0;
	botFuncDef._statements = [ new DeleteStatement((this$0 = this._statement, this$0._token), (arg1$0 = args[0], arg2$0 = args[1], new ArrayExpression((this$0$0 = this._expr, this$0$0._token), arg1$0, arg2$0))) ];
	Util$rebaseClosures$LMemberFunctionDefinition$LMemberFunctionDefinition$(topFuncDef, botFuncDef);
};


_DeleteStatementTransformer$x2E_Stash.prototype._clone$LExpression$LExpression$ = function (arg1, arg2) {
	var this$0;
	return new ArrayExpression((this$0 = this._expr, this$0._token), arg1, arg2);
};


function _SwitchStatementTransformer$x2ECaseStash() {
	this.index = _SwitchStatementTransformer$x2ECaseStash.count++;
};

$__jsx_extend([_SwitchStatementTransformer$x2ECaseStash], Stash);
_SwitchStatementTransformer$x2ECaseStash.prototype.clone$ = function () {
	throw new Error("not supported");
};


$__jsx_lazy_init(node, "__dirname", function () {
	return eval("__dirname") + "";
});
$__jsx_lazy_init(node, "__filename", function () {
	return eval("__filename") + "";
});
$__jsx_lazy_init(node, "fs", function () {
	return node$require$S('fs');
});
$__jsx_lazy_init(node, "path", function () {
	return node$require$S('path');
});
$__jsx_lazy_init(node, "child_process", function () {
	return node$require$S('child_process');
});
$__jsx_lazy_init(node, "url", function () {
	return node$require$S('url');
});
$__jsx_lazy_init(node, "http", function () {
	return node$require$S('http');
});
$__jsx_lazy_init(node, "https", function () {
	return node$require$S('https');
});
$__jsx_lazy_init(node, "net", function () {
	return node$require$S('net');
});
$__jsx_lazy_init(node, "util", function () {
	return node$require$S('util');
});
$__jsx_lazy_init(Timer, "_requestAnimationFrame", function () {
	return Timer$_getRequestAnimationFrameImpl$B(true);
});
$__jsx_lazy_init(Timer, "_cancelAnimationFrame", function () {
	return Timer$_getCancelAnimationFrameImpl$B(true);
});
$__jsx_lazy_init(Util, "_builtInClass", function () {
	return Util$asSet$AS([ "Array", "Boolean", "Date", "Function", "Map", "Math", "Number", "Object", "RegExp", "String", "JSON", "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "JSX", "Transferable", "ArrayBuffer", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "DataView" ]);
});
$__jsx_lazy_init(Util, "_builtInContainer", function () {
	return Util$asSet$AS([ "Array", "Map", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array" ]);
});
Util._stringLiteralEncodingMap = ({ "\0": "\\0", "\r": "\\r", "\n": "\\n", "\t": "\\t", "\"": "\\\"", "\'": "\\\'", "\\": "\\\\" });
_Util.OUTPUTNAME_IDENTIFIER = "emitter.outputname";
$__jsx_lazy_init(_Util, "_ecma262reserved", function () {
	return Util$asSet$AS([ "break", "do", "instanceof", "typeof", "case", "else", "new", "var", "catch", "finally", "return", "void", "continue", "for", "switch", "while", "debugger", "function", "this", "with", "default", "if", "throw", "delete", "in", "try", "class", "enum", "extends", "super", "const", "export", "import", "implements", "let", "private", "public", "yield", "interface", "package", "protected", "static", "null", "true", "false" ]);
});
_Namer.IDENTIFIER = "namer";
_MinifiedNameGenerator._MINIFY_CHARS = "$_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
$__jsx_lazy_init(_MinifiedNameGenerator, "GLOBALS", function () {
	return "NaN Infinity undefined evalparseInt parseFloat isNaN isFinite decodeURI decodeURIComponent encodeURI encodeURIComponent Object Function Array String Boolean Number Date RegExp Error EvalError RangeError ReferenceError SyntaxError TypeError URIError Math".split(/\s+/);
});
_Minifier.CLASSSTASH_IDENTIFIER = "minifier.class";
_Minifier.SCOPESTASH_IDENTIFIER = "minifier.scope";
_Minifier.LOCALSTASH_IDENTIFIER = "minifier.local";
_UnaryExpressionEmitter._operatorPrecedence = {};
_PreIncrementExpressionEmitter._operatorPrecedence = {};
_PostIncrementExpressionEmitter._operatorPrecedence = {};
_PostIncrementExpressionEmitter.TEMP_VAR_NAME = "$__jsx_postinc_t";
_InstanceofExpressionEmitter._operatorPrecedence = 0;
_PropertyExpressionEmitter._operatorPrecedence = 0;
_FunctionExpressionEmitter._operatorPrecedence = 0;
_AdditiveExpressionEmitter._operatorPrecedence = 0;
_AssignmentExpressionEmitter._operatorPrecedence = {};
_FusedAssignmentExpressionEmitter._fusedIntHelpers = ({ "+": "$__jsx_ipadd", "-": "$__jsx_ipsub", "*": "$__jsx_ipmul", "/": "$__jsx_ipdiv", "%": "$__jsx_ipmod" });
_FusedAssignmentExpressionEmitter._operatorPrecedence = {};
_EqualityExpressionEmitter._operatorPrecedence = {};
_InExpressionEmitter._operatorPrecedence = 0;
_LogicalExpressionEmitter._operatorPrecedence = {};
_ShiftExpressionEmitter._operatorPrecedence = {};
_BinaryNumberExpressionEmitter._OPS_RETURNING_INT = ({ '&': true, '|': true, '^': true });
_BinaryNumberExpressionEmitter._operatorPrecedence = {};
_ArrayExpressionEmitter._operatorPrecedence = 0;
_ConditionalExpressionEmitter._operatorPrecedence = 0;
_CallExpressionEmitter._operatorPrecedence = 0;
_SuperExpressionEmitter._operatorPrecedence = 0;
_NewExpressionEmitter._operatorPrecedence = 0;
_CommaExpressionEmitter._operatorPrecedence = 0;
NodePlatform.COLOR_BLACK = 30;
NodePlatform.COLOR_RED = 31;
NodePlatform.COLOR_GREEN = 32;
NodePlatform.COLOR_YELLOW = 33;
NodePlatform.COLOR_BLUE = 34;
$__jsx_lazy_init(NodePlatform, "_isColorSupported", function () {
	return (function () {
		var term;
		if (process.stdout.isTTY && process.stderr.isTTY) {
			term = (process.env.TERM || "").toLowerCase();
			return /color/.test(term) || /xterm/.test(term);
		}
		return false;
	})();
});
Meta.VERSION_STRING = "0.9.89";
Meta.VERSION_NUMBER = 0.009089;
Meta.LAST_COMMIT_HASH = "8e8c6105f36f3dfe440ea026a3c93a3444977102";
Meta.LAST_COMMIT_DATE = "2014-05-20 06:01:03 +0900";
Meta.IDENTIFIER = "0.9.89 (2014-05-20 06:01:03 +0900; 8e8c6105f36f3dfe440ea026a3c93a3444977102)";
JavaScriptEmitter.BOOTSTRAP_NONE = 0;
JavaScriptEmitter.BOOTSTRAP_EXECUTABLE = 1;
JavaScriptEmitter.BOOTSTRAP_TEST = 2;
JavaScriptEmitter._initialized = false;
LocalVariableStatuses.UNTYPED_RECURSIVE_FUNCTION = -1;
LocalVariableStatuses.UNSET = 0;
LocalVariableStatuses.ISSET = 1;
LocalVariableStatuses.MAYBESET = 2;
ClassDefinition.IS_CONST = 1;
ClassDefinition.IS_ABSTRACT = 2;
ClassDefinition.IS_FINAL = 4;
ClassDefinition.IS_STATIC = 8;
ClassDefinition.IS_NATIVE = 16;
ClassDefinition.IS_OVERRIDE = 32;
ClassDefinition.IS_INTERFACE = 64;
ClassDefinition.IS_MIXIN = 128;
ClassDefinition.IS_FAKE = 256;
ClassDefinition.IS_READONLY = 512;
ClassDefinition.IS_INLINE = 1024;
ClassDefinition.IS_PURE = 2048;
ClassDefinition.IS_DELETE = 4096;
ClassDefinition.IS_GENERATOR = 8192;
ClassDefinition.IS_EXPORT = 16384;
ClassDefinition.IS_GENERATED = 32768;
ClassDefinition.GET_MEMBER_MODE_ALL = 0;
ClassDefinition.GET_MEMBER_MODE_CLASS_ONLY = 1;
ClassDefinition.GET_MEMBER_MODE_SUPER = 2;
ClassDefinition.GET_MEMBER_MODE_FUNCTION_WITH_BODY = 3;
MemberVariableDefinition.NOT_ANALYZED = 0;
MemberVariableDefinition.IS_ANALYZING = 1;
MemberVariableDefinition.ANALYZE_SUCEEDED = 2;
MemberVariableDefinition.ANALYZE_FAILED = 3;
$__jsx_lazy_init(Type, "voidType", function () {
	return new VoidType();
});
$__jsx_lazy_init(Type, "nullType", function () {
	return new NullType();
});
$__jsx_lazy_init(Type, "booleanType", function () {
	return new BooleanType();
});
$__jsx_lazy_init(Type, "integerType", function () {
	return new IntegerType();
});
$__jsx_lazy_init(Type, "numberType", function () {
	return new NumberType();
});
$__jsx_lazy_init(Type, "stringType", function () {
	return new StringType();
});
$__jsx_lazy_init(Type, "variantType", function () {
	return new VariantType();
});
BooleanType._classDef = null;
IntegerType._classDef = null;
NumberType._classDef = null;
StringType._classDef = null;
FunctionType._classDef = null;
_Lexer.ident = " [a-zA-Z_] [a-zA-Z0-9_]* ";
_Lexer.doubleQuoted = ' "  [^"\\\\]* (?: \\\\. [^"\\\\]* )* " ';
_Lexer.singleQuoted = " '  [^'\\\\]* (?: \\\\. [^'\\\\]* )* ' ";
$__jsx_lazy_init(_Lexer, "stringLiteral", function () {
	return _Lexer$makeAlt$AS([ " '  [^'\\\\]* (?: \\\\. [^'\\\\]* )* ' ", ' "  [^"\\\\]* (?: \\\\. [^"\\\\]* )* " ' ]);
});
$__jsx_lazy_init(_Lexer, "regexpLiteral", function () {
	return ' "  [^"\\\\]* (?: \\\\. [^"\\\\]* )* " '.replace(/"/g, "/") + "[mgi]*";
});
_Lexer.heredocStartDoubleQuoted = '"""';
_Lexer.heredocStartSingleQuoted = "'''";
$__jsx_lazy_init(_Lexer, "heredocStart", function () {
	return _Lexer$makeAlt$AS([ '"""', "'''" ]);
});
_Lexer.heredocEndDoubleQuoted = ' (?:^|.*?[^\\\\]) (?:\\\\\\\\)* """ ';
_Lexer.heredocEndSingleQuoted = " (?:^|.*?[^\\\\]) (?:\\\\\\\\)* ''' ";
_Lexer.decimalIntegerLiteral = "(?: 0 | [1-9][0-9]* )";
_Lexer.exponentPart = "(?: [eE] [+-]? [0-9]+ )";
$__jsx_lazy_init(_Lexer, "numberLiteral", function () {
	return _Lexer$makeAlt$AS([ "(?: (?: 0 | [1-9][0-9]* ) \\. [0-9]* (?: [eE] [+-]? [0-9]+ )? )", "(?: \\. [0-9]+ (?: [eE] [+-]? [0-9]+ )? )", "(?: (?: 0 | [1-9][0-9]* )(?: [eE] [+-]? [0-9]+ ) )", "NaN", "Infinity" ]) + "\\b";
});
$__jsx_lazy_init(_Lexer, "integerLiteral", function () {
	return _Lexer$makeAlt$AS([ "(?: 0 [xX] [0-9a-fA-F]+ )", "(?: 0 | [1-9][0-9]* )" ]) + "(?![\\.0-9eE])\\b";
});
$__jsx_lazy_init(_Lexer, "rxIdent", function () {
	return _Lexer$rx$S("^ [a-zA-Z_] [a-zA-Z0-9_]* ");
});
$__jsx_lazy_init(_Lexer, "rxStringLiteral", function () {
	return _Lexer$rx$S("^" + _Lexer.stringLiteral);
});
$__jsx_lazy_init(_Lexer, "rxNumberLiteral", function () {
	return _Lexer$rx$S("^" + _Lexer.numberLiteral);
});
$__jsx_lazy_init(_Lexer, "rxIntegerLiteral", function () {
	return _Lexer$rx$S("^" + _Lexer.integerLiteral);
});
$__jsx_lazy_init(_Lexer, "rxRegExpLiteral", function () {
	return _Lexer$rx$S("^" + _Lexer.regexpLiteral);
});
$__jsx_lazy_init(_Lexer, "rxHeredocStart", function () {
	return _Lexer$rx$S("^" + _Lexer.heredocStart);
});
$__jsx_lazy_init(_Lexer, "rxHeredocEndDoubleQuoted", function () {
	return _Lexer$rx$S(' (?:^|.*?[^\\\\]) (?:\\\\\\\\)* """ ');
});
$__jsx_lazy_init(_Lexer, "rxHeredocEndSingleQuoted", function () {
	return _Lexer$rx$S(" (?:^|.*?[^\\\\]) (?:\\\\\\\\)* ''' ");
});
_Lexer.rxNewline = /(?:\r\n?|\n)/;
$__jsx_lazy_init(_Lexer, "keywords", function () {
	return Util$asSet$AS([ "null", "true", "false", "NaN", "Infinity", "break", "do", "instanceof", "typeof", "case", "else", "new", "var", "finally", "return", "void", "const", "for", "switch", "while", "function", "this", "if", "throw", "in", "try", "class", "extends", "super", "import", "implements", "static", "__FILE__", "__LINE__", "undefined" ]);
});
$__jsx_lazy_init(_Lexer, "reserved", function () {
	return Util$asSet$AS([ "debugger", "with", "export", "let", "private", "public", "yield", "protected", "extern", "native", "as", "operator" ]);
});
SourceMapper.NODE_SOURCE_MAP_HEADER = "require('source-map-support').install();\n\n";
SourceMapper.WEB_SOURCE_MAP_HEADER = "";
_NoAssertCommand.IDENTIFIER = "no-assert";
_NoLogCommand.IDENTIFIER = "no-log";
_DeadCodeEliminationOptimizeCommand.IDENTIFIER = "dce";
_ReturnIfOptimizeCommand.IDENTIFIER = "return-if";
_LCSEOptimizeCommand.IDENTIFIER = "lcse";
_ArrayLengthOptimizeCommand.IDENTIFIER = "array-length";
_TailRecursionOptimizeCommand.IDENTIFIER = "tail-rec";
_TailRecursionOptimizeCommand.LABEL = "$TAIL_REC";
_LinkTimeOptimizationCommand.IDENTIFIER = "lto";
_StripOptimizeCommand.IDENTIFIER = "strip";
_DetermineCalleeCommand.IDENTIFIER = "determine-callee";
_StaticizeOptimizeCommand.IDENTIFIER = "staticize";
_UnclassifyOptimizationCommand.IDENTIFIER = "unclassify";
_FoldConstantCommand.IDENTIFIER = "fold-const";
_FoldConstantCommand.LONG_STRING_LITERAL = 64;
_InlineOptimizeCommand.IDENTIFIER = "inline";
_InlineOptimizeCommand.INLINE_THRESHOLD = 30;
_UnboxOptimizeCommand.IDENTIFIER = "unbox";
_NoDebugCommand.IDENTIFIER = "no-debug";
Compiler.MODE_COMPILE = 0;
Compiler.MODE_PARSE = 1;
Compiler.MODE_COMPLETE = 2;
Compiler.MODE_DOC = 3;
_ExpressionTransformer._expressionCountMap = {};
_StatementTransformer._statementCountMap = {};
_Util$1._numUniqVar = 0;
GeneratorTransformCommand.IDENTIFIER = "generator";
ANFTransformCommand.IDENTIFIER = "anf";
CPSTransformCommand.IDENTIFIER = "cps";
FixedExpressionTransformCommand.IDENTIFIER = "fixed";
NormalizeTryStatementTransformCommand.IDENTIFIER = "normalize-try";
ForInStatementTransformCommand.IDENTIFIER = "transform-for-in";
_SwitchStatementTransformer$x2ECaseStash.ID = "CASE-ID";
_SwitchStatementTransformer$x2ECaseStash.count = 0;

var $__jsx_classMap = {
	"src/jsx-node-front.jsx": {
		_Main: _Main,
		_Main$: _Main,
		NodePlatform: NodePlatform,
		NodePlatform$: NodePlatform,
		NodePlatform$S: NodePlatform$0
	},
	"system:lib/js/js/nodejs.jsx": {
		node: node
	},
	"system:lib/js/timer.jsx": {
		Timer: Timer,
		Timer$: Timer,
		TimerHandle: TimerHandle
	},
	"src/util.jsx": {
		Util: Util,
		Util$: Util,
		"Util.ArgumentTypeRequest": Util$x2EArgumentTypeRequest,
		"Util.ArgumentTypeRequest$ALType$ALToken$": Util$x2EArgumentTypeRequest
	},
	"src/jsemitter.jsx": {
		_Util: _Util,
		_Util$: _Util,
		_TempVarLister: _TempVarLister,
		_TempVarLister$: _TempVarLister,
		_Mangler: _Mangler,
		_Mangler$: _Mangler,
		_Namer: _Namer,
		_Namer$: _Namer,
		_MinifiedNameGenerator: _MinifiedNameGenerator,
		_MinifiedNameGenerator$AS: _MinifiedNameGenerator,
		_Minifier: _Minifier,
		_Minifier$LJavaScriptEmitter$ALClassDefinition$: _Minifier,
		_StatementEmitter: _StatementEmitter,
		_StatementEmitter$LJavaScriptEmitter$: _StatementEmitter,
		_ConstructorInvocationStatementEmitter: _ConstructorInvocationStatementEmitter,
		_ConstructorInvocationStatementEmitter$LJavaScriptEmitter$LConstructorInvocationStatement$: _ConstructorInvocationStatementEmitter,
		_ExpressionStatementEmitter: _ExpressionStatementEmitter,
		_ExpressionStatementEmitter$LJavaScriptEmitter$LExpressionStatement$: _ExpressionStatementEmitter,
		_FunctionStatementEmitter: _FunctionStatementEmitter,
		_FunctionStatementEmitter$LJavaScriptEmitter$LFunctionStatement$: _FunctionStatementEmitter,
		_ReturnStatementEmitter: _ReturnStatementEmitter,
		_ReturnStatementEmitter$LJavaScriptEmitter$LReturnStatement$: _ReturnStatementEmitter,
		_DeleteStatementEmitter: _DeleteStatementEmitter,
		_DeleteStatementEmitter$LJavaScriptEmitter$LDeleteStatement$: _DeleteStatementEmitter,
		_BreakStatementEmitter: _BreakStatementEmitter,
		_BreakStatementEmitter$LJavaScriptEmitter$LBreakStatement$: _BreakStatementEmitter,
		_ContinueStatementEmitter: _ContinueStatementEmitter,
		_ContinueStatementEmitter$LJavaScriptEmitter$LContinueStatement$: _ContinueStatementEmitter,
		_DoWhileStatementEmitter: _DoWhileStatementEmitter,
		_DoWhileStatementEmitter$LJavaScriptEmitter$LDoWhileStatement$: _DoWhileStatementEmitter,
		_ForInStatementEmitter: _ForInStatementEmitter,
		_ForInStatementEmitter$LJavaScriptEmitter$LForInStatement$: _ForInStatementEmitter,
		_ForStatementEmitter: _ForStatementEmitter,
		_ForStatementEmitter$LJavaScriptEmitter$LForStatement$: _ForStatementEmitter,
		_IfStatementEmitter: _IfStatementEmitter,
		_IfStatementEmitter$LJavaScriptEmitter$LIfStatement$: _IfStatementEmitter,
		_SwitchStatementEmitter: _SwitchStatementEmitter,
		_SwitchStatementEmitter$LJavaScriptEmitter$LSwitchStatement$: _SwitchStatementEmitter,
		_CaseStatementEmitter: _CaseStatementEmitter,
		_CaseStatementEmitter$LJavaScriptEmitter$LCaseStatement$: _CaseStatementEmitter,
		_DefaultStatementEmitter: _DefaultStatementEmitter,
		_DefaultStatementEmitter$LJavaScriptEmitter$LDefaultStatement$: _DefaultStatementEmitter,
		_WhileStatementEmitter: _WhileStatementEmitter,
		_WhileStatementEmitter$LJavaScriptEmitter$LWhileStatement$: _WhileStatementEmitter,
		_TryStatementEmitter: _TryStatementEmitter,
		_TryStatementEmitter$LJavaScriptEmitter$LTryStatement$: _TryStatementEmitter,
		_CatchStatementEmitter: _CatchStatementEmitter,
		_CatchStatementEmitter$LJavaScriptEmitter$LCatchStatement$: _CatchStatementEmitter,
		_ThrowStatementEmitter: _ThrowStatementEmitter,
		_ThrowStatementEmitter$LJavaScriptEmitter$LThrowStatement$: _ThrowStatementEmitter,
		_AssertStatementEmitter: _AssertStatementEmitter,
		_AssertStatementEmitter$LJavaScriptEmitter$LAssertStatement$: _AssertStatementEmitter,
		_LogStatementEmitter: _LogStatementEmitter,
		_LogStatementEmitter$LJavaScriptEmitter$LLogStatement$: _LogStatementEmitter,
		_DebuggerStatementEmitter: _DebuggerStatementEmitter,
		_DebuggerStatementEmitter$LJavaScriptEmitter$LDebuggerStatement$: _DebuggerStatementEmitter,
		_ExpressionEmitter: _ExpressionEmitter,
		_ExpressionEmitter$LJavaScriptEmitter$: _ExpressionEmitter,
		_LocalExpressionEmitter: _LocalExpressionEmitter,
		_LocalExpressionEmitter$LJavaScriptEmitter$LLocalExpression$: _LocalExpressionEmitter,
		_ClassExpressionEmitter: _ClassExpressionEmitter,
		_ClassExpressionEmitter$LJavaScriptEmitter$LClassExpression$: _ClassExpressionEmitter,
		_NullExpressionEmitter: _NullExpressionEmitter,
		_NullExpressionEmitter$LJavaScriptEmitter$LNullExpression$: _NullExpressionEmitter,
		_BooleanLiteralExpressionEmitter: _BooleanLiteralExpressionEmitter,
		_BooleanLiteralExpressionEmitter$LJavaScriptEmitter$LBooleanLiteralExpression$: _BooleanLiteralExpressionEmitter,
		_IntegerLiteralExpressionEmitter: _IntegerLiteralExpressionEmitter,
		_IntegerLiteralExpressionEmitter$LJavaScriptEmitter$LIntegerLiteralExpression$: _IntegerLiteralExpressionEmitter,
		_NumberLiteralExpressionEmitter: _NumberLiteralExpressionEmitter,
		_NumberLiteralExpressionEmitter$LJavaScriptEmitter$LNumberLiteralExpression$: _NumberLiteralExpressionEmitter,
		_StringLiteralExpressionEmitter: _StringLiteralExpressionEmitter,
		_StringLiteralExpressionEmitter$LJavaScriptEmitter$LStringLiteralExpression$: _StringLiteralExpressionEmitter,
		_RegExpLiteralExpressionEmitter: _RegExpLiteralExpressionEmitter,
		_RegExpLiteralExpressionEmitter$LJavaScriptEmitter$LRegExpLiteralExpression$: _RegExpLiteralExpressionEmitter,
		_ArrayLiteralExpressionEmitter: _ArrayLiteralExpressionEmitter,
		_ArrayLiteralExpressionEmitter$LJavaScriptEmitter$LArrayLiteralExpression$: _ArrayLiteralExpressionEmitter,
		_MapLiteralExpressionEmitter: _MapLiteralExpressionEmitter,
		_MapLiteralExpressionEmitter$LJavaScriptEmitter$LMapLiteralExpression$: _MapLiteralExpressionEmitter,
		_ThisExpressionEmitter: _ThisExpressionEmitter,
		_ThisExpressionEmitter$LJavaScriptEmitter$LThisExpression$: _ThisExpressionEmitter,
		_AsExpressionEmitter: _AsExpressionEmitter,
		_AsExpressionEmitter$LJavaScriptEmitter$LAsExpression$: _AsExpressionEmitter,
		_AsNoConvertExpressionEmitter: _AsNoConvertExpressionEmitter,
		_AsNoConvertExpressionEmitter$LJavaScriptEmitter$LAsNoConvertExpression$: _AsNoConvertExpressionEmitter,
		_OperatorExpressionEmitter: _OperatorExpressionEmitter,
		_OperatorExpressionEmitter$LJavaScriptEmitter$: _OperatorExpressionEmitter,
		_UnaryExpressionEmitter: _UnaryExpressionEmitter,
		_UnaryExpressionEmitter$LJavaScriptEmitter$LUnaryExpression$: _UnaryExpressionEmitter,
		_PreIncrementExpressionEmitter: _PreIncrementExpressionEmitter,
		_PreIncrementExpressionEmitter$LJavaScriptEmitter$LPreIncrementExpression$: _PreIncrementExpressionEmitter,
		_PostIncrementExpressionEmitter: _PostIncrementExpressionEmitter,
		_PostIncrementExpressionEmitter$LJavaScriptEmitter$LPostIncrementExpression$: _PostIncrementExpressionEmitter,
		_InstanceofExpressionEmitter: _InstanceofExpressionEmitter,
		_InstanceofExpressionEmitter$LJavaScriptEmitter$LInstanceofExpression$: _InstanceofExpressionEmitter,
		_PropertyExpressionEmitter: _PropertyExpressionEmitter,
		_PropertyExpressionEmitter$LJavaScriptEmitter$LPropertyExpression$: _PropertyExpressionEmitter,
		_FunctionExpressionEmitter: _FunctionExpressionEmitter,
		_FunctionExpressionEmitter$LJavaScriptEmitter$LFunctionExpression$: _FunctionExpressionEmitter,
		_AdditiveExpressionEmitter: _AdditiveExpressionEmitter,
		_AdditiveExpressionEmitter$LJavaScriptEmitter$LAdditiveExpression$: _AdditiveExpressionEmitter,
		_AssignmentExpressionEmitter: _AssignmentExpressionEmitter,
		_AssignmentExpressionEmitter$LJavaScriptEmitter$LAssignmentExpression$: _AssignmentExpressionEmitter,
		_FusedAssignmentExpressionEmitter: _FusedAssignmentExpressionEmitter,
		_FusedAssignmentExpressionEmitter$LJavaScriptEmitter$LFusedAssignmentExpression$: _FusedAssignmentExpressionEmitter,
		_EqualityExpressionEmitter: _EqualityExpressionEmitter,
		_EqualityExpressionEmitter$LJavaScriptEmitter$LEqualityExpression$: _EqualityExpressionEmitter,
		_InExpressionEmitter: _InExpressionEmitter,
		_InExpressionEmitter$LJavaScriptEmitter$LInExpression$: _InExpressionEmitter,
		_LogicalExpressionEmitter: _LogicalExpressionEmitter,
		_LogicalExpressionEmitter$LJavaScriptEmitter$LLogicalExpression$: _LogicalExpressionEmitter,
		_ShiftExpressionEmitter: _ShiftExpressionEmitter,
		_ShiftExpressionEmitter$LJavaScriptEmitter$LShiftExpression$: _ShiftExpressionEmitter,
		_BinaryNumberExpressionEmitter: _BinaryNumberExpressionEmitter,
		_BinaryNumberExpressionEmitter$LJavaScriptEmitter$LBinaryNumberExpression$: _BinaryNumberExpressionEmitter,
		_ArrayExpressionEmitter: _ArrayExpressionEmitter,
		_ArrayExpressionEmitter$LJavaScriptEmitter$LArrayExpression$: _ArrayExpressionEmitter,
		_ConditionalExpressionEmitter: _ConditionalExpressionEmitter,
		_ConditionalExpressionEmitter$LJavaScriptEmitter$LConditionalExpression$: _ConditionalExpressionEmitter,
		_CallExpressionEmitter: _CallExpressionEmitter,
		_CallExpressionEmitter$LJavaScriptEmitter$LCallExpression$: _CallExpressionEmitter,
		_SuperExpressionEmitter: _SuperExpressionEmitter,
		_SuperExpressionEmitter$LJavaScriptEmitter$LSuperExpression$: _SuperExpressionEmitter,
		_NewExpressionEmitter: _NewExpressionEmitter,
		_NewExpressionEmitter$LJavaScriptEmitter$LNewExpression$: _NewExpressionEmitter,
		_CommaExpressionEmitter: _CommaExpressionEmitter,
		_CommaExpressionEmitter$LJavaScriptEmitter$LCommaExpression$: _CommaExpressionEmitter,
		_BootstrapBuilder: _BootstrapBuilder,
		_BootstrapBuilder$: _BootstrapBuilder,
		_ExecutableBootstrapBuilder: _ExecutableBootstrapBuilder,
		_ExecutableBootstrapBuilder$: _ExecutableBootstrapBuilder,
		_TestBootstrapBuilder: _TestBootstrapBuilder,
		_TestBootstrapBuilder$: _TestBootstrapBuilder,
		_JSEmitterStash: _JSEmitterStash,
		_JSEmitterStash$: _JSEmitterStash,
		JavaScriptEmitter: JavaScriptEmitter,
		JavaScriptEmitter$LPlatform$: JavaScriptEmitter,
		"_Util.OutputNameStash": _Util$x2EOutputNameStash,
		"_Util.OutputNameStash$S": _Util$x2EOutputNameStash,
		"_Namer._TryStash": _Namer$x2E_TryStash,
		"_Namer._TryStash$S": _Namer$x2E_TryStash,
		"_Namer._CatchTargetStash": _Namer$x2E_CatchTargetStash,
		"_Namer._CatchTargetStash$LTryStatement$": _Namer$x2E_CatchTargetStash,
		"_Minifier._ClassStash": _Minifier$x2E_ClassStash,
		"_Minifier._ClassStash$": _Minifier$x2E_ClassStash,
		"_Minifier._ScopeStash": _Minifier$x2E_ScopeStash,
		"_Minifier._ScopeStash$": _Minifier$x2E_ScopeStash,
		"_Minifier._LocalStash": _Minifier$x2E_LocalStash,
		"_Minifier._LocalStash$": _Minifier$x2E_LocalStash,
		"_Minifier._MinifyingNamer": _Minifier$x2E_MinifyingNamer,
		"_Minifier._MinifyingNamer$": _Minifier$x2E_MinifyingNamer
	},
	"src/platform.jsx": {
		Platform: Platform,
		Platform$: Platform
	},
	"src/jsx-command.jsx": {
		JSXCommand: JSXCommand,
		JSXCommand$: JSXCommand
	},
	"src/meta.jsx": {
		Meta: Meta,
		Meta$: Meta
	},
	"src/expression.jsx": {
		MapLiteralElement: MapLiteralElement,
		MapLiteralElement$LToken$LExpression$: MapLiteralElement,
		Expression: Expression,
		Expression$LToken$: Expression,
		Expression$LExpression$: Expression$0,
		CommaExpression: CommaExpression,
		CommaExpression$LToken$LExpression$LExpression$: CommaExpression,
		FunctionExpression: FunctionExpression,
		FunctionExpression$LToken$LMemberFunctionDefinition$: FunctionExpression,
		MapLiteralExpression: MapLiteralExpression,
		MapLiteralExpression$LToken$ALMapLiteralElement$LType$: MapLiteralExpression,
		ArrayLiteralExpression: ArrayLiteralExpression,
		ArrayLiteralExpression$LToken$ALExpression$LType$: ArrayLiteralExpression,
		OperatorExpression: OperatorExpression,
		OperatorExpression$LToken$: OperatorExpression,
		OperatorExpression$LExpression$: OperatorExpression$0,
		NewExpression: NewExpression,
		NewExpression$LToken$LType$ALExpression$: NewExpression,
		NewExpression$LNewExpression$: NewExpression$0,
		SuperExpression: SuperExpression,
		SuperExpression$LToken$LToken$ALExpression$: SuperExpression,
		SuperExpression$LSuperExpression$: SuperExpression$0,
		CallExpression: CallExpression,
		CallExpression$LToken$LExpression$ALExpression$: CallExpression,
		CallExpression$LCallExpression$: CallExpression$0,
		ConditionalExpression: ConditionalExpression,
		ConditionalExpression$LToken$LExpression$LExpression$LExpression$: ConditionalExpression,
		ConditionalExpression$LToken$LExpression$LExpression$LExpression$LType$: ConditionalExpression$0,
		BinaryExpression: BinaryExpression,
		BinaryExpression$LToken$LExpression$LExpression$: BinaryExpression,
		ShiftExpression: ShiftExpression,
		ShiftExpression$LToken$LExpression$LExpression$: ShiftExpression,
		LogicalExpression: LogicalExpression,
		LogicalExpression$LToken$LExpression$LExpression$: LogicalExpression,
		InExpression: InExpression,
		InExpression$LToken$LExpression$LExpression$: InExpression,
		EqualityExpression: EqualityExpression,
		EqualityExpression$LToken$LExpression$LExpression$: EqualityExpression,
		BinaryNumberExpression: BinaryNumberExpression,
		BinaryNumberExpression$LToken$LExpression$LExpression$: BinaryNumberExpression,
		FusedAssignmentExpression: FusedAssignmentExpression,
		FusedAssignmentExpression$LToken$LExpression$LExpression$: FusedAssignmentExpression,
		AssignmentExpression: AssignmentExpression,
		AssignmentExpression$LToken$LExpression$LExpression$: AssignmentExpression,
		ArrayExpression: ArrayExpression,
		ArrayExpression$LToken$LExpression$LExpression$: ArrayExpression,
		ArrayExpression$LToken$LExpression$LExpression$LType$: ArrayExpression$0,
		AdditiveExpression: AdditiveExpression,
		AdditiveExpression$LToken$LExpression$LExpression$: AdditiveExpression,
		UnaryExpression: UnaryExpression,
		UnaryExpression$LToken$LExpression$: UnaryExpression,
		YieldExpression: YieldExpression,
		YieldExpression$LToken$LExpression$: YieldExpression,
		YieldExpression$LToken$LExpression$LType$LType$: YieldExpression$0,
		SignExpression: SignExpression,
		SignExpression$LToken$LExpression$: SignExpression,
		TypeofExpression: TypeofExpression,
		TypeofExpression$LToken$LExpression$: TypeofExpression,
		PropertyExpression: PropertyExpression,
		PropertyExpression$LToken$LExpression$LToken$ALType$: PropertyExpression,
		PropertyExpression$LToken$LExpression$LToken$ALType$LType$: PropertyExpression$0,
		IncrementExpression: IncrementExpression,
		IncrementExpression$LToken$LExpression$: IncrementExpression,
		PreIncrementExpression: PreIncrementExpression,
		PreIncrementExpression$LToken$LExpression$: PreIncrementExpression,
		PostIncrementExpression: PostIncrementExpression,
		PostIncrementExpression$LToken$LExpression$: PostIncrementExpression,
		LogicalNotExpression: LogicalNotExpression,
		LogicalNotExpression$LToken$LExpression$: LogicalNotExpression,
		AsNoConvertExpression: AsNoConvertExpression,
		AsNoConvertExpression$LToken$LExpression$LType$: AsNoConvertExpression,
		AsExpression: AsExpression,
		AsExpression$LToken$LExpression$LType$: AsExpression,
		InstanceofExpression: InstanceofExpression,
		InstanceofExpression$LToken$LExpression$LType$: InstanceofExpression,
		BitwiseNotExpression: BitwiseNotExpression,
		BitwiseNotExpression$LToken$LExpression$: BitwiseNotExpression,
		LeafExpression: LeafExpression,
		LeafExpression$LToken$: LeafExpression,
		ThisExpression: ThisExpression,
		ThisExpression$LToken$LClassDefinition$: ThisExpression,
		RegExpLiteralExpression: RegExpLiteralExpression,
		RegExpLiteralExpression$LToken$: RegExpLiteralExpression,
		RegExpLiteralExpression$LToken$LType$: RegExpLiteralExpression$0,
		PrimitiveLiteralExpression: PrimitiveLiteralExpression,
		PrimitiveLiteralExpression$LToken$: PrimitiveLiteralExpression,
		StringLiteralExpression: StringLiteralExpression,
		StringLiteralExpression$LToken$: StringLiteralExpression,
		FileMacroExpression: FileMacroExpression,
		FileMacroExpression$LToken$: FileMacroExpression,
		NumberLiteralExpression: NumberLiteralExpression,
		NumberLiteralExpression$LToken$: NumberLiteralExpression,
		LineMacroExpression: LineMacroExpression,
		LineMacroExpression$LToken$: LineMacroExpression,
		IntegerLiteralExpression: IntegerLiteralExpression,
		IntegerLiteralExpression$LToken$: IntegerLiteralExpression,
		BooleanLiteralExpression: BooleanLiteralExpression,
		BooleanLiteralExpression$LToken$: BooleanLiteralExpression,
		NullExpression: NullExpression,
		NullExpression$LToken$LType$: NullExpression,
		ClassExpression: ClassExpression,
		ClassExpression$LToken$LType$: ClassExpression,
		LocalExpression: LocalExpression,
		LocalExpression$LToken$LLocalVariable$: LocalExpression
	},
	"src/analysis.jsx": {
		InstantiationContext: InstantiationContext,
		InstantiationContext$ALCompileError$HLType$: InstantiationContext,
		TemplateInstantiationRequest: TemplateInstantiationRequest,
		TemplateInstantiationRequest$LToken$SALType$: TemplateInstantiationRequest,
		Block: Block,
		Block$: Block,
		BlockContext: BlockContext,
		BlockContext$LLocalVariableStatuses$LBlock$: BlockContext,
		AnalysisContext: AnalysisContext,
		AnalysisContext$ALCompileError$LParser$F$LParser$LClassDefinition$LClassDefinition$$: AnalysisContext,
		Stash: Stash,
		Stash$: Stash,
		Stashable: Stashable,
		Stashable$: Stashable,
		LocalVariable: LocalVariable,
		LocalVariable$LToken$LType$B: LocalVariable,
		CaughtVariable: CaughtVariable,
		CaughtVariable$LToken$LType$: CaughtVariable,
		ArgumentDeclaration: ArgumentDeclaration,
		ArgumentDeclaration$LToken$LType$: ArgumentDeclaration,
		ArgumentDeclaration$LToken$LType$LExpression$: ArgumentDeclaration$0,
		LocalVariableStatuses: LocalVariableStatuses,
		LocalVariableStatuses$LMemberFunctionDefinition$LLocalVariableStatuses$: LocalVariableStatuses,
		LocalVariableStatuses$LLocalVariableStatuses$: LocalVariableStatuses$0,
		CompileIssue: CompileIssue,
		CompileIssue$LToken$S: CompileIssue,
		CompileIssue$SNNS: CompileIssue$0,
		CompileError: CompileError,
		CompileError$LToken$S: CompileError,
		CompileError$SNNS: CompileError$0,
		CompileWarning: CompileWarning,
		CompileWarning$LToken$S: CompileWarning,
		CompileWarning$SNNS: CompileWarning$0,
		UnusedWarning: UnusedWarning,
		UnusedWarning$LToken$S: UnusedWarning,
		UnusedWarning$SNNS: UnusedWarning$0,
		DeprecatedWarning: DeprecatedWarning,
		DeprecatedWarning$LToken$S: DeprecatedWarning,
		DeprecatedWarning$SNNS: DeprecatedWarning$0,
		ExperimentalWarning: ExperimentalWarning,
		ExperimentalWarning$LToken$S: ExperimentalWarning,
		ExperimentalWarning$SNNS: ExperimentalWarning$0,
		CompileNote: CompileNote,
		CompileNote$LToken$S: CompileNote,
		CompileNote$SNNS: CompileNote$0
	},
	"src/statement.jsx": {
		Statement: Statement,
		Statement$: Statement,
		LabelStatement: LabelStatement,
		LabelStatement$S: LabelStatement,
		GotoStatement: GotoStatement,
		GotoStatement$S: GotoStatement,
		InformationStatement: InformationStatement,
		InformationStatement$LToken$: InformationStatement,
		DebuggerStatement: DebuggerStatement,
		DebuggerStatement$LToken$: DebuggerStatement,
		LogStatement: LogStatement,
		LogStatement$LToken$ALExpression$: LogStatement,
		AssertStatement: AssertStatement,
		AssertStatement$LToken$LExpression$LExpression$: AssertStatement,
		ThrowStatement: ThrowStatement,
		ThrowStatement$LToken$LExpression$: ThrowStatement,
		CatchStatement: CatchStatement,
		CatchStatement$LToken$LCaughtVariable$ALStatement$: CatchStatement,
		TryStatement: TryStatement,
		TryStatement$LToken$ALStatement$ALCatchStatement$ALStatement$: TryStatement,
		DefaultStatement: DefaultStatement,
		DefaultStatement$LToken$: DefaultStatement,
		CaseStatement: CaseStatement,
		CaseStatement$LToken$LExpression$: CaseStatement,
		IfStatement: IfStatement,
		IfStatement$LToken$LExpression$ALStatement$ALStatement$: IfStatement,
		LabellableStatement: LabellableStatement,
		LabellableStatement$LToken$LToken$: LabellableStatement,
		SwitchStatement: SwitchStatement,
		SwitchStatement$LToken$LToken$LExpression$ALStatement$: SwitchStatement,
		ContinuableStatement: ContinuableStatement,
		ContinuableStatement$LToken$LToken$ALStatement$: ContinuableStatement,
		WhileStatement: WhileStatement,
		WhileStatement$LToken$LToken$LExpression$ALStatement$: WhileStatement,
		ForStatement: ForStatement,
		ForStatement$LToken$LToken$LExpression$LExpression$LExpression$ALStatement$: ForStatement,
		ForInStatement: ForInStatement,
		ForInStatement$LToken$LToken$LExpression$LExpression$ALStatement$: ForInStatement,
		DoWhileStatement: DoWhileStatement,
		DoWhileStatement$LToken$LToken$LExpression$ALStatement$: DoWhileStatement,
		JumpStatement: JumpStatement,
		JumpStatement$LToken$LToken$: JumpStatement,
		ContinueStatement: ContinueStatement,
		ContinueStatement$LToken$LToken$: ContinueStatement,
		BreakStatement: BreakStatement,
		BreakStatement$LToken$LToken$: BreakStatement,
		ReturnStatement: ReturnStatement,
		ReturnStatement$LToken$LExpression$: ReturnStatement,
		FunctionStatement: FunctionStatement,
		FunctionStatement$LToken$LMemberFunctionDefinition$: FunctionStatement,
		UnaryExpressionStatement: UnaryExpressionStatement,
		UnaryExpressionStatement$LExpression$: UnaryExpressionStatement,
		DeleteStatement: DeleteStatement,
		DeleteStatement$LToken$LExpression$: DeleteStatement,
		ExpressionStatement: ExpressionStatement,
		ExpressionStatement$LExpression$: ExpressionStatement,
		ConstructorInvocationStatement: ConstructorInvocationStatement,
		ConstructorInvocationStatement$LToken$LType$ALExpression$: ConstructorInvocationStatement,
		ConstructorInvocationStatement$LToken$LType$ALExpression$LFunctionType$: ConstructorInvocationStatement$0
	},
	"src/emitter.jsx": {
		Emitter: Emitter,
		Emitter$: Emitter
	},
	"src/classdef.jsx": {
		TemplateDefinition: TemplateDefinition,
		TemplateDefinition$: TemplateDefinition,
		ClassDefinition: ClassDefinition,
		ClassDefinition$LToken$SNLParsedObjectType$ALParsedObjectType$ALMemberDefinition$ALClassDefinition$ALTemplateClassDefinition$ALParsedObjectType$LDocComment$: ClassDefinition,
		MemberDefinition: MemberDefinition,
		MemberDefinition$LToken$LToken$NALMemberFunctionDefinition$LDocComment$: MemberDefinition,
		MemberVariableDefinition: MemberVariableDefinition,
		MemberVariableDefinition$LToken$LToken$NLType$LExpression$ALMemberFunctionDefinition$LDocComment$: MemberVariableDefinition,
		MemberFunctionDefinition: MemberFunctionDefinition,
		MemberFunctionDefinition$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$: MemberFunctionDefinition,
		InstantiatedMemberFunctionDefinition: InstantiatedMemberFunctionDefinition,
		InstantiatedMemberFunctionDefinition$LToken$LToken$NLType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$: InstantiatedMemberFunctionDefinition,
		TemplateFunctionDefinition: TemplateFunctionDefinition,
		TemplateFunctionDefinition$LToken$LToken$NALToken$LType$ALArgumentDeclaration$ALLocalVariable$ALStatement$ALMemberFunctionDefinition$LToken$LDocComment$: TemplateFunctionDefinition,
		TemplateClassDefinition: TemplateClassDefinition,
		TemplateClassDefinition$LToken$SNALToken$LParsedObjectType$ALParsedObjectType$ALMemberDefinition$ALClassDefinition$ALTemplateClassDefinition$ALParsedObjectType$LDocComment$: TemplateClassDefinition,
		InstantiatedClassDefinition: InstantiatedClassDefinition,
		InstantiatedClassDefinition$LTemplateClassDefinition$ALType$LParsedObjectType$ALParsedObjectType$ALMemberDefinition$ALClassDefinition$ALTemplateClassDefinition$ALParsedObjectType$: InstantiatedClassDefinition,
		"MemberFunctionDefinition._CloneStash": MemberFunctionDefinition$x2E_CloneStash,
		"MemberFunctionDefinition._CloneStash$": MemberFunctionDefinition$x2E_CloneStash,
		"MemberFunctionDefinition._CloneStash$LMemberFunctionDefinition$x2E_CloneStash$": MemberFunctionDefinition$x2E_CloneStash$0
	},
	"src/type.jsx": {
		Type: Type,
		Type$: Type,
		VoidType: VoidType,
		VoidType$: VoidType,
		NullType: NullType,
		NullType$: NullType,
		PrimitiveType: PrimitiveType,
		PrimitiveType$: PrimitiveType,
		BooleanType: BooleanType,
		BooleanType$: BooleanType,
		IntegerType: IntegerType,
		IntegerType$: IntegerType,
		NumberType: NumberType,
		NumberType$: NumberType,
		StringType: StringType,
		StringType$: StringType,
		VariantType: VariantType,
		VariantType$: VariantType,
		NullableType: NullableType,
		NullableType$LType$: NullableType,
		VariableLengthArgumentType: VariableLengthArgumentType,
		VariableLengthArgumentType$LType$: VariableLengthArgumentType,
		ObjectType: ObjectType,
		ObjectType$LClassDefinition$: ObjectType,
		ParsedObjectType: ParsedObjectType,
		ParsedObjectType$LQualifiedName$ALType$: ParsedObjectType,
		FunctionType: FunctionType,
		FunctionType$: FunctionType,
		FunctionChoiceType: FunctionChoiceType,
		FunctionChoiceType$ALResolvedFunctionType$: FunctionChoiceType,
		ResolvedFunctionType: ResolvedFunctionType,
		ResolvedFunctionType$LToken$LType$ALType$B: ResolvedFunctionType,
		StaticFunctionType: StaticFunctionType,
		StaticFunctionType$LToken$LType$ALType$B: StaticFunctionType,
		MemberFunctionType: MemberFunctionType,
		MemberFunctionType$LToken$LType$LType$ALType$B: MemberFunctionType,
		TemplateFunctionType: TemplateFunctionType,
		TemplateFunctionType$LToken$LTemplateFunctionDefinition$: TemplateFunctionType
	},
	"src/parser.jsx": {
		Token: Token,
		Token$SBUSNN: Token,
		Token$SBUSN: Token$0,
		Token$SBUS: Token$1,
		Token$SB: Token$2,
		Token$S: Token$3,
		_Lexer: _Lexer,
		_Lexer$: _Lexer,
		Import: Import,
		Import$LParser$: Import,
		Import$LToken$LToken$ALToken$: Import$0,
		WildcardImport: WildcardImport,
		WildcardImport$LToken$LToken$ALToken$SS: WildcardImport,
		QualifiedName: QualifiedName,
		QualifiedName$LToken$: QualifiedName,
		QualifiedName$LToken$LImport$: QualifiedName$0,
		QualifiedName$LToken$LParsedObjectType$: QualifiedName$1,
		ParserState: ParserState,
		ParserState$NNLDocComment$NBNNNN: ParserState,
		ClassState: ClassState,
		ClassState$LClassState$LParsedObjectType$ALToken$LParsedObjectType$ALParsedObjectType$ALParsedObjectType$NALClassDefinition$ALTemplateClassDefinition$: ClassState,
		Scope: Scope,
		Scope$LScope$ALLocalVariable$LLocalVariable$ALArgumentDeclaration$ALStatement$ALMemberFunctionDefinition$B: Scope,
		Parser: Parser,
		Parser$LToken$SLCompletionRequest$: Parser
	},
	"src/jssourcemap.jsx": {
		SourceMapper: SourceMapper,
		SourceMapper$SUSS: SourceMapper
	},
	"src/optimizer.jsx": {
		_Util: _Util$0,
		_Util$: _Util$0,
		Optimizer: Optimizer,
		Optimizer$: Optimizer,
		_OptimizeCommand: _OptimizeCommand,
		_OptimizeCommand$S: _OptimizeCommand,
		_FunctionOptimizeCommand: _FunctionOptimizeCommand,
		_FunctionOptimizeCommand$S: _FunctionOptimizeCommand,
		_NoAssertCommand: _NoAssertCommand,
		_NoAssertCommand$: _NoAssertCommand,
		_NoLogCommand: _NoLogCommand,
		_NoLogCommand$: _NoLogCommand,
		_DeadCodeEliminationOptimizeCommand: _DeadCodeEliminationOptimizeCommand,
		_DeadCodeEliminationOptimizeCommand$: _DeadCodeEliminationOptimizeCommand,
		_ReturnIfOptimizeCommand: _ReturnIfOptimizeCommand,
		_ReturnIfOptimizeCommand$: _ReturnIfOptimizeCommand,
		_LCSECachedExpression: _LCSECachedExpression,
		_LCSECachedExpression$LExpression$F$LExpression$V$: _LCSECachedExpression,
		_LCSEOptimizeCommand: _LCSEOptimizeCommand,
		_LCSEOptimizeCommand$: _LCSEOptimizeCommand,
		_ArrayLengthOptimizeCommand: _ArrayLengthOptimizeCommand,
		_ArrayLengthOptimizeCommand$: _ArrayLengthOptimizeCommand,
		_TailRecursionOptimizeCommand: _TailRecursionOptimizeCommand,
		_TailRecursionOptimizeCommand$: _TailRecursionOptimizeCommand,
		_LinkTimeOptimizationCommand: _LinkTimeOptimizationCommand,
		_LinkTimeOptimizationCommand$: _LinkTimeOptimizationCommand,
		_StripOptimizeCommand: _StripOptimizeCommand,
		_StripOptimizeCommand$: _StripOptimizeCommand,
		_DetermineCalleeCommand: _DetermineCalleeCommand,
		_DetermineCalleeCommand$: _DetermineCalleeCommand,
		_StaticizeOptimizeCommand: _StaticizeOptimizeCommand,
		_StaticizeOptimizeCommand$: _StaticizeOptimizeCommand,
		_UnclassifyOptimizationCommand: _UnclassifyOptimizationCommand,
		_UnclassifyOptimizationCommand$: _UnclassifyOptimizationCommand,
		_FoldConstantCommand: _FoldConstantCommand,
		_FoldConstantCommand$: _FoldConstantCommand,
		_InlineOptimizeCommand: _InlineOptimizeCommand,
		_InlineOptimizeCommand$: _InlineOptimizeCommand,
		_UnboxOptimizeCommand: _UnboxOptimizeCommand,
		_UnboxOptimizeCommand$: _UnboxOptimizeCommand,
		_NoDebugCommand: _NoDebugCommand,
		_NoDebugCommand$: _NoDebugCommand,
		"_LinkTimeOptimizationCommand.Stash": _LinkTimeOptimizationCommand$x2EStash,
		"_LinkTimeOptimizationCommand.Stash$": _LinkTimeOptimizationCommand$x2EStash,
		"_StripOptimizeCommand._Stash": _StripOptimizeCommand$x2E_Stash,
		"_StripOptimizeCommand._Stash$": _StripOptimizeCommand$x2E_Stash,
		"_DetermineCalleeCommand.Stash": _DetermineCalleeCommand$x2EStash,
		"_DetermineCalleeCommand.Stash$": _DetermineCalleeCommand$x2EStash,
		"_DetermineCalleeCommand.Stash$L_DetermineCalleeCommand$x2EStash$": _DetermineCalleeCommand$x2EStash$0,
		"_StaticizeOptimizeCommand.Stash": _StaticizeOptimizeCommand$x2EStash,
		"_StaticizeOptimizeCommand.Stash$": _StaticizeOptimizeCommand$x2EStash,
		"_StaticizeOptimizeCommand.Stash$L_StaticizeOptimizeCommand$x2EStash$": _StaticizeOptimizeCommand$x2EStash$0,
		"_UnclassifyOptimizationCommand.Stash": _UnclassifyOptimizationCommand$x2EStash,
		"_UnclassifyOptimizationCommand.Stash$": _UnclassifyOptimizationCommand$x2EStash,
		"_UnclassifyOptimizationCommand.Stash$L_UnclassifyOptimizationCommand$x2EStash$": _UnclassifyOptimizationCommand$x2EStash$0,
		"_FoldConstantCommand.Stash": _FoldConstantCommand$x2EStash,
		"_FoldConstantCommand.Stash$": _FoldConstantCommand$x2EStash,
		"_FoldConstantCommand.Stash$L_FoldConstantCommand$x2EStash$": _FoldConstantCommand$x2EStash$0,
		"_InlineOptimizeCommand.Stash": _InlineOptimizeCommand$x2EStash,
		"_InlineOptimizeCommand.Stash$": _InlineOptimizeCommand$x2EStash,
		"_InlineOptimizeCommand.Stash$L_InlineOptimizeCommand$x2EStash$": _InlineOptimizeCommand$x2EStash$0,
		"_UnboxOptimizeCommand.Stash": _UnboxOptimizeCommand$x2EStash,
		"_UnboxOptimizeCommand.Stash$": _UnboxOptimizeCommand$x2EStash,
		"_NoDebugCommand.Stash": _NoDebugCommand$x2EStash,
		"_NoDebugCommand.Stash$": _NoDebugCommand$x2EStash
	},
	"src/compiler.jsx": {
		Compiler: Compiler,
		Compiler$LPlatform$: Compiler
	},
	"src/completion.jsx": {
		CompletionRequest: CompletionRequest,
		CompletionRequest$NN: CompletionRequest,
		CompletionCandidates: CompletionCandidates,
		CompletionCandidates$: CompletionCandidates,
		KeywordCompletionCandidate: KeywordCompletionCandidate,
		KeywordCompletionCandidate$S: KeywordCompletionCandidate,
		CompletionCandidatesOfTopLevel: CompletionCandidatesOfTopLevel,
		CompletionCandidatesOfTopLevel$LParser$F$LClassDefinition$B$: CompletionCandidatesOfTopLevel,
		_CompletionCandidatesWithLocal: _CompletionCandidatesWithLocal,
		_CompletionCandidatesWithLocal$LParser$: _CompletionCandidatesWithLocal,
		_CompletionCandidatesOfNamespace: _CompletionCandidatesOfNamespace,
		_CompletionCandidatesOfNamespace$LImport$F$LClassDefinition$B$: _CompletionCandidatesOfNamespace,
		_CompletionCandidatesOfProperty: _CompletionCandidatesOfProperty,
		_CompletionCandidatesOfProperty$LExpression$: _CompletionCandidatesOfProperty
	},
	"src/doc.jsx": {
		DocCommentNode: DocCommentNode,
		DocCommentNode$: DocCommentNode,
		DocCommentParameter: DocCommentParameter,
		DocCommentParameter$LToken$: DocCommentParameter,
		DocCommentTag: DocCommentTag,
		DocCommentTag$S: DocCommentTag,
		DocComment: DocComment,
		DocComment$: DocComment,
		DocumentGenerator: DocumentGenerator,
		DocumentGenerator$LCompiler$SS: DocumentGenerator
	},
	"src/instruments.jsx": {
		_ExpressionTransformer: _ExpressionTransformer,
		_ExpressionTransformer$LCPSTransformCommand$S: _ExpressionTransformer,
		_MultiaryOperatorTransformer: _MultiaryOperatorTransformer,
		_MultiaryOperatorTransformer$LCPSTransformCommand$S: _MultiaryOperatorTransformer,
		_LeafExpressionTransformer: _LeafExpressionTransformer,
		_LeafExpressionTransformer$LCPSTransformCommand$LLeafExpression$: _LeafExpressionTransformer,
		_ArrayLiteralExpressionTransformer: _ArrayLiteralExpressionTransformer,
		_ArrayLiteralExpressionTransformer$LCPSTransformCommand$LArrayLiteralExpression$: _ArrayLiteralExpressionTransformer,
		_MapLiteralExpressionTransformer: _MapLiteralExpressionTransformer,
		_MapLiteralExpressionTransformer$LCPSTransformCommand$LMapLiteralExpression$: _MapLiteralExpressionTransformer,
		_FunctionExpressionTransformer: _FunctionExpressionTransformer,
		_FunctionExpressionTransformer$LCPSTransformCommand$LFunctionExpression$: _FunctionExpressionTransformer,
		_UnaryExpressionTransformer: _UnaryExpressionTransformer,
		_UnaryExpressionTransformer$LCPSTransformCommand$LUnaryExpression$: _UnaryExpressionTransformer,
		_BitwiseNotExpressionTransformer: _BitwiseNotExpressionTransformer,
		_BitwiseNotExpressionTransformer$LCPSTransformCommand$LBitwiseNotExpression$: _BitwiseNotExpressionTransformer,
		_InstanceofExpressionTransformer: _InstanceofExpressionTransformer,
		_InstanceofExpressionTransformer$LCPSTransformCommand$LInstanceofExpression$: _InstanceofExpressionTransformer,
		_AsExpressionTransformer: _AsExpressionTransformer,
		_AsExpressionTransformer$LCPSTransformCommand$LAsExpression$: _AsExpressionTransformer,
		_AsNoConvertExpressionTransformer: _AsNoConvertExpressionTransformer,
		_AsNoConvertExpressionTransformer$LCPSTransformCommand$LAsNoConvertExpression$: _AsNoConvertExpressionTransformer,
		_LogicalNotExpressionTransformer: _LogicalNotExpressionTransformer,
		_LogicalNotExpressionTransformer$LCPSTransformCommand$LLogicalNotExpression$: _LogicalNotExpressionTransformer,
		_IncrementExpressionTransformer: _IncrementExpressionTransformer,
		_IncrementExpressionTransformer$LCPSTransformCommand$LIncrementExpression$: _IncrementExpressionTransformer,
		_PostIncrementExpressionTransformer: _PostIncrementExpressionTransformer,
		_PostIncrementExpressionTransformer$LCPSTransformCommand$LIncrementExpression$: _PostIncrementExpressionTransformer,
		_PreIncrementExpressionTransformer: _PreIncrementExpressionTransformer,
		_PreIncrementExpressionTransformer$LCPSTransformCommand$LIncrementExpression$: _PreIncrementExpressionTransformer,
		_PropertyExpressionTransformer: _PropertyExpressionTransformer,
		_PropertyExpressionTransformer$LCPSTransformCommand$LPropertyExpression$: _PropertyExpressionTransformer,
		_TypeofExpressionTransformer: _TypeofExpressionTransformer,
		_TypeofExpressionTransformer$LCPSTransformCommand$LTypeofExpression$: _TypeofExpressionTransformer,
		_SignExpressionTransformer: _SignExpressionTransformer,
		_SignExpressionTransformer$LCPSTransformCommand$LSignExpression$: _SignExpressionTransformer,
		_YieldExpressionTransformer: _YieldExpressionTransformer,
		_YieldExpressionTransformer$LCPSTransformCommand$LYieldExpression$: _YieldExpressionTransformer,
		_BinaryExpressionTransformer: _BinaryExpressionTransformer,
		_BinaryExpressionTransformer$LCPSTransformCommand$LBinaryExpression$: _BinaryExpressionTransformer,
		_AdditiveExpressionTransformer: _AdditiveExpressionTransformer,
		_AdditiveExpressionTransformer$LCPSTransformCommand$LAdditiveExpression$: _AdditiveExpressionTransformer,
		_ArrayExpressionTransformer: _ArrayExpressionTransformer,
		_ArrayExpressionTransformer$LCPSTransformCommand$LArrayExpression$: _ArrayExpressionTransformer,
		_AssignmentExpressionTransformer: _AssignmentExpressionTransformer,
		_AssignmentExpressionTransformer$LCPSTransformCommand$LAssignmentExpression$: _AssignmentExpressionTransformer,
		_FusedAssignmentExpressionTransformer: _FusedAssignmentExpressionTransformer,
		_FusedAssignmentExpressionTransformer$LCPSTransformCommand$LFusedAssignmentExpression$: _FusedAssignmentExpressionTransformer,
		_BinaryNumberExpressionTransformer: _BinaryNumberExpressionTransformer,
		_BinaryNumberExpressionTransformer$LCPSTransformCommand$LBinaryNumberExpression$: _BinaryNumberExpressionTransformer,
		_EqualityExpressionTransformer: _EqualityExpressionTransformer,
		_EqualityExpressionTransformer$LCPSTransformCommand$LEqualityExpression$: _EqualityExpressionTransformer,
		_InExpressionTransformer: _InExpressionTransformer,
		_InExpressionTransformer$LCPSTransformCommand$LInExpression$: _InExpressionTransformer,
		_LogicalExpressionTransformer: _LogicalExpressionTransformer,
		_LogicalExpressionTransformer$LCPSTransformCommand$LLogicalExpression$: _LogicalExpressionTransformer,
		_ShiftExpressionTransformer: _ShiftExpressionTransformer,
		_ShiftExpressionTransformer$LCPSTransformCommand$LShiftExpression$: _ShiftExpressionTransformer,
		_ConditionalExpressionTransformer: _ConditionalExpressionTransformer,
		_ConditionalExpressionTransformer$LCPSTransformCommand$LConditionalExpression$: _ConditionalExpressionTransformer,
		_CallExpressionTransformer: _CallExpressionTransformer,
		_CallExpressionTransformer$LCPSTransformCommand$LCallExpression$: _CallExpressionTransformer,
		_SuperExpressionTransformer: _SuperExpressionTransformer,
		_SuperExpressionTransformer$LCPSTransformCommand$LSuperExpression$: _SuperExpressionTransformer,
		_NewExpressionTransformer: _NewExpressionTransformer,
		_NewExpressionTransformer$LCPSTransformCommand$LNewExpression$: _NewExpressionTransformer,
		_CommaExpressionTransformer: _CommaExpressionTransformer,
		_CommaExpressionTransformer$LCPSTransformCommand$LCommaExpression$: _CommaExpressionTransformer,
		_StatementTransformer: _StatementTransformer,
		_StatementTransformer$LCPSTransformCommand$S: _StatementTransformer,
		_ConstructorInvocationStatementTransformer: _ConstructorInvocationStatementTransformer,
		_ConstructorInvocationStatementTransformer$LCPSTransformCommand$LConstructorInvocationStatement$: _ConstructorInvocationStatementTransformer,
		_ExpressionStatementTransformer: _ExpressionStatementTransformer,
		_ExpressionStatementTransformer$LCPSTransformCommand$LExpressionStatement$: _ExpressionStatementTransformer,
		_FunctionStatementTransformer: _FunctionStatementTransformer,
		_FunctionStatementTransformer$LCPSTransformCommand$LFunctionStatement$: _FunctionStatementTransformer,
		_ReturnStatementTransformer: _ReturnStatementTransformer,
		_ReturnStatementTransformer$LCPSTransformCommand$LReturnStatement$: _ReturnStatementTransformer,
		_DeleteStatementTransformer: _DeleteStatementTransformer,
		_DeleteStatementTransformer$LCPSTransformCommand$LDeleteStatement$: _DeleteStatementTransformer,
		_BreakStatementTransformer: _BreakStatementTransformer,
		_BreakStatementTransformer$LCPSTransformCommand$LBreakStatement$: _BreakStatementTransformer,
		_ContinueStatementTransformer: _ContinueStatementTransformer,
		_ContinueStatementTransformer$LCPSTransformCommand$LContinueStatement$: _ContinueStatementTransformer,
		_LabellableStatementTransformer: _LabellableStatementTransformer,
		_LabellableStatementTransformer$LCPSTransformCommand$S: _LabellableStatementTransformer,
		_DoWhileStatementTransformer: _DoWhileStatementTransformer,
		_DoWhileStatementTransformer$LCPSTransformCommand$LDoWhileStatement$: _DoWhileStatementTransformer,
		_ForInStatementTransformer: _ForInStatementTransformer,
		_ForInStatementTransformer$LCPSTransformCommand$LForInStatement$: _ForInStatementTransformer,
		_ForStatementTransformer: _ForStatementTransformer,
		_ForStatementTransformer$LCPSTransformCommand$LForStatement$: _ForStatementTransformer,
		_IfStatementTransformer: _IfStatementTransformer,
		_IfStatementTransformer$LCPSTransformCommand$LIfStatement$: _IfStatementTransformer,
		_SwitchStatementTransformer: _SwitchStatementTransformer,
		_SwitchStatementTransformer$LCPSTransformCommand$LSwitchStatement$: _SwitchStatementTransformer,
		_CaseStatementTransformer: _CaseStatementTransformer,
		_CaseStatementTransformer$LCPSTransformCommand$LCaseStatement$: _CaseStatementTransformer,
		_DefaultStatementTransformer: _DefaultStatementTransformer,
		_DefaultStatementTransformer$LCPSTransformCommand$LDefaultStatement$: _DefaultStatementTransformer,
		_WhileStatementTransformer: _WhileStatementTransformer,
		_WhileStatementTransformer$LCPSTransformCommand$LWhileStatement$: _WhileStatementTransformer,
		_TryStatementTransformer: _TryStatementTransformer,
		_TryStatementTransformer$LCPSTransformCommand$LTryStatement$: _TryStatementTransformer,
		_CatchStatementTransformer: _CatchStatementTransformer,
		_CatchStatementTransformer$LCPSTransformCommand$LCatchStatement$: _CatchStatementTransformer,
		_ThrowStatementTransformer: _ThrowStatementTransformer,
		_ThrowStatementTransformer$LCPSTransformCommand$LThrowStatement$: _ThrowStatementTransformer,
		_AssertStatementTransformer: _AssertStatementTransformer,
		_AssertStatementTransformer$LCPSTransformCommand$LAssertStatement$: _AssertStatementTransformer,
		_LogStatementTransformer: _LogStatementTransformer,
		_LogStatementTransformer$LCPSTransformCommand$LLogStatement$: _LogStatementTransformer,
		_DebuggerStatementTransformer: _DebuggerStatementTransformer,
		_DebuggerStatementTransformer$LCPSTransformCommand$LDebuggerStatement$: _DebuggerStatementTransformer,
		GeneratorTransformCommand: GeneratorTransformCommand,
		GeneratorTransformCommand$LCompiler$: GeneratorTransformCommand,
		ANFTransformCommand: ANFTransformCommand,
		ANFTransformCommand$LCompiler$: ANFTransformCommand,
		CPSTransformCommand: CPSTransformCommand,
		CPSTransformCommand$LCompiler$: CPSTransformCommand,
		"_DeleteStatementTransformer._Stash": _DeleteStatementTransformer$x2E_Stash,
		"_DeleteStatementTransformer._Stash$LCPSTransformCommand$LDeleteStatement$": _DeleteStatementTransformer$x2E_Stash,
		"_SwitchStatementTransformer.CaseStash": _SwitchStatementTransformer$x2ECaseStash,
		"_SwitchStatementTransformer.CaseStash$": _SwitchStatementTransformer$x2ECaseStash
	},
	"src/transformer.jsx": {
		_Util: _Util$1,
		_Util$: _Util$1,
		TransformCommand: TransformCommand,
		TransformCommand$LCompiler$S: TransformCommand,
		FunctionTransformCommand: FunctionTransformCommand,
		FunctionTransformCommand$LCompiler$S: FunctionTransformCommand,
		ExpressionTransformCommand: ExpressionTransformCommand,
		ExpressionTransformCommand$LCompiler$S: ExpressionTransformCommand,
		FixedExpressionTransformCommand: FixedExpressionTransformCommand,
		FixedExpressionTransformCommand$LCompiler$: FixedExpressionTransformCommand,
		StatementTransformCommand: StatementTransformCommand,
		StatementTransformCommand$LCompiler$S: StatementTransformCommand,
		NormalizeTryStatementTransformCommand: NormalizeTryStatementTransformCommand,
		NormalizeTryStatementTransformCommand$LCompiler$: NormalizeTryStatementTransformCommand,
		ForInStatementTransformCommand: ForInStatementTransformCommand,
		ForInStatementTransformCommand$LCompiler$: ForInStatementTransformCommand
	}
};


/**
 * launches _Main.main(:string[]):void invoked by jsx --run|--executable
 */
JSX.runMain = function (sourceFile, args) {
	var module = JSX.require(sourceFile);
	if (! module) {
		throw new ReferenceError("entry point module not found in " + sourceFile);
	}
	if (! module._Main) {
		throw new ReferenceError("entry point _Main not found in " + sourceFile);
	}
	if (! module._Main.main) {
		throw new ReferenceError("entry point _Main.main(:string[]):void not found in " + sourceFile);
	}
	module._Main.main(args);
};

/**
 * launches _Test#test*():void invoked by jsx --test
 */
JSX.runTests = function (sourceFile, tests) {
	var module = JSX.require(sourceFile);
	if (! module) return;

	var testClass = module._Test;

	if (!testClass) return; // skip if there's no test class

	if(tests.length === 0) {
		var p = testClass.prototype;
		for (var m in p) {
			if (p[m] instanceof Function && m.match(/^test\w*$/)) {
				tests.push(m);
			}
		}
	}

	var testCase = new testClass();

	if (testCase.beforeClass != null)
		testCase.beforeClass(tests);

	for (var i = 0; i < tests.length; ++i) {
		(function (method) {
			if (method in testCase) {
				testCase.run(method, function() { testCase[method](); });
			}
			else {
				throw new ReferenceError("No such test method: " + method);
			}
		}(tests[i]));
	}

	if (testCase.afterClass != null)
		testCase.afterClass();
};
JSX.runMain("src/jsx-node-front.jsx", process.argv.slice(2));
})(JSX);
